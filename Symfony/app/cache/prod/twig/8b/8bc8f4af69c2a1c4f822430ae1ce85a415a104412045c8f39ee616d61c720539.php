<?php

/* support/include/mpdf/mpdf.php */
class __TwigTemplate_b41dbb0e54b723afd252a764607adc4a1363ae659ca1b999eb38ea6192b85851 extends Twig_Template
{
    public function __construct(Twig_Environment $env)
    {
        parent::__construct($env);

        $this->parent = false;

        $this->blocks = array(
        );
    }

    protected function doDisplay(array $context, array $blocks = array())
    {
        // line 1
        echo "<?php

// ******************************************************************************
// Software: mPDF, Unicode-HTML Free PDF generator                              *
// Version:  5.7.3     based on                                                   *
//           FPDF by Olivier PLATHEY                                            *
//           HTML2FPDF by Renato Coelho                                         *
// Date:     2013-09-01                                                         *
// Author:   Ian Back <ianb@bpm1.com>                                           *
// License:  GPL                                                                *
//                                                                              *
// Changes:  See changelog.txt                                                  *
// ******************************************************************************


define('mPDF_VERSION','5.7.3');

//Scale factor
define('_MPDFK', (72/25.4));

/*-- HTML-CSS --*/
define('AUTOFONT_CJK',1);
define('AUTOFONT_THAIVIET',2);
define('AUTOFONT_RTL',4);
define('AUTOFONT_INDIC',8);
define('AUTOFONT_ALL',15);

define('_BORDER_ALL',15);
define('_BORDER_TOP',8);
define('_BORDER_RIGHT',4);
define('_BORDER_BOTTOM',2);
define('_BORDER_LEFT',1);
/*-- END HTML-CSS --*/

if (!defined('_MPDF_PATH')) define('_MPDF_PATH', dirname(preg_replace('/\\\\\\\\/','/',__FILE__)) . '/');
if (!defined('_MPDF_URI')) define('_MPDF_URI',_MPDF_PATH);

require_once(_MPDF_PATH.'includes/functions.php');
require_once(_MPDF_PATH.'config_cp.php');

if (!defined('_JPGRAPH_PATH')) define(\"_JPGRAPH_PATH\", _MPDF_PATH.'jpgraph/');

if (!defined('_MPDF_TEMP_PATH')) define(\"_MPDF_TEMP_PATH\", _MPDF_PATH.'tmp/');

if (!defined('_MPDF_TTFONTPATH')) { define('_MPDF_TTFONTPATH',_MPDF_PATH.'ttfonts/'); }
if (!defined('_MPDF_TTFONTDATAPATH')) { define('_MPDF_TTFONTDATAPATH',_MPDF_PATH.'ttfontdata/'); }

\$errorlevel=error_reporting();
\$errorlevel=error_reporting(\$errorlevel & ~E_NOTICE);

//error_reporting(E_ALL);

if(function_exists(\"date_default_timezone_set\")) {
\tif (ini_get(\"date.timezone\")==\"\") { date_default_timezone_set(\"Europe/London\"); }
}
if (!function_exists(\"mb_strlen\")) { die(\"Error - mPDF requires mb_string functions. Ensure that PHP is compiled with php_mbstring.dll enabled.\"); }

if (!defined('PHP_VERSION_ID')) {
    \$version = explode('.', PHP_VERSION);
    define('PHP_VERSION_ID', (\$version[0] * 10000 + \$version[1] * 100 + \$version[2]));
}
// Machine dependent number of bytes used to pack \"double\" into binary (used in cacheTables)
\$test = pack(\"d\", 134455.474557333333666);
define(\"_DSIZE\", strlen(\$test));

class mPDF
{

///////////////////////////////
// EXTERNAL (PUBLIC) VARIABLES
// Define these in config.php
///////////////////////////////
var \$CJKforceend;\t// mPDF 5.6.40
// mPDF 5.6.34
var \$h2bookmarks;
var \$h2toc;
var \$decimal_align;\t// mPDF 5.6.13
var \$margBuffer;\t// mPDF 5.4.04
var \$splitTableBorderWidth;\t// mPDF 5.4.16

var \$cacheTables;
var \$bookmarkStyles;
var \$useActiveForms;

var \$repackageTTF;
var \$allowCJKorphans;
var \$allowCJKoverflow;

var \$useKerning;
var \$restrictColorSpace;
var \$bleedMargin;
var \$crossMarkMargin;
var \$cropMarkMargin;
var \$cropMarkLength;
var \$nonPrintMargin;

var \$PDFX;
var \$PDFXauto;

var \$PDFA;
var \$PDFAauto;
var \$ICCProfile;

var \$printers_info;
var \$iterationCounter;
var \$smCapsScale;
var \$smCapsStretch;

var \$backupSubsFont;
var \$backupSIPFont;
var \$debugfonts;
var \$useAdobeCJK;
var \$percentSubset;
var \$maxTTFFilesize;
var \$BMPonly;

var \$tableMinSizePriority;

var \$dpi;
var \$watermarkImgAlphaBlend;
var \$watermarkImgBehind;
var \$justifyB4br;
var \$packTableData;
var \$pgsIns;
var \$simpleTables;
var \$enableImports;

var \$debug;
var \$showStats;
var \$setAutoTopMargin;
var \$setAutoBottomMargin;
var \$autoMarginPadding;
var \$collapseBlockMargins;
var \$falseBoldWeight;
var \$normalLineheight;
var \$progressBar;
var \$incrementFPR1;
var \$incrementFPR2;
var \$incrementFPR3;
var \$incrementFPR4;

var \$SHYlang;
var \$SHYleftmin;
var \$SHYrightmin;
var \$SHYcharmin;
var \$SHYcharmax;
var \$SHYlanguages;
// PageNumber Conditional Text
var \$pagenumPrefix;
var \$pagenumSuffix;
var \$nbpgPrefix;
var \$nbpgSuffix;
var \$showImageErrors;
var \$allow_output_buffering;
var \$autoPadding;
var \$useGraphs;
var \$autoFontGroupSize;
var \$tabSpaces;
var \$useLang;
var \$restoreBlockPagebreaks;
var \$watermarkTextAlpha;
var \$watermarkImageAlpha;
var \$watermark_size;
var \$watermark_pos;
var \$annotSize;
var \$annotMargin;
var \$annotOpacity;
var \$title2annots;
var \$keepColumns;
var \$keep_table_proportions;
var \$ignore_table_widths;
var \$ignore_table_percents;
var \$list_align_style;
var \$list_number_suffix;
var \$useSubstitutions;
var \$CSSselectMedia;

var \$forcePortraitHeaders;
var \$forcePortraitMargins;
var \$displayDefaultOrientation;
var \$ignore_invalid_utf8;
var \$allowedCSStags;
var \$onlyCoreFonts;
var \$allow_charset_conversion;

var \$jSWord;
var \$jSmaxChar;
var \$jSmaxCharLast;
var \$jSmaxWordLast;

var \$max_colH_correction;


var \$table_error_report;
var \$table_error_report_param;
var \$biDirectional;
var \$text_input_as_HTML;
var \$anchor2Bookmark;
var \$list_indent_first_level;
var \$shrink_tables_to_fit;

var \$allow_html_optional_endtags;

var \$img_dpi;

var \$defaultheaderfontsize;
var \$defaultheaderfontstyle;
var \$defaultheaderline;
var \$defaultfooterfontsize;
var \$defaultfooterfontstyle;
var \$defaultfooterline;
var \$header_line_spacing;
var \$footer_line_spacing;

var \$pregUHCchars;
var \$pregSJISchars;
var \$pregCJKchars;
var \$pregASCIIchars1;
var \$pregASCIIchars2;
var \$pregASCIIchars3;
var \$pregVIETchars;
var \$pregVIETPluschars;

var \$pregRTLchars;
var \$pregHEBchars;
var \$pregARABICchars;
var \$pregNonARABICchars;
// INDIC
var \$pregHIchars;
var \$pregBNchars;
var \$pregPAchars;
var \$pregGUchars;
var \$pregORchars;
var \$pregTAchars;
var \$pregTEchars;
var \$pregKNchars;
var \$pregMLchars;
var \$pregSHchars;
var \$pregINDextra;

var \$mirrorMargins;
var \$default_lineheight_correction;
var \$watermarkText;
var \$watermarkImage;
var \$showWatermarkText;
var \$showWatermarkImage;

var \$fontsizes;

// Aliases for backward compatability
var \$UnvalidatedText;\t// alias = \$watermarkText
var \$TopicIsUnvalidated;\t// alias = \$showWatermarkText
var \$useOddEven;\t\t// alias = \$mirrorMargins
var \$useSubstitutionsMB;\t// alias = \$useSubstitutions



//////////////////////
// CLASS OBJECTS
//////////////////////
var \$cssmgr;
var \$grad;
var \$bmp;
var \$wmf;
var \$tocontents;
var \$form;
var \$directw;

//////////////////////
// INTERNAL VARIABLES
//////////////////////
var \$uniqstr;\t// mPDF 5.7.2
var \$writingToC;\t// mPDF 5.6.38
// mPDF 5.6.01
var \$layers;
var \$current_layer;
var \$open_layer_pane;
var \$decimal_offset;\t// mPDF 5.6.13
var \$inMeter;\t// mPDF 5.5.09

var \$CJKleading;
var \$CJKfollowing;
var \$CJKoverflow;

var \$textshadow;

var \$colsums;
var \$spanborder;
var \$spanborddet;

var \$visibility;

var \$useRC128encryption;
var \$uniqid;

var \$kerning;
var \$fixedlSpacing;
var \$minwSpacing;
var \$lSpacingCSS;
var \$wSpacingCSS;

var \$listDir;
var \$spotColorIDs;
var \$SVGcolors;
var \$spotColors;
var \$defTextColor;
var \$defDrawColor;
var \$defFillColor;

var \$tableBackgrounds;
var \$inlineDisplayOff;
var \$kt_y00;
var \$kt_p00;
var \$upperCase;
var \$checkSIP;
var \$checkSMP;
var \$checkCJK;
var \$tableCJK;

var \$watermarkImgAlpha;
var \$PDFAXwarnings;
var \$MetadataRoot;
var \$OutputIntentRoot;
var \$InfoRoot;
var \$current_filename;
var \$parsers;
var \$current_parser;
var \$_obj_stack;
var \$_don_obj_stack;
var \$_current_obj_id;
var \$tpls;
var \$tpl;
var \$tplprefix;
var \$_res;

var \$pdf_version;
var \$noImageFile;
var \$lastblockbottommargin;
var \$baselineC;
// mPDF 5.7.3  inline text-decoration parameters
var \$baselineSup;
var \$baselineSub;
var \$baselineS;
var \$subPos;
var \$subArrMB;
var \$ReqFontStyle;
var \$tableClipPath ;
var \$forceExactLineheight;
var \$listOcc;

var \$fullImageHeight;
var \$inFixedPosBlock;\t\t// Internal flag for position:fixed block
var \$fixedPosBlock;\t\t// Buffer string for position:fixed block
var \$fixedPosBlockDepth;
var \$fixedPosBlockBBox;
var \$fixedPosBlockSave;
var \$maxPosL;
var \$maxPosR;

var \$loaded;

var \$extraFontSubsets;
var \$docTemplateStart;\t\t// Internal flag for page (page no. -1) that docTemplate starts on
var \$time0;

// Classes
var \$indic;
var \$barcode;

var \$SHYpatterns;
var \$loadedSHYpatterns;
var \$loadedSHYdictionary;
var \$SHYdictionary;
var \$SHYdictionaryWords;

var \$spanbgcolorarray;
var \$default_font;
var \$list_lineheight;
var \$headerbuffer;
var \$lastblocklevelchange;
var \$nestedtablejustfinished;
var \$linebreakjustfinished;
var \$cell_border_dominance_L;
var \$cell_border_dominance_R;
var \$cell_border_dominance_T;
var \$cell_border_dominance_B;
var \$table_keep_together;
var \$plainCell_properties;
var \$inherit_lineheight;
var \$listitemtype;
var \$shrin_k1;
var \$outerfilled;

var \$blockContext;
var \$floatDivs;


var \$patterns;
var \$pageBackgrounds;

var \$bodyBackgroundGradient;
var \$bodyBackgroundImage;
var \$bodyBackgroundColor;

var \$writingHTMLheader;\t// internal flag - used both for writing HTMLHeaders/Footers and FixedPos block
var \$writingHTMLfooter;
var \$autoFontGroups;
var \$angle;

var \$gradients;

var \$kwt_Reference;
var \$kwt_BMoutlines;
var \$kwt_toc;

var \$tbrot_Reference;
var \$tbrot_BMoutlines;
var \$tbrot_toc;

var \$col_Reference;
var \$col_BMoutlines;
var \$col_toc;

var \$currentGraphId;
var \$graphs;

var \$floatbuffer;
var \$floatmargins;

var \$bullet;
var \$bulletarray;

var \$rtlAsArabicFarsi;\t\t// DEPRACATED

var \$currentLang;
var \$default_lang;
var \$default_available_fonts;
var \$pageTemplate;
var \$docTemplate;
var \$docTemplateContinue;

var \$arabGlyphs;
var \$arabHex;
var \$persianGlyphs;
var \$persianHex;
var \$arabVowels;
var \$arabPrevLink;
var \$arabNextLink;


var \$formobjects; // array of Form Objects for WMF
var \$InlineProperties;
var \$InlineAnnots;
var \$ktAnnots;
var \$tbrot_Annots;
var \$kwt_Annots;
var \$columnAnnots;
var \$columnForms;

var \$PageAnnots;

var \$pageDim;\t// Keep track of page wxh for orientation changes - set in _beginpage, used in _putannots

var \$breakpoints;

var \$tableLevel;
var \$tbctr;
var \$innermostTableLevel;
var \$saveTableCounter;
var \$cellBorderBuffer;

var \$saveHTMLFooter_height;
var \$saveHTMLFooterE_height;

var \$firstPageBoxHeader;
var \$firstPageBoxHeaderEven;
var \$firstPageBoxFooter;
var \$firstPageBoxFooterEven;

var \$page_box;
var \$show_marks;\t// crop or cross marks

var \$basepathIsLocal;

var \$use_kwt;
var \$kwt;
var \$kwt_height;
var \$kwt_y0;
var \$kwt_x0;
var \$kwt_buffer;
var \$kwt_Links;
var \$kwt_moved;
var \$kwt_saved;

var \$PageNumSubstitutions;

var \$table_borders_separate;
var \$base_table_properties;
var \$borderstyles;

var \$listjustfinished;
var \$blockjustfinished;

var \$orig_bMargin;
var \$orig_tMargin;
var \$orig_lMargin;
var \$orig_rMargin;
var \$orig_hMargin;
var \$orig_fMargin;

var \$pageheaders;
var \$pagefooters;

var \$pageHTMLheaders;
var \$pageHTMLfooters;

var \$saveHTMLHeader;
var \$saveHTMLFooter;

var \$HTMLheaderPageLinks;
var \$HTMLheaderPageAnnots;
var \$HTMLheaderPageForms;

// See config_fonts.php for these next 5 values
var \$available_unifonts;
var \$sans_fonts;
var \$serif_fonts;
var \$mono_fonts;
var \$defaultSubsFont;

// List of ALL available CJK fonts (incl. styles) (Adobe add-ons)  hw removed
var \$available_CJK_fonts;

var \$HTMLHeader;
var \$HTMLFooter;
var \$HTMLHeaderE;
var \$HTMLFooterE;
var \$bufferoutput;

var \$showdefaultpagenos;\t// DEPRACATED -left for backward compatability


// CJK fonts
var \$Big5_widths;
var \$GB_widths;
var \$SJIS_widths;
var \$UHC_widths;

// SetProtection
var \$encrypted;\t//whether document is protected
var \$Uvalue;\t//U entry in pdf document
var \$Ovalue;\t//O entry in pdf document
var \$Pvalue;\t//P entry in pdf document
var \$enc_obj_id;\t//encryption object id
var \$last_rc4_key;\t//last RC4 key encrypted (cached for optimisation)
var \$last_rc4_key_c;\t//last RC4 computed key
var \$encryption_key;
var \$padding;\t//used for encryption


// Bookmark
var \$BMoutlines;
var \$OutlineRoot;
// INDEX
var \$ColActive;
var \$Reference;
var \$CurrCol;
var \$NbCol;
var \$y0;\t\t\t//Top ordinate of columns
var \$ColL;
var \$ColWidth;
var \$ColGap;
// COLUMNS
var \$ColR;
var \$ChangeColumn;
var \$columnbuffer;
var \$ColDetails;
var \$columnLinks;
var \$colvAlign;
// Substitutions
var \$substitute;\t\t// Array of substitution strings e.g. <ttz>112</ttz>
var \$entsearch;\t\t// Array of HTML entities (>ASCII 127) to substitute
var \$entsubstitute;\t// Array of substitution decimal unicode for the Hi entities


// Default values if no style sheet offered\t(cf. http://www.w3.org/TR/CSS21/sample.html)
var \$defaultCSS;

var \$linemaxfontsize;
var \$lineheight_correction;
var \$lastoptionaltag;\t// Save current block item which HTML specifies optionsl endtag
var \$pageoutput;
var \$charset_in;
var \$blk;
var \$blklvl;
var \$ColumnAdjust;
var \$ws;\t// Word spacing
var \$HREF;
var \$pgwidth;
var \$fontlist;
var \$oldx;
var \$oldy;
var \$B;
var \$U;      //underlining flag
var \$S;\t// SmallCaps flag
var \$I;

var \$tdbegin;
var \$table;
var \$cell;
var \$col;
var \$row;

var \$divbegin;
var \$divalign;
var \$divwidth;
var \$divheight;
var \$divrevert;
var \$spanbgcolor;

var \$listlvl;
var \$listnum;
var \$listtype;
var \$listoccur;
var \$listlist;
var \$listitem;

var \$pjustfinished;
var \$ignorefollowingspaces;
var \$SUP;
var \$SUB;
var \$SMALL;
var \$BIG;
var \$toupper;
var \$tolower;
var \$capitalize;
var \$dash_on;
var \$dotted_on;
var \$strike;

var \$textbuffer;
var \$currentfontstyle;
var \$currentfontfamily;
var \$currentfontsize;
var \$colorarray;
var \$bgcolorarray;
var \$internallink;
var \$enabledtags;

var \$lineheight;
var \$basepath;
var \$textparam;

var \$specialcontent;
var \$selectoption;
var \$objectbuffer;

// Table Rotation
var \$table_rotate;
var \$tbrot_maxw;
var \$tbrot_maxh;
var \$tablebuffer;
var \$tbrot_align;
var \$tbrot_Links;

var \$divbuffer;\t\t// Buffer used when keeping DIV on one page
var \$keep_block_together;\t// Keep a Block from page-break-inside: avoid
var \$ktLinks;\t\t// Keep-together Block links array
var \$ktBlock;\t\t// Keep-together Block array
var \$ktForms;
var \$ktReference;
var \$ktBMoutlines;
var \$_kttoc;

var \$tbrot_y0;
var \$tbrot_x0;
var \$tbrot_w;
var \$tbrot_h;

var \$mb_enc;
var \$directionality;

var \$extgstates; // Used for alpha channel - Transparency (Watermark)
var \$mgl;
var \$mgt;
var \$mgr;
var \$mgb;

var \$tts;
var \$ttz;
var \$tta;

var \$headerDetails;
var \$footerDetails;

// Best to alter the below variables using default stylesheet above
var \$page_break_after_avoid;
var \$margin_bottom_collapse;
var \$list_indent;
var \$list_align;
var \$list_margin_bottom;
var \$default_font_size;\t// in pts
var \$original_default_font_size;\t// used to save default sizes when using table default
var \$original_default_font;
var \$watermark_font;
var \$defaultAlign;

// TABLE
var \$defaultTableAlign;
var \$tablethead;
var \$thead_font_weight;
var \$thead_font_style;
var \$thead_font_smCaps;
var \$thead_valign_default;
var \$thead_textalign_default;
var \$tabletfoot;
var \$tfoot_font_weight;
var \$tfoot_font_style;
var \$tfoot_font_smCaps;
var \$tfoot_valign_default;
var \$tfoot_textalign_default;

var \$trow_text_rotate;

var \$cellPaddingL;
var \$cellPaddingR;
var \$cellPaddingT;
var \$cellPaddingB;
var \$table_lineheight;
var \$table_border_attr_set;
var \$table_border_css_set;

var \$shrin_k;\t\t\t// factor with which to shrink tables - used internally - do not change
var \$shrink_this_table_to_fit;\t// 0 or false to disable; value (if set) gives maximum factor to reduce fontsize
var \$MarginCorrection;\t// corrects for OddEven Margins
var \$margin_footer;
var \$margin_header;

var \$tabletheadjustfinished;
var \$usingCoreFont;
var \$charspacing;

//Private properties FROM FPDF
var \$DisplayPreferences;
var \$flowingBlockAttr;
var \$page;               //current page number
var \$n;                  //current object number
var \$offsets;            //array of object offsets
var \$buffer;             //buffer holding in-memory PDF
var \$pages;              //array containing pages
var \$state;              //current document state
var \$compress;           //compression flag
var \$DefOrientation;     //default orientation
var \$CurOrientation;     //current orientation
var \$OrientationChanges; //array indicating orientation changes
var \$k;                  //scale factor (number of points in user unit)
var \$fwPt;
var \$fhPt;         //dimensions of page format in points
var \$fw;
var \$fh;             //dimensions of page format in user unit
var \$wPt;
var \$hPt;           //current dimensions of page in points
var \$w;
var \$h;               //current dimensions of page in user unit
var \$lMargin;            //left margin
var \$tMargin;            //top margin
var \$rMargin;            //right margin
var \$bMargin;            //page break margin
var \$cMarginL;            //cell margin Left
var \$cMarginR;            //cell margin Right
var \$cMarginT;            //cell margin Left
var \$cMarginB;            //cell margin Right
var \$DeflMargin;            //Default left margin
var \$DefrMargin;            //Default right margin
var \$x;
var \$y;               //current position in user unit for cell positioning
var \$lasth;              //height of last cell printed
var \$LineWidth;          //line width in user unit
var \$CoreFonts;          //array of standard font names
var \$fonts;              //array of used fonts
var \$FontFiles;          //array of font files
var \$images;             //array of used images
var \$PageLinks;          //array of links in pages
var \$links;              //array of internal links
var \$FontFamily;         //current font family
var \$FontStyle;          //current font style
var \$CurrentFont;        //current font info
var \$FontSizePt;         //current font size in points
var \$FontSize;           //current font size in user unit
var \$DrawColor;          //commands for drawing color
var \$FillColor;          //commands for filling color
var \$TextColor;          //commands for text color
var \$ColorFlag;          //indicates whether fill and text colors are different
var \$autoPageBreak;      //automatic page breaking
var \$PageBreakTrigger;   //threshold used to trigger page breaks
var \$InFooter;           //flag set when processing footer
var \$InHTMLFooter;

var \$processingFooter;   //flag set when processing footer - added for columns
var \$processingHeader;   //flag set when processing header - added for columns
var \$ZoomMode;           //zoom display mode
var \$LayoutMode;         //layout display mode
var \$title;              //title
var \$subject;            //subject
var \$author;             //author
var \$keywords;           //keywords
var \$creator;            //creator

var \$aliasNbPg;       //alias for total number of pages
var \$aliasNbPgGp;       //alias for total number of pages in page group
var \$aliasNbPgHex;
var \$aliasNbPgGpHex;

var \$ispre;

var \$outerblocktags;
var \$innerblocktags;


// **********************************
// **********************************
// **********************************
// **********************************
// **********************************
// **********************************
// **********************************
// **********************************
// **********************************

function mPDF(\$mode='',\$format='A4',\$default_font_size=0,\$default_font='',\$mgl=15,\$mgr=15,\$mgt=16,\$mgb=16,\$mgh=9,\$mgf=9, \$orientation='P') {

/*-- BACKGROUNDS --*/
\t\tif (!class_exists('grad', false)) { include(_MPDF_PATH.'classes/grad.php'); }
\t\tif (empty(\$this->grad)) { \$this->grad = new grad(\$this); }
/*-- END BACKGROUNDS --*/
/*-- FORMS --
\t\tif (!class_exists('form', false)) { include(_MPDF_PATH.'classes/form.php'); }
\t\tif (empty(\$this->form)) { \$this->form = new form(\$this); }
/*-- END FORMS --*/

\t\$this->time0 = microtime(true);
\t//Some checks
\t\$this->_dochecks();

\t// Set up Aliases for backwards compatability
\t\$this->UnvalidatedText =& \$this->watermarkText;
\t\$this->TopicIsUnvalidated =& \$this->showWatermarkText;
\t\$this->AliasNbPg =& \$this->aliasNbPg;
\t\$this->AliasNbPgGp =& \$this->aliasNbPgGp;
\t\$this->BiDirectional =& \$this->biDirectional;
\t\$this->Anchor2Bookmark =& \$this->anchor2Bookmark;
\t\$this->KeepColumns =& \$this->keepColumns;
\t\$this->useOddEven =& \$this->mirrorMargins;
\t\$this->useSubstitutionsMB =& \$this->useSubstitutions;

\t\$this->writingToC = false;\t// mPDF 5.6.38
\t\$this->uniqstr = '20110230';\t// mPDF 5.7.2
\t// mPDF 5.6.01
\t\$this->layers = array();
\t\$this->current_layer = 0;
\t\$this->open_layer_pane = false;

\t\$this->visibility='visible';

\t//Initialization of properties
\t\$this->spotColors=array();
\t\$this->spotColorIDs = array();
\t\$this->tableBackgrounds = array();

\t\$this->kt_y00 = '';
\t\$this->kt_p00 = '';
\t\$this->iterationCounter = false;
\t\$this->BMPonly = array();
\t\$this->page=0;
\t\$this->n=2;
\t\$this->buffer='';
\t\$this->objectbuffer = array();
\t\$this->pages=array();
\t\$this->OrientationChanges=array();
\t\$this->state=0;
\t\$this->fonts=array();
\t\$this->FontFiles=array();
\t\$this->images=array();
\t\$this->links=array();
\t\$this->InFooter=false;
\t\$this->processingFooter=false;
\t\$this->processingHeader=false;
\t\$this->lasth=0;
\t\$this->FontFamily='';
\t\$this->FontStyle='';
\t\$this->FontSizePt=9;
\t\$this->U=false;
\t// Small Caps
\t\$this->upperCase = array();
\t\$this->S = false;
\t\$this->smCapsScale = 1;
\t\$this->smCapsStretch = 100;
\t\$this->margBuffer = 0;\t// mPDF 5.4.04
\t\$this->inMeter = false;\t// mPDF 5.5.09
\t\$this->decimal_offset = 0;

\t\$this->defTextColor = \$this->TextColor = \$this->SetTColor(\$this->ConvertColor(0),true);
\t\$this->defDrawColor = \$this->DrawColor = \$this->SetDColor(\$this->ConvertColor(0),true);
\t\$this->defFillColor = \$this->FillColor = \$this->SetFColor(\$this->ConvertColor(255),true);

\t//SVG color names array
\t//http://www.w3schools.com/css/css_colornames.asp
\t\$this->SVGcolors = array('antiquewhite'=>'#FAEBD7','aqua'=>'#00FFFF','aquamarine'=>'#7FFFD4','beige'=>'#F5F5DC','black'=>'#000000',
'blue'=>'#0000FF','brown'=>'#A52A2A','cadetblue'=>'#5F9EA0','chocolate'=>'#D2691E','cornflowerblue'=>'#6495ED','crimson'=>'#DC143C',
'darkblue'=>'#00008B','darkgoldenrod'=>'#B8860B','darkgreen'=>'#006400','darkmagenta'=>'#8B008B','darkorange'=>'#FF8C00',
'darkred'=>'#8B0000','darkseagreen'=>'#8FBC8F','darkslategray'=>'#2F4F4F','darkviolet'=>'#9400D3','deepskyblue'=>'#00BFFF',
'dodgerblue'=>'#1E90FF','firebrick'=>'#B22222','forestgreen'=>'#228B22','fuchsia'=>'#FF00FF','gainsboro'=>'#DCDCDC','gold'=>'#FFD700',
'gray'=>'#808080','green'=>'#008000','greenyellow'=>'#ADFF2F','hotpink'=>'#FF69B4','indigo'=>'#4B0082','khaki'=>'#F0E68C',
'lavenderblush'=>'#FFF0F5','lemonchiffon'=>'#FFFACD','lightcoral'=>'#F08080','lightgoldenrodyellow'=>'#FAFAD2','lightgreen'=>'#90EE90',
'lightsalmon'=>'#FFA07A','lightskyblue'=>'#87CEFA','lightslategray'=>'#778899','lightyellow'=>'#FFFFE0','lime'=>'#00FF00','limegreen'=>'#32CD32',
'magenta'=>'#FF00FF','maroon'=>'#800000','mediumaquamarine'=>'#66CDAA','mediumorchid'=>'#BA55D3','mediumseagreen'=>'#3CB371',
'mediumspringgreen'=>'#00FA9A','mediumvioletred'=>'#C71585','midnightblue'=>'#191970','mintcream'=>'#F5FFFA','moccasin'=>'#FFE4B5','navy'=>'#000080',
'olive'=>'#808000','orange'=>'#FFA500','orchid'=>'#DA70D6','palegreen'=>'#98FB98',
'palevioletred'=>'#D87093','peachpuff'=>'#FFDAB9','pink'=>'#FFC0CB','powderblue'=>'#B0E0E6','purple'=>'#800080',
'red'=>'#FF0000','royalblue'=>'#4169E1','salmon'=>'#FA8072','seagreen'=>'#2E8B57','sienna'=>'#A0522D','silver'=>'#C0C0C0','skyblue'=>'#87CEEB',
'slategray'=>'#708090','springgreen'=>'#00FF7F','steelblue'=>'#4682B4','tan'=>'#D2B48C','teal'=>'#008080','thistle'=>'#D8BFD8','turquoise'=>'#40E0D0',
'violetred'=>'#D02090','white'=>'#FFFFFF','yellow'=>'#FFFF00',
'aliceblue'=>'#f0f8ff', 'azure'=>'#f0ffff', 'bisque'=>'#ffe4c4', 'blanchedalmond'=>'#ffebcd', 'blueviolet'=>'#8a2be2', 'burlywood'=>'#deb887',
'chartreuse'=>'#7fff00', 'coral'=>'#ff7f50', 'cornsilk'=>'#fff8dc', 'cyan'=>'#00ffff', 'darkcyan'=>'#008b8b', 'darkgray'=>'#a9a9a9',
'darkgrey'=>'#a9a9a9', 'darkkhaki'=>'#bdb76b', 'darkolivegreen'=>'#556b2f', 'darkorchid'=>'#9932cc', 'darksalmon'=>'#e9967a',
'darkslateblue'=>'#483d8b', 'darkslategrey'=>'#2f4f4f', 'darkturquoise'=>'#00ced1', 'deeppink'=>'#ff1493', 'dimgray'=>'#696969',
'dimgrey'=>'#696969', 'floralwhite'=>'#fffaf0', 'ghostwhite'=>'#f8f8ff', 'goldenrod'=>'#daa520', 'grey'=>'#808080', 'honeydew'=>'#f0fff0',
'indianred'=>'#cd5c5c', 'ivory'=>'#fffff0', 'lavender'=>'#e6e6fa', 'lawngreen'=>'#7cfc00', 'lightblue'=>'#add8e6', 'lightcyan'=>'#e0ffff',
'lightgray'=>'#d3d3d3', 'lightgrey'=>'#d3d3d3', 'lightpink'=>'#ffb6c1', 'lightseagreen'=>'#20b2aa', 'lightslategrey'=>'#778899',
'lightsteelblue'=>'#b0c4de', 'linen'=>'#faf0e6', 'mediumblue'=>'#0000cd', 'mediumpurple'=>'#9370db', 'mediumslateblue'=>'#7b68ee',
'mediumturquoise'=>'#48d1cc', 'mistyrose'=>'#ffe4e1', 'navajowhite'=>'#ffdead', 'oldlace'=>'#fdf5e6', 'olivedrab'=>'#6b8e23', 'orangered'=>'#ff4500',
'palegoldenrod'=>'#eee8aa', 'paleturquoise'=>'#afeeee', 'papayawhip'=>'#ffefd5', 'peru'=>'#cd853f', 'plum'=>'#dda0dd', 'rosybrown'=>'#bc8f8f',
'saddlebrown'=>'#8b4513', 'sandybrown'=>'#f4a460', 'seashell'=>'#fff5ee', 'slateblue'=>'#6a5acd', 'slategrey'=>'#708090', 'snow'=>'#fffafa',
'tomato'=>'#ff6347', 'violet'=>'#ee82ee', 'wheat'=>'#f5deb3', 'whitesmoke'=>'#f5f5f5', 'yellowgreen'=>'#9acd32');

\t\$this->ColorFlag=false;
\t\$this->extgstates = array();

\t\$this->mb_enc='windows-1252';
\t\$this->directionality='ltr';
\t\$this->defaultAlign = 'L';
\t\$this->defaultTableAlign = 'L';

\t\$this->fixedPosBlockSave = array();
\t\$this->extraFontSubsets = 0;

\t\$this->SHYpatterns = array();
\t\$this->loadedSHYdictionary = false;
\t\$this->SHYdictionary = array();
\t\$this->SHYdictionaryWords = array();
\t\$this->blockContext = 1;
\t\$this->floatDivs = array();
\t\$this->DisplayPreferences='';

\t\$this->patterns = array();\t\t// Tiling patterns used for backgrounds
\t\$this->pageBackgrounds = array();
\t\$this->writingHTMLheader = false;\t// internal flag - used both for writing HTMLHeaders/Footers and FixedPos block
\t\$this->writingHTMLfooter = false;\t// internal flag - used both for writing HTMLHeaders/Footers and FixedPos block
\t\$this->gradients = array();

\t\$this->kwt_Reference = array();
\t\$this->kwt_BMoutlines = array();
\t\$this->kwt_toc = array();

\t\$this->tbrot_Reference = array();
\t\$this->tbrot_BMoutlines = array();
\t\$this->tbrot_toc = array();

\t\$this->col_Reference = array();
\t\$this->col_BMoutlines = array();
\t\$this->col_toc = array();
\t\$this->graphs = array();

\t\$this->pgsIns = array();
\t\$this->PDFAXwarnings = array();
\t\$this->inlineDisplayOff = false;
\t\$this->kerning = false;
\t\$this->lSpacingCSS = '';
\t\$this->wSpacingCSS = '';
\t\$this->fixedlSpacing = false;
\t\$this->minwSpacing = 0;


\t\$this->baselineC = 0.35;\t// Baseline for text
\t// mPDF 5.7.3  inline text-decoration parameters
\t\$this->baselineSup = 0.5;\t// Sets default change in baseline for <sup> text bas factor of preceeding fontsize
\t\$this->baselineSub = -0.2;\t// Sets default change in baseline for <sub> text bas factor of preceeding fontsize
\t\$this->baselineS = 0.3;\t\t// Sets default height for <strike> text as factor of fontsize

\t\$this->noImageFile = str_replace(\"\\\\\",\"/\",dirname(__FILE__)) . '/includes/no_image.jpg';
\t\$this->subPos = 0;
\t\$this->forceExactLineheight = false;
\t\$this->listOcc = 0;
\t\$this->normalLineheight = 1.3;
\t// These are intended as configuration variables, and should be set in config.php - which will override these values;
\t// set here as failsafe as will cause an error if not defined
\t\$this->incrementFPR1 = 10;
\t\$this->incrementFPR2 = 10;
\t\$this->incrementFPR3 = 10;
\t\$this->incrementFPR4 = 10;

\t\$this->fullImageHeight = false;
\t\$this->floatbuffer = array();
\t\$this->floatmargins = array();
\t\$this->autoFontGroups = 0;
\t\$this->formobjects=array(); // array of Form Objects for WMF
\t\$this->InlineProperties=array();
\t\$this->InlineAnnots=array();
\t\$this->ktAnnots=array();
\t\$this->tbrot_Annots=array();
\t\$this->kwt_Annots=array();
\t\$this->columnAnnots=array();
\t\$this->pageDim=array();
\t\$this->breakpoints = array();\t// used in columnbuffer
\t\$this->tableLevel=0;
\t\$this->tbctr=array();\t// counter for nested tables at each level
\t\$this->page_box = array();
\t\$this->show_marks = '';\t// crop or cross marks
\t\$this->kwt = false;
\t\$this->kwt_height = 0;
\t\$this->kwt_y0 = 0;
\t\$this->kwt_x0 = 0;
\t\$this->kwt_buffer = array();
\t\$this->kwt_Links = array();
\t\$this->kwt_moved = false;
\t\$this->kwt_saved = false;
\t\$this->PageNumSubstitutions = array();
\t\$this->base_table_properties=array();
\t\$this->borderstyles = array('inset','groove','outset','ridge','dotted','dashed','solid','double');
\t\$this->tbrot_align = 'C';
\t\$this->pageheaders=array();
\t\$this->pagefooters=array();

\t\$this->pageHTMLheaders=array();
\t\$this->pageHTMLfooters=array();
\t\$this->HTMLheaderPageLinks = array();
\t\$this->HTMLheaderPageAnnots = array();

\t\$this->ktForms = array();
\t\$this->HTMLheaderPageForms = array();
\t\$this->columnForms = array();
\t\$this->tbrotForms = array();
\t\$this->useRC128encryption = false;
\t\$this->uniqid = '';

\t\$this->bufferoutput = false;
\t\$this->encrypted=false;    \t\t//whether document is protected
\t\$this->BMoutlines=array();
\t\$this->ColActive=0;        \t\t//Flag indicating that columns are on (the index is being processed)
\t\$this->Reference=array();  \t\t//Array containing the references
\t\$this->CurrCol=0;              \t//Current column number
\t\$this->ColL = array(0);\t\t\t// Array of Left pos of columns - absolute - needs Margin correction for Odd-Even
\t\$this->ColR = array(0);\t\t\t// Array of Right pos of columns - absolute pos - needs Margin correction for Odd-Even
\t\$this->ChangeColumn = 0;
\t\$this->columnbuffer = array();
\t\$this->ColDetails = array();\t\t// Keeps track of some column details
\t\$this->columnLinks = array();\t\t// Cross references PageLinks
\t\$this->substitute = array();\t\t// Array of substitution strings e.g. <ttz>112</ttz>
\t\$this->entsearch = array();\t\t// Array of HTML entities (>ASCII 127) to substitute
\t\$this->entsubstitute = array();\t// Array of substitution decimal unicode for the Hi entities
\t\$this->lastoptionaltag = '';
\t\$this->charset_in = '';
\t\$this->blk = array();
\t\$this->blklvl = 0;
\t\$this->tts = false;
\t\$this->ttz = false;
\t\$this->tta = false;
\t\$this->ispre=false;

\t\$this->checkSIP = false;
\t\$this->checkSMP = false;
\t\$this->checkCJK = false;
\t\$this->tableCJK = false;

\t\$this->headerDetails=array();
\t\$this->footerDetails=array();
\t\$this->page_break_after_avoid = false;
\t\$this->margin_bottom_collapse = false;
\t\$this->tablethead = 0;
\t\$this->tabletfoot = 0;
\t\$this->table_border_attr_set = 0;
\t\$this->table_border_css_set = 0;
\t\$this->shrin_k = 1.0;
\t\$this->shrink_this_table_to_fit = 0;
\t\$this->MarginCorrection = 0;

\t\$this->tabletheadjustfinished = false;
\t\$this->usingCoreFont = false;
\t\$this->charspacing=0;

\t\$this->autoPageBreak = true;

\trequire(_MPDF_PATH.'config.php');\t// config data

\t\$this->_setPageSize(\$format, \$orientation);
\t\$this->DefOrientation=\$orientation;

\t\$this->margin_header=\$mgh;
\t\$this->margin_footer=\$mgf;

\t\$bmargin=\$mgb;

\t\$this->DeflMargin = \$mgl;
\t\$this->DefrMargin = \$mgr;

\t\$this->orig_tMargin = \$mgt;
\t\$this->orig_bMargin = \$bmargin;
\t\$this->orig_lMargin = \$this->DeflMargin;
\t\$this->orig_rMargin = \$this->DefrMargin;
\t\$this->orig_hMargin = \$this->margin_header;
\t\$this->orig_fMargin = \$this->margin_footer;

\tif (\$this->setAutoTopMargin=='pad') { \$mgt += \$this->margin_header; }
\tif (\$this->setAutoBottomMargin=='pad') { \$mgb += \$this->margin_footer; }
\t\$this->SetMargins(\$this->DeflMargin,\$this->DefrMargin,\$mgt);\t// sets l r t margin
\t//Automatic page break
\t\$this->SetAutoPageBreak(\$this->autoPageBreak,\$bmargin);\t// sets \$this->bMargin & PageBreakTrigger

\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;

\t//Interior cell margin (1 mm) ? not used
\t\$this->cMarginL = 1;
\t\$this->cMarginR = 1;
\t//Line width (0.2 mm)
\t\$this->LineWidth=.567/_MPDFK;

\t//To make the function Footer() work - replaces {nb} with page number
\t\$this->AliasNbPages();
\t\$this->AliasNbPageGroups();

\t\$this->aliasNbPgHex = '{nbHEXmarker}';
\t\$this->aliasNbPgGpHex = '{nbpgHEXmarker}';

\t//Enable all tags as default
\t\$this->DisableTags();
\t//Full width display mode
\t\$this->SetDisplayMode(100);\t// fullwidth?\t\t'fullpage'
\t//Compression
\t\$this->SetCompression(true);
\t//Set default display preferences
\t\$this->SetDisplayPreferences('');

\t// Font data
\trequire(_MPDF_PATH.'config_fonts.php');
\t// Available fonts
\t\$this->available_unifonts = array();
\tforeach (\$this->fontdata AS \$f => \$fs) {
\t\tif (isset(\$fs['R']) && \$fs['R']) { \$this->available_unifonts[] = \$f; }
\t\tif (isset(\$fs['B']) && \$fs['B']) { \$this->available_unifonts[] = \$f.'B'; }
\t\tif (isset(\$fs['I']) && \$fs['I']) { \$this->available_unifonts[] = \$f.'I'; }
\t\tif (isset(\$fs['BI']) && \$fs['BI']) { \$this->available_unifonts[] = \$f.'BI'; }
\t}

\t\$this->default_available_fonts = \$this->available_unifonts;

\t\$optcore = false;
\t\$onlyCoreFonts = false;
\tif (preg_match('/([\\-+])aCJK/i',\$mode, \$m)) {
\t\t\$mode = preg_replace('/([\\-+])aCJK/i','',\$mode);
\t\tif (\$m[1]=='+') { \$this->useAdobeCJK = true; }
\t\telse { \$this->useAdobeCJK = false; }
\t}

\tif (strlen(\$mode)==1) {
\t\tif (\$mode=='s') { \$this->percentSubset = 100; \$mode = ''; }
\t\telse if (\$mode=='c') { \$onlyCoreFonts = true; \$mode = ''; }
\t}
\telse if (substr(\$mode,-2)=='-s') {
\t\t\$this->percentSubset = 100;
\t\t\$mode = substr(\$mode,0,strlen(\$mode)-2);
\t}
\telse if (substr(\$mode,-2)=='-c') {
\t\t\$onlyCoreFonts = true;
\t\t\$mode = substr(\$mode,0,strlen(\$mode)-2);
\t}
\telse if (substr(\$mode,-2)=='-x') {
\t\t\$optcore = true;
\t\t\$mode = substr(\$mode,0,strlen(\$mode)-2);
\t}

\t// Autodetect if mode is a language_country string (en-GB or en_GB or en)
\tif ((strlen(\$mode) == 5 && \$mode != 'UTF-8') || strlen(\$mode) == 2) {
\t\tlist (\$coreSuitable,\$mpdf_pdf_unifonts) = GetLangOpts(\$mode, \$this->useAdobeCJK);
\t\tif (\$coreSuitable && \$optcore) { \$onlyCoreFonts = true; }
\t\tif (\$mpdf_pdf_unifonts) {
\t\t\t\$this->RestrictUnicodeFonts(\$mpdf_pdf_unifonts);
\t\t\t\$this->default_available_fonts = \$mpdf_pdf_unifonts;
\t\t}
\t\t\$this->currentLang = \$mode;
\t\t\$this->default_lang = \$mode;
\t}

\t\$this->onlyCoreFonts =  \$onlyCoreFonts;

\tif (\$this->onlyCoreFonts) {
\t\t\$this->setMBencoding('windows-1252');\t// sets \$this->mb_enc
\t}
\telse {
\t\t\$this->setMBencoding('UTF-8');\t// sets \$this->mb_enc
\t}
\t@mb_regex_encoding('UTF-8');\t// required only for mb_ereg... and mb_split functions


\t// Adobe CJK fonts
\t\$this->available_CJK_fonts = array('gb','big5','sjis','uhc','gbB','big5B','sjisB','uhcB','gbI','big5I','sjisI','uhcI',
\t\t'gbBI','big5BI','sjisBI','uhcBI');


\t//Standard fonts
\t\$this->CoreFonts=array('ccourier'=>'Courier','ccourierB'=>'Courier-Bold','ccourierI'=>'Courier-Oblique','ccourierBI'=>'Courier-BoldOblique',
\t\t'chelvetica'=>'Helvetica','chelveticaB'=>'Helvetica-Bold','chelveticaI'=>'Helvetica-Oblique','chelveticaBI'=>'Helvetica-BoldOblique',
\t\t'ctimes'=>'Times-Roman','ctimesB'=>'Times-Bold','ctimesI'=>'Times-Italic','ctimesBI'=>'Times-BoldItalic',
\t\t'csymbol'=>'Symbol','czapfdingbats'=>'ZapfDingbats');
\t\$this->fontlist=array(\"ctimes\",\"ccourier\",\"chelvetica\",\"csymbol\",\"czapfdingbats\");

\t// Substitutions
\t\$this->setHiEntitySubstitutions();

\tif (\$this->onlyCoreFonts) {
\t\t\$this->useSubstitutions = true;
\t\t\$this->SetSubstitutions();
\t}
    // osTicket custom — seems that substitions are necessary for eastern
    // languages to work with packaged fonts
\t//else { \$this->useSubstitutions = false; }

/*-- HTML-CSS --*/

\tif (!class_exists('cssmgr', false)) { include(_MPDF_PATH .'classes/cssmgr.php'); }
\t\$this->cssmgr = new cssmgr(\$this);
\tif (file_exists(_MPDF_PATH.'mpdf.css')) {
\t\t\$css = file_get_contents(_MPDF_PATH.'mpdf.css');
\t\t\$css2 = \$this->cssmgr->ReadDefaultCSS(\$css);
\t\t\$this->defaultCSS = \$this->cssmgr->array_merge_recursive_unique(\$this->defaultCSS,\$css2);
\t}
/*-- END HTML-CSS --*/

\tif (\$default_font=='') {
\t  if (\$this->onlyCoreFonts) {
\t\tif (in_array(strtolower(\$this->defaultCSS['BODY']['FONT-FAMILY']),\$this->mono_fonts)) { \$default_font = 'ccourier'; }
\t\telse if (in_array(strtolower(\$this->defaultCSS['BODY']['FONT-FAMILY']),\$this->sans_fonts)) { \$default_font = 'chelvetica'; }
\t\telse { \$default_font = 'ctimes'; }
\t  }
\t  else { \$default_font = \$this->defaultCSS['BODY']['FONT-FAMILY']; }
\t}
\tif (!\$default_font_size) {
\t\t\$mmsize = \$this->ConvertSize(\$this->defaultCSS['BODY']['FONT-SIZE']);
\t\t\$default_font_size = \$mmsize*(_MPDFK);
\t}

\tif (\$default_font) { \$this->SetDefaultFont(\$default_font); }
\tif (\$default_font_size) { \$this->SetDefaultFontSize(\$default_font_size); }

\t\$this->SetLineHeight();\t// lineheight is in mm

\t\$this->SetFColor(\$this->ConvertColor(255));
\t\$this->HREF='';
\t\$this->oldy=-1;
\t\$this->B=0;
\t\$this->U=false;
\t\$this->S=false;
\t\$this->I=0;

\t\$this->listlvl=0;
\t\$this->listnum=0;
\t\$this->listtype='';
\t\$this->listoccur=array();
\t\$this->listlist=array();
\t\$this->listitem=array();

\t\$this->tdbegin=false;
\t\$this->table=array();
\t\$this->cell=array();
\t\$this->col=-1;
\t\$this->row=-1;
\t\$this->cellBorderBuffer = array();

\t\$this->divbegin=false;
\t\$this->divalign='';
\t\$this->divwidth=0;
\t\$this->divheight=0;
\t\$this->spanbgcolor=false;
\t\$this->divrevert=false;
\t\$this->spanborder=false;
\t\$this->spanborddet=array();

\t\$this->blockjustfinished=false;
\t\$this->listjustfinished=false;
\t\$this->ignorefollowingspaces = true; //in order to eliminate exceeding left-side spaces
\t\$this->toupper=false;
\t\$this->tolower=false;
\t\$this->capitalize=false;
\t\$this->dash_on=false;
\t\$this->dotted_on=false;
\t\$this->SUP=false;
\t\$this->SUB=false;
\t\$this->strike=false;
\t\$this->textshadow='';

\t\$this->currentfontfamily='';
\t\$this->currentfontsize='';
\t\$this->currentfontstyle='';
\t\$this->colorarray=array();
\t\$this->spanbgcolorarray=array();
\t\$this->textbuffer=array();
\t\$this->internallink=array();
\t\$this->basepath = \"\";

\t\$this->SetBasePath('');

\t\$this->textparam = array();

\t\$this->specialcontent = '';
\t\$this->selectoption = array();

/*-- IMPORTS --*/

\t\$this->tpls = array();
\t\$this->tpl = 0;
\t\$this->tplprefix = \"/TPL\";
\t\$this->res = array();
\tif (\$this->enableImports) {
\t\t\$this->SetImportUse();
\t}
/*-- END IMPORTS --*/

\tif (\$this->progressBar) { \$this->StartProgressBarOutput(\$this->progressBar) ;\t}\t// *PROGRESS-BAR*
}


function _setPageSize(\$format, &\$orientation) {
\t//Page format
\tif(is_string(\$format))
\t{
\t\tif (\$format=='') { \$format = 'A4'; }
\t\t\$pfo = 'P';
\t\tif(preg_match('/([0-9a-zA-Z]*)-L/i',\$format,\$m)) {\t// e.g. A4-L = A4 landscape
\t\t\t\$format=\$m[1];
\t\t\t\$pfo='L';
\t\t}
\t\t\$format = \$this->_getPageFormat(\$format);
\t\tif (!\$format) { \$this->Error('Unknown page format: '.\$format); }
\t\telse { \$orientation = \$pfo; }

\t\t\$this->fwPt=\$format[0];
\t\t\$this->fhPt=\$format[1];
\t}
\telse
\t{
\t\tif (!\$format[0] || !\$format[1]) { \$this->Error('Invalid page format: '.\$format[0].' '.\$format[1]); }
\t\t\$this->fwPt=\$format[0]*_MPDFK;
\t\t\$this->fhPt=\$format[1]*_MPDFK;
\t}
\t\$this->fw=\$this->fwPt/_MPDFK;
\t\$this->fh=\$this->fhPt/_MPDFK;
\t//Page orientation
\t\$orientation=strtolower(\$orientation);
\tif(\$orientation=='p' or \$orientation=='portrait')
\t{
\t\t\$orientation='P';
\t\t\$this->wPt=\$this->fwPt;
\t\t\$this->hPt=\$this->fhPt;
\t}
\telseif(\$orientation=='l' or \$orientation=='landscape')
\t{
\t\t\$orientation='L';
\t\t\$this->wPt=\$this->fhPt;
\t\t\$this->hPt=\$this->fwPt;
\t}
\telse \$this->Error('Incorrect orientation: '.\$orientation);
\t\$this->CurOrientation=\$orientation;

\t\$this->w=\$this->wPt/_MPDFK;
\t\$this->h=\$this->hPt/_MPDFK;
}

function _getPageFormat(\$format) {
\t\tswitch (strtoupper(\$format)) {
\t\t\tcase '4A0': {\$format = array(4767.87,6740.79); break;}
\t\t\tcase '2A0': {\$format = array(3370.39,4767.87); break;}
\t\t\tcase 'A0': {\$format = array(2383.94,3370.39); break;}
\t\t\tcase 'A1': {\$format = array(1683.78,2383.94); break;}
\t\t\tcase 'A2': {\$format = array(1190.55,1683.78); break;}
\t\t\tcase 'A3': {\$format = array(841.89,1190.55); break;}
\t\t\tcase 'A4': default: {\$format = array(595.28,841.89); break;}
\t\t\tcase 'A5': {\$format = array(419.53,595.28); break;}
\t\t\tcase 'A6': {\$format = array(297.64,419.53); break;}
\t\t\tcase 'A7': {\$format = array(209.76,297.64); break;}
\t\t\tcase 'A8': {\$format = array(147.40,209.76); break;}
\t\t\tcase 'A9': {\$format = array(104.88,147.40); break;}
\t\t\tcase 'A10': {\$format = array(73.70,104.88); break;}
\t\t\tcase 'B0': {\$format = array(2834.65,4008.19); break;}
\t\t\tcase 'B1': {\$format = array(2004.09,2834.65); break;}
\t\t\tcase 'B2': {\$format = array(1417.32,2004.09); break;}
\t\t\tcase 'B3': {\$format = array(1000.63,1417.32); break;}
\t\t\tcase 'B4': {\$format = array(708.66,1000.63); break;}
\t\t\tcase 'B5': {\$format = array(498.90,708.66); break;}
\t\t\tcase 'B6': {\$format = array(354.33,498.90); break;}
\t\t\tcase 'B7': {\$format = array(249.45,354.33); break;}
\t\t\tcase 'B8': {\$format = array(175.75,249.45); break;}
\t\t\tcase 'B9': {\$format = array(124.72,175.75); break;}
\t\t\tcase 'B10': {\$format = array(87.87,124.72); break;}
\t\t\tcase 'C0': {\$format = array(2599.37,3676.54); break;}
\t\t\tcase 'C1': {\$format = array(1836.85,2599.37); break;}
\t\t\tcase 'C2': {\$format = array(1298.27,1836.85); break;}
\t\t\tcase 'C3': {\$format = array(918.43,1298.27); break;}
\t\t\tcase 'C4': {\$format = array(649.13,918.43); break;}
\t\t\tcase 'C5': {\$format = array(459.21,649.13); break;}
\t\t\tcase 'C6': {\$format = array(323.15,459.21); break;}
\t\t\tcase 'C7': {\$format = array(229.61,323.15); break;}
\t\t\tcase 'C8': {\$format = array(161.57,229.61); break;}
\t\t\tcase 'C9': {\$format = array(113.39,161.57); break;}
\t\t\tcase 'C10': {\$format = array(79.37,113.39); break;}
\t\t\tcase 'RA0': {\$format = array(2437.80,3458.27); break;}
\t\t\tcase 'RA1': {\$format = array(1729.13,2437.80); break;}
\t\t\tcase 'RA2': {\$format = array(1218.90,1729.13); break;}
\t\t\tcase 'RA3': {\$format = array(864.57,1218.90); break;}
\t\t\tcase 'RA4': {\$format = array(609.45,864.57); break;}
\t\t\tcase 'SRA0': {\$format = array(2551.18,3628.35); break;}
\t\t\tcase 'SRA1': {\$format = array(1814.17,2551.18); break;}
\t\t\tcase 'SRA2': {\$format = array(1275.59,1814.17); break;}
\t\t\tcase 'SRA3': {\$format = array(907.09,1275.59); break;}
\t\t\tcase 'SRA4': {\$format = array(637.80,907.09); break;}
\t\t\tcase 'LETTER': {\$format = array(612.00,792.00); break;}
\t\t\tcase 'LEGAL': {\$format = array(612.00,1008.00); break;}
\t\t\tcase 'LEDGER': {\$format = array(279.00,432.00); break;}
\t\t\tcase 'TABLOID': {\$format = array(279.00,432.00); break;}
\t\t\tcase 'EXECUTIVE': {\$format = array(521.86,756.00); break;}
\t\t\tcase 'FOLIO': {\$format = array(612.00,936.00); break;}
\t\t\tcase 'B': {\$format=array(362.83,561.26 );\t break;}\t\t//\t'B' format paperback size 128x198mm
\t\t\tcase 'A': {\$format=array(314.65,504.57 );\t break;}\t\t//\t'A' format paperback size 111x178mm
\t\t\tcase 'DEMY': {\$format=array(382.68,612.28 );  break;}\t\t//\t'Demy' format paperback size 135x216mm
\t\t\tcase 'ROYAL': {\$format=array(433.70,663.30 );  break;}\t//\t'Royal' format paperback size 153x234mm
\t\t\tdefault: \$format = false;
\t\t}
\treturn \$format;
}


/*-- PROGRESS-BAR --*/
function StartProgressBarOutput(\$mode=1) {
\t// must be relative path, or URI (not a file system path)
\tif (!defined('_MPDF_URI')) {
\t\t\$this->progressBar = false;
\t\tif (\$this->debug) { \$this->Error(\"You need to define _MPDF_URI to use the progress bar!\"); }
\t\telse return false;
\t}
\t\$this->progressBar = \$mode;
\tif (\$this->progbar_altHTML) {
\t\techo \$this->progbar_altHTML;
\t}
\telse {
\t   echo '<html>
\t<head>
\t<title>mPDF File Progress</title>
\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />
\t<link rel=\"stylesheet\" type=\"text/css\" href=\"'._MPDF_URI.'progbar.css?19292ad\" />
\t\t</head>
\t<body>
\t<div class=\"main\">
\t\t<div class=\"heading\">'.\$this->progbar_heading.'</div>
\t\t<div class=\"demo\">
\t   ';
\t   if (\$this->progressBar==2) { echo '\t\t<table width=\"100%\"><tr><td style=\"width: 50%;\">
\t\t\t<span class=\"barheading\">Writing HTML code</span> <br/>

\t\t\t<div class=\"progressBar\">
\t\t\t<div id=\"element1\"  class=\"innerBar\">&nbsp;</div>
\t\t\t</div>
\t\t\t<span class=\"code\" id=\"box1\"></span>
\t\t\t</td><td style=\"width: 50%;\">
\t\t\t<span class=\"barheading\">Autosizing elements</span> <br/>
\t\t\t<div class=\"progressBar\">
\t\t\t<div id=\"element4\"  class=\"innerBar\">&nbsp;</div>
\t\t\t</div>
\t\t\t<span class=\"code\" id=\"box4\"></span>
\t\t\t<br/><br/>
\t\t\t<span class=\"barheading\">Writing Tables</span> <br/>
\t\t\t<div class=\"progressBar\">
\t\t\t<div id=\"element7\"  class=\"innerBar\">&nbsp;</div>
\t\t\t</div>
\t\t\t<span class=\"code\" id=\"box7\"></span>
\t\t\t</td></tr>
\t\t\t<tr><td><br /><br /></td><td></td></tr>
\t\t\t<tr><td style=\"width: 50%;\">
\t'; }
\techo '\t\t\t<span class=\"barheading\">Writing PDF file</span> <br/>
\t\t\t<div class=\"progressBar\">
\t\t\t<div id=\"element2\"  class=\"innerBar\">&nbsp;</div>
\t\t\t</div>
\t\t\t<span class=\"code\" id=\"box2\"></span>
\t   ';
\t   if (\$this->progressBar==2) { echo '
\t\t\t</td><td style=\"width: 50%;\">
\t\t\t<span class=\"barheading\">Memory usage</span> <br/>
\t\t\t<div class=\"progressBar\">
\t\t\t<div id=\"element5\"  class=\"innerBar\">&nbsp;</div>
\t\t\t</div>
\t\t\t<span id=\"box5\">0</span> '.ini_get(\"memory_limit\").'<br />
\t\t\t<br/><br/>
\t\t\t<span class=\"barheading\">Memory usage (peak)</span> <br/>
\t\t\t<div class=\"progressBar\">
\t\t\t<div id=\"element6\"  class=\"innerBar\">&nbsp;</div>
\t\t\t</div>
\t\t\t<span id=\"box6\">0</span> '.ini_get(\"memory_limit\").'<br />
\t\t\t</td></tr>
\t\t\t</table>
\t   '; }
\t   echo '\t\t\t<br/><br/>
\t\t<span id=\"box3\"></span>

\t\t</div>
\t   ';
\t}
\tob_flush();
      flush();
}

function UpdateProgressBar(\$el,\$val,\$txt='') {
\t// \$val should be a string - 5 = actual value, +15 = increment

\tif (\$this->progressBar<2) {
\t\tif (\$el>3) { return; }
\t\telse if (\$el ==1) { \$el = 2; }
\t}
\techo '<script type=\"text/javascript\">';
\tif (\$val) { echo ' document.getElementById(\\'element'.\$el.'\\').style.width=\\''.\$val.'%\\'; '; }
\tif (\$txt) { echo ' document.getElementById(\\'box'.\$el.'\\').innerHTML=\\''.\$txt.'\\'; '; }
\tif (\$this->progressBar==2) {
\t\t\$m = round(memory_get_usage(true)/1048576);
\t\t\$m2 = round(memory_get_peak_usage(true)/1048576);
\t\t\$mem = \$m * 100 / (ini_get(\"memory_limit\")+0);
\t\t\$mem2 = \$m2 * 100 / (ini_get(\"memory_limit\")+0);
\t\techo ' document.getElementById(\\'element5\\').style.width=\\''.\$mem.'%\\'; ';
\t\techo ' document.getElementById(\\'element6\\').style.width=\\''.\$mem2.'%\\'; ';
\t\techo ' document.getElementById(\\'box5\\').innerHTML=\\''.\$m.'MB / \\'; ';
\t\techo ' document.getElementById(\\'box6\\').innerHTML=\\''.\$m2.'MB / \\'; ';
\t}
\techo '</script>'.\"\\n\";
\tob_flush();
\tflush();
}
/*-- END PROGRESS-BAR --*/



function RestrictUnicodeFonts(\$res) {
\t// \$res = array of (Unicode) fonts to restrict to: e.g. norasi|norasiB - language specific
\tif (count(\$res)) {\t// Leave full list of available fonts if passed blank array
\t\t\$this->available_unifonts = \$res;
\t}
\telse { \$this->available_unifonts = \$this->default_available_fonts; }
\tif (count(\$this->available_unifonts) == 0) { \$this->available_unifonts[] = \$this->default_available_fonts[0]; }
\t\$this->available_unifonts = array_values(\$this->available_unifonts);
}


function setMBencoding(\$enc) {
\tif (\$this->mb_enc != \$enc) {
\t\t\$this->mb_enc = \$enc;
\t\tmb_internal_encoding(\$this->mb_enc);
\t}
}


function SetMargins(\$left,\$right,\$top) {
\t//Set left, top and right margins
\t\$this->lMargin=\$left;
\t\$this->rMargin=\$right;
\t\$this->tMargin=\$top;
}

function ResetMargins() {
\t//ReSet left, top margins
\tif ((\$this->forcePortraitHeaders || \$this->forcePortraitMargins) && \$this->DefOrientation=='P' && \$this->CurOrientation=='L') {
\t    if ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\$this->tMargin=\$this->orig_rMargin;
\t\t\$this->bMargin=\$this->orig_lMargin;
\t    }
\t    else {\t// ODD\t// OR NOT MIRRORING MARGINS/FOOTERS
\t\t\$this->tMargin=\$this->orig_lMargin;
\t\t\$this->bMargin=\$this->orig_rMargin;
\t    }
\t   \$this->lMargin=\$this->DeflMargin;
\t   \$this->rMargin=\$this->DefrMargin;
\t   \$this->MarginCorrection = 0;
\t   \$this->PageBreakTrigger=\$this->h-\$this->bMargin;
\t}
\telse  if ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\$this->lMargin=\$this->DefrMargin;
\t\t\$this->rMargin=\$this->DeflMargin;
\t\t\$this->MarginCorrection = \$this->DefrMargin-\$this->DeflMargin;

\t}
\telse {\t// ODD\t// OR NOT MIRRORING MARGINS/FOOTERS
\t\t\$this->lMargin=\$this->DeflMargin;
\t\t\$this->rMargin=\$this->DefrMargin;
\t\tif (\$this->mirrorMargins) { \$this->MarginCorrection = \$this->DeflMargin-\$this->DefrMargin; }
\t}
\t\$this->x=\$this->lMargin;

}

function SetLeftMargin(\$margin) {
\t//Set left margin
\t\$this->lMargin=\$margin;
\tif(\$this->page>0 and \$this->x<\$margin) \$this->x=\$margin;
}

function SetTopMargin(\$margin) {
\t//Set top margin
\t\$this->tMargin=\$margin;
}

function SetRightMargin(\$margin) {
\t//Set right margin
\t\$this->rMargin=\$margin;
}

function SetAutoPageBreak(\$auto,\$margin=0) {
\t//Set auto page break mode and triggering margin
\t\$this->autoPageBreak=\$auto;
\t\$this->bMargin=\$margin;
\t\$this->PageBreakTrigger=\$this->h-\$margin;
}

function SetDisplayMode(\$zoom,\$layout='continuous') {
\t//Set display mode in viewer
\tif(\$zoom=='fullpage' or \$zoom=='fullwidth' or \$zoom=='real' or \$zoom=='default' or !is_string(\$zoom))
\t\t\$this->ZoomMode=\$zoom;
\telse
\t\t\$this->Error('Incorrect zoom display mode: '.\$zoom);
\tif(\$layout=='single' or \$layout=='continuous' or \$layout=='two' or \$layout=='twoleft' or \$layout=='tworight' or \$layout=='default')
\t\t\$this->LayoutMode=\$layout;
\telse
\t\t\$this->Error('Incorrect layout display mode: '.\$layout);
}

function SetCompression(\$compress) {
\t//Set page compression
\tif(function_exists('gzcompress'))\t\$this->compress=\$compress;
\telse \$this->compress=false;
}

function SetTitle(\$title) {
\t//Title of document // Arrives as UTF-8
\t\$this->title = \$title;
}

function SetSubject(\$subject) {
\t//Subject of document
\t\$this->subject= \$subject;
}

function SetAuthor(\$author) {
\t//Author of document
\t\$this->author= \$author;
}

function SetKeywords(\$keywords) {
\t//Keywords of document
\t\$this->keywords= \$keywords;
}

function SetCreator(\$creator) {
\t//Creator of document
\t\$this->creator= \$creator;
}


function SetAnchor2Bookmark(\$x) {
\t\$this->anchor2Bookmark = \$x;
}

function AliasNbPages(\$alias='{nb}') {
\t//Define an alias for total number of pages
\t\$this->aliasNbPg=\$alias;
}

function AliasNbPageGroups(\$alias='{nbpg}') {
\t//Define an alias for total number of pages in a group
\t\$this->aliasNbPgGp=\$alias;
}

function SetAlpha(\$alpha, \$bm='Normal', \$return=false, \$mode='B') {
// alpha: real value from 0 (transparent) to 1 (opaque)
// bm:    blend mode, one of the following:
//          Normal, Multiply, Screen, Overlay, Darken, Lighten, ColorDodge, ColorBurn,
//          HardLight, SoftLight, Difference, Exclusion, Hue, Saturation, Color, Luminosity
// set alpha for stroking (CA) and non-stroking (ca) operations
// mode determines F (fill) S (stroke) B (both)
\tif ((\$this->PDFA || \$this->PDFX) && \$alpha!=1) {
\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"Image opacity must be 100% (Opacity changed to 100%)\"; }
\t\t\$alpha = 1;
\t}
\t\$a = array('BM'=>'/'.\$bm);
\tif (\$mode=='F' || \$mode=='B') \$a['ca'] = \$alpha;\t// mPDF 5.7.2
\tif (\$mode=='S' || \$mode=='B') \$a['CA'] = \$alpha;\t// mPDF 5.7.2
\t\$gs = \$this->AddExtGState(\$a);
\tif (\$return) { return sprintf('/GS%d gs', \$gs); }
\telse { \$this->_out(sprintf('/GS%d gs', \$gs)); }
}

function AddExtGState(\$parms) {
\t\$n = count(\$this->extgstates);
\t// check if graphics state already exists
\tfor (\$i=1; \$i<=\$n; \$i++) {
\t  if (count(\$this->extgstates[\$i]['parms']) == count(\$parms)) {
\t    \$same = true;
\t    foreach(\$this->extgstates[\$i]['parms'] AS \$k=>\$v) {
\t\tif (!isset(\$parms[\$k]) || \$parms[\$k] != \$v) { \$same = false; break; }
\t    }
\t    if (\$same) { return \$i; }
\t  }
\t}
\t\$n++;
\t\$this->extgstates[\$n]['parms'] = \$parms;
\treturn \$n;
}

function SetVisibility(\$v) {
\tif ((\$this->PDFA || \$this->PDFX) && \$this->visibility!='visible') { \$this->PDFAXwarnings[] = \"Cannot set visibility to anything other than full when using PDFA or PDFX\"; return ''; }
\telse if (!\$this->PDFA && !\$this->PDFX)
\t\t\$this->pdf_version='1.5';
\tif(\$this->visibility!='visible') {
\t\t\$this->_out('EMC');
\t\t\$this->hasOC=intval(\$this->hasOC );\t// mPDF 5.6.01
\t}
\tif(\$v=='printonly') {
\t\t\$this->_out('/OC /OC1 BDC');
\t\t\$this->hasOC=(\$this->hasOC | 1);\t// mPDF 5.6.01
\t}
\telseif(\$v=='screenonly') {
\t\t\$this->_out('/OC /OC2 BDC');
\t\t\$this->hasOC=(\$this->hasOC | 2);\t// mPDF 5.6.01
\t}
\telseif(\$v=='hidden') {
\t\t\$this->_out('/OC /OC3 BDC');
\t\t\$this->hasOC=(\$this->hasOC | 4);\t// mPDF 5.6.01
\t}
\telseif(\$v!='visible')
\t\t\$this->Error('Incorrect visibility: '.\$v);
\t\$this->visibility=\$v;
}

function Error(\$msg) {
\t//Fatal error
\theader('Content-Type: text/html; charset=utf-8');
\tdie('<B>mPDF error: </B>'.\$msg);
}

function Open() {
\t//Begin document
\tif(\$this->state==0)\t\$this->_begindoc();
}

function Close() {
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'2','Closing last page'); }\t// *PROGRESS-BAR*
\t//Terminate document
\tif(\$this->state==3)\treturn;
\tif(\$this->page==0) \$this->AddPage(\$this->CurOrientation);
\tif (count(\$this->cellBorderBuffer)) { \$this->printcellbuffer(); }\t// *TABLES*
\tif (\$this->tablebuffer) { \$this->printtablebuffer(); }\t// *TABLES*
/*-- COLUMNS --*/

\tif (\$this->ColActive) {
\t\t\$this->SetColumns(0);
\t\t\$this->ColActive = 0;
\t\tif (count(\$this->columnbuffer)) { \$this->printcolumnbuffer(); }
\t}
/*-- END COLUMNS --*/
\tif (count(\$this->divbuffer)) { \$this->printdivbuffer(); }

\t// BODY Backgrounds
\t\$s = '';

\t\$s .= \$this->PrintBodyBackgrounds();

\t\$s .= \$this->PrintPageBackgrounds();
\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', \"\\n\".\$s.\"\\n\".'\\\\1', \$this->pages[\$this->page]);
\t\$this->pageBackgrounds = array();

\tif(\$this->visibility!='visible')
\t\t\$this->SetVisibility('visible');
\t// mPDF 5.6.01 - LAYERS
\t\$this->EndLayer();

\tif (!\$this->tocontents || !\$this->tocontents->TOCmark) { //Page footer
\t\t\$this->InFooter=true;
\t\t\$this->Footer();
\t\t\$this->InFooter=false;
\t}
\tif (\$this->tocontents && (\$this->tocontents->TOCmark || count(\$this->tocontents->m_TOC))) { \$this->tocontents->insertTOC(); }\t// *TOC*

\t//Close page
\t\$this->_endpage();

\t//Close document
\t\$this->_enddoc();
}

/*-- BACKGROUNDS --*/
function _resizeBackgroundImage(\$imw, \$imh, \$cw, \$ch, \$resize=0, \$repx, \$repy, \$pba=array(), \$size=array()) {\t// mPDF 5.6.10
\t// pba is background positioning area (from CSS background-origin) may not always be set [x,y,w,h]
\t// size is from CSS3 background-size - takes precendence over old resize
\t//\t\$w - absolute length or % or auto or cover | contain
\t//\t\$h - absolute length or % or auto or cover | contain
\t// mPDF 5.6.10
\tif (isset(\$pba['w'])) \$cw = \$pba['w'];
\tif (isset(\$pba['h'])) \$ch = \$pba['h'];

\t\$cw = \$cw*_MPDFK;
\t\$ch = \$ch*_MPDFK;
\tif (empty(\$size) && !\$resize) { return array(\$imw, \$imh, \$repx, \$repy); }

\t// mPDF 5.6.10
\tif (isset(\$size['w']) && \$size['w']) {
\t\tif (\$size['w']=='contain') {
\t\t// Scale the image, while preserving its intrinsic aspect ratio (if any), to the largest size such that both its width and its height can fit inside the background positioning area.
\t\t// Same as resize==3
\t\t\t\$h = \$imh * \$cw/\$imw;
\t\t\t\$w = \$cw;
\t\t\tif (\$h > \$ch) {
\t\t\t\t\$w = \$w * \$ch/\$h;
\t\t\t\t\$h = \$ch;
\t\t\t}
\t\t}
\t\telse if (\$size['w']=='cover') {
\t\t// Scale the image, while preserving its intrinsic aspect ratio (if any), to the smallest size such that both its width and its height can completely cover the background positioning area.
\t\t\t\$h = \$imh * \$cw/\$imw;
\t\t\t\$w = \$cw;
\t\t\tif (\$h < \$ch) {
\t\t\t\t\$w = \$w * \$h/\$ch;
\t\t\t\t\$h = \$ch;
\t\t\t}
\t\t}
\t\telse {
\t\t\tif (stristr(\$size['w'] ,'%')) {
\t\t\t\t\$size['w'] += 0;
\t\t\t\t\$size['w'] /= 100;
\t\t\t\t\$size['w'] = (\$cw * \$size['w']);
\t\t\t}
\t\t\tif (stristr(\$size['h'] ,'%')) {
\t\t\t\t\$size['h'] += 0;
\t\t\t\t\$size['h'] /= 100;
\t\t\t\t\$size['h'] = (\$ch * \$size['h']);
\t\t\t}
\t\t\tif (\$size['w']=='auto' && \$size['h']=='auto') {
\t\t\t\t\$w = \$imw;
\t\t\t\t\$h = \$imh;
\t\t\t}
\t\t\telse if (\$size['w']=='auto' && \$size['h']!='auto') {
\t\t\t\t\$w = \$imw * \$size['h']/\$imh;
\t\t\t\t\$h = \$size['h'];
\t\t\t}
\t\t\telse if (\$size['w']!='auto' && \$size['h']=='auto') {
\t\t\t\t\$h = \$imh * \$size['w']/\$imw;
\t\t\t\t\$w = \$size['w'];
\t\t\t}
\t\t\telse {
\t\t\t\t\$w = \$size['w'];
\t\t\t\t\$h = \$size['h'];
\t\t\t}
\t\t}
\t\treturn array(\$w, \$h, \$repx, \$repy);
\t}
\telse if (\$resize==1 && \$imw > \$cw) {
\t\t\$h = \$imh * \$cw/\$imw;
\t\treturn array(\$cw, \$h, \$repx, \$repy);
\t}
\telse if (\$resize==2 && \$imh > \$ch) {
\t\t\$w = \$imw * \$ch/\$imh;
\t\treturn array(\$w, \$ch, \$repx, \$repy);
\t}
\telse if (\$resize==3) {
\t\t\$w = \$imw;
\t\t\$h = \$imh;
\t\tif (\$w > \$cw) {
\t\t\t\$h = \$h * \$cw/\$w;
\t\t\t\$w = \$cw;
\t\t}
\t\tif (\$h > \$ch) {
\t\t\t\$w = \$w * \$ch/\$h;
\t\t\t\$h = \$ch;
\t\t}
\t\treturn array(\$w, \$h, \$repx, \$repy);
\t}
\telse if (\$resize==4) {
\t\t\$h = \$imh * \$cw/\$imw;
\t\treturn array(\$cw, \$h, \$repx, \$repy);
\t}
\telse if (\$resize==5) {
\t\t\$w = \$imw * \$ch/\$imh;
\t\treturn array(\$w, \$ch, \$repx, \$repy);
\t}
\telse if (\$resize==6) {
\t\treturn array(\$cw, \$ch, \$repx, \$repy);
\t}
\treturn array(\$imw, \$imh, \$repx, \$repy);
}


function SetBackground(&\$properties, &\$maxwidth) {
\t// mPDF 5.6.10  5.6.11
\tif (isset(\$properties['BACKGROUND-ORIGIN']) && (\$properties['BACKGROUND-ORIGIN']=='border-box' || \$properties['BACKGROUND-ORIGIN']== 'content-box')) { \$origin = \$properties['BACKGROUND-ORIGIN']; }
\telse { \$origin = 'padding-box'; }
\t// mPDF 5.6.10
\tif (isset(\$properties['BACKGROUND-SIZE'])) {
\t\tif (stristr(\$properties['BACKGROUND-SIZE'] ,'contain') ) { \$bsw = \$bsh = 'contain'; }
\t\telse if (stristr(\$properties['BACKGROUND-SIZE'] ,'cover') ) { \$bsw = \$bsh = 'cover'; }
\t\telse {
\t\t\t\$bsw = \$bsh = 'auto';
\t\t\t\$sz = preg_split('/\\s+/',trim(\$properties['BACKGROUND-SIZE']));
\t\t\tif (count(\$sz)==2) { \$bsw = \$sz[0]; \$bsh = \$sz[1]; }
\t\t\telse { \$bsw = \$sz[0]; }
\t\t\tif (!stristr(\$bsw ,'%') && !stristr(\$bsw ,'auto') ) { \$bsw = \$this->ConvertSize(\$bsw ,\$maxwidth,\$this->FontSize); }
\t\t\tif (!stristr(\$bsh ,'%') && !stristr(\$bsh ,'auto') ) { \$bsh = \$this->ConvertSize(\$bsh ,\$maxwidth,\$this->FontSize); }
\t\t}
\t\t\$size = array('w'=>\$bsw, 'h'=>\$bsh);
\t}
\t   if (preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/',\$properties['BACKGROUND-IMAGE'])) {
\t\treturn array('gradient'=>\$properties['BACKGROUND-IMAGE'], 'origin'=>\$origin, 'size'=>\$size );\t// mPDF 5.6.10
\t   }
\t   else {
\t\t\$file = \$properties['BACKGROUND-IMAGE'];
\t\t\$sizesarray = \$this->Image(\$file,0,0,0,0,'','',false, false, false, false, true);
\t\tif (isset(\$sizesarray['IMAGE_ID'])) {
\t\t\t\$image_id = \$sizesarray['IMAGE_ID'];
\t\t\t\$orig_w = \$sizesarray['WIDTH']*_MPDFK;\t\t// in user units i.e. mm
 \t\t\t\$orig_h = \$sizesarray['HEIGHT']*_MPDFK;\t\t// (using \$this->img_dpi)
\t\t\tif (isset(\$properties['BACKGROUND-IMAGE-RESOLUTION'])) {
\t\t\t\tif (preg_match('/from-image/i', \$properties['BACKGROUND-IMAGE-RESOLUTION']) && isset(\$sizesarray['set-dpi']) && \$sizesarray['set-dpi']>0) {
\t\t\t\t\t\$orig_w *= \$this->img_dpi / \$sizesarray['set-dpi'];
\t\t\t\t\t\$orig_h *= \$this->img_dpi / \$sizesarray['set-dpi'];
\t\t\t\t}
\t\t\t\telse if (preg_match('/(\\d+)dpi/i', \$properties['BACKGROUND-IMAGE-RESOLUTION'], \$m)) {
\t\t\t\t\t\$dpi = \$m[1];
\t\t\t\t\tif (\$dpi > 0) {
\t\t\t\t\t\t\$orig_w *= \$this->img_dpi / \$dpi;
\t\t\t\t\t\t\$orig_h *= \$this->img_dpi / \$dpi;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t\$x_repeat = true;
\t\t\t\$y_repeat = true;
\t\t\tif (isset(\$properties['BACKGROUND-REPEAT'])) {
\t\t\t\tif (\$properties['BACKGROUND-REPEAT']=='no-repeat' || \$properties['BACKGROUND-REPEAT']=='repeat-x') { \$y_repeat = false; }
\t\t\t\tif (\$properties['BACKGROUND-REPEAT']=='no-repeat' || \$properties['BACKGROUND-REPEAT']=='repeat-y') { \$x_repeat = false; }
\t\t\t}
\t\t\t\$x_pos = 0;
\t\t\t\$y_pos = 0;
\t\t\tif (isset(\$properties['BACKGROUND-POSITION'])) {
\t\t\t\t\$ppos = preg_split('/\\s+/',\$properties['BACKGROUND-POSITION']);
\t\t\t\t\$x_pos = \$ppos[0];
\t\t\t\t\$y_pos = \$ppos[1];
\t\t\t\tif (!stristr(\$x_pos ,'%') ) { \$x_pos = \$this->ConvertSize(\$x_pos ,\$maxwidth,\$this->FontSize); }
\t\t\t\tif (!stristr(\$y_pos ,'%') ) { \$y_pos = \$this->ConvertSize(\$y_pos ,\$maxwidth,\$this->FontSize); }
\t\t\t}
\t\t\tif (isset(\$properties['BACKGROUND-IMAGE-RESIZE'])) { \$resize = \$properties['BACKGROUND-IMAGE-RESIZE']; }
\t\t\telse { \$resize = 0; }
\t\t\tif (isset(\$properties['BACKGROUND-IMAGE-OPACITY'])) { \$opacity = \$properties['BACKGROUND-IMAGE-OPACITY']; }
\t\t\telse { \$opacity = 1; }
\t\t\treturn array('image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$sizesarray['itype'], 'origin'=>\$origin, 'size'=>\$size );
\t\t}
\t   }
\t   return false;
}
/*-- END BACKGROUNDS --*/

function PrintBodyBackgrounds() {
\t\$s = '';
\t\$clx = 0;
\t\$cly = 0;
\t\$clw = \$this->w;
\t\$clh = \$this->h;
\t// If using bleed and trim margins in paged media
\tif (\$this->pageDim[\$this->page]['outer_width_LR'] || \$this->pageDim[\$this->page]['outer_width_TB']) {
\t\t\$clx = \$this->pageDim[\$this->page]['outer_width_LR'] - \$this->pageDim[\$this->page]['bleedMargin'];
\t\t\$cly = \$this->pageDim[\$this->page]['outer_width_TB'] - \$this->pageDim[\$this->page]['bleedMargin'];
\t\t\$clw = \$this->w - 2*\$clx;
\t\t\$clh = \$this->h - 2*\$cly;
\t}

\tif (\$this->bodyBackgroundColor) {
\t\t\$s .= 'q ' .\$this->SetFColor(\$this->bodyBackgroundColor, true).\"\\n\";
\t\tif (\$this->bodyBackgroundColor{0}==5) {\t// RGBa
\t\t\t\$s .= \$this->SetAlpha(ord(\$this->bodyBackgroundColor{4})/100, 'Normal', true, 'F').\"\\n\";
\t\t}
\t\telse if (\$this->bodyBackgroundColor{0}==6) {\t// CMYKa
\t\t\t\$s .= \$this->SetAlpha(ord(\$this->bodyBackgroundColor{5})/100, 'Normal', true, 'F').\"\\n\";
\t\t}
\t\t\$s .= sprintf('%.3F %.3F %.3F %.3F re f Q', (\$clx*_MPDFK), (\$cly*_MPDFK),\$clw*_MPDFK,\$clh*_MPDFK).\"\\n\";
\t}

/*-- BACKGROUNDS --*/
\tif (\$this->bodyBackgroundGradient) {
\t\t\$g = \$this->grad->parseBackgroundGradient(\$this->bodyBackgroundGradient);
\t\tif (\$g) {
\t\t\t\$s .= \$this->grad->Gradient(\$clx, \$cly, \$clw, \$clh, (isset(\$g['gradtype']) ? \$g['gradtype'] : null), \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend'], true);
\t\t}
\t}
\tif (\$this->bodyBackgroundImage) {
\t   if ( \$this->bodyBackgroundImage['gradient'] && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$this->bodyBackgroundImage['gradient'])) {
\t\t\$g = \$this->grad->parseMozGradient( \$this->bodyBackgroundImage['gradient']);
\t\tif (\$g) {
\t\t\t\$s .= \$this->grad->Gradient(\$clx, \$cly, \$clw, \$clh, \$g['type'], \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend'], true);
\t\t}
\t   }
\t   else if (\$this->bodyBackgroundImage['image_id']) {\t// Background pattern
\t\t\t\$n = count(\$this->patterns)+1;
\t\t\t// If using resize, uses TrimBox (not including the bleed)
\t\t\tlist(\$orig_w, \$orig_h, \$x_repeat, \$y_repeat) = \$this->_resizeBackgroundImage(\$this->bodyBackgroundImage['orig_w'], \$this->bodyBackgroundImage['orig_h'], \$clw, \$clh, \$this->bodyBackgroundImage['resize'], \$this->bodyBackgroundImage['x_repeat'], \$this->bodyBackgroundImage['y_repeat']);

\t\t\t\$this->patterns[\$n] = array('x'=>\$clx, 'y'=>\$cly, 'w'=>\$clw, 'h'=>\$clh, 'pgh'=>\$this->h, 'image_id'=>\$this->bodyBackgroundImage['image_id'], 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$this->bodyBackgroundImage['x_pos'], 'y_pos'=>\$this->bodyBackgroundImage['y_pos'], 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'itype'=>\$this->bodyBackgroundImage['itype']);
\t\t\tif ((\$this->bodyBackgroundImage['opacity']>0 || \$this->bodyBackgroundImage['opacity']==='0') && \$this->bodyBackgroundImage['opacity']<1) { \$opac = \$this->SetAlpha(\$this->bodyBackgroundImage['opacity'],'Normal',true); }
\t\t\telse { \$opac = ''; }
\t\t\t\$s .= sprintf('q /Pattern cs /P%d scn %s %.3F %.3F %.3F %.3F re f Q', \$n, \$opac, (\$clx*_MPDFK), (\$cly*_MPDFK),\$clw*_MPDFK, \$clh*_MPDFK) .\"\\n\";
\t   }
\t}
/*-- END BACKGROUNDS --*/
\treturn \$s;
}


function PrintPageBackgrounds(\$adjustmenty=0) {
\t\$s = '';

\tksort(\$this->pageBackgrounds);
\tforeach(\$this->pageBackgrounds AS \$bl=>\$pbs) {
\t\tforeach (\$pbs AS \$pb) {
\t\t  if ((!isset(\$pb['image_id']) && !isset(\$pb['gradient'])) || isset(\$pb['shadowonly'])) {\t// Background colour or boxshadow
\t\t\t// mPDF 5.6.01  - LAYERS
\t\t\tif(\$pb['z-index']>0) {
\t\t\t\t\$this->current_layer = \$pb['z-index'];
\t\t\t\t\$s .= \"\\n\".'/OCBZ-index /ZI'.\$pb['z-index'].' BDC'.\"\\n\";
\t\t\t}

\t\t\tif(\$pb['visibility']!='visible') {
\t\t\t\tif(\$pb['visibility']=='printonly')
\t\t\t\t\t\$s .= '/OC /OC1 BDC'.\"\\n\";
\t\t\t\telse if(\$pb['visibility']=='screenonly')
\t\t\t\t\t\$s .= '/OC /OC2 BDC'.\"\\n\";
\t\t\t\telse if(\$pb['visibility']=='hidden')
\t\t\t\t\t\$s .= '/OC /OC3 BDC'.\"\\n\";
\t\t\t}
\t\t\t// Box shadow
\t\t\tif (isset(\$pb['shadow']) && \$pb['shadow']) { \$s .= \$pb['shadow'].\"\\n\"; }
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= \$pb['clippath'].\"\\n\"; }
\t\t\t\$s .= 'q '.\$this->SetFColor(\$pb['col'], true).\"\\n\";
\t\t\tif (\$pb['col']{0}==5) {\t// RGBa
\t\t\t\t\$s .= \$this->SetAlpha(ord(\$pb['col']{4})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t}
\t\t\telse if (\$pb['col']{0}==6) {\t// CMYKa
\t\t\t\t\$s .= \$this->SetAlpha(ord(\$pb['col']{5})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t}
\t\t\t\$s .= sprintf('%.3F %.3F %.3F %.3F re f Q',\$pb['x']*_MPDFK,(\$this->h-\$pb['y'])*_MPDFK,\$pb['w']*_MPDFK,-\$pb['h']*_MPDFK).\"\\n\";
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= 'Q'.\"\\n\"; }
\t\t\tif(\$pb['visibility']!='visible')
\t\t\t\t\$s .= 'EMC'.\"\\n\";

\t\t\t// mPDF 5.6.01  - LAYERS
\t\t\tif(\$pb['z-index']>0) {
\t\t\t\t\$s .= \"\\n\".'EMCBZ-index'.\"\\n\";
\t\t\t\t\$this->current_layer = 0;
\t\t\t}
\t\t  }
\t\t}
/*-- BACKGROUNDS --*/
\t\tforeach (\$pbs AS \$pb) {
\t\t  // mPDF 5.6.01  - LAYERS
\t \t  if ((isset(\$pb['gradient']) && \$pb['gradient']) || (isset(\$pb['image_id']) && \$pb['image_id'])) {
\t\t \tif(\$pb['z-index']>0) {
\t\t\t\t\$this->current_layer = \$pb['z-index'];
\t\t\t\t\$s .= \"\\n\".'/OCGZ-index /ZI'.\$pb['z-index'].' BDC'.\"\\n\";
\t\t \t}
\t\t \tif(\$pb['visibility']!='visible') {
\t\t\t\tif(\$pb['visibility']=='printonly')
\t\t\t\t\t\$s .= '/OC /OC1 BDC'.\"\\n\";
\t\t\t\telse if(\$pb['visibility']=='screenonly')
\t\t\t\t\t\$s .= '/OC /OC2 BDC'.\"\\n\";
\t\t\t\telse if(\$pb['visibility']=='hidden')
\t\t\t\t\t\$s .= '/OC /OC3 BDC'.\"\\n\";
\t\t \t}
\t\t  }
\t \t  if (isset(\$pb['gradient']) && \$pb['gradient']) {
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= \$pb['clippath'].\"\\n\"; }
\t\t\t\$s .= \$this->grad->Gradient(\$pb['x'], \$pb['y'], \$pb['w'], \$pb['h'], \$pb['gradtype'], \$pb['stops'], \$pb['colorspace'], \$pb['coords'], \$pb['extend'], true);
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= 'Q'.\"\\n\"; }
\t\t  }
\t\t  else if (isset(\$pb['image_id']) && \$pb['image_id']) {\t// Background Image
\t\t\t\$pb['y'] -= \$adjustmenty;
\t\t\t\$pb['h'] += \$adjustmenty;
\t\t\t\$n = count(\$this->patterns)+1;
\t\t\tlist(\$orig_w, \$orig_h, \$x_repeat, \$y_repeat) = \$this->_resizeBackgroundImage(\$pb['orig_w'], \$pb['orig_h'], \$pb['w'], \$pb['h'], \$pb['resize'], \$pb['x_repeat'], \$pb['y_repeat'], \$pb['bpa'], \$pb['size']);\t// mPDF 5.6.10
\t\t\t\$this->patterns[\$n] = array('x'=>\$pb['x'], 'y'=>\$pb['y'], 'w'=>\$pb['w'], 'h'=>\$pb['h'], 'pgh'=>\$this->h, 'image_id'=>\$pb['image_id'], 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$pb['x_pos'], 'y_pos'=>\$pb['y_pos'], 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'itype'=>\$pb['itype'], 'bpa'=>\$pb['bpa']);\t// mPDF 5.6.10
\t\t\t\$x = \$pb['x']*_MPDFK;
\t\t\t\$y = (\$this->h - \$pb['y'])*_MPDFK;
\t\t\t\$w = \$pb['w']*_MPDFK;
\t\t\t\$h = -\$pb['h']*_MPDFK;
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= \$pb['clippath'].\"\\n\"; }
\t\t\tif (\$this->writingHTMLfooter || \$this->writingHTMLheader) {\t// Write each (tiles) image rather than use as a pattern
\t\t\t\t\$iw = \$pb['orig_w']/_MPDFK;
\t\t\t\t\$ih = \$pb['orig_h']/_MPDFK;

\t\t\t\t\$w = \$pb['w'];
\t\t\t\t\$h = \$pb['h'];
\t\t\t\t\$x0 = \$pb['x'];
\t\t\t\t\$y0 = \$pb['y'];

\t\t\t\t// mPDF 5.6.11
\t\t\t\tif (isset(\$pb['bpa']) && \$pb['bpa']) {
\t\t\t\t\t\$w = \$pb['bpa']['w'];
\t\t\t\t\t\$h = \$pb['bpa']['h'];
\t\t\t\t\t\$x0 = \$pb['bpa']['x'];
\t\t\t\t\t\$y0 = \$pb['bpa']['y'];
\t\t\t\t}

\t\t\t\t// mPDF 5.6.11
\t\t\t\tif (isset(\$pb['size']['w']) && \$pb['size']['w']) {
\t\t\t\t\t\$size = \$pb['size'];

\t\t\t\t\tif (\$size['w']=='contain') {
\t\t\t\t\t// Scale the image, while preserving its intrinsic aspect ratio (if any), to the largest size such that both its width and its height can fit inside the background positioning area.
\t\t\t\t\t// Same as resize==3
\t\t\t\t\t\t\$ih = \$ih * \$pb['bpa']['w']/\$iw;
\t\t\t\t\t\t\$iw = \$pb['bpa']['w'];
\t\t\t\t\t\tif (\$ih > \$pb['bpa']['h']) {
\t\t\t\t\t\t\t\$iw = \$iw * \$pb['bpa']['h']/\$ih;
\t\t\t\t\t\t\t\$ih = \$pb['bpa']['h'];
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\telse if (\$size['w']=='cover') {
\t\t\t\t\t// Scale the image, while preserving its intrinsic aspect ratio (if any), to the smallest size such that both its width and its height can completely cover the background positioning area.
\t\t\t\t\t\t\$ih = \$ih * \$pb['bpa']['w']/\$iw;
\t\t\t\t\t\t\$iw = \$pb['bpa']['w'];
\t\t\t\t\t\tif (\$ih < \$pb['bpa']['h']) {
\t\t\t\t\t\t\t\$iw = \$iw * \$ih/\$pb['bpa']['h'];
\t\t\t\t\t\t\t\$ih = \$pb['bpa']['h'];
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\tif (stristr(\$size['w'] ,'%')) {
\t\t\t\t\t\t\t\$size['w'] += 0;
\t\t\t\t\t\t\t\$size['w'] /= 100;
\t\t\t\t\t\t\t\$size['w'] = (\$pb['bpa']['w'] * \$size['w']);
\t\t\t\t\t\t}
\t\t\t\t\t\tif (stristr(\$size['h'] ,'%')) {
\t\t\t\t\t\t\t\$size['h'] += 0;
\t\t\t\t\t\t\t\$size['h'] /= 100;
\t\t\t\t\t\t\t\$size['h'] = (\$pb['bpa']['h'] * \$size['h']);
\t\t\t\t\t\t}
\t\t\t\t\t\tif (\$size['w']=='auto' && \$size['h']=='auto') {
\t\t\t\t\t\t\t\$iw = \$iw;
\t\t\t\t\t\t\t\$ih = \$ih;
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$size['w']=='auto' && \$size['h']!='auto') {
\t\t\t\t\t\t\t\$iw = \$iw * \$size['h']/\$ih;
\t\t\t\t\t\t\t\$ih = \$size['h'];
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$size['w']!='auto' && \$size['h']=='auto') {
\t\t\t\t\t\t\t\$ih = \$ih * \$size['w']/\$iw;
\t\t\t\t\t\t\t\$iw = \$size['w'];
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$iw = \$size['w'];
\t\t\t\t\t\t\t\$ih = \$size['h'];
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\t// Number to repeat
\t\t\t\tif (\$pb['x_repeat']) { \$nx = ceil(\$pb['w']/\$iw)+1; } \t// mPDF 5.6.11
\t\t\t\telse { \$nx = 1; }
\t\t\t\tif (\$pb['y_repeat']) { \$ny = ceil(\$pb['h']/\$ih)+1; } \t// mPDF 5.6.11
\t\t\t\telse { \$ny = 1; }

\t\t\t\t\$x_pos = \$pb['x_pos'];
\t\t\t\tif (stristr(\$x_pos ,'%') ) {
\t\t\t\t\t\$x_pos += 0;
\t\t\t\t\t\$x_pos /= 100;
\t\t\t\t\t\$x_pos = (\$pb['bpa']['w'] * \$x_pos) - (\$iw * \$x_pos); \t// mPDF 5.6.11
\t\t\t\t}
\t\t\t\t\$y_pos = \$pb['y_pos'];
\t\t\t\tif (stristr(\$y_pos ,'%') ) {
\t\t\t\t\t\$y_pos += 0;
\t\t\t\t\t\$y_pos /= 100;
\t\t\t\t\t\$y_pos = (\$pb['bpa']['h'] * \$y_pos) - (\$ih * \$y_pos); \t// mPDF 5.6.11
\t\t\t\t}
\t\t\t\tif (\$nx>1) {
\t\t\t\t\twhile(\$x_pos>(\$pb['x']-\$pb['bpa']['x'])) { \$x_pos -= \$iw; }\t// mPDF 5.6.11
\t\t\t\t}
\t\t\t\tif (\$ny>1) {
\t\t\t\t\twhile(\$y_pos>(\$pb['y']-\$pb['bpa']['y'])) { \$y_pos -= \$ih; }\t// mPDF 5.6.11
\t\t\t\t}
\t\t\t\tfor(\$xi=0;\$xi<\$nx;\$xi++) {
\t\t\t\t  for(\$yi=0;\$yi<\$ny;\$yi++) {
\t\t\t\t\t\$x = \$x0 + \$x_pos + (\$iw*\$xi);
\t\t\t\t\t\$y = \$y0 + \$y_pos + (\$ih*\$yi);
\t\t\t\t\tif (\$pb['opacity']>0 && \$pb['opacity']<1) { \$opac = \$this->SetAlpha(\$pb['opacity'],'Normal',true); }
\t\t\t\t\telse { \$opac = ''; }
\t\t\t\t\t\$s .= sprintf(\"q %s %.3F 0 0 %.3F %.3F %.3F cm /I%d Do Q\", \$opac,\$iw*_MPDFK,\$ih*_MPDFK,\$x*_MPDFK,(\$this->h-(\$y+\$ih))*_MPDFK,\$pb['image_id']) .\"\\n\";
\t\t\t\t  }
\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t\t\tif ((\$pb['opacity']>0 || \$pb['opacity']==='0') && \$pb['opacity']<1) { \$opac = \$this->SetAlpha(\$pb['opacity'],'Normal',true); }
\t\t\t\telse { \$opac = ''; }
\t\t\t\t\$s .= sprintf('q /Pattern cs /P%d scn %s %.3F %.3F %.3F %.3F re f Q', \$n, \$opac, \$x, \$y, \$w, \$h) .\"\\n\";
\t\t\t}
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= 'Q'.\"\\n\"; }
\t\t  }
\t \t  if ((isset(\$pb['gradient']) && \$pb['gradient']) || (isset(\$pb['image_id']) && \$pb['image_id'])) {
\t\t \tif(\$pb['visibility']!='visible')
\t\t\t\t\$s .= 'EMC'.\"\\n\";

\t\t\t// mPDF 5.6.01  - LAYERS
\t\t\tif(\$pb['z-index']>0) {
\t\t\t\t\$s .= \"\\n\".'EMCGZ-index'.\"\\n\";
\t\t\t\t\$this->current_layer = 0;
\t\t\t}
\t\t  }

\t\t}
/*-- END BACKGROUNDS --*/
\t}
\treturn \$s;
}

function PrintTableBackgrounds(\$adjustmenty=0) {
\t\$s = '';
/*-- BACKGROUNDS --*/
\tksort(\$this->tableBackgrounds);
\tforeach(\$this->tableBackgrounds AS \$bl=>\$pbs) {
\t\tforeach (\$pbs AS \$pb) {
\t \t if ((!isset(\$pb['gradient']) || !\$pb['gradient']) && (!isset(\$pb['image_id']) || !\$pb['image_id'])) {
\t\t\t\$s .= 'q '.\$this->SetFColor(\$pb['col'], true).\"\\n\";
\t\t\tif (\$pb['col']{0}==5) {\t// RGBa
\t\t\t\t\$s .= \$this->SetAlpha(ord(\$pb['col']{4})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t}
\t\t\telse if (\$pb['col']{0}==6) {\t// CMYKa
\t\t\t\t\$s .= \$this->SetAlpha(ord(\$pb['col']{5})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t}
\t\t\t\$s .= sprintf('%.3F %.3F %.3F %.3F re %s Q',\$pb['x']*_MPDFK,(\$this->h-\$pb['y'])*_MPDFK,\$pb['w']*_MPDFK,-\$pb['h']*_MPDFK,'f').\"\\n\";
\t\t  }
\t \t if (isset(\$pb['gradient']) && \$pb['gradient']) {
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= \$pb['clippath'].\"\\n\"; }
\t\t\t\$s .= \$this->grad->Gradient(\$pb['x'], \$pb['y'], \$pb['w'], \$pb['h'], \$pb['gradtype'], \$pb['stops'], \$pb['colorspace'], \$pb['coords'], \$pb['extend'], true);
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= 'Q'.\"\\n\"; }
\t\t  }
\t\t  if (isset(\$pb['image_id']) && \$pb['image_id']) {\t// Background pattern
\t\t\t\$pb['y'] -= \$adjustmenty;
\t\t\t\$pb['h'] += \$adjustmenty;
\t\t\t\$n = count(\$this->patterns)+1;
\t\t\tlist(\$orig_w, \$orig_h, \$x_repeat, \$y_repeat) = \$this->_resizeBackgroundImage(\$pb['orig_w'], \$pb['orig_h'], \$pb['w'], \$pb['h'], \$pb['resize'], \$pb['x_repeat'], \$pb['y_repeat']);
\t\t\t\$this->patterns[\$n] = array('x'=>\$pb['x'], 'y'=>\$pb['y'], 'w'=>\$pb['w'], 'h'=>\$pb['h'], 'pgh'=>\$this->h, 'image_id'=>\$pb['image_id'], 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$pb['x_pos'], 'y_pos'=>\$pb['y_pos'], 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'itype'=>\$pb['itype']);
\t\t\t\$x = \$pb['x']*_MPDFK;
\t\t\t\$y = (\$this->h - \$pb['y'])*_MPDFK;
\t\t\t\$w = \$pb['w']*_MPDFK;
\t\t\t\$h = -\$pb['h']*_MPDFK;
\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= \$pb['clippath'].\"\\n\"; }

\t\t\t// mPDF 5.7.3
\t\t\tif ((\$this->writingHTMLfooter || \$this->writingHTMLheader) && (!isset(\$pb['clippath']) || \$pb['clippath']=='') ) {
\t\t\t\t// Set clipping path
\t\t\t\t\$pb['clippath'] = sprintf(' q 0 w %.3F %.3F m %.3F %.3F l %.3F %.3F l %.3F %.3F l %.3F %.3F l W n ', \$x, \$y, \$x, \$y+\$h, \$x+\$w, \$y+\$h, \$x+\$w, \$y, \$x, \$y);
\t\t\t}

\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= \$pb['clippath'].\"\\n\"; }

\t\t\t// mPDF 5.7.3
\t\t\tif (\$this->writingHTMLfooter || \$this->writingHTMLheader) {\t// Write each (tiles) image rather than use as a pattern
\t\t\t\t\$iw = \$pb['orig_w']/_MPDFK;
\t\t\t\t\$ih = \$pb['orig_h']/_MPDFK;

\t\t\t\t\$w = \$pb['w'];
\t\t\t\t\$h = \$pb['h'];
\t\t\t\t\$x0 = \$pb['x'];
\t\t\t\t\$y0 = \$pb['y'];

\t\t\t\tif (isset(\$pb['bpa']) && \$pb['bpa']) {
\t\t\t\t\t\$w = \$pb['bpa']['w'];
\t\t\t\t\t\$h = \$pb['bpa']['h'];
\t\t\t\t\t\$x0 = \$pb['bpa']['x'];
\t\t\t\t\t\$y0 = \$pb['bpa']['y'];
\t\t\t\t}

\t\t\t\tif (isset(\$pb['size']['w']) && \$pb['size']['w']) {
\t\t\t\t\t\$size = \$pb['size'];

\t\t\t\t\tif (\$size['w']=='contain') {
\t\t\t\t\t// Scale the image, while preserving its intrinsic aspect ratio (if any), to the largest size such that both its width and its height can fit inside the background positioning area.
\t\t\t\t\t// Same as resize==3
\t\t\t\t\t\t\$ih = \$ih * \$pb['bpa']['w']/\$iw;
\t\t\t\t\t\t\$iw = \$pb['bpa']['w'];
\t\t\t\t\t\tif (\$ih > \$pb['bpa']['h']) {
\t\t\t\t\t\t\t\$iw = \$iw * \$pb['bpa']['h']/\$ih;
\t\t\t\t\t\t\t\$ih = \$pb['bpa']['h'];
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\telse if (\$size['w']=='cover') {
\t\t\t\t\t// Scale the image, while preserving its intrinsic aspect ratio (if any), to the smallest size such that both its width and its height can completely cover the background positioning area.
\t\t\t\t\t\t\$ih = \$ih * \$pb['bpa']['w']/\$iw;
\t\t\t\t\t\t\$iw = \$pb['bpa']['w'];
\t\t\t\t\t\tif (\$ih < \$pb['bpa']['h']) {
\t\t\t\t\t\t\t\$iw = \$iw * \$ih/\$pb['bpa']['h'];
\t\t\t\t\t\t\t\$ih = \$pb['bpa']['h'];
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\tif (stristr(\$size['w'] ,'%')) {
\t\t\t\t\t\t\t\$size['w'] += 0;
\t\t\t\t\t\t\t\$size['w'] /= 100;
\t\t\t\t\t\t\t\$size['w'] = (\$pb['bpa']['w'] * \$size['w']);
\t\t\t\t\t\t}
\t\t\t\t\t\tif (stristr(\$size['h'] ,'%')) {
\t\t\t\t\t\t\t\$size['h'] += 0;
\t\t\t\t\t\t\t\$size['h'] /= 100;
\t\t\t\t\t\t\t\$size['h'] = (\$pb['bpa']['h'] * \$size['h']);
\t\t\t\t\t\t}
\t\t\t\t\t\tif (\$size['w']=='auto' && \$size['h']=='auto') {
\t\t\t\t\t\t\t\$iw = \$iw;
\t\t\t\t\t\t\t\$ih = \$ih;
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$size['w']=='auto' && \$size['h']!='auto') {
\t\t\t\t\t\t\t\$iw = \$iw * \$size['h']/\$ih;
\t\t\t\t\t\t\t\$ih = \$size['h'];
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$size['w']!='auto' && \$size['h']=='auto') {
\t\t\t\t\t\t\t\$ih = \$ih * \$size['w']/\$iw;
\t\t\t\t\t\t\t\$iw = \$size['w'];
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$iw = \$size['w'];
\t\t\t\t\t\t\t\$ih = \$size['h'];
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\t// Number to repeat
\t\t\t\tif (\$pb['x_repeat']) { \$nx = ceil(\$pb['w']/\$iw)+1; }
\t\t\t\telse { \$nx = 1; }
\t\t\t\tif (\$pb['y_repeat']) { \$ny = ceil(\$pb['h']/\$ih)+1; }
\t\t\t\telse { \$ny = 1; }

\t\t\t\t\$x_pos = \$pb['x_pos'];
\t\t\t\tif (stristr(\$x_pos ,'%') ) {
\t\t\t\t\t\$x_pos += 0;
\t\t\t\t\t\$x_pos /= 100;
\t\t\t\t\t\$x_pos = (\$pb['bpa']['w'] * \$x_pos) - (\$iw * \$x_pos);
\t\t\t\t}
\t\t\t\t\$y_pos = \$pb['y_pos'];
\t\t\t\tif (stristr(\$y_pos ,'%') ) {
\t\t\t\t\t\$y_pos += 0;
\t\t\t\t\t\$y_pos /= 100;
\t\t\t\t\t\$y_pos = (\$pb['bpa']['h'] * \$y_pos) - (\$ih * \$y_pos);
\t\t\t\t}
\t\t\t\tif (\$nx>1) {
\t\t\t\t\twhile(\$x_pos>(\$pb['x']-\$pb['bpa']['x'])) { \$x_pos -= \$iw; }
\t\t\t\t}
\t\t\t\tif (\$ny>1) {
\t\t\t\t\twhile(\$y_pos>(\$pb['y']-\$pb['bpa']['y'])) { \$y_pos -= \$ih; }
\t\t\t\t}
\t\t\t\tfor(\$xi=0;\$xi<\$nx;\$xi++) {
\t\t\t\t  for(\$yi=0;\$yi<\$ny;\$yi++) {
\t\t\t\t\t\$x = \$x0 + \$x_pos + (\$iw*\$xi);
\t\t\t\t\t\$y = \$y0 + \$y_pos + (\$ih*\$yi);
\t\t\t\t\tif (\$pb['opacity']>0 && \$pb['opacity']<1) { \$opac = \$this->SetAlpha(\$pb['opacity'],'Normal',true); }
\t\t\t\t\telse { \$opac = ''; }
\t\t\t\t\t\$s .= sprintf(\"q %s %.3F 0 0 %.3F %.3F %.3F cm /I%d Do Q\", \$opac,\$iw*_MPDFK,\$ih*_MPDFK,\$x*_MPDFK,(\$this->h-(\$y+\$ih))*_MPDFK,\$pb['image_id']) .\"\\n\";
\t\t\t\t  }
\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t\t\tif ((\$pb['opacity']>0 || \$pb['opacity']==='0') && \$pb['opacity']<1) { \$opac = \$this->SetAlpha(\$pb['opacity'],'Normal',true); }
\t\t\t\telse { \$opac = ''; }
\t\t\t\t\$s .= sprintf('q /Pattern cs /P%d scn %s %.3F %.3F %.3F %.3F re f Q', \$n, \$opac, \$x, \$y, \$w, \$h) .\"\\n\";
\t\t\t}

\t\t\tif (isset(\$pb['clippath']) && \$pb['clippath']) { \$s .= 'Q'.\"\\n\"; }
\t\t  }
\t\t}
\t}
/*-- END BACKGROUNDS --*/
\treturn \$s;
}

// mPDF 5.6.01 - LAYERS
function BeginLayer(\$id) {
\tif(\$this->current_layer>0) \$this->EndLayer();
\tif (\$id < 1) { return false; }
\tif (!isset(\$this->layers[\$id])) {
\t\t\$this->layers[\$id] = array('name'=>'Layer '.(\$id) );
\t\tif ((\$this->PDFA || \$this->PDFX)) { \$this->PDFAXwarnings[] = \"Cannot use layers when using PDFA or PDFX\"; return ''; }
\t\telse if (!\$this->PDFA && !\$this->PDFX) { \$this->pdf_version='1.5'; }
\t}
\t\$this->current_layer = \$id;
\t\$this->_out('/OCZ-index /ZI'.\$id.' BDC');

\t\$this->pageoutput[\$this->page] = array();
}

function EndLayer() {
\tif(\$this->current_layer>0) {
\t\t\$this->_out('EMCZ-index');
\t\t\$this->current_layer = 0;
\t}
}



// Depracated - can use AddPage for all
function AddPages(\$orientation='',\$condition='', \$resetpagenum='', \$pagenumstyle='', \$suppress='',\$mgl='',\$mgr='',\$mgt='',\$mgb='',\$mgh='',\$mgf='',\$ohname='',\$ehname='',\$ofname='',\$efname='',\$ohvalue=0,\$ehvalue=0,\$ofvalue=0,\$efvalue=0,\$pagesel='',\$newformat='')
{
\t\$this->AddPage(\$orientation,\$condition,\$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf, \$ohname, \$ehname, \$ofname, \$efname, \$ohvalue, \$ehvalue, \$ofvalue, \$efvalue,\$pagesel,\$newformat);
}


function AddPageByArray(\$a) {
\tif (!is_array(\$a)) { \$a = array(); }
\t\$orientation = (isset(\$a['orientation']) ? \$a['orientation'] : '');
\t\$condition = (isset(\$a['condition']) ? \$a['condition'] : (isset(\$a['type']) ? \$a['type'] : ''));
\t\$resetpagenum = (isset(\$a['resetpagenum']) ? \$a['resetpagenum'] : '');
\t\$pagenumstyle = (isset(\$a['pagenumstyle']) ? \$a['pagenumstyle'] : '');
\t\$suppress = (isset(\$a['suppress']) ? \$a['suppress'] : '');
\t\$mgl = (isset(\$a['mgl']) ? \$a['mgl'] : (isset(\$a['margin-left']) ? \$a['margin-left'] : ''));
\t\$mgr = (isset(\$a['mgr']) ? \$a['mgr'] : (isset(\$a['margin-right']) ? \$a['margin-right'] : ''));
\t\$mgt = (isset(\$a['mgt']) ? \$a['mgt'] : (isset(\$a['margin-top']) ? \$a['margin-top'] : ''));
\t\$mgb = (isset(\$a['mgb']) ? \$a['mgb'] : (isset(\$a['margin-bottom']) ? \$a['margin-bottom'] : ''));
\t\$mgh = (isset(\$a['mgh']) ? \$a['mgh'] : (isset(\$a['margin-header']) ? \$a['margin-header'] : ''));
\t\$mgf = (isset(\$a['mgf']) ? \$a['mgf'] : (isset(\$a['margin-footer']) ? \$a['margin-footer'] : ''));
\t\$ohname = (isset(\$a['ohname']) ? \$a['ohname'] : (isset(\$a['odd-header-name']) ? \$a['odd-header-name'] : ''));
\t\$ehname = (isset(\$a['ehname']) ? \$a['ehname'] : (isset(\$a['even-header-name']) ? \$a['even-header-name'] : ''));
\t\$ofname = (isset(\$a['ofname']) ? \$a['ofname'] : (isset(\$a['odd-footer-name']) ? \$a['odd-footer-name'] : ''));
\t\$efname = (isset(\$a['efname']) ? \$a['efname'] : (isset(\$a['even-footer-name']) ? \$a['even-footer-name'] : ''));
\t\$ohvalue = (isset(\$a['ohvalue']) ? \$a['ohvalue'] : (isset(\$a['odd-header-value']) ? \$a['odd-header-value'] : 0));
\t\$ehvalue = (isset(\$a['ehvalue']) ? \$a['ehvalue'] : (isset(\$a['even-header-value']) ? \$a['even-header-value'] : 0));
\t\$ofvalue = (isset(\$a['ofvalue']) ? \$a['ofvalue'] : (isset(\$a['odd-footer-value']) ? \$a['odd-footer-value'] : 0));
\t\$efvalue = (isset(\$a['efvalue']) ? \$a['efvalue'] : (isset(\$a['even-footer-value']) ? \$a['even-footer-value'] : 0));
\t\$pagesel = (isset(\$a['pagesel']) ? \$a['pagesel'] : (isset(\$a['pageselector']) ? \$a['pageselector'] : ''));
\t\$newformat = (isset(\$a['newformat']) ? \$a['newformat'] : (isset(\$a['sheet-size']) ? \$a['sheet-size'] : ''));

\t\$this->AddPage(\$orientation,\$condition,\$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf, \$ohname, \$ehname, \$ofname, \$efname, \$ohvalue, \$ehvalue, \$ofvalue, \$efvalue,\$pagesel,\$newformat);

}


function AddPage(\$orientation='',\$condition='', \$resetpagenum='', \$pagenumstyle='', \$suppress='',\$mgl='',\$mgr='',\$mgt='',\$mgb='',\$mgh='',\$mgf='',\$ohname='',\$ehname='',\$ofname='',\$efname='',\$ohvalue=0,\$ehvalue=0,\$ofvalue=0,\$efvalue=0,\$pagesel='',\$newformat='')
{
/*-- CSS-FLOAT --*/
\t// Float DIV
\t// Cannot do with columns on, or if any change in page orientation/margins etc.
\t// If next page already exists - i.e background /headers and footers already written
\tif (\$this->state > 0 && \$this->page < count(\$this->pages)) {
\t\t\$bak_cml = \$this->cMarginL;
\t\t\$bak_cmr = \$this->cMarginR;
\t\t\$bak_dw = \$this->divwidth;
\t\t// Paint Div Border if necessary
   \t\tif (\$this->blklvl > 0) {
\t\t\t\$save_tr = \$this->table_rotate;\t// *TABLES*
\t\t\t\$this->table_rotate = 0;\t// *TABLES*
\t\t\tif (\$this->y == \$this->blk[\$this->blklvl]['y0']) {  \$this->blk[\$this->blklvl]['startpage']++; }
\t\t\tif ((\$this->y > \$this->blk[\$this->blklvl]['y0']) || \$this->flowingBlockAttr['is_table'] ) { \$toplvl = \$this->blklvl; }
\t\t\telse { \$toplvl = \$this->blklvl-1; }
\t\t\t\$sy = \$this->y;
\t\t\tfor (\$bl=1;\$bl<=\$toplvl;\$bl++) {
\t\t\t\t\$this->PaintDivBB('pagebottom',0,\$bl);
\t\t\t}
\t\t\t\$this->y = \$sy;
\t\t\t\$this->table_rotate = \$save_tr;\t// *TABLES*
\t\t}
\t\t\$s = \$this->PrintPageBackgrounds();

\t\t// Writes after the marker so not overwritten later by page background etc.
\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\t\$this->pageBackgrounds = array();
\t\t\$family=\$this->FontFamily;
\t\t\$style=\$this->FontStyle.(\$this->U ? 'U' : '').(\$this->S ? 'S' : '');
\t\t\$size=\$this->FontSizePt;
\t\t\$lw=\$this->LineWidth;
\t\t\$dc=\$this->DrawColor;
\t\t\$fc=\$this->FillColor;
\t\t\$tc=\$this->TextColor;
\t\t\$cf=\$this->ColorFlag;

\t\t\$this->printfloatbuffer();

\t\t//Move to next page
\t\t\$this->page++;
\t\t\$this->ResetMargins();
\t\t\$this->SetAutoPageBreak(\$this->autoPageBreak,\$this->bMargin);
\t\t\$this->x=\$this->lMargin;
\t\t\$this->y=\$this->tMargin;
\t\t\$this->FontFamily='';
\t\t\$this->_out('2 J');
\t\t\$this->LineWidth=\$lw;
\t\t\$this->_out(sprintf('%.3F w',\$lw*_MPDFK));
\t\tif(\$family)\t\$this->SetFont(\$family,\$style,\$size,true,true);
\t\t\$this->DrawColor=\$dc;
\t\tif(\$dc!=\$this->defDrawColor) \$this->_out(\$dc);
\t\t\$this->FillColor=\$fc;
\t\tif(\$fc!=\$this->defFillColor) \$this->_out(\$fc);
\t\t\$this->TextColor=\$tc;
\t\t\$this->ColorFlag=\$cf;
\t\tfor(\$bl=1;\$bl<=\$this->blklvl;\$bl++) {
\t\t\t\$this->blk[\$bl]['y0'] = \$this->y;
\t\t\t// Don't correct more than once for background DIV containing a Float
\t\t\tif (!isset(\$this->blk[\$bl]['marginCorrected'][\$this->page])) { \$this->blk[\$bl]['x0'] += \$this->MarginCorrection; }
\t\t\t\$this->blk[\$bl]['marginCorrected'][\$this->page] = true;
\t\t}
\t\t\$this->cMarginL = \$bak_cml;
\t\t\$this->cMarginR = \$bak_cmr;
\t\t\$this->divwidth = \$bak_dw;
\t\treturn '';
\t}
/*-- END CSS-FLOAT --*/

\t//Start a new page
\tif(\$this->state==0) \$this->Open();

\t\$bak_cml = \$this->cMarginL;
\t\$bak_cmr = \$this->cMarginR;
\t\$bak_dw = \$this->divwidth;


\t\$bak_lh = \$this->lineheight;

\t\$orientation = substr(strtoupper(\$orientation),0,1);
\t\$condition = strtoupper(\$condition);


\tif (\$condition == 'NEXT-EVEN') {\t// always adds at least one new page to create an Even page
\t   if (!\$this->mirrorMargins) { \$condition = ''; }
\t   else {
\t\tif (\$pagesel) { \$pbch = \$pagesel; \$pagesel = ''; }\t// *CSS-PAGE*
\t\telse { \$pbch = false; }\t// *CSS-PAGE*
\t\t\$this->AddPage(\$this->CurOrientation,'O');
\t\tif (\$pbch ) { \$pagesel = \$pbch; }\t// *CSS-PAGE*
\t\t\$condition = '';
\t   }
\t}
\tif (\$condition == 'NEXT-ODD') {\t// always adds at least one new page to create an Odd page
\t   if (!\$this->mirrorMargins) { \$condition = ''; }
\t   else {
\t\tif (\$pagesel) { \$pbch = \$pagesel; \$pagesel = ''; }\t// *CSS-PAGE*
\t\telse { \$pbch = false; }\t// *CSS-PAGE*
\t\t\$this->AddPage(\$this->CurOrientation,'E');
\t\tif (\$pbch ) { \$pagesel = \$pbch; }\t// *CSS-PAGE*
\t\t\$condition = '';
\t   }
\t}


\tif (\$condition == 'E') {\t// only adds new page if needed to create an Even page
\t   if (!\$this->mirrorMargins || (\$this->page)%2==0) { return false; }
\t}
\tif (\$condition == 'O') {\t// only adds new page if needed to create an Odd page
\t   if (!\$this->mirrorMargins || (\$this->page)%2==1) { return false; }
\t}

\tif (\$resetpagenum || \$pagenumstyle || \$suppress) {
\t\t\$this->PageNumSubstitutions[] = array('from'=>(\$this->page+1), 'reset'=> \$resetpagenum, 'type'=>\$pagenumstyle, 'suppress'=>\$suppress);
\t}


\t\$save_tr = \$this->table_rotate;\t// *TABLES*
\t\$this->table_rotate = 0;\t// *TABLES*
\t\$save_kwt = \$this->kwt;
\t\$this->kwt = 0;
\t// mPDF 5.6.01 - LAYERS
\t\$save_layer = \$this->current_layer;
\t\$save_vis = \$this->visibility;

\tif(\$this->visibility!='visible')
\t\t\$this->SetVisibility('visible');
\t// mPDF 5.6.01 - LAYERS
\t\$this->EndLayer();

\t// Paint Div Border if necessary
   \t//PAINTS BACKGROUND COLOUR OR BORDERS for DIV - DISABLED FOR COLUMNS (cf. AcceptPageBreak) AT PRESENT in ->PaintDivBB
   \tif (!\$this->ColActive && \$this->blklvl > 0) {
\t\tif (isset(\$this->blk[\$this->blklvl]['y0']) && \$this->y == \$this->blk[\$this->blklvl]['y0']) {
\t\t\tif (isset(\$this->blk[\$this->blklvl]['startpage'])) { \$this->blk[\$this->blklvl]['startpage']++; }
\t\t\telse { \$this->blk[\$this->blklvl]['startpage'] = 1; }
\t\t}
\t\tif ((isset(\$this->blk[\$this->blklvl]['y0']) && \$this->y > \$this->blk[\$this->blklvl]['y0']) || \$this->flowingBlockAttr['is_table'] ) { \$toplvl = \$this->blklvl; }
\t\telse { \$toplvl = \$this->blklvl-1; }
\t\t\$sy = \$this->y;
\t\tfor (\$bl=1;\$bl<=\$toplvl;\$bl++) {

\t\t\t// mPDF 5.6.01 - LAYERS
\t\t\tif (\$this->blk[\$bl]['z-index']>0) {
\t\t\t\t\$this->BeginLayer(\$this->blk[\$bl]['z-index']);
\t\t\t}
\t\t\tif (isset(\$this->blk[\$bl]['visibility']) && \$this->blk[\$bl]['visibility'] && \$this->blk[\$bl]['visibility']!='visible') {
\t\t\t\t\$this->SetVisibility(\$this->blk[\$bl]['visibility']);
\t\t\t}

\t\t\t\$this->PaintDivBB('pagebottom',0,\$bl);
\t\t}
\t\t\$this->y = \$sy;
\t\t// RESET block y0 and x0 - see below
\t}

\tif(\$this->visibility!='visible')
\t\t\$this->SetVisibility('visible');
\t// mPDF 5.6.01 - LAYERS
\t\$this->EndLayer();

\t// BODY Backgrounds
\tif (\$this->page > 0) {
\t\t\$s = '';
\t\t\$s .= \$this->PrintBodyBackgrounds();

\t\t\$s .= \$this->PrintPageBackgrounds();
\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', \"\\n\".\$s.\"\\n\".'\\\\1', \$this->pages[\$this->page]);
\t\t\$this->pageBackgrounds = array();
\t}

\t\$save_kt = \$this->keep_block_together;
\t\$this->keep_block_together = 0;

\t\$save_cols = false;
/*-- COLUMNS --*/
\tif (\$this->ColActive) {
\t\t\$save_cols = true;
\t\t\$save_nbcol = \$this->NbCol;\t// other values of gap and vAlign will not change by setting Columns off
\t\t\$this->SetColumns(0);
\t}
/*-- END COLUMNS --*/


\t\$family=\$this->FontFamily;
\t\$style=\$this->FontStyle.(\$this->U ? 'U' : '').(\$this->S ? 'S' : '');
\t\$size=\$this->FontSizePt;
\t\$this->ColumnAdjust = true;\t// enables column height adjustment for the page
\t\$lw=\$this->LineWidth;
\t\$dc=\$this->DrawColor;
\t\$fc=\$this->FillColor;
\t\$tc=\$this->TextColor;
\t\$cf=\$this->ColorFlag;
\tif(\$this->page>0)
\t{
\t\t//Page footer
\t\t\$this->InFooter=true;

\t\t\$this->Reset();
\t\t\$this->pageoutput[\$this->page] = array();

\t\t\$this->Footer();
\t\t//Close page
\t\t\$this->_endpage();
\t}


\t//Start new page
\t\$this->_beginpage(\$orientation,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$ohname,\$ehname,\$ofname,\$efname,\$ohvalue,\$ehvalue,\$ofvalue,\$efvalue,\$pagesel,\$newformat);
\tif (\$this->docTemplate) {
\t\t\$pagecount = \$this->SetSourceFile(\$this->docTemplate);
\t\tif ((\$this->page - \$this->docTemplateStart) > \$pagecount) {
\t\t\tif (\$this->docTemplateContinue) {
\t\t\t\t\$tplIdx = \$this->ImportPage(\$pagecount);
\t\t\t\t\$this->UseTemplate(\$tplIdx);
\t\t\t}
\t\t}
\t\telse {
\t\t\t\$tplIdx = \$this->ImportPage((\$this->page - \$this->docTemplateStart));
\t\t\t\$this->UseTemplate(\$tplIdx);
\t\t}
\t}
\tif (\$this->pageTemplate) {
\t\t\$this->UseTemplate(\$this->pageTemplate);
\t}

\t// Tiling Patterns
\t\$this->_out('___PAGE___START'.\$this->uniqstr);
\t\$this->_out('___BACKGROUND___PATTERNS'.\$this->uniqstr);
\t\$this->_out('___HEADER___MARKER'.\$this->uniqstr);
\t\$this->pageBackgrounds = array();

\t//Set line cap style to square
\t\$this->SetLineCap(2);
\t//Set line width
\t\$this->LineWidth=\$lw;
\t\$this->_out(sprintf('%.3F w',\$lw*_MPDFK));
\t//Set font
\tif(\$family)\t\$this->SetFont(\$family,\$style,\$size,true,true);\t// forces write
\t//Set colors
\t\$this->DrawColor=\$dc;
\tif(\$dc!=\$this->defDrawColor) \$this->_out(\$dc);
\t\$this->FillColor=\$fc;
\tif(\$fc!=\$this->defFillColor) \$this->_out(\$fc);
\t\$this->TextColor=\$tc;
\t\$this->ColorFlag=\$cf;

\t//Page header
\t\$this->Header();

\t//Restore line width
\tif(\$this->LineWidth!=\$lw)
\t{
\t\t\$this->LineWidth=\$lw;
\t\t\$this->_out(sprintf('%.3F w',\$lw*_MPDFK));
\t}
\t//Restore font
\tif(\$family)\t\$this->SetFont(\$family,\$style,\$size,true,true);\t// forces write
\t//Restore colors
\tif(\$this->DrawColor!=\$dc)
\t{
\t\t\$this->DrawColor=\$dc;
\t\t\$this->_out(\$dc);
\t}
\tif(\$this->FillColor!=\$fc)
\t{
\t\t\$this->FillColor=\$fc;
\t\t\$this->_out(\$fc);
\t}
\t\$this->TextColor=\$tc;
\t\$this->ColorFlag=\$cf;
 \t\$this->InFooter=false;

\t// mPDF 5.6.01 - LAYERS
\tif (\$save_layer>0)
\t\t\$this->BeginLayer(\$save_layer);

\tif(\$save_vis!='visible')
\t\t\$this->SetVisibility(\$save_vis);

/*-- COLUMNS --*/
\tif (\$save_cols) {
\t\t// Restore columns
\t\t\$this->SetColumns(\$save_nbcol,\$this->colvAlign,\$this->ColGap);
\t}
\tif (\$this->ColActive) { \$this->SetCol(0); }
/*-- END COLUMNS --*/


   \t//RESET BLOCK BORDER TOP
   \tif (!\$this->ColActive) {
\t\tfor(\$bl=1;\$bl<=\$this->blklvl;\$bl++) {
\t\t\t\$this->blk[\$bl]['y0'] = \$this->y;
\t\t\tif (isset(\$this->blk[\$bl]['x0'])) { \$this->blk[\$bl]['x0'] += \$this->MarginCorrection; }
\t\t\telse { \$this->blk[\$bl]['x0'] = \$this->MarginCorrection; }
\t\t\t// Added mPDF 3.0 Float DIV
\t\t\t\$this->blk[\$bl]['marginCorrected'][\$this->page] = true;
\t\t}
\t}


\t\$this->table_rotate = \$save_tr;\t// *TABLES*
\t\$this->kwt = \$save_kwt;

\t\$this->keep_block_together = \$save_kt ;

\t\$this->cMarginL = \$bak_cml;
\t\$this->cMarginR = \$bak_cmr;
\t\$this->divwidth = \$bak_dw;

\t\$this->lineheight = \$bak_lh;
}


function PageNo() {
\t//Get current page number
\treturn \$this->page;
}

function AddSpotColorsFromFile(\$file) {
\t\$colors = @file(\$file) or die(\"Cannot load spot colors file - \".\$file);
\tforeach(\$colors AS \$sc) {
\t\tlist(\$name, \$c, \$m, \$y, \$k) = preg_split(\"/\\t/\",\$sc);
\t\t\$c = intval(\$c);
\t\t\$m = intval(\$m);
\t\t\$y = intval(\$y);
\t\t\$k = intval(\$k);
\t\t\$this->AddSpotColor(\$name, \$c, \$m, \$y, \$k);
\t}
}

function AddSpotColor(\$name, \$c, \$m, \$y, \$k) {
\t\$name = strtoupper(trim(\$name));
\tif(!isset(\$this->spotColors[\$name])) {
\t\t\$i=count(\$this->spotColors)+1;
\t\t\$this->spotColors[\$name]=array('i'=>\$i,'c'=>\$c,'m'=>\$m,'y'=>\$y,'k'=>\$k);
\t\t\$this->spotColorIDs[\$i]=\$name;
\t}
}

function SetColor(\$col, \$type='') {
\t\$out = '';
\tif (\$col{0}==3 || \$col{0}==5) {\t// RGB / RGBa
\t\t\$out = sprintf('%.3F %.3F %.3F rg',ord(\$col{1})/255,ord(\$col{2})/255,ord(\$col{3})/255);
\t}
\telse if (\$col{0}==1) {\t// GRAYSCALE
\t\t\$out = sprintf('%.3F g',ord(\$col{1})/255);
\t}
\telse if (\$col{0}==2) {\t// SPOT COLOR
\t\t\$out = sprintf('/CS%d cs %.3F scn',ord(\$col{1}),ord(\$col{2})/100);
\t}
\telse if (\$col{0}==4 || \$col{0}==6) {\t// CMYK / CMYKa
\t\t\$out = sprintf('%.3F %.3F %.3F %.3F k', ord(\$col{1})/100, ord(\$col{2})/100, ord(\$col{3})/100, ord(\$col{4})/100);
\t}
\tif (\$type=='Draw') { \$out = strtoupper(\$out); }\t// e.g. rg => RG
\telse if (\$type=='CodeOnly') { \$out = preg_replace('/\\s(rg|g|k)/','',\$out); }
\treturn \$out;
}


function SetDColor(\$col, \$return=false) {
\t\$out = \$this->SetColor(\$col, 'Draw');
\tif (\$return) { return \$out; }
\tif (\$out=='') { return ''; }
\t\$this->DrawColor = \$out;
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['DrawColor']) && \$this->pageoutput[\$this->page]['DrawColor'] != \$this->DrawColor) || !isset(\$this->pageoutput[\$this->page]['DrawColor']) || \$this->keep_block_together)) { \$this->_out(\$this->DrawColor); }
\t\$this->pageoutput[\$this->page]['DrawColor'] = \$this->DrawColor;
}

function SetFColor(\$col, \$return=false) {
\t\$out = \$this->SetColor(\$col, 'Fill');
\tif (\$return) { return \$out; }
\tif (\$out=='') { return ''; }
\t\$this->FillColor = \$out;
\t\$this->ColorFlag = (\$out != \$this->TextColor);
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['FillColor']) && \$this->pageoutput[\$this->page]['FillColor'] != \$this->FillColor) || !isset(\$this->pageoutput[\$this->page]['FillColor']) || \$this->keep_block_together)) { \$this->_out(\$this->FillColor); }
\t\$this->pageoutput[\$this->page]['FillColor'] = \$this->FillColor;
}

function SetTColor(\$col, \$return=false) {
\t\$out = \$this->SetColor(\$col, 'Text');
\tif (\$return) { return \$out; }
\tif (\$out=='') { return ''; }
\t\$this->TextColor = \$out;
\t\$this->ColorFlag = (\$this->FillColor != \$out);
}


function SetDrawColor(\$r,\$g=-1,\$b=-1,\$col4=-1, \$return=false) {
\t//Set color for all stroking operations
\t\$col = array();
\tif((\$r==0 and \$g==0 and \$b==0 && \$col4 == -1) or \$g==-1) { \$col = \$this->ConvertColor(\$r); }
\telse if (\$col4 == -1) { \$col = \$this->ConvertColor('rgb('.\$r.','.\$g.','.\$b.')'); }
\telse { \$col = \$this->ConvertColor('cmyk('.\$r.','.\$g.','.\$b.','.\$col4.')'); }
\t\$out = \$this->SetDColor(\$col, \$return);
\treturn \$out;
}

function SetFillColor(\$r,\$g=-1,\$b=-1,\$col4=-1, \$return=false) {
\t//Set color for all filling operations
\t\$col = array();
\tif((\$r==0 and \$g==0 and \$b==0 && \$col4 == -1) or \$g==-1) { \$col = \$this->ConvertColor(\$r); }
\telse if (\$col4 == -1) { \$col = \$this->ConvertColor('rgb('.\$r.','.\$g.','.\$b.')'); }
\telse { \$col = \$this->ConvertColor('cmyk('.\$r.','.\$g.','.\$b.','.\$col4.')'); }
\t\$out = \$this->SetFColor(\$col, \$return);
\treturn \$out;
}

function SetTextColor(\$r,\$g=-1,\$b=-1,\$col4=-1, \$return=false) {
\t//Set color for text
\t\$col = array();
\tif((\$r==0 and \$g==0 and \$b==0 && \$col4 == -1) or \$g==-1) { \$col = \$this->ConvertColor(\$r); }
\telse if (\$col4 == -1) { \$col = \$this->ConvertColor('rgb('.\$r.','.\$g.','.\$b.')'); }
\telse { \$col = \$this->ConvertColor('cmyk('.\$r.','.\$g.','.\$b.','.\$col4.')'); }
\t\$out = \$this->SetTColor(\$col, \$return);
\treturn \$out;
}

function _getCharWidth(&\$cw, \$u, \$isdef=true) {
\tif (\$u==0) { \$w = false; }
\telse { \$w = (ord(\$cw[\$u*2]) << 8) + ord(\$cw[\$u*2+1]); }
\tif (\$w == 65535) { return 0; }
\telse if (\$w) { return \$w; }
\telse if (\$isdef) { return false; }
\telse { return 0; }
}

function _charDefined(&\$cw, \$u) {
\tif (\$u==0) { return false; }
\t\$w = (ord(\$cw[\$u*2]) << 8) + ord(\$cw[\$u*2+1]);
\tif (\$w) { return true; }
\telse { return false; }
}

function GetCharWidthCore(\$c) {
\t//Get width of a single character in the current Core font
\t\$c = (string)\$c;
\t\$w = 0;
\t// Soft Hyphens chr(173)
\tif (\$c == chr(173) && \$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats') {
\t\treturn 0;
\t}
\telse if (\$this->S && isset(\$this->upperCase[ord(\$c)])) {
\t\t\$charw = \$this->CurrentFont['cw'][chr(\$this->upperCase[ord(\$c)])];
\t\tif (\$charw!==false) {
\t\t\t\$charw = \$charw*\$this->smCapsScale * \$this->smCapsStretch/100;
\t\t\t\$w+=\$charw;
\t\t}
\t}
\telse if (isset(\$this->CurrentFont['cw'][\$c])) {
\t\t\$w += \$this->CurrentFont['cw'][\$c];
\t}
\telse if (isset(\$this->CurrentFont['cw'][ord(\$c)])) {
\t\t\$w += \$this->CurrentFont['cw'][ord(\$c)];
\t}
\t\$w *=  (\$this->FontSize/ 1000);
\tif (\$this->minwSpacing || \$this->fixedlSpacing) {
\t\tif (\$c==' ') \$nb_spaces = 1;
\t\telse \$nb_spaces = 0;
\t\t\$w += \$this->fixedlSpacing + (\$nb_spaces * \$this->minwSpacing);
\t}
\treturn (\$w);
}

function GetCharWidthNonCore(\$c, \$addSubset=true) {
\t//Get width of a single character in the current Non-Core font
\t\$c = (string)\$c;
\t\$w = 0;
\t\$unicode = \$this->UTF8StringToArray(\$c, \$addSubset);
\t\$char = \$unicode[0];
/*-- CJK-FONTS --*/
\tif (\$this->CurrentFont['type'] == 'Type0') {\t// CJK Adobe fonts
\t\t\tif (\$char == 173) { return 0; }\t// Soft Hyphens
\t\t\telseif (isset(\$this->CurrentFont['cw'][\$char])) { \$w+=\$this->CurrentFont['cw'][\$char]; }
\t\t\telseif(isset(\$this->CurrentFont['MissingWidth'])) { \$w += \$this->CurrentFont['MissingWidth']; }
\t\t\telse { \$w += 500; }
\t}
\telse {
/*-- END CJK-FONTS --*/
\t\t\tif (\$char == 173) { return 0; }\t// Soft Hyphens
\t\t\telse if (\$this->S && isset(\$this->upperCase[\$char])) {
\t\t\t\t\$charw = \$this->_getCharWidth(\$this->CurrentFont['cw'],\$this->upperCase[\$char]);
\t\t\t\tif (\$charw!==false) {
\t\t\t\t\t\$charw = \$charw*\$this->smCapsScale * \$this->smCapsStretch/100;
\t\t\t\t\t\$w+=\$charw;
\t\t\t\t}
\t\t\t\telseif(isset(\$this->CurrentFont['desc']['MissingWidth'])) { \$w += \$this->CurrentFont['desc']['MissingWidth']; }
\t\t\t\telseif(isset(\$this->CurrentFont['MissingWidth'])) { \$w += \$this->CurrentFont['MissingWidth']; }
\t\t\t\telse { \$w += 500; }
\t\t\t}
\t\t\telse {
\t\t\t\t\$charw = \$this->_getCharWidth(\$this->CurrentFont['cw'],\$char);
\t\t\t\tif (\$charw!==false) { \$w+=\$charw; }
\t\t\t\telseif(isset(\$this->CurrentFont['desc']['MissingWidth'])) { \$w += \$this->CurrentFont['desc']['MissingWidth']; }
\t\t\t\telseif(isset(\$this->CurrentFont['MissingWidth'])) { \$w += \$this->CurrentFont['MissingWidth']; }
\t\t\t\telse { \$w += 500; }
\t\t\t}
\t}\t// *CJK-FONTS*
\t\$w *=  (\$this->FontSize/ 1000);
\tif (\$this->minwSpacing || \$this->fixedlSpacing) {
\t\tif (\$c==' ') \$nb_spaces = 1;
\t\telse \$nb_spaces = 0;
\t\t\$w += \$this->fixedlSpacing + (\$nb_spaces * \$this->minwSpacing);
\t}
\treturn (\$w);
}


function GetCharWidth(\$c, \$addSubset=true) {
\tif (!\$this->usingCoreFont) {
\t\treturn \$this->GetCharWidthNonCore(\$c, \$addSubset);
\t}
\telse {
\t\treturn \$this->GetCharWidthCore(\$c);
\t}
}

function GetStringWidth(\$s, \$addSubset=true) {
\t\t\t//Get width of a string in the current font
\t\t\t\$s = (string)\$s;
\t\t\t\$cw = &\$this->CurrentFont['cw'];
\t\t\t\$w = 0;
\t\t\t\$kerning = 0;
\t\t\t\$lastchar = 0;
\t\t\t\$nb_carac = 0;
\t\t\t\$nb_spaces = 0;
\t\t\t// mPDF ITERATION
\t\t\tif (\$this->iterationCounter) \$s = preg_replace('/{iteration ([a-zA-Z0-9_]+)}/', '\\\\1', \$s);

\t\t\tif (!\$this->usingCoreFont) {
\t\t\t      \$s = str_replace(\"\\xc2\\xad\",'',\$s );
\t\t\t\t\$unicode = \$this->UTF8StringToArray(\$s, \$addSubset);
\t\t\t\tif (\$this->minwSpacing || \$this->fixedlSpacing) {
\t\t\t\t\t\$nb_carac = count(\$unicode);
\t\t\t\t\t\$nb_spaces = mb_substr_count(\$s,' ', \$this->mb_enc);
\t\t\t\t}
/*-- CJK-FONTS --*/
\t\t\t\tif (\$this->CurrentFont['type'] == 'Type0') {\t// CJK Adobe fonts
\t\t\t\t\tforeach(\$unicode as \$char) {
\t\t\t\t\t\tif (isset(\$cw[\$char])) { \$w+=\$cw[\$char]; }
\t\t\t\t\t\telseif(isset(\$this->CurrentFont['MissingWidth'])) { \$w += \$this->CurrentFont['MissingWidth']; }
\t\t\t\t\t\telse { \$w += 500; }
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse {
/*-- END CJK-FONTS --*/
\t\t\t\t\tforeach(\$unicode as \$char) {
\t\t\t\t\t\tif (\$this->S && isset(\$this->upperCase[\$char])) {
\t\t\t\t\t\t\t\$charw = \$this->_getCharWidth(\$cw,\$this->upperCase[\$char]);
\t\t\t\t\t\t\tif (\$charw!==false) {
\t\t\t\t\t\t\t\t\$charw = \$charw*\$this->smCapsScale * \$this->smCapsStretch/100;
\t\t\t\t\t\t\t\t\$w+=\$charw;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\telseif(isset(\$this->CurrentFont['desc']['MissingWidth'])) { \$w += \$this->CurrentFont['desc']['MissingWidth']; }
\t\t\t\t\t\t\telseif(isset(\$this->CurrentFont['MissingWidth'])) { \$w += \$this->CurrentFont['MissingWidth']; }
\t\t\t\t\t\t\telse { \$w += 500; }
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$charw = \$this->_getCharWidth(\$cw,\$char);
\t\t\t\t\t\t\tif (\$charw!==false) { \$w+=\$charw; }
\t\t\t\t\t\t\telseif(isset(\$this->CurrentFont['desc']['MissingWidth'])) { \$w += \$this->CurrentFont['desc']['MissingWidth']; }
\t\t\t\t\t\t\telseif(isset(\$this->CurrentFont['MissingWidth'])) { \$w += \$this->CurrentFont['MissingWidth']; }
\t\t\t\t\t\t\telse { \$w += 500; }
\t\t\t\t\t\t\tif (\$this->kerning && \$this->useKerning && \$lastchar) {
\t\t\t\t\t\t\t\tif (isset(\$this->CurrentFont['kerninfo'][\$lastchar][\$char])) {
\t\t\t\t\t\t\t\t\t\$kerning += \$this->CurrentFont['kerninfo'][\$lastchar][\$char];
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\$lastchar = \$char;
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}\t// *CJK-FONTS*

\t\t\t}
\t\t\telse {
\t\t\t\tif (\$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats') {
\t\t\t      \t\$s = str_replace(chr(173),'',\$s );
\t\t\t\t}
\t\t\t\t\$nb_carac = \$l = strlen(\$s);
\t\t\t\tif (\$this->minwSpacing || \$this->fixedlSpacing) {
\t\t\t\t\t\$nb_spaces = substr_count(\$s,' ');
\t\t\t\t}
\t\t\t\tfor(\$i=0; \$i<\$l; \$i++) {
\t\t\t\t\tif (\$this->S && isset(\$this->upperCase[ord(\$s[\$i])])) {
\t\t\t\t\t\t\$charw = \$cw[chr(\$this->upperCase[ord(\$s[\$i])])];
\t\t\t\t\t\tif (\$charw!==false) {
\t\t\t\t\t\t\t\$charw = \$charw*\$this->smCapsScale * \$this->smCapsStretch/100;
\t\t\t\t\t\t\t\$w+=\$charw;
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\telse if (isset(\$cw[\$s[\$i]])) {
\t\t\t\t\t\t\$w += \$cw[\$s[\$i]];
\t\t\t\t\t}
\t\t\t\t\telse if (isset(\$cw[ord(\$s[\$i])])) {
\t\t\t\t\t\t\$w += \$cw[ord(\$s[\$i])];
\t\t\t\t\t}
\t\t\t\t\tif (\$this->kerning && \$this->useKerning && \$i>0) {
\t\t\t\t\t\tif (isset(\$this->CurrentFont['kerninfo'][\$s[(\$i-1)]][\$s[\$i]])) {
\t\t\t\t\t\t\t\$kerning += \$this->CurrentFont['kerninfo'][\$s[(\$i-1)]][\$s[\$i]];
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\tunset(\$cw);
\t\t\tif (\$this->kerning && \$this->useKerning) { \$w += \$kerning; }
\t\t\t\$w *=  (\$this->FontSize/ 1000);
\t\t\t\$w += ((\$nb_carac + \$nb_spaces) * \$this->fixedlSpacing) + (\$nb_spaces * \$this->minwSpacing);
\t\t\treturn (\$w);
}

function SetLineWidth(\$width) {
\t//Set line width
\t\$this->LineWidth=\$width;
\t\$lwout = (sprintf('%.3F w',\$width*_MPDFK));
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['LineWidth']) && \$this->pageoutput[\$this->page]['LineWidth'] != \$lwout) || !isset(\$this->pageoutput[\$this->page]['LineWidth']) || \$this->keep_block_together)) {
\t\t \$this->_out(\$lwout);
\t}
\t\$this->pageoutput[\$this->page]['LineWidth'] = \$lwout;
}

function Line(\$x1,\$y1,\$x2,\$y2) {
\t//Draw a line
\t\$this->_out(sprintf('%.3F %.3F m %.3F %.3F l S',\$x1*_MPDFK,(\$this->h-\$y1)*_MPDFK,\$x2*_MPDFK,(\$this->h-\$y2)*_MPDFK));
}

function Arrow(\$x1,\$y1,\$x2,\$y2,\$headsize=3,\$fill='B',\$angle=25) {
  //F == fill //S == stroke //B == stroke and fill
  // angle = splay of arrowhead - 1 - 89 degrees
  if(\$fill=='F')\t\$fill='f';
  elseif(\$fill=='FD' or \$fill=='DF' or \$fill=='B') \$fill='B';
  else \$fill='S';
  \$a = atan2((\$y2-\$y1),(\$x2-\$x1));
  \$b = \$a + deg2rad(\$angle);
  \$c = \$a - deg2rad(\$angle);
  \$x3 = \$x2 - (\$headsize* cos(\$b));
  \$y3 = \$this->h-(\$y2 - (\$headsize* sin(\$b)));
  \$x4 = \$x2 - (\$headsize* cos(\$c));
  \$y4 = \$this->h-(\$y2 - (\$headsize* sin(\$c)));

  \$x5 = \$x3-(\$x3-\$x4)/2;\t// mid point of base of arrowhead - to join arrow line to
  \$y5 = \$y3-(\$y3-\$y4)/2;

  \$s = '';
  \$s.=sprintf('%.3F %.3F m %.3F %.3F l S',\$x1*_MPDFK,(\$this->h-\$y1)*_MPDFK,\$x5*_MPDFK,\$y5*_MPDFK);
  \$this->_out(\$s);

  \$s = '';
  \$s.=sprintf('%.3F %.3F m %.3F %.3F l %.3F %.3F l %.3F %.3F l %.3F %.3F l ',\$x5*_MPDFK,\$y5*_MPDFK,\$x3*_MPDFK,\$y3*_MPDFK,\$x2*_MPDFK,(\$this->h-\$y2)*_MPDFK,\$x4*_MPDFK,\$y4*_MPDFK,\$x5*_MPDFK,\$y5*_MPDFK);
  \$s.=\$fill;
  \$this->_out(\$s);
}


function Rect(\$x,\$y,\$w,\$h,\$style='') {
\t//Draw a rectangle
\tif(\$style=='F')\t\$op='f';
\telseif(\$style=='FD' or \$style=='DF') \$op='B';
\telse \$op='S';
\t\$this->_out(sprintf('%.3F %.3F %.3F %.3F re %s',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$w*_MPDFK,-\$h*_MPDFK,\$op));
}

function AddFont(\$family,\$style='') {
\tif(empty(\$family)) { return; }
\t\$family = strtolower(\$family);
\t\$style=strtoupper(\$style);
\t\$style=str_replace('U','',\$style);
\tif(\$style=='IB') \$style='BI';
\t\$fontkey = \$family.\$style;
\t// check if the font has been already added
\tif(isset(\$this->fonts[\$fontkey])) {
\t\treturn;
\t}

/*-- CJK-FONTS --*/
\tif (in_array(\$family,\$this->available_CJK_fonts)) {
\t\tif (empty(\$this->Big5_widths)) { require(_MPDF_PATH . 'includes/CJKdata.php'); }
\t\t\$this->AddCJKFont(\$family);\t// don't need to add style
\t\treturn;
\t}
/*-- END CJK-FONTS --*/

\tif (\$this->usingCoreFont) { die(\"mPDF Error - problem with Font management\"); }

\t\$stylekey = \$style;
\tif (!\$style) { \$stylekey = 'R'; }

\tif (!isset(\$this->fontdata[\$family][\$stylekey]) || !\$this->fontdata[\$family][\$stylekey]) {
\t\tdie('mPDF Error - Font is not supported - '.\$family.' '.\$style);
\t}

\t\$name = '';
\t\$originalsize = 0;
\t\$sip = false;
\t\$smp = false;
\t\$unAGlyphs = false;\t// mPDF 5.4.05
\t\$haskerninfo = false;
\t\$BMPselected = false;
\t@include(_MPDF_TTFONTDATAPATH.\$fontkey.'.mtx.php');

\t\$ttffile = '';
\tif (defined('_MPDF_SYSTEM_TTFONTS')) {
\t\t\$ttffile = _MPDF_SYSTEM_TTFONTS.\$this->fontdata[\$family][\$stylekey];
\t\tif (!file_exists(\$ttffile)) { \$ttffile = ''; }
\t}
\tif (!\$ttffile) {
\t\t\$ttffile = \$this->fontdata[\$family][\$stylekey];
        if (\$ttffile[0] != '/' && \$ttffile[1] != ':' && strpos(\$ttffile, 'phar://') !== 0)
            // Not an absolute path
            \$ttffile = _MPDF_TTFONTPATH.\$ttffile;
\t\tif (!file_exists(\$ttffile)) { die(\"mPDF Error - cannot find TTF TrueType font file - \".\$ttffile); }
\t}
\t\$ttfstat = stat(\$ttffile);

\tif (isset(\$this->fontdata[\$family]['TTCfontID'][\$stylekey])) { \$TTCfontID = \$this->fontdata[\$family]['TTCfontID'][\$stylekey]; }
\telse { \$TTCfontID = 0; }


\t\$BMPonly = false;
\tif (in_array(\$family,\$this->BMPonly)) { \$BMPonly = true; }
\t\$regenerate = false;
\tif (\$BMPonly && !\$BMPselected) { \$regenerate = true; }
\telse if (!\$BMPonly && \$BMPselected) { \$regenerate = true; }
\tif (\$this->useKerning && !\$haskerninfo) { \$regenerate = true; }
\t// mPDF 5.4.05
\tif (isset(\$this->fontdata[\$family]['unAGlyphs']) && \$this->fontdata[\$family]['unAGlyphs'] && !\$unAGlyphs) {
\t\t\$regenerate = true;
\t\t\$unAGlyphs = true;
\t}
\telse if ((!isset(\$this->fontdata[\$family]['unAGlyphs']) || !\$this->fontdata[\$family]['unAGlyphs']) && \$unAGlyphs) {
\t\t\$regenerate = true;
\t\t\$unAGlyphs = false;
\t}
\tif (!isset(\$name) || \$originalsize != \$ttfstat['size'] || \$regenerate) {
\t\tif (!class_exists('TTFontFile', false)) { include(_MPDF_PATH .'classes/ttfontsuni.php'); }
\t\t\$ttf = new TTFontFile();
\t\t\$ttf->getMetrics(\$ttffile, \$TTCfontID, \$this->debugfonts, \$BMPonly, \$this->useKerning, \$unAGlyphs);\t// mPDF 5.4.05
\t\t\$cw = \$ttf->charWidths;
\t\t\$kerninfo = \$ttf->kerninfo;
\t\t\$haskerninfo = true;
\t\t\$name = preg_replace('/[ ()]/','',\$ttf->fullName);
\t\t\$sip = \$ttf->sipset;
\t\t\$smp = \$ttf->smpset;

\t\t\$desc= array('Ascent'=>round(\$ttf->ascent),
\t\t'Descent'=>round(\$ttf->descent),
\t\t'CapHeight'=>round(\$ttf->capHeight),
\t\t'Flags'=>\$ttf->flags,
\t\t'FontBBox'=>'['.round(\$ttf->bbox[0]).\" \".round(\$ttf->bbox[1]).\" \".round(\$ttf->bbox[2]).\" \".round(\$ttf->bbox[3]).']',
\t\t'ItalicAngle'=>\$ttf->italicAngle,
\t\t'StemV'=>round(\$ttf->stemV),
\t\t'MissingWidth'=>round(\$ttf->defaultWidth));
\t\t\$panose = '';
\t\t// mPDF 5.5.19
\t\tif (count(\$ttf->panose)) {
\t\t\t\$panoseArray = array_merge(array(\$ttf->sFamilyClass, \$ttf->sFamilySubClass), \$ttf->panose);
\t\t\tforeach(\$panoseArray as \$value)
\t\t\t\t\$panose .= ' '.dechex(\$value);
\t\t}
\t\t\$up = round(\$ttf->underlinePosition);
\t\t\$ut = round(\$ttf->underlineThickness);
\t\t\$originalsize = \$ttfstat['size']+0;
\t\t\$type = 'TTF';
\t\t//Generate metrics .php file
\t\t\$s='<?php'.\"\\n\";
\t\t\$s.='\$name=\\''.\$name.\"';\\n\";
\t\t\$s.='\$type=\\''.\$type.\"';\\n\";
\t\t\$s.='\$desc='.var_export(\$desc,true).\";\\n\";
\t\t\$s.='\$up='.\$up.\";\\n\";
\t\t\$s.='\$ut='.\$ut.\";\\n\";
\t\t\$s.='\$ttffile=\\''.\$ttffile.\"';\\n\";
\t\t\$s.='\$TTCfontID=\\''.\$TTCfontID.\"';\\n\";
\t\t\$s.='\$originalsize='.\$originalsize.\";\\n\";
\t\tif (\$sip) \$s.='\$sip=true;'.\"\\n\";
\t\telse \$s.='\$sip=false;'.\"\\n\";
\t\tif (\$smp) \$s.='\$smp=true;'.\"\\n\";
\t\telse \$s.='\$smp=false;'.\"\\n\";
\t\tif (\$BMPonly) \$s.='\$BMPselected=true;'.\"\\n\";
\t\telse \$s.='\$BMPselected=false;'.\"\\n\";
\t\t\$s.='\$fontkey=\\''.\$fontkey.\"';\\n\";
\t\t\$s.='\$panose=\\''.\$panose.\"';\\n\";
\t\tif (\$this->useKerning) {
\t\t\t\$s.='\$kerninfo='.var_export(\$kerninfo,true).\";\\n\";
\t\t\t\$s.='\$haskerninfo=true;'.\"\\n\";
\t\t}
\t\telse \$s.='\$haskerninfo=false;'.\"\\n\";
\t\t// mPDF 5.4.05
\t\tif (\$this->fontdata[\$family]['unAGlyphs']) {
\t\t\t\$s.='\$unAGlyphs=true;'.\"\\n\";
\t\t}
\t\telse \$s.='\$unAGlyphs=false;'.\"\\n\";
\t\t\$s.=\"?>\";
\t\tif (is_writable(dirname(_MPDF_TTFONTDATAPATH.'x'))) {
\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$fontkey.'.mtx.php',\"w\");
\t\t\tfwrite(\$fh,\$s,strlen(\$s));
\t\t\tfclose(\$fh);
\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$fontkey.'.cw.dat',\"wb\");
\t\t\tfwrite(\$fh,\$cw,strlen(\$cw));
\t\t\tfclose(\$fh);
\t\t\t@unlink(_MPDF_TTFONTDATAPATH.\$fontkey.'.cgm');
\t\t\t@unlink(_MPDF_TTFONTDATAPATH.\$fontkey.'.z');
\t\t\t@unlink(_MPDF_TTFONTDATAPATH.\$fontkey.'.cw127.php');
\t\t\t@unlink(_MPDF_TTFONTDATAPATH.\$fontkey.'.cw');
\t\t}
\t\telse if (\$this->debugfonts) { \$this->Error('Cannot write to the font caching directory - '._MPDF_TTFONTDATAPATH); }
\t\tunset(\$ttf);
\t}
\telse {
\t\t\$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$fontkey.'.cw.dat');
\t}

\tif (isset(\$this->fontdata[\$family]['indic']) && \$this->fontdata[\$family]['indic']) { \$indic = true; }
\telse { \$indic = false; }
\tif (isset(\$this->fontdata[\$family]['sip-ext']) && \$this->fontdata[\$family]['sip-ext']) { \$sipext = \$this->fontdata[\$family]['sip-ext']; }
\telse { \$sipext = ''; }


\t\$i = count(\$this->fonts)+\$this->extraFontSubsets+1;
\tif (\$sip || \$smp) {
\t\t\$this->fonts[\$fontkey] = array('i'=>\$i, 'type'=>\$type, 'name'=>\$name, 'desc'=>\$desc, 'panose'=>\$panose, 'up'=>\$up, 'ut'=>\$ut, 'cw'=>\$cw, 'ttffile'=>\$ttffile, 'fontkey'=>\$fontkey, 'subsets'=>array(0=>range(0,127)), 'subsetfontids'=>array(\$i), 'used'=>false, 'indic'=>\$indic, 'sip'=>\$sip, 'sipext'=>\$sipext, 'smp'=>\$smp, 'TTCfontID' => \$TTCfontID, 'unAGlyphs' => false);\t// mPDF 5.4.05
\t}
\telse  {
\t\t\$ss = array();
\t\tfor (\$s=32; \$s<128; \$s++) { \$ss[\$s] = \$s; }
\t\t\$this->fonts[\$fontkey] = array('i'=>\$i, 'type'=>\$type, 'name'=>\$name, 'desc'=>\$desc, 'panose'=>\$panose, 'up'=>\$up, 'ut'=>\$ut, 'cw'=>\$cw, 'ttffile'=>\$ttffile, 'fontkey'=>\$fontkey, 'subset'=>\$ss, 'used'=>false, 'indic'=>\$indic, 'sip'=>\$sip, 'sipext'=>\$sipext, 'smp'=>\$smp, 'TTCfontID' => \$TTCfontID, 'unAGlyphs' => \$unAGlyphs);\t// mPDF 5.4.05
\t}
\tif (\$this->useKerning && \$haskerninfo) { \$this->fonts[\$fontkey]['kerninfo'] = \$kerninfo; }
\t\$this->FontFiles[\$fontkey]=array('length1'=>\$originalsize, 'type'=>\"TTF\", 'ttffile'=>\$ttffile, 'sip'=>\$sip, 'smp'=>\$smp);
\tunset(\$cw);
}



function SetFont(\$family,\$style='',\$size=0, \$write=true, \$forcewrite=false) {
\t\$family=strtolower(\$family);
\tif (!\$this->onlyCoreFonts) {
\t\tif (\$family == 'sans' || \$family == 'sans-serif') { \$family = \$this->sans_fonts[0]; }
\t\tif (\$family == 'serif') { \$family = \$this->serif_fonts[0]; }
\t\tif (\$family == 'mono' || \$family == 'monospace') { \$family = \$this->mono_fonts[0]; }
\t}
\tif (isset(\$this->fonttrans[\$family]) && \$this->fonttrans[\$family]) { \$family = \$this->fonttrans[\$family]; }
\tif(\$family=='') {
\t\tif (\$this->FontFamily) { \$family=\$this->FontFamily; }
\t\telse if (\$this->default_font) { \$family=\$this->default_font; }
\t\telse { \$this->Error(\"No font or default font set!\"); }
\t}
\t\$this->ReqFontStyle = \$style;\t// required or requested style - used later for artificial bold/italic

\tif ((\$family == 'csymbol') || (\$family == 'czapfdingbats')  || (\$family == 'ctimes')  || (\$family == 'ccourier') || (\$family == 'chelvetica')) {
\t\tif (\$this->PDFA || \$this->PDFX) {
\t\t   if (\$family == 'csymbol' || \$family == 'czapfdingbats') {
\t\t\t\$this->Error(\"Symbol and Zapfdingbats cannot be embedded in mPDF (required for PDFA1-b or PDFX/1-a).\");
\t\t   }
\t\t   if (\$family == 'ctimes'  || \$family == 'ccourier' || \$family == 'chelvetica') {
\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"Core Adobe font \".ucfirst(\$family).\" cannot be embedded in mPDF, which is required for PDFA1-b or PDFX/1-a. (Embedded font will be substituted.)\"; }
\t\t\tif (\$family == 'chelvetica') { \$family = 'sans'; }
\t\t\tif (\$family == 'ctimes') { \$family = 'serif'; }
\t\t\tif (\$family == 'ccourier') { \$family = 'mono'; }
\t\t   }
\t\t   \$this->usingCoreFont = false;
\t\t}
\t\telse { \$this->usingCoreFont = true; }
\t\tif(\$family=='csymbol' || \$family=='czapfdingbats') { \$style=''; }
\t}
\telse {  \$this->usingCoreFont = false; }

\t\$this->U=false;
\t\$this->S=false;
\tif (\$style) {
\t\t\$style=strtoupper(\$style);
\t\tif(strpos(\$style,'U')!==false) {
\t\t\t\$this->U=true;
\t\t\t\$style=str_replace('U','',\$style);
\t\t}
\t\tif(strpos(\$style,'S')!==false) {
\t\t\t\$this->S=true;
\t\t\t// Small Caps
\t\t\tif (empty(\$this->upperCase)) { @include(_MPDF_PATH.'includes/upperCase.php'); }
\t\t\t\$style=str_replace('S','',\$style);
\t\t}
\t\tif (\$style=='IB') \$style='BI';
\t}
\tif (\$size==0) \$size=\$this->FontSizePt;

\t\$fontkey=\$family.\$style;

\t\$stylekey = \$style;
\tif (!\$stylekey) { \$stylekey = \"R\"; }

\tif (!\$this->onlyCoreFonts && !\$this->usingCoreFont) {
\t\tif(!isset(\$this->fonts[\$fontkey]) || count(\$this->default_available_fonts) != count(\$this->available_unifonts) ) { // not already added
/*-- CJK-FONTS --*/
\t\t  // CJK fonts
\t\t  if (in_array(\$fontkey,\$this->available_CJK_fonts)) {
\t\t\tif(!isset(\$this->fonts[\$fontkey])) {\t// already added
\t\t\t\tif (empty(\$this->Big5_widths)) { require(_MPDF_PATH . 'includes/CJKdata.php'); }
\t\t\t\t\$this->AddCJKFont(\$family);\t// don't need to add style
\t\t\t}
\t\t  }
\t\t  // Test to see if requested font/style is available - or substitute
\t\t  else
/*-- END CJK-FONTS --*/
\t\t  if (!in_array(\$fontkey,\$this->available_unifonts)) {
\t\t\t// If font[nostyle] exists - set it
\t\t\tif (in_array(\$family,\$this->available_unifonts)) {
\t\t\t\t\$style = '';
\t\t\t}

\t\t\t// Else if only one font available - set it (assumes if only one font available it will not have a style)
\t\t\telse if (count(\$this->available_unifonts) == 1) {
\t\t\t\t\$family = \$this->available_unifonts[0];
\t\t\t\t\$style = '';
\t\t\t}

\t\t\telse {
\t\t\t\t\$found = 0;
\t\t\t\t// else substitute font of similar type
\t\t\t\tif (in_array(\$family,\$this->sans_fonts)) {
\t\t\t\t\t\$i = array_intersect(\$this->sans_fonts,\$this->available_unifonts);
\t\t\t\t\tif (count(\$i)) {
\t\t\t\t\t\t\$i = array_values(\$i);
\t\t\t\t\t\t// with requested style if possible
\t\t\t\t\t\tif (!in_array((\$i[0].\$style),\$this->available_unifonts)) {
\t\t\t\t\t\t\t\$style = '';
\t\t\t\t\t\t}
\t\t\t\t\t\t\$family = \$i[0];
\t\t\t\t\t\t\$found = 1;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse if (in_array(\$family,\$this->serif_fonts)) {
\t\t\t\t\t\$i = array_intersect(\$this->serif_fonts,\$this->available_unifonts);
\t\t\t\t\tif (count(\$i)) {
\t\t\t\t\t\t\$i = array_values(\$i);
\t\t\t\t\t\t// with requested style if possible
\t\t\t\t\t\tif (!in_array((\$i[0].\$style),\$this->available_unifonts)) {
\t\t\t\t\t\t\t\$style = '';
\t\t\t\t\t\t}
\t\t\t\t\t\t\$family = \$i[0];
\t\t\t\t\t\t\$found = 1;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse if (in_array(\$family,\$this->mono_fonts)) {
\t\t\t\t\t\$i = array_intersect(\$this->mono_fonts,\$this->available_unifonts);
\t\t\t\t\tif (count(\$i)) {
\t\t\t\t\t\t\$i = array_values(\$i);
\t\t\t\t\t\t// with requested style if possible
\t\t\t\t\t\tif (!in_array((\$i[0].\$style),\$this->available_unifonts)) {
\t\t\t\t\t\t\t\$style = '';
\t\t\t\t\t\t}
\t\t\t\t\t\t\$family = \$i[0];
\t\t\t\t\t\t\$found = 1;
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\tif (!\$found) {
\t\t\t\t\t// set first available font
\t\t\t\t\t\$fs = \$this->available_unifonts[0];
\t\t\t\t\tpreg_match('/^([a-z_0-9\\-]+)([BI]{0,2})\$/',\$fs,\$fas);\t// Allow \"-\"
\t\t\t\t\t// with requested style if possible
\t\t\t\t\t\$ws = \$fas[1].\$style;
\t\t\t\t\tif (in_array(\$ws,\$this->available_unifonts)) {
\t\t\t\t\t\t\$family = \$fas[1]; // leave \$style as is
\t\t\t\t\t}
\t\t\t\t\telse if (in_array(\$fas[1],\$this->available_unifonts)) {
\t\t\t\t\t// or without style
\t\t\t\t\t\t\$family = \$fas[1];
\t\t\t\t\t\t\$style = '';
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t// or with the style specified
\t\t\t\t\t\t\$family = \$fas[1];
\t\t\t\t\t\t\$style = \$fas[2];
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t\$fontkey = \$family.\$style;
\t\t  }
\t\t}
\t\t// try to add font (if not already added)
\t\t\$this->AddFont(\$family, \$style);

\t\t//Test if font is already selected
\t\tif(\$this->FontFamily == \$family && \$this->FontFamily == \$this->currentfontfamily && \$this->FontStyle == \$style && \$this->FontStyle == \$this->currentfontstyle && \$this->FontSizePt == \$size && \$this->FontSizePt == \$this->currentfontsize && !\$forcewrite) {
\t\t\treturn \$family;
\t\t}

\t\t\$fontkey = \$family.\$style;

\t\t//Select it
\t\t\$this->FontFamily = \$family;
\t\t\$this->FontStyle = \$style;
\t\t\$this->FontSizePt = \$size;
\t\t\$this->FontSize = \$size / _MPDFK;
\t\t\$this->CurrentFont = &\$this->fonts[\$fontkey];
\t\tif (\$write) {
\t\t\t\$fontout = (sprintf('BT /F%d %.3F Tf ET', \$this->CurrentFont['i'], \$this->FontSizePt));
\t\t\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['Font']) && \$this->pageoutput[\$this->page]['Font'] != \$fontout) || !isset(\$this->pageoutput[\$this->page]['Font']) || \$this->keep_block_together)) { \$this->_out(\$fontout); }
\t\t\t\$this->pageoutput[\$this->page]['Font'] = \$fontout;
\t\t}



\t\t// Added - currentfont (lowercase) used in HTML2PDF
\t\t\$this->currentfontfamily=\$family;
\t\t\$this->currentfontsize=\$size;
\t\t\$this->currentfontstyle=\$style.(\$this->U ? 'U' : '').(\$this->S ? 'S' : '');
\t\t\$this->setMBencoding('UTF-8');
\t}

\telse { \t// if using core fonts


\t\tif (\$this->PDFA || \$this->PDFX) {
\t\t\t\$this->Error('Core Adobe fonts cannot be embedded in mPDF (required for PDFA1-b or PDFX/1-a) - cannot use option to use core fonts.');
\t\t}
\t\t\$this->setMBencoding('windows-1252');

\t\t//Test if font is already selected
\t\tif((\$this->FontFamily == \$family) AND (\$this->FontStyle == \$style) AND (\$this->FontSizePt == \$size) && !\$forcewrite) {
\t\t\treturn \$family;
\t\t}

\t\tif (!isset(\$this->CoreFonts[\$fontkey])) {
\t\t\tif (in_array(\$family,\$this->serif_fonts)) { \$family = 'ctimes'; }
\t\t\telse if (in_array(\$family,\$this->mono_fonts)) { \$family = 'ccourier'; }
\t\t\telse { \$family = 'chelvetica'; }
\t\t\t\$this->usingCoreFont = true;
\t\t\t\$fontkey = \$family.\$style;
\t\t}

\t\tif(!isset(\$this->fonts[\$fontkey])) \t{
\t\t\t// STANDARD CORE FONTS
\t\t\tif (isset(\$this->CoreFonts[\$fontkey])) {
\t\t\t\t//Load metric file
\t\t\t\t\$file=\$family;
\t\t\t\tif(\$family=='ctimes' || \$family=='chelvetica' || \$family=='ccourier') { \$file.=strtolower(\$style); }
\t\t\t\t\$file.='.php';
\t\t\t\tinclude(_MPDF_PATH.'font/'.\$file);
\t\t\t\tif(!isset(\$cw)) { \$this->Error('Could not include font metric file'); }
\t\t\t\t\$i=count(\$this->fonts)+\$this->extraFontSubsets+1;
\t\t\t\t\$this->fonts[\$fontkey]=array('i'=>\$i,'type'=>'core','name'=>\$this->CoreFonts[\$fontkey],'desc'=>\$desc,'up'=>\$up,'ut'=>\$ut,'cw'=>\$cw);
\t\t\t\tif (\$this->useKerning) { \$this->fonts[\$fontkey]['kerninfo'] = \$kerninfo; }
\t\t\t}
\t\t\telse {
\t\t\t\tdie('mPDF error - Font not defined');
\t\t\t}
\t\t}
\t\t//Test if font is already selected
\t\tif((\$this->FontFamily == \$family) AND (\$this->FontStyle == \$style) AND (\$this->FontSizePt == \$size) && !\$forcewrite) {
\t\t\treturn \$family;
\t\t}
\t\t//Select it
\t\t\$this->FontFamily=\$family;
\t\t\$this->FontStyle=\$style;
\t\t\$this->FontSizePt=\$size;
\t\t\$this->FontSize=\$size/_MPDFK;
\t\t\$this->CurrentFont=&\$this->fonts[\$fontkey];
\t\tif (\$write) {
\t\t\t\$fontout = (sprintf('BT /F%d %.3F Tf ET', \$this->CurrentFont['i'], \$this->FontSizePt));
\t\t\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['Font']) && \$this->pageoutput[\$this->page]['Font'] != \$fontout) || !isset(\$this->pageoutput[\$this->page]['Font']) || \$this->keep_block_together)) { \$this->_out(\$fontout); }
\t\t\t\$this->pageoutput[\$this->page]['Font'] = \$fontout;
\t\t}
\t\t// Added - currentfont (lowercase) used in HTML2PDF
\t\t\$this->currentfontfamily=\$family;
\t\t\$this->currentfontsize=\$size;
\t\t\$this->currentfontstyle=\$style.(\$this->U ? 'U' : '').(\$this->S ? 'S' : '');

\t}

\treturn \$family;
}

function SetFontSize(\$size,\$write=true) {
\t//Set font size in points
\tif(\$this->FontSizePt==\$size) return;
\t\$this->FontSizePt=\$size;
\t\$this->FontSize=\$size/_MPDFK;
\t\$this->currentfontsize=\$size;
\t\tif (\$write) {
\t\t\t\$fontout = (sprintf('BT /F%d %.3F Tf ET', \$this->CurrentFont['i'], \$this->FontSizePt));
\t\t\t// Edited mPDF 3.0
\t\t\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['Font']) && \$this->pageoutput[\$this->page]['Font'] != \$fontout) || !isset(\$this->pageoutput[\$this->page]['Font']) || \$this->keep_block_together)) { \$this->_out(\$fontout); }
\t\t\t\$this->pageoutput[\$this->page]['Font'] = \$fontout;
\t\t}
}

function AddLink() {
\t//Create a new internal link
\t\$n=count(\$this->links)+1;
\t\$this->links[\$n]=array(0,0);
\treturn \$n;
}

function SetLink(\$link,\$y=0,\$page=-1) {
\t//Set destination of internal link
\tif(\$y==-1) \$y=\$this->y;
\tif(\$page==-1)\t\$page=\$this->page;
\t\$this->links[\$link]=array(\$page,\$y);
}

function Link(\$x,\$y,\$w,\$h,\$link) {
\t\$l = array(\$x*_MPDFK,\$this->hPt-\$y*_MPDFK,\$w*_MPDFK,\$h*_MPDFK,\$link);
\tif (\$this->keep_block_together) {\t// Save to array - don't write yet
\t\t\$this->ktLinks[\$this->page][]= \$l;
\t\treturn;
\t}
\telse if (\$this->table_rotate) {\t// *TABLES*
\t\t\$this->tbrot_Links[\$this->page][]= \$l;\t// *TABLES*
\t\treturn;\t// *TABLES*
\t}\t// *TABLES*
\telse if (\$this->kwt) {
\t\t\$this->kwt_Links[\$this->page][]= \$l;
\t\treturn;
\t}

\tif (\$this->writingHTMLheader || \$this->writingHTMLfooter) {
\t\t\$this->HTMLheaderPageLinks[]= \$l;
\t\treturn;
\t}
\t//Put a link on the page
\t\$this->PageLinks[\$this->page][]= \$l;
\t// Save cross-reference to Column buffer
\t\$ref = count(\$this->PageLinks[\$this->page])-1;\t// *COLUMNS*
\t\$this->columnLinks[\$this->CurrCol][INTVAL(\$this->x)][INTVAL(\$this->y)] = \$ref;\t// *COLUMNS*

}

function Text(\$x,\$y,\$txt) {
\t// Output a string
\t// Called (internally) by Watermark and _tableWrite [rotated cells]
\t// Expects input to be mb_encoded if necessary and RTL reversed

\t// ARTIFICIAL BOLD AND ITALIC
\t\$s = 'q ';
\tif (\$this->falseBoldWeight && strpos(\$this->ReqFontStyle,\"B\") !== false && strpos(\$this->FontStyle,\"B\") === false) {
\t\t\$s  .= '2 Tr 1 J 1 j ';
\t\t\$s .= sprintf('%.3F w ',(\$this->FontSize/130)*_MPDFK*\$this->falseBoldWeight);
\t\t\$tc = strtoupper(\$this->TextColor); // change 0 0 0 rg to 0 0 0 RG
\t\tif(\$this->FillColor!=\$tc) { \$s .= \$tc.' '; }\t\t// stroke (outline) = same colour as text(fill)
\t}
\tif (strpos(\$this->ReqFontStyle,\"I\") !== false && strpos(\$this->FontStyle,\"I\") === false) {
\t\t\$aix = '1 0 0.261799 1 %.3F %.3F Tm';
\t}
\telse { \$aix = '%.3F %.3F Td'; }

\tif(\$this->ColorFlag) \$s.=\$this->TextColor.' ';

\t\$this->CurrentFont['used']= true;
\tif (\$this->CurrentFont['type']=='TTF' && (\$this->CurrentFont['sip'] || \$this->CurrentFont['smp'])) {
\t      \$txt2 = str_replace(chr(194).chr(160),chr(32),\$txt);
\t\t\$txt2 = \$this->UTF8toSubset(\$txt2);
\t\t\$s.=sprintf('BT '.\$aix.' %s Tj ET ',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$txt2);
\t}
\telse if (!\$this->usingCoreFont) {
\t      \$txt2 = str_replace(chr(194).chr(160),chr(32),\$txt);
\t\t\$this->UTF8StringToArray(\$txt2);\t// this is just to add chars to subset list
\t\tif (\$this->kerning && \$this->useKerning) { \$s .= \$this->_kern(\$txt2, '', \$aix, \$x, \$y); }
\t\telse {
\t\t\t//Convert string to UTF-16BE without BOM
\t\t\t\$txt2= \$this->UTF8ToUTF16BE(\$txt2, false);
\t\t\t\$s.=sprintf('BT '.\$aix.' (%s) Tj ET ',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$this->_escape(\$txt2));
\t\t}
\t}
\telse {
\t      \$txt2 = str_replace(chr(160),chr(32),\$txt);
\t\tif (\$this->kerning && \$this->useKerning) { \$s .= \$this->_kern(\$txt2, '', \$aix, \$x, \$y); }
\t\telse {
\t\t\t\$s.=sprintf('BT '.\$aix.' (%s) Tj ET ',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$this->_escape(\$txt2));
\t\t}
\t}
\tif(\$this->U && \$txt!='') {
\t\t\$c = strtoupper(\$this->TextColor); // change 0 0 0 rg to 0 0 0 RG
\t\tif(\$this->FillColor!=\$c) { \$s.= ' '.\$c.' '; }
\t\tif (isset(\$this->CurrentFont['up'])) { \$up=\$this->CurrentFont['up']; }
\t\telse { \$up = -100; }
\t\t\$adjusty = (-\$up/1000* \$this->FontSize);
 \t\tif (isset(\$this->CurrentFont['ut'])) { \$ut=\$this->CurrentFont['ut']/1000* \$this->FontSize; }
\t\telse { \$ut = 60/1000* \$this->FontSize; }
\t\t\$olw = \$this->LineWidth;
\t\t\$s.=' '.(sprintf(' %.3F w',\$ut*_MPDFK));
\t\t\$s.=' '.\$this->_dounderline(\$x,\$y + \$adjusty,\$txt);
\t\t\$s.=' '.(sprintf(' %.3F w',\$olw*_MPDFK));
\t\tif(\$this->FillColor!=\$c) { \$s.= ' '.\$this->FillColor.' '; }
\t}
   \t// STRIKETHROUGH
\tif(\$this->strike && \$txt!='') {
\t\t\$c = strtoupper(\$this->TextColor); // change 0 0 0 rg to 0 0 0 RG
\t\tif(\$this->FillColor!=\$c) { \$s.= ' '.\$c.' '; }
    \t\t//Superscript and Subscript Y coordinate adjustment (now for striked-through texts)
\t\tif (isset(\$this->CurrentFont['desc']['CapHeight'])) { \$ch=\$this->CurrentFont['desc']['CapHeight']; }
\t\telse { \$ch = 700; }
\t\t\$adjusty = (-\$ch/1000* \$this->FontSize) * 0.35;
 \t\tif (isset(\$this->CurrentFont['ut'])) { \$ut=\$this->CurrentFont['ut']/1000* \$this->FontSize; }
\t\telse { \$ut = 60/1000* \$this->FontSize; }
\t\t\$olw = \$this->LineWidth;
\t\t\$s.=' '.(sprintf(' %.3F w',\$ut*_MPDFK));
\t\t\$s.=' '.\$this->_dounderline(\$x,\$y+\$adjusty,\$txt);
\t\t\$s.=' '.(sprintf(' %.3F w',\$olw*_MPDFK));
\t\tif(\$this->FillColor!=\$c) { \$s.= ' '.\$this->FillColor.' '; }
\t}
\t\$s .= 'Q';
\t\$this->_out(\$s);
}

/*-- DIRECTW --*/
function WriteText(\$x,\$y,\$txt) {
\t// Output a string using Text() but does encoding and text reversing of RTL
\t\$txt = \$this->purify_utf8_text(\$txt);
\tif (\$this->text_input_as_HTML) {
\t\t\$txt = \$this->all_entities_to_utf8(\$txt);
\t}
\tif (\$this->usingCoreFont) { \$txt = mb_convert_encoding(\$txt,\$this->mb_enc,'UTF-8'); }
\t// DIRECTIONALITY
\tif (preg_match(\"/([\".\$this->pregRTLchars.\"])/u\", \$txt)) { \$this->biDirectional = true; }\t// *RTL*
\t\$this->magic_reverse_dir(\$txt, true, \$this->directionality);\t// *RTL*
\t// Font-specific ligature substitution for Indic fonts
\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) \$this->ConvertIndic(\$txt);\t// *INDIC*
\t\$this->Text(\$x,\$y,\$txt);
}

function WriteCell(\$w,\$h=0,\$txt='',\$border=0,\$ln=0,\$align='',\$fill=0,\$link='', \$currentx=0) {
\t//Output a cell using Cell() but does encoding and text reversing of RTL
\t\$txt = \$this->purify_utf8_text(\$txt);
\tif (\$this->text_input_as_HTML) {
\t\t\$txt = \$this->all_entities_to_utf8(\$txt);
\t}
\tif (\$this->usingCoreFont) { \$txt = mb_convert_encoding(\$txt,\$this->mb_enc,'UTF-8'); }
\t// DIRECTIONALITY
\tif (preg_match(\"/([\".\$this->pregRTLchars.\"])/u\", \$txt)) { \$this->biDirectional = true; }\t// *RTL*
\t\$this->magic_reverse_dir(\$txt, true, \$this->directionality);\t// *RTL*
\t// Font-specific ligature substitution for Indic fonts
\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) \$this->ConvertIndic(\$txt);\t// *INDIC*
\t\$this->Cell(\$w,\$h,\$txt,\$border,\$ln,\$align,\$fill,\$link, \$currentx);
}
/*-- END DIRECTW --*/


function ResetSpacing() {
\tif (\$this->ws != 0) { \$this->_out('BT 0 Tw ET'); }
\t\$this->ws=0;
\tif (\$this->charspacing != 0) { \$this->_out('BT 0 Tc ET'); }
\t\$this->charspacing=0;
}


function SetSpacing(\$cs,\$ws) {
\tif (intval(\$cs*1000)==0) { \$cs = 0; }
\tif (\$cs) { \$this->_out(sprintf('BT %.3F Tc ET',\$cs)); }
\telse if (\$this->charspacing != 0) { \$this->_out('BT 0 Tc ET'); }
\t\$this->charspacing=\$cs;
\tif (intval(\$ws*1000)==0) { \$ws = 0; }
\tif (\$ws) { \$this->_out(sprintf('BT %.3F Tw ET',\$ws)); }
\telse if (\$this->ws != 0) { \$this->_out('BT 0 Tw ET'); }
\t\$this->ws=\$ws;
}

// WORD SPACING
function GetJspacing(\$nc,\$ns,\$w,\$inclCursive) {
\t\$ws = 0;
\t\$charspacing = 0;
\t\$ww = \$this->jSWord;
\t\$ncx = \$nc-1;
\tif (\$nc == 0) { return array(0,0); }
\telse if (\$nc==1) { \$charspacing = \$w; }
\t// Only word spacing allowed / possible
\telse if (\$this->fixedlSpacing !== false || \$inclCursive) {
\t\tif (\$ns) { \$ws = \$w / \$ns; }
\t}
\telse if (!\$ns) {
\t\t\$charspacing = \$w / (\$ncx );
\t\tif ((\$this->jSmaxChar > 0) && (\$charspacing > \$this->jSmaxChar)) {
\t\t\t\$charspacing = \$this->jSmaxChar;
\t\t}
\t}
\telse if (\$ns == (\$ncx )) {
\t\t\$charspacing = \$w / \$ns;
\t}
\telse {
\t\tif (\$this->usingCoreFont) {
\t\t\t\$cs = (\$w * (1 - \$this->jSWord)) / (\$ncx );
\t\t\tif ((\$this->jSmaxChar > 0) && (\$cs > \$this->jSmaxChar)) {
\t\t\t\t\$cs = \$this->jSmaxChar;
\t\t\t\t\$ww = 1 - ((\$cs * (\$ncx ))/\$w);
\t\t\t}
\t\t\t\$charspacing = \$cs;
\t\t\t\$ws = (\$w * (\$ww) ) / \$ns;
\t\t}
\t\telse {
\t\t\t\$cs = (\$w * (1 - \$this->jSWord)) / (\$ncx -\$ns);
\t\t\tif ((\$this->jSmaxChar > 0) && (\$cs > \$this->jSmaxChar)) {
\t\t\t\t\$cs = \$this->jSmaxChar;
\t\t\t\t\$ww = 1 - ((\$cs * (\$ncx -\$ns))/\$w);
\t\t\t}
\t\t\t\$charspacing = \$cs;
\t\t\t\$ws = ((\$w * (\$ww) ) / \$ns) - \$charspacing;
\t\t}
\t}
\treturn array(\$charspacing,\$ws);
}

function Cell(\$w,\$h=0,\$txt='',\$border=0,\$ln=0,\$align='',\$fill=0,\$link='', \$currentx=0, \$lcpaddingL=0, \$lcpaddingR=0, \$valign='M', \$spanfill=0, \$abovefont=0, \$belowfont=0, \$exactWidth=false) {
\t//Output a cell
\t// Expects input to be mb_encoded if necessary and RTL reversed
\t// NON_BREAKING SPACE
\tif (\$this->usingCoreFont) {
\t      \$txt = str_replace(chr(160),chr(32),\$txt);
\t}
\telse {
\t      \$txt = str_replace(chr(194).chr(160),chr(32),\$txt);
\t}

\t\$oldcolumn = \$this->CurrCol;
\t// Automatic page break
\t// Allows PAGE-BREAK-AFTER = avoid to work
\tif (!\$this->tableLevel && ((\$this->y+\$this->divheight>\$this->PageBreakTrigger) || (\$this->y+\$h>\$this->PageBreakTrigger) ||
\t\t(\$this->y+(\$h*2)+\$this->blk[\$this->blklvl]['padding_bottom']+\$this->blk[\$this->blklvl]['margin_bottom']>\$this->PageBreakTrigger && \$this->blk[\$this->blklvl]['page_break_after_avoid'])) and !\$this->InFooter and \$this->AcceptPageBreak()) {\t// mPDF 5.7.2
\t\t\$x=\$this->x;//Current X position


\t\t// WORD SPACING
\t\t\$ws=\$this->ws;//Word Spacing
\t\t\$charspacing=\$this->charspacing;//Character Spacing
\t\t\$this->ResetSpacing();

\t\t\$this->AddPage(\$this->CurOrientation);
\t\t// Added to correct for OddEven Margins
\t\t\$x += \$this->MarginCorrection;
\t\tif (\$currentx) {
\t\t\t\$currentx += \$this->MarginCorrection;
\t\t}
\t\t\$this->x=\$x;
\t\t// WORD SPACING
\t\t\$this->SetSpacing(\$charspacing,\$ws);
\t}

\t// Test: to put line through centre of cell: \$this->Line(\$this->x,\$this->y+(\$h/2),\$this->x+50,\$this->y+(\$h/2));

/*-- COLUMNS --*/
\t// COLS
\t// COLUMN CHANGE
\tif (\$this->CurrCol != \$oldcolumn) {
\t\tif (\$currentx) {
\t\t\t\$currentx += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t}
\t\t\$this->x += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t}

\t// COLUMNS Update/overwrite the lowest bottom of printing y value for a column
\tif (\$this->ColActive) {
\t\tif (\$h) { \$this->ColDetails[\$this->CurrCol]['bottom_margin'] = \$this->y+\$h; }
\t\telse { \$this->ColDetails[\$this->CurrCol]['bottom_margin'] = \$this->y+\$this->divheight; }
\t}
/*-- END COLUMNS --*/

\t// KEEP BLOCK TOGETHER Update/overwrite the lowest bottom of printing y value on first page
\tif (\$this->keep_block_together) {
\t\tif (\$h) { \$this->ktBlock[\$this->page]['bottom_margin'] = \$this->y+\$h; }
//\t\telse { \$this->ktBlock[\$this->page]['bottom_margin'] = \$this->y+\$this->divheight; }
\t}

\tif(\$w==0) \$w = \$this->w-\$this->rMargin-\$this->x;
\t\$s='';
\tif(\$fill==1 && \$this->FillColor) {
\t\tif((isset(\$this->pageoutput[\$this->page]['FillColor']) && \$this->pageoutput[\$this->page]['FillColor'] != \$this->FillColor) || !isset(\$this->pageoutput[\$this->page]['FillColor']) || \$this->keep_block_together) { \$s .= \$this->FillColor.' '; }
\t\t\$this->pageoutput[\$this->page]['FillColor'] = \$this->FillColor;
\t}


\t\$boxtop = \$this->y;
\t\$boxheight = \$h;
\t\$boxbottom = \$this->y+\$h;

\tif(\$txt!='') {
\t\t// FONT SIZE - this determines the baseline caculation
\t\tif (\$this->linemaxfontsize && !\$this->processingHeader) { \$bfs = \$this->linemaxfontsize; }
\t\telse  { \$bfs = \$this->FontSize; }
    \t\t//Calculate baseline Superscript and Subscript Y coordinate adjustment
\t\t\$bfx = \$this->baselineC;
    \t\t\$baseline = \$bfx*\$bfs;
\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\tif(\$this->SUP) { \$baseline -= \$this->textparam['text-baseline']; }\t// mPDF 5.7.1
\t\telse if(\$this->SUB) { \$baseline -= \$this->textparam['text-baseline']; }\t// mPDF 5.7.1
\t\telse if(\$this->bullet) { \$baseline += (\$bfx-0.7)*\$this->FontSize; }

\t\t// Vertical align (for Images)
\t\tif (\$abovefont || \$belowfont) {\t// from flowing block - valign always M
\t\t\t\$va = \$abovefont + (0.5*\$bfs);
\t\t}
\t\telse if (\$this->lineheight_correction) {
\t\t\tif (\$valign == 'T') { \$va = (0.5 * \$bfs * \$this->lineheight_correction); }
\t\t\telse if (\$valign == 'B') { \$va = \$h-(0.5 * \$bfs * \$this->lineheight_correction); }
\t\t\telse { \$va = 0.5*\$h; }\t// Middle
\t\t}
\t\telse {
\t\t\tif (\$valign == 'T') { \$va = (0.5 * \$bfs * \$this->default_lineheight_correction); }
\t\t\telse if (\$valign == 'B') { \$va = \$h-(0.5 * \$bfs * \$this->default_lineheight_correction); }
\t\t\telse { \$va = 0.5*\$h; }\t// Middle
\t\t}

\t\t// ONLY SET THESE IF WANT TO CONFINE BORDER +/- FILL TO FIT FONTSIZE - NOT FULL CELL AS IS ORIGINAL FUNCTION
\t\t// spanfill or spanborder are set in FlowingBlock functions
\t\tif (\$spanfill || !empty(\$this->spanborddet) || \$link!='') {
\t\t\t\$exth = 0.2;\t// Add to fontsize to increase height of background / link / border
\t\t\t\$boxtop = \$this->y+\$baseline+\$va-(\$this->FontSize*(1+\$exth/2)*(0.5+\$bfx));
\t\t\t\$boxheight = \$this->FontSize * (1+\$exth);
\t\t\t\$boxbottom = \$boxtop + \$boxheight;
\t\t}
\t}

\t\$bbw = \$tbw = \$lbw = \$rbw = 0;\t// Border widths
\tif (!empty(\$this->spanborddet)) {
\t\tif (!isset(\$this->spanborddet['B'])) { \$this->spanborddet['B'] = array('s' => 0, 'style' => '', 'w' => 0); }
\t\tif (!isset(\$this->spanborddet['T'])) { \$this->spanborddet['T'] = array('s' => 0, 'style' => '', 'w' => 0); }
\t\tif (!isset(\$this->spanborddet['L'])) { \$this->spanborddet['L'] = array('s' => 0, 'style' => '', 'w' => 0); }
\t\tif (!isset(\$this->spanborddet['R'])) { \$this->spanborddet['R'] = array('s' => 0, 'style' => '', 'w' => 0); }
\t\t\$bbw = \$this->spanborddet['B']['w'];
\t\t\$tbw = \$this->spanborddet['T']['w'];
\t\t\$lbw = \$this->spanborddet['L']['w'];
\t\t\$rbw = \$this->spanborddet['R']['w'];
\t}
\tif(\$fill==1 || \$border==1 || !empty(\$this->spanborddet)) {
\t\tif (!empty(\$this->spanborddet)) {
\t\t\tif (\$fill==1) {
\t\t\t\t\$s.=sprintf('%.3F %.3F %.3F %.3F re f ',(\$this->x-\$lbw)*_MPDFK,(\$this->h-\$boxtop+\$tbw)*_MPDFK,(\$w+\$lbw+\$rbw)*_MPDFK,(-\$boxheight-\$tbw-\$bbw)*_MPDFK);
\t\t\t}
\t\t\t\$s.= ' q ';
\t\t\t\$dashon = 3;
\t\t\t\$dashoff = 3.5;
\t\t\t\$dot = 2.5;
\t\t\tif(\$tbw) {
\t\t\t\t\$short = 0;
\t\t\t\tif (\$this->spanborddet['T']['style'] == 'dashed') {
\t\t\t\t\t\$s.=sprintf(' 0 j 0 J [%.3F %.3F] 0 d ',\$tbw*\$dashon*_MPDFK,\$tbw*\$dashoff*_MPDFK);
\t\t\t\t}
\t\t\t\telse if (\$this->spanborddet['T']['style'] == 'dotted') {
\t\t\t\t\t\$s.=sprintf(' 1 j 1 J [%.3F %.3F] %.3F d ',0.001,\$tbw*\$dot*_MPDFK,-\$tbw/2*_MPDFK);
\t\t\t\t\t\$short = \$tbw/2;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=' 0 j 0 J [] 0 d ';
\t\t\t\t}
\t\t\t\t\$c = \$this->SetDColor(\$this->spanborddet['T']['c'],true);
\t\t\t\tif (\$this->spanborddet['T']['style'] == 'double') {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$tbw/3*_MPDFK);
\t\t\t\t\t\$xadj = \$xadj2 = 0;
\t\t\t\t\tif (\$this->spanborddet['L']['style'] == 'double') { \$xadj = \$this->spanborddet['L']['w']*2/3; }
\t\t\t\t\tif (\$this->spanborddet['R']['style'] == 'double') { \$xadj2 = \$this->spanborddet['R']['w']*2/3; }
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw)*_MPDFK,(\$this->h-\$boxtop+\$tbw*5/6)*_MPDFK,(\$this->x+\$w+\$rbw-\$short)*_MPDFK,(\$this->h-\$boxtop+\$tbw*5/6)*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw+\$xadj)*_MPDFK,(\$this->h-\$boxtop+\$tbw/6)*_MPDFK,(\$this->x+\$w+\$rbw-\$short-\$xadj2)*_MPDFK,(\$this->h-\$boxtop+\$tbw/6)*_MPDFK);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$tbw*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw)*_MPDFK,(\$this->h-\$boxtop+\$tbw/2)*_MPDFK,(\$this->x+\$w+\$rbw-\$short)*_MPDFK,(\$this->h-\$boxtop+\$tbw/2)*_MPDFK);
\t\t\t\t}
\t\t\t}
\t\t\tif(\$bbw) {
\t\t\t\t\$short = 0;
\t\t\t\tif (\$this->spanborddet['B']['style'] == 'dashed') {
\t\t\t\t\t\$s.=sprintf(' 0 j 0 J [%.3F %.3F] 0 d ',\$bbw*\$dashon*_MPDFK,\$bbw*\$dashoff*_MPDFK);
\t\t\t\t}
\t\t\t\telse if (\$this->spanborddet['B']['style'] == 'dotted') {
\t\t\t\t\t\$s.=sprintf(' 1 j 1 J [%.3F %.3F] %.3F d ',0.001,\$bbw*\$dot*_MPDFK,-\$bbw/2*_MPDFK);
\t\t\t\t\t\$short = \$bbw/2;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=' 0 j 0 J [] 0 d ';
\t\t\t\t}
\t\t\t\t\$c = \$this->SetDColor(\$this->spanborddet['B']['c'],true);
\t\t\t\tif (\$this->spanborddet['B']['style'] == 'double') {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$bbw/3*_MPDFK);
\t\t\t\t\t\$xadj = \$xadj2 = 0;
\t\t\t\t\tif (\$this->spanborddet['L']['style'] == 'double') { \$xadj = \$this->spanborddet['L']['w']*2/3; }
\t\t\t\t\tif (\$this->spanborddet['R']['style'] == 'double') { \$xadj2 = \$this->spanborddet['R']['w']*2/3; }
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw+\$xadj)*_MPDFK,(\$this->h-\$boxbottom-\$bbw/6)*_MPDFK,(\$this->x+\$w+\$rbw-\$short-\$xadj2)*_MPDFK,(\$this->h-\$boxbottom-\$bbw/6)*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw)*_MPDFK,(\$this->h-\$boxbottom-\$bbw*5/6)*_MPDFK,(\$this->x+\$w+\$rbw-\$short)*_MPDFK,(\$this->h-\$boxbottom-\$bbw*5/6)*_MPDFK);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$bbw*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw)*_MPDFK,(\$this->h-\$boxbottom-\$bbw/2)*_MPDFK,(\$this->x+\$w+\$rbw-\$short)*_MPDFK,(\$this->h-\$boxbottom-\$bbw/2)*_MPDFK);
\t\t\t\t}
\t\t\t}
\t\t\tif(\$lbw) {
\t\t\t\t\$short = 0;
\t\t\t\tif (\$this->spanborddet['L']['style'] == 'dashed') {
\t\t\t\t\t\$s.=sprintf(' 0 j 0 J [%.3F %.3F] 0 d ',\$lbw*\$dashon*_MPDFK,\$lbw*\$dashoff*_MPDFK);
\t\t\t\t}
\t\t\t\telse if (\$this->spanborddet['L']['style'] == 'dotted') {
\t\t\t\t\t\$s.=sprintf(' 1 j 1 J [%.3F %.3F] %.3F d ',0.001,\$lbw*\$dot*_MPDFK,-\$lbw/2*_MPDFK);
\t\t\t\t\t\$short = \$lbw/2;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=' 0 j 0 J [] 0 d ';
\t\t\t\t}
\t\t\t\t\$c = \$this->SetDColor(\$this->spanborddet['L']['c'],true);
\t\t\t\tif (\$this->spanborddet['L']['style'] == 'double') {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$lbw/3*_MPDFK);
\t\t\t\t\t\$yadj = \$yadj2 = 0;
\t\t\t\t\tif (\$this->spanborddet['T']['style'] == 'double') { \$yadj = \$this->spanborddet['T']['w']*2/3; }
\t\t\t\t\tif (\$this->spanborddet['B']['style'] == 'double') { \$yadj2 = \$this->spanborddet['B']['w']*2/3; }
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw/6)*_MPDFK,(\$this->h-\$boxtop+\$tbw-\$yadj)*_MPDFK,(\$this->x-\$lbw/6)*_MPDFK,(\$this->h-\$boxbottom-\$bbw+\$short+\$yadj2)*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw*5/6)*_MPDFK,(\$this->h-\$boxtop+\$tbw)*_MPDFK,(\$this->x-\$lbw*5/6)*_MPDFK,(\$this->h-\$boxbottom-\$bbw+\$short)*_MPDFK);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$lbw*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x-\$lbw/2)*_MPDFK,(\$this->h-\$boxtop+\$tbw)*_MPDFK,(\$this->x-\$lbw/2)*_MPDFK,(\$this->h-\$boxbottom-\$bbw+\$short)*_MPDFK);
\t\t\t\t}
\t\t\t}
\t\t\tif(\$rbw) {
\t\t\t\t\$short = 0;
\t\t\t\tif (\$this->spanborddet['R']['style'] == 'dashed') {
\t\t\t\t\t\$s.=sprintf(' 0 j 0 J [%.3F %.3F] 0 d ',\$rbw*\$dashon*_MPDFK,\$rbw*\$dashoff*_MPDFK);
\t\t\t\t}
\t\t\t\telse if (\$this->spanborddet['R']['style'] == 'dotted') {
\t\t\t\t\t\$s.=sprintf(' 1 j 1 J [%.3F %.3F] %.3F d ',0.001,\$rbw*\$dot*_MPDFK,-\$rbw/2*_MPDFK);
\t\t\t\t\t\$short = \$rbw/2;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=' 0 j 0 J [] 0 d ';
\t\t\t\t}
\t\t\t\t\$c = \$this->SetDColor(\$this->spanborddet['R']['c'],true);
\t\t\t\tif (\$this->spanborddet['R']['style'] == 'double') {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$rbw/3*_MPDFK);
\t\t\t\t\t\$yadj = \$yadj2 = 0;
\t\t\t\t\tif (\$this->spanborddet['T']['style'] == 'double') { \$yadj = \$this->spanborddet['T']['w']*2/3; }
\t\t\t\t\tif (\$this->spanborddet['B']['style'] == 'double') { \$yadj2 = \$this->spanborddet['B']['w']*2/3; }
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x+\$w+\$rbw/6)*_MPDFK,(\$this->h-\$boxtop+\$tbw-\$yadj)*_MPDFK,(\$this->x+\$w+\$rbw/6)*_MPDFK,(\$this->h-\$boxbottom-\$bbw+\$short+\$yadj2)*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x+\$w+\$rbw*5/6)*_MPDFK,(\$this->h-\$boxtop+\$tbw)*_MPDFK,(\$this->x+\$w+\$rbw*5/6)*_MPDFK,(\$this->h-\$boxbottom-\$bbw+\$short)*_MPDFK);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s.=sprintf(' %s %.3F w ',\$c,\$rbw*_MPDFK);
\t\t\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$this->x+\$w+\$rbw/2)*_MPDFK,(\$this->h-\$boxtop+\$tbw)*_MPDFK,(\$this->x+\$w+\$rbw/2)*_MPDFK,(\$this->h-\$boxbottom-\$bbw+\$short)*_MPDFK);
\t\t\t\t}
\t\t\t}
\t\t\t\$s.= ' Q ';
\t\t}
\t\telse {
\t\t\tif (\$fill==1) \$op=(\$border==1) ? 'B' : 'f';
\t\t\telse \$op='S';
\t\t\t\$s.=sprintf('%.3F %.3F %.3F %.3F re %s ',\$this->x*_MPDFK,(\$this->h-\$boxtop)*_MPDFK,\$w*_MPDFK,-\$boxheight*_MPDFK,\$op);
\t\t}
\t}

\tif(is_string(\$border)) {
\t\t\$x=\$this->x;
\t\t\$y=\$this->y;
\t\tif(is_int(strpos(\$border,'L')))
\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',\$x*_MPDFK,(\$this->h-\$boxtop)*_MPDFK,\$x*_MPDFK,(\$this->h-(\$boxbottom))*_MPDFK);
\t\tif(is_int(strpos(\$border,'T')))
\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',\$x*_MPDFK,(\$this->h-\$boxtop)*_MPDFK,(\$x+\$w)*_MPDFK,(\$this->h-\$boxtop)*_MPDFK);
\t\tif(is_int(strpos(\$border,'R')))
\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',(\$x+\$w)*_MPDFK,(\$this->h-\$boxtop)*_MPDFK,(\$x+\$w)*_MPDFK,(\$this->h-(\$boxbottom))*_MPDFK);
\t\tif(is_int(strpos(\$border,'B')))
\t\t\t\$s.=sprintf('%.3F %.3F m %.3F %.3F l S ',\$x*_MPDFK,(\$this->h-(\$boxbottom))*_MPDFK,(\$x+\$w)*_MPDFK,(\$this->h-(\$boxbottom))*_MPDFK);
\t}

\tif(\$txt!='') {
\t\tif (\$exactWidth)
\t\t\t\$stringWidth = \$w;
\t\telse
\t\t\t\$stringWidth = \$this->GetStringWidth(\$txt) + ( \$this->charspacing * mb_strlen( \$txt, \$this->mb_enc ) / _MPDFK )
\t\t\t\t + ( \$this->ws * mb_substr_count( \$txt, ' ', \$this->mb_enc ) / _MPDFK );

\t\t// Set x OFFSET FOR PRINTING
\t\tif(\$align=='R') {
\t\t\t\$dx=\$w-\$this->cMarginR - \$stringWidth - \$lcpaddingR;
\t\t}
\t\telseif(\$align=='C') {
\t\t\t\$dx=((\$w - \$stringWidth )/2);
\t\t}
\t\telseif(\$align=='L' or \$align=='J') \$dx=\$this->cMarginL + \$lcpaddingL;
    \t\telse \$dx = 0;

\t\tif(\$this->ColorFlag) \$s .='q '.\$this->TextColor.' ';

\t\t// OUTLINE
\t\tif(\$this->textparam['outline-s'] && !\$this->S) {\t// mPDF 5.6.07
\t\t\t\$s .=' '.sprintf('%.3F w',\$this->LineWidth*_MPDFK).' ';
\t\t\t\$s .=\" \$this->DrawColor \";
\t\t\t\$s .=\" 2 Tr \";
    \t\t}
\t\telse if (\$this->falseBoldWeight && strpos(\$this->ReqFontStyle,\"B\") !== false && strpos(\$this->FontStyle,\"B\") === false && !\$this->S) {\t// can't use together with OUTLINE or Small Caps
\t\t\t\$s .= ' 2 Tr 1 J 1 j ';
\t\t\t\$s .= ' '.sprintf('%.3F w',(\$this->FontSize/130)*_MPDFK*\$this->falseBoldWeight).' ';
\t\t\t\$tc = strtoupper(\$this->TextColor); // change 0 0 0 rg to 0 0 0 RG
\t\t\tif(\$this->FillColor!=\$tc) { \$s .= ' '.\$tc.' '; }\t\t// stroke (outline) = same colour as text(fill)
\t\t}
\t\telse { \$s .=\" 0 Tr \"; }\t// mPDF 5.6.07

\t\tif (strpos(\$this->ReqFontStyle,\"I\") !== false && strpos(\$this->FontStyle,\"I\") === false) {\t// Artificial italic
\t\t\t\$aix = '1 0 0.261799 1 %.3F %.3F Tm ';
\t\t}
\t\telse { \$aix = '%.3F %.3F Td '; }

\t\t// THE TEXT
\t\t\$sub = '';
\t\t\$this->CurrentFont['used']= true;

\t\t// WORD SPACING
\t\t// IF multibyte - Tw has no effect - need to use alternative method - do word spacing using an adjustment before each space
\t\tif (\$this->ws && !\$this->usingCoreFont && !\$this->CurrentFont['sip'] && !\$this->CurrentFont['smp'] && !\$this->S) {
\t\t  \$sub .= ' BT 0 Tw ET ';
\t\t  if (\$this->kerning && \$this->useKerning) { \$sub .= \$this->_kern(\$txt, 'MBTw', \$aix, (\$this->x+\$dx), (\$this->y+\$baseline+\$va)); }
\t\t  else {
\t\t\t\$space = \" \";
\t\t\t//Convert string to UTF-16BE without BOM
\t\t\t\$space= \$this->UTF8ToUTF16BE(\$space , false);
\t\t\t\$space=\$this->_escape(\$space );
\t\t\t\$sub .=sprintf('BT '.\$aix,(\$this->x+\$dx)*_MPDFK,(\$this->h-(\$this->y+\$baseline+\$va))*_MPDFK);
\t\t\t\$t = explode(' ',\$txt);
\t\t\t\$sub .=sprintf(' %.3F Tc [',\$this->charspacing);
\t\t\t\$numt = count(\$t);
\t\t\tfor(\$i=0;\$i<\$numt;\$i++) {
\t\t\t\t\$tx = \$t[\$i];
\t\t\t\t//Convert string to UTF-16BE without BOM
\t\t\t\t\$tx = \$this->UTF8ToUTF16BE(\$tx , false);
\t\t\t\t\$tx = \$this->_escape(\$tx);
\t\t\t\t\$sub .=sprintf('(%s) ',\$tx);
\t\t\t\tif ((\$i+1)<\$numt) {
\t\t\t\t\t\$adj = -(\$this->ws)*1000/\$this->FontSizePt;
\t\t\t\t\t\$sub .=sprintf('%d(%s) ',\$adj,\$space);
\t\t\t\t}
\t\t\t}
\t\t\t\$sub .='] TJ ';
\t\t\t\$sub .=' ET';
\t\t  }
\t\t}
\t\telse {
\t\t  \$txt2= \$txt;
\t\t  if (\$this->CurrentFont['type']=='TTF' && (\$this->CurrentFont['sip'] || \$this->CurrentFont['smp'])) {
\t\t\tif (\$this->S) { \$sub .= \$this->_smallCaps(\$txt2, 'SIPSMP', \$aix, \$dx, _MPDFK, \$baseline, \$va); }
\t\t\telse {
\t\t\t\t\$txt2 = \$this->UTF8toSubset(\$txt2);
\t\t\t\t\$sub .=sprintf('BT '.\$aix.' %s Tj ET',(\$this->x+\$dx)*_MPDFK,(\$this->h-(\$this->y+\$baseline+\$va))*_MPDFK,\$txt2);
\t\t\t}
\t\t  }
\t\t  else {
\t\t\tif (\$this->S) { \$sub .= \$this->_smallCaps(\$txt2, '', \$aix, \$dx, _MPDFK, \$baseline, \$va); }
\t\t\telse if (\$this->kerning && \$this->useKerning) { \$sub .= \$this->_kern(\$txt2, '', \$aix, (\$this->x+\$dx), (\$this->y+\$baseline+\$va)); }
\t\t\telse {
\t\t\t\tif (!\$this->usingCoreFont) {
\t\t\t\t\t\$txt2 = \$this->UTF8ToUTF16BE(\$txt2, false);
\t\t\t\t}
\t\t\t\t\$txt2=\$this->_escape(\$txt2);
\t\t\t\t\$sub .=sprintf('BT '.\$aix.' (%s) Tj ET',(\$this->x+\$dx)*_MPDFK,(\$this->h-(\$this->y+\$baseline+\$va))*_MPDFK,\$txt2);
\t\t\t}
\t\t  }
\t\t}
\t\t// UNDERLINE
\t\tif(\$this->U) {\t// mPDF 6
\t\t\t\$c = strtoupper(\$this->TextColor); // change 0 0 0 rg to 0 0 0 RG
\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\tif (isset(\$this->textparam['u-decoration']['color'])) {
\t\t\t\t\$c = \$this->textparam['u-decoration']['color'];
\t\t\t}
\t\t\tif(\$this->FillColor!=\$c) { \$sub .= ' '.\$c.' '; }
\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\t\$decorationfontkey = \$this->textparam['decoration-fontkey'];
\t\t\t\$decorationfontsize = \$this->textparam['decoration-fontsize'];
\t\t\tif (isset(\$this->fonts[\$decorationfontkey]['up'])) { \$up=\$this->fonts[\$decorationfontkey]['up']; }
\t\t\telse { \$up = -100; }
\t\t\t\$adjusty = (-\$up/1000* \$decorationfontsize);
\t\t\tif (isset(\$this->fonts[\$decorationfontkey]['ut'])) { \$ut=\$this->fonts[\$decorationfontkey]['ut']/1000* \$decorationfontsize; }
\t\t\telse { \$ut = 60/1000* \$decorationfontsize; }
\t\t\t\$ubaseline = \$this->baselineC*\$bfs - \$this->textparam['decoration-baseline'];
\t\t\t\$olw = \$this->LineWidth;
\t\t\t\$sub .=' '.(sprintf(' %.3F w 0 j 0 J ',\$ut*_MPDFK));
\t\t\t\$sub .=' '.\$this->_dounderline(\$this->x+\$dx,\$this->y+\$ubaseline+\$va+\$adjusty,\$txt,\$OTLdata,\$textvar);
\t\t\t\$sub .=' '.(sprintf(' %.3F w 2 j 2 J ',\$olw*_MPDFK));
\t\t\tif(\$this->FillColor!=\$c) { \$sub .= ' '.\$this->FillColor.' '; }
\t\t}

   \t\t// STRIKETHROUGH
\t\tif(\$this->strike) {\t// mPDF 6
\t\t\t\$c = strtoupper(\$this->TextColor); // change 0 0 0 rg to 0 0 0 RG
\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\tif (isset(\$this->textparam['s-decoration']['color'])) {
\t\t\t\t\$c = \$this->textparam['s-decoration']['color'];
\t\t\t}
\t\t\tif(\$this->FillColor!=\$c) { \$sub .= ' '.\$c.' '; }
\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\t\$decorationfontkey = \$this->textparam['decoration-fontkey'];
\t\t\t\$decorationfontsize = \$this->textparam['decoration-fontsize'];
 \t\t\t//Superscript and Subscript Y coordinate adjustment (now for striked-through texts)
\t\t\tif (isset(\$this->fonts[\$decorationfontkey]['desc']['CapHeight'])) { \$ch=\$this->fonts[\$decorationfontkey]['desc']['CapHeight']; }
\t\t\telse { \$ch = 700; }
\t\t\t\$adjusty = (-\$ch/1000* \$decorationfontsize) * \$this->baselineS;
 \t\t\tif (isset(\$this->fonts[\$decorationfontkey]['ut'])) { \$ut=\$this->fonts[\$decorationfontkey]['ut']/1000* \$decorationfontsize; }
\t\t\telse { \$ut = 60/1000* \$decorationfontsize; }
\t\t\t\$sbaseline = \$this->baselineC*\$bfs - \$this->textparam['decoration-baseline'];
\t\t\t\$olw = \$this->LineWidth;
\t\t\t\$sub .=' '.(sprintf(' %.3F w 0 j 0 J ',\$ut*_MPDFK));
\t\t\t\$sub .=' '.\$this->_dounderline(\$this->x+\$dx,\$this->y+\$sbaseline+\$va+\$adjusty,\$txt,\$OTLdata,\$textvar);
\t\t\t\$sub .=' '.(sprintf(' %.3F w 2 j 2 J ',\$olw*_MPDFK));
\t\t\tif(\$this->FillColor!=\$c) { \$sub .= ' '.\$this->FillColor.' '; }
\t\t}

\t\t// TEXT SHADOW
\t\tif (\$this->textshadow) {\t\t// First to process is last in CSS comma separated shadows
\t\t\tforeach(\$this->textshadow AS \$ts) {
\t\t\t\t\t\$s .= ' q ';
\t\t\t\t\t\$s .= \$this->SetTColor(\$ts['col'], true).\"\\n\";
\t\t\t\t\tif (\$ts['col']{0}==5 && ord(\$ts['col']{4})<100) {\t// RGBa
\t\t\t\t\t\t\$s .= \$this->SetAlpha(ord(\$ts['col']{4})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t\t\t}
\t\t\t\t\telse if (\$ts['col']{0}==6 && ord(\$ts['col']{5})<100) {\t// CMYKa
\t\t\t\t\t\t\$s .= \$this->SetAlpha(ord(\$ts['col']{5})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t\t\t}
\t\t\t\t\telse if (\$ts['col']{0}==1 && \$ts['col']{2}==1 && ord(\$ts['col']{3})<100) {\t// Gray
\t\t\t\t\t\t\$s .= \$this->SetAlpha(ord(\$ts['col']{3})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t\t\t}
\t\t\t\t\t\$s .= sprintf(' 1 0 0 1 %.4F %.4F cm', \$ts['x']*_MPDFK, -\$ts['y']*_MPDFK).\"\\n\";
\t\t\t\t\t\$s .= \$sub;
\t\t\t\t\t\$s .= ' Q ';
\t\t\t}
\t\t}

\t\t\$s .= \$sub;

\t\t// COLOR
\t\tif(\$this->ColorFlag) \$s .=' Q';

\t\t// LINK
\t\tif(\$link!='') {
\t\t\t\$this->Link(\$this->x,\$boxtop,\$w,\$boxheight,\$link);
\t\t}
\t}
\tif(\$s) \$this->_out(\$s);

\t// WORD SPACING
\tif (\$this->ws && !\$this->usingCoreFont) {
\t\t\$this->_out(sprintf('BT %.3F Tc ET',\$this->charspacing));
\t}
\t\$this->lasth=\$h;
\tif( strpos(\$txt,\"\\n\") !== false) \$ln=1; // cell recognizes \\n from <BR> tag
\tif(\$ln>0)
\t{
\t\t//Go to next line
\t\t\$this->y += \$h;
\t\tif(\$ln==1) {
\t\t\t//Move to next line
\t\t\tif (\$currentx != 0) { \$this->x=\$currentx; }
\t\t\telse { \$this->x=\$this->lMargin; }
   \t\t}
\t}
\telse \$this->x+=\$w;


}


function _kern(\$txt, \$mode, \$aix, \$x, \$y) {
   if (\$mode == 'MBTw') {\t// Multibyte requiring word spacing
\t\t  \$space = ' ';
\t\t  //Convert string to UTF-16BE without BOM
\t\t  \$space= \$this->UTF8ToUTF16BE(\$space , false);
\t\t  \$space=\$this->_escape(\$space );
\t\t  \$s = sprintf(' BT '.\$aix,\$x*_MPDFK,(\$this->h-\$y)*_MPDFK);
\t\t  \$t = explode(' ',\$txt);
\t\t  for(\$i=0;\$i<count(\$t);\$i++) {
\t\t\t\$tx = \$t[\$i];

\t\t\t\$tj = '(';
\t\t\t\$unicode = \$this->UTF8StringToArray(\$tx);
\t\t\tfor(\$ti=0;\$ti<count(\$unicode);\$ti++) {
\t\t\t\tif (\$ti > 0 && isset(\$this->CurrentFont['kerninfo'][\$unicode[(\$ti-1)]][\$unicode[\$ti]]))  {
\t\t\t\t\t\t\t\$kern = -\$this->CurrentFont['kerninfo'][\$unicode[(\$ti-1)]][\$unicode[\$ti]];
\t\t\t\t\t\t\t\$tj .= sprintf(')%d(',\$kern);
\t\t\t\t}
\t\t\t\t\$tc = code2utf(\$unicode[\$ti]);
\t\t\t\t\$tc = \$this->UTF8ToUTF16BE(\$tc, false);
\t\t\t\t\$tj .= \$this->_escape(\$tc);
\t\t\t}
\t\t\t\$tj .= ')';
\t\t\t\$s.=sprintf(' %.3F Tc [%s] TJ',\$this->charspacing,\$tj);


\t\t\tif ((\$i+1)<count(\$t)) {
\t\t\t\t\$s.=sprintf(' %.3F Tc (%s) Tj',\$this->ws+\$this->charspacing,\$space);
\t\t\t}
\t\t  }
\t\t  \$s.=' ET ';
   }
   else if (!\$this->usingCoreFont) {
\t\$s = '';
\t\$tj = '(';
\t\$unicode = \$this->UTF8StringToArray(\$txt);
\tfor(\$i=0;\$i<count(\$unicode);\$i++) {
\t\tif (\$i > 0 && isset(\$this->CurrentFont['kerninfo'][\$unicode[(\$i-1)]][\$unicode[\$i]])) {
\t\t\t\t\t\$kern = -\$this->CurrentFont['kerninfo'][\$unicode[(\$i-1)]][\$unicode[\$i]];
\t\t\t\t\t\$tj .= sprintf(')%d(',\$kern);
\t\t}
\t\t\$tx = code2utf(\$unicode[\$i]);
\t\t\$tx = \$this->UTF8ToUTF16BE(\$tx, false);
\t\t\$tj .= \$this->_escape(\$tx);
\t}
\t\$tj .= ')';
\t\$s.=sprintf(' BT '.\$aix.' [%s] TJ ET ',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$tj);
   }
   else {\t// CORE Font
\t\$s = '';
\t\$tj = '(';
\t\$l = strlen(\$txt);
\tfor(\$i=0;\$i<\$l;\$i++) {
\t\tif (\$i > 0 && isset(\$this->CurrentFont['kerninfo'][\$txt[(\$i-1)]][\$txt[\$i]])) {
\t\t\t\$kern = -\$this->CurrentFont['kerninfo'][\$txt[(\$i-1)]][\$txt[\$i]];
\t\t\t\$tj .= sprintf(')%d(',\$kern);
\t\t}
\t\t\$tj .= \$this->_escape(\$txt[\$i]);
\t}
\t\$tj .= ')';
\t\$s.=sprintf(' BT '.\$aix.' [%s] TJ ET ',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$tj);
   }

   return \$s;
}


function _smallCaps(\$txt, \$mode, \$aix, \$dx, \$k, \$baseline, \$va) {
\t\$upp = false;
\t\$str = array();
\t\$bits = array();
\tif (!\$this->usingCoreFont) {
\t   \$unicode = \$this->UTF8StringToArray(\$txt);
\t   foreach(\$unicode as \$char) {
\t\tif (\$this->ws && \$char == 32) { \t// space
\t\t\tif (count(\$str)) { \$bits[] = array(\$upp, \$str, false); }
\t\t\t\$bits[] = array(false, array(32), true);
\t\t\t\$str = array();
\t\t\t\$upp = false;
\t\t}
\t\telse if (isset(\$this->upperCase[\$char])) {
\t\t\tif (!\$upp) {
\t\t\t\tif (count(\$str)) { \$bits[] = array(\$upp, \$str, false); }
\t\t\t\t\$str = array();
\t\t\t}
\t\t\t\$str[] = \$this->upperCase[\$char];
\t\t\tif ((!isset(\$this->CurrentFont['sip']) || !\$this->CurrentFont['sip']) && (!isset(\$this->CurrentFont['smp']) || !\$this->CurrentFont['smp'])) {
\t\t\t\t\$this->CurrentFont['subset'][\$this->upperCase[\$char]] = \$this->upperCase[\$char];
\t\t\t}
\t\t\t\$upp = true;
\t\t}
\t\telse {
\t\t\tif (\$upp) {
\t\t\t\tif (count(\$str)) { \$bits[] = array(\$upp, \$str, false); }
\t\t\t\t\$str = array();
\t\t\t}
\t\t\t\$str[] = \$char;
\t\t\t\$upp = false;
\t\t}
\t   }
\t}
\telse {
\t   for(\$i=0;\$i<strlen(\$txt);\$i++) {
\t\tif (isset(\$this->upperCase[ord(\$txt[\$i])]) && \$this->upperCase[ord(\$txt[\$i])] < 256) {
\t\t\tif (!\$upp) {
\t\t\t\tif (count(\$str)) { \$bits[] = array(\$upp, \$str, false); }
\t\t\t\t\$str = array();
\t\t\t}
\t\t\t\$str[] = \$this->upperCase[ord(\$txt[\$i])];
\t\t\t\$upp = true;
\t\t}
\t\telse {
\t\t\tif (\$upp) {
\t\t\t\tif (count(\$str)) { \$bits[] = array(\$upp, \$str, false); }
\t\t\t\t\$str = array();
\t\t\t}
\t\t\t\$str[] = ord(\$txt[\$i]);
\t\t\t\$upp = false;
\t\t}
\t   }
\t}
\tif (count(\$str)) { \$bits[] = array(\$upp, \$str, false); }

\t\$fid = \$this->CurrentFont['i'];

\t\$s=sprintf(' BT '.\$aix,(\$this->x+\$dx)*\$k,(\$this->h-(\$this->y+\$baseline+\$va))*\$k);
\tforeach(\$bits AS \$b) {
\t\tif (\$b[0]) { \$upp = true; }
\t\telse { \$upp = false; }

\t\t\$size = count (\$b[1]);
\t\t\$txt = '';
\t\tfor (\$i = 0; \$i < \$size; \$i++) {
\t\t\t\$txt .= code2utf(\$b[1][\$i]);
\t\t}
\t\tif (\$this->usingCoreFont) {
\t\t\t\$txt = utf8_decode(\$txt);
\t\t}
\t\tif (\$mode == 'SIPSMP') {
\t\t\t\$txt = \$this->UTF8toSubset(\$txt);
\t\t}
\t\telse {
\t\t\tif (!\$this->usingCoreFont) {
\t\t\t\t\$txt = \$this->UTF8ToUTF16BE(\$txt, false);
\t\t\t}
\t\t\t\$txt=\$this->_escape(\$txt);
\t\t\t\$txt = '('.\$txt.')';
\t\t}
\t\tif (\$b[2]) { // space
\t\t\t\$s.=sprintf(' /F%d %.3F Tf %d Tz', \$fid, \$this->FontSizePt, 100);
\t\t\t\$s.=sprintf(' %.3F Tc', (\$this->charspacing+\$this->ws));
\t\t\t\$s.=sprintf(' %s Tj', \$txt);
\t\t}
\t\telse if (\$upp) {
\t\t\t\$s.=sprintf(' /F%d %.3F Tf', \$fid, \$this->FontSizePt*\$this->smCapsScale);
\t\t\t\$s.=sprintf(' %d Tz', \$this->smCapsStretch);
\t\t\t\$s.=sprintf(' %.3F Tc', (\$this->charspacing*100/\$this->smCapsStretch));
\t\t\t\$s.=sprintf(' %s Tj', \$txt);
\t\t}
\t\telse {
\t\t\t\$s.=sprintf(' /F%d %.3F Tf %d Tz', \$fid, \$this->FontSizePt, 100);
\t\t\t\$s.=sprintf(' %.3F Tc', (\$this->charspacing));
\t\t\t\$s.=sprintf(' %s Tj', \$txt);
\t\t}
\t}
\t\$s.=' ET ';
\treturn \$s;
}


function MultiCell(\$w,\$h,\$txt,\$border=0,\$align='',\$fill=0,\$link='',\$directionality='ltr',\$encoded=false)
{
\t// Parameter (pre-)encoded - When called internally from ToC or textarea: mb_encoding already done - but not reverse RTL/Indic
\tif (!\$encoded) {
\t\t\$txt = \$this->purify_utf8_text(\$txt);
\t\tif (\$this->text_input_as_HTML) {
\t\t\t\$txt = \$this->all_entities_to_utf8(\$txt);
\t\t}
\t\tif (\$this->usingCoreFont) { \$txt = mb_convert_encoding(\$txt,\$this->mb_enc,'UTF-8'); }
\t\t// Font-specific ligature substitution for Indic fonts
\t\telse if (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) {\t// *INDIC*
\t\t\t\$this->ConvertIndic(\$tmp);\t// *INDIC*
\t\t}\t// *INDIC*
\t\tif (preg_match(\"/([\".\$this->pregRTLchars.\"])/u\", \$txt)) { \$this->biDirectional = true; }\t// *RTL*
\t}
\tif (!\$align) { \$align = \$this->defaultAlign; }

\t//Output text with automatic or explicit line breaks
\t\$cw=&\$this->CurrentFont['cw'];
\tif(\$w==0)\t\$w=\$this->w-\$this->rMargin-\$this->x;

\t\$wmax = (\$w - (\$this->cMarginL+\$this->cMarginR));
\tif (\$this->usingCoreFont)  {
\t\t\$s=str_replace(\"\\r\",'',\$txt);
\t\t\$nb=strlen(\$s);
\t\twhile(\$nb>0 and \$s[\$nb-1]==\"\\n\")\t\$nb--;
\t}
\telse {
\t\t\$s=str_replace(\"\\r\",'',\$txt);
\t\t\$nb=mb_strlen(\$s, \$this->mb_enc );
\t\twhile(\$nb>0 and mb_substr(\$s,\$nb-1,1,\$this->mb_enc )==\"\\n\")\t\$nb--;
\t}
\t\$b=0;
\tif(\$border) {
\t\tif(\$border==1) {
\t\t\t\$border='LTRB';
\t\t\t\$b='LRT';
\t\t\t\$b2='LR';
\t\t}
\t\telse {
\t\t\t\$b2='';
\t\t\tif(is_int(strpos(\$border,'L')))\t\$b2.='L';
\t\t\tif(is_int(strpos(\$border,'R')))\t\$b2.='R';
\t\t\t\$b=is_int(strpos(\$border,'T')) ? \$b2.'T' : \$b2;
\t\t}
\t}
\t\$sep=-1;
\t\$i=0;
\t\$j=0;
\t\$l=0;
\t\$ns=0;
\t\$nl=1;



   if (!\$this->usingCoreFont)  {
\t\$checkCursive=false;
\tif (\$this->biDirectional) {  \$checkCursive=true; }
\telse if (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) {  \$checkCursive=true; }\t// *INDIC*
\twhile(\$i<\$nb) {
\t\t//Get next character
\t\t\$c = mb_substr(\$s,\$i,1,\$this->mb_enc );
\t\tif(\$c == \"\\n\") {
\t\t\t//Explicit line break
\t\t\t// WORD SPACING
\t\t\t\$this->ResetSpacing();
\t\t\t\$tmp = rtrim(mb_substr(\$s,\$j,\$i-\$j,\$this->mb_enc));
\t\t\t// DIRECTIONALITY
\t\t\t\$this->magic_reverse_dir(\$tmp, true, \$directionality);\t// *RTL*

\t\t\t\$this->Cell(\$w,\$h,\$tmp,\$b,2,\$align,\$fill,\$link);
\t\t\t\$i++;
\t\t\t\$sep=-1;
\t\t\t\$j=\$i;
\t\t\t\$l=0;
\t\t\t\$ns=0;
\t\t\t\$nl++;
\t\t\tif(\$border and \$nl==2) \$b=\$b2;
\t\t\tcontinue;
\t\t}
\t\tif(\$c == \" \") {
\t\t\t\$sep=\$i;
\t\t\t\$ls=\$l;
\t\t\t\$ns++;
\t\t}

\t\t\$l += \$this->GetCharWidthNonCore(\$c);

\t\tif(\$l>\$wmax) {
\t\t\t//Automatic line break
\t\t\tif(\$sep==-1) {\t// Only one word
\t\t\t\tif(\$i==\$j) \$i++;
\t\t\t\t// WORD SPACING
\t\t\t\t\$this->ResetSpacing();
\t\t\t\t\$tmp = rtrim(mb_substr(\$s,\$j,\$i-\$j,\$this->mb_enc));
\t\t\t\t// DIRECTIONALITY
\t\t\t\t\$this->magic_reverse_dir(\$tmp, true, \$directionality);\t// *RTL*

\t\t\t\t\$this->Cell(\$w,\$h,\$tmp,\$b,2,\$align,\$fill,\$link);
\t\t\t}
\t\t\telse {
\t\t\t\t\$tmp = rtrim(mb_substr(\$s,\$j,\$sep-\$j,\$this->mb_enc));
\t\t\t\tif(\$align=='J') {
\t\t\t\t\t//////////////////////////////////////////
\t\t\t\t\t// JUSTIFY J using Unicode fonts (Word spacing doesn't work)
\t\t\t\t\t// WORD SPACING UNICODE
\t\t\t\t\t// Change NON_BREAKING SPACE to spaces so they are 'spaced' properly
\t\t\t\t\t\$tmp = str_replace(chr(194).chr(160),chr(32),\$tmp );
\t\t\t\t\t\$len_ligne = \$this->GetStringWidth(\$tmp );
\t\t\t\t\t\$nb_carac = mb_strlen( \$tmp , \$this->mb_enc ) ;
\t\t\t\t\t\$nb_spaces = mb_substr_count( \$tmp ,' ', \$this->mb_enc ) ;

\t\t\t\t\t\$inclCursive=false;
\t\t\t\t\tif (\$checkCursive) {
\t\t\t\t\t\tif (preg_match(\"/([\".\$this->pregRTLchars.\"])/u\", \$tmp)) { \$inclCursive = true; }\t// *RTL*
\t\t\t\t\t\tif (preg_match(\"/([\".\$this->pregHIchars.\$this->pregBNchars.\$this->pregPAchars.\"])/u\", \$tmp)) { \$inclCursive = true; }\t// *INDIC*
\t\t\t\t\t}
\t\t\t\t\tlist(\$charspacing,\$ws) = \$this->GetJspacing(\$nb_carac,\$nb_spaces,(((\$wmax) - \$len_ligne) * _MPDFK),\$inclCursive);
\t\t\t\t\t\$this->SetSpacing(\$charspacing,\$ws);
\t\t\t\t\t//////////////////////////////////////////
\t\t\t\t}

\t\t\t\t// DIRECTIONALITY
\t\t\t\t\$this->magic_reverse_dir(\$tmp, true, \$directionality);\t// *RTL*

\t\t\t\t\$this->Cell(\$w,\$h,\$tmp,\$b,2,\$align,\$fill,\$link);
\t\t\t\t\$i=\$sep+1;
\t\t\t}
\t\t\t\$sep=-1;
\t\t\t\$j=\$i;
\t\t\t\$l=0;
\t\t\t\$ns=0;
\t\t\t\$nl++;
\t\t\tif(\$border and \$nl==2) \$b=\$b2;
\t\t}
\t\telse \$i++;
\t}
\t//Last chunk
\t// WORD SPACING

\t\$this->ResetSpacing();

   }


   else {

\twhile(\$i<\$nb) {
\t\t//Get next character
\t\t\$c=\$s[\$i];
\t\tif(\$c == \"\\n\") {
\t\t\t//Explicit line break
\t\t\t// WORD SPACING
\t\t\t\$this->ResetSpacing();
\t\t\t\$this->Cell(\$w,\$h,substr(\$s,\$j,\$i-\$j),\$b,2,\$align,\$fill,\$link);
\t\t\t\$i++;
\t\t\t\$sep=-1;
\t\t\t\$j=\$i;
\t\t\t\$l=0;
\t\t\t\$ns=0;
\t\t\t\$nl++;
\t\t\tif(\$border and \$nl==2) \$b=\$b2;
\t\t\tcontinue;
\t\t}
\t\tif(\$c == \" \") {
\t\t\t\$sep=\$i;
\t\t\t\$ls=\$l;
\t\t\t\$ns++;
\t\t}

\t\t\$l += \$this->GetCharWidthCore(\$c);
\t\tif(\$l>\$wmax) {
\t\t\t//Automatic line break
\t\t\tif(\$sep==-1) {
\t\t\t\tif(\$i==\$j) \$i++;
\t\t\t\t// WORD SPACING
\t\t\t\t\$this->ResetSpacing();
\t\t\t\t\$this->Cell(\$w,\$h,substr(\$s,\$j,\$i-\$j),\$b,2,\$align,\$fill,\$link);
\t\t\t}
\t\t\telse {
\t\t\t\tif(\$align=='J') {
\t\t\t\t\t\$tmp = rtrim(substr(\$s,\$j,\$sep-\$j));
\t\t\t\t\t//////////////////////////////////////////
\t\t\t\t\t// JUSTIFY J using Unicode fonts (Word spacing doesn't work)
\t\t\t\t\t// WORD SPACING NON_UNICDOE/CJK
\t\t\t\t\t// Change NON_BREAKING SPACE to spaces so they are 'spaced' properly
\t\t\t\t\t\$tmp = str_replace(chr(160),chr(32),\$tmp);
\t\t\t\t\t\$len_ligne = \$this->GetStringWidth(\$tmp );
\t\t\t\t\t\$nb_carac = strlen( \$tmp ) ;
\t\t\t\t\t\$nb_spaces = substr_count( \$tmp ,' ' ) ;
\t\t\t\t\tlist(\$charspacing,\$ws) = \$this->GetJspacing(\$nb_carac,\$nb_spaces,(((\$wmax) - \$len_ligne) * _MPDFK),false);
\t\t\t\t\t\$this->SetSpacing(\$charspacing,\$ws);
\t\t\t\t\t//////////////////////////////////////////
\t\t\t\t}
\t\t\t\t\$this->Cell(\$w,\$h,substr(\$s,\$j,\$sep-\$j),\$b,2,\$align,\$fill,\$link);
\t\t\t\t\$i=\$sep+1;
\t\t\t}
\t\t\t\$sep=-1;
\t\t\t\$j=\$i;
\t\t\t\$l=0;
\t\t\t\$ns=0;
\t\t\t\$nl++;
\t\t\tif(\$border and \$nl==2) \$b=\$b2;
\t\t}
\t\telse \$i++;
\t}
\t//Last chunk
\t// WORD SPACING

\t\$this->ResetSpacing();

   }
\t//Last chunk
   if(\$border and is_int(strpos(\$border,'B')))\t\$b.='B';
   if (!\$this->usingCoreFont)  {
\t\t\$tmp = rtrim(mb_substr(\$s,\$j,\$i-\$j,\$this->mb_enc));
\t\t// DIRECTIONALITY
\t\t\$this->magic_reverse_dir(\$tmp, true, \$directionality);\t// *RTL*
   \t\t\$this->Cell(\$w,\$h,\$tmp,\$b,2,\$align,\$fill,\$link);
   }
   else { \$this->Cell(\$w,\$h,substr(\$s,\$j,\$i-\$j),\$b,2,\$align,\$fill,\$link); }
   \$this->x=\$this->lMargin;
}


/*-- DIRECTW --*/
function Write(\$h,\$txt,\$currentx=0,\$link='',\$directionality='ltr',\$align='') {
\tif (!class_exists('directw', false)) { include(_MPDF_PATH.'classes/directw.php'); }
\tif (empty(\$this->directw)) { \$this->directw = new directw(\$this); }
\t\$this->directw->Write(\$h,\$txt,\$currentx,\$link,\$directionality,\$align);
}
/*-- END DIRECTW --*/


/*-- HTML-CSS --*/
function saveInlineProperties() {
\t\$saved = array();
\t\$saved[ 'family' ] = \$this->FontFamily;
\t\$saved[ 'style' ] = \$this->FontStyle;
\t\$saved[ 'sizePt' ] = \$this->FontSizePt;
\t\$saved[ 'size' ] = \$this->FontSize;
\t\$saved[ 'HREF' ] = \$this->HREF;
\t\$saved[ 'underline' ] = \$this->U;
\t\$saved[ 'smCaps' ] = \$this->S;
\t\$saved[ 'strike' ] = \$this->strike;
\t\$saved[ 'textshadow' ] = \$this->textshadow;
\t\$saved[ 'SUP' ] = \$this->SUP;
\t\$saved[ 'SUB' ] = \$this->SUB;
\t\$saved[ 'linewidth' ] = \$this->LineWidth;
\t\$saved[ 'drawcolor' ] = \$this->DrawColor;
\t\$saved[ 'textparam' ] = \$this->textparam;
\t\$saved[ 'toupper' ] = \$this->toupper;
\t\$saved[ 'tolower' ] = \$this->tolower;
\t\$saved[ 'capitalize' ] = \$this->capitalize;
\t\$saved[ 'fontkerning' ] = \$this->kerning;
\t\$saved[ 'lSpacingCSS' ] = \$this->lSpacingCSS;
\t\$saved[ 'wSpacingCSS' ] = \$this->wSpacingCSS;
\t\$saved[ 'I' ] = \$this->I;
\t\$saved[ 'B' ] = \$this->B;
\t\$saved[ 'colorarray' ] = \$this->colorarray;
\t\$saved[ 'bgcolorarray' ] = \$this->spanbgcolorarray;
\t\$saved[ 'border' ] = \$this->spanborddet;
\t\$saved[ 'color' ] = \$this->TextColor;
\t\$saved[ 'bgcolor' ] = \$this->FillColor;
\t\$saved[ 'lang' ] = \$this->currentLang;
\t\$saved[ 'display_off' ] = \$this->inlineDisplayOff;

\treturn \$saved;
}

function restoreInlineProperties( &\$saved) {
\t\$FontFamily = \$saved[ 'family' ];
\t\$this->FontStyle = \$saved[ 'style' ];
\t\$this->FontSizePt = \$saved[ 'sizePt' ];
\t\$this->FontSize = \$saved[ 'size' ];

\t\$this->currentLang =  \$saved['lang'];
\tif (\$this->useLang && !\$this->usingCoreFont) {
\t  if (\$this->currentLang != \$this->default_lang && ((strlen(\$this->currentLang) == 5 && \$this->currentLang != 'UTF-8') || strlen(\$this->currentLang ) == 2)) {
\t\tlist (\$coreSuitable,\$mpdf_pdf_unifonts) = GetLangOpts(\$this->currentLang, \$this->useAdobeCJK);
\t\tif (\$mpdf_pdf_unifonts) { \$this->RestrictUnicodeFonts(\$mpdf_pdf_unifonts); }
\t\telse { \$this->RestrictUnicodeFonts(\$this->default_available_fonts ); }
\t  }
\t  else {
\t\t\$this->RestrictUnicodeFonts(\$this->default_available_fonts );
\t  }
\t}

\t\$this->ColorFlag = (\$this->FillColor != \$this->TextColor); //Restore ColorFlag as well

\t\$this->HREF = \$saved[ 'HREF' ];
\t\$this->U = \$saved[ 'underline' ];
\t\$this->S = \$saved[ 'smCaps' ];
\t\$this->strike = \$saved[ 'strike' ];
\t\$this->textshadow = \$saved[ 'textshadow' ];
\t\$this->SUP = \$saved[ 'SUP' ];
\t\$this->SUB = \$saved[ 'SUB' ];
\t\$this->LineWidth = \$saved[ 'linewidth' ];
\t\$this->DrawColor = \$saved[ 'drawcolor' ];
\t\$this->textparam = \$saved[ 'textparam' ];
\t\$this->inlineDisplayOff = \$saved['display_off'];

\t\$this->toupper = \$saved[ 'toupper' ];
\t\$this->tolower = \$saved[ 'tolower' ];
\t\$this->capitalize = \$saved[ 'capitalize' ];
\t\$this->kerning = \$saved[ 'fontkerning' ];
\t\$this->lSpacingCSS = \$saved[ 'lSpacingCSS' ];
\tif ((\$this->lSpacingCSS || \$this->lSpacingCSS==='0') && strtoupper(\$this->lSpacingCSS) != 'NORMAL') {
\t\t\$this->fixedlSpacing = \$this->ConvertSize(\$this->lSpacingCSS,\$this->FontSize);
\t}
\telse { \$this->fixedlSpacing = false; }
\t\$this->wSpacingCSS = \$saved[ 'wSpacingCSS' ];
\tif (\$this->wSpacingCSS && strtoupper(\$this->wSpacingCSS) != 'NORMAL') {
\t\t\$this->minwSpacing = \$this->ConvertSize(\$this->wSpacingCSS,\$this->FontSize);
\t}
\telse { \$this->minwSpacing = 0; }

\t\$this->SetFont(\$FontFamily, \$saved[ 'style' ].(\$this->U ? 'U' : '').(\$this->S ? 'S' : ''),\$saved[ 'sizePt' ],false);

\t\$this->currentfontstyle = \$saved[ 'style' ].(\$this->U ? 'U' : '').(\$this->S ? 'S' : '');
\t\$this->currentfontsize = \$saved[ 'sizePt' ];
\t\$this->SetStylesArray(array('S'=>\$this->S, 'U'=>\$this->U, 'B'=>\$saved[ 'B' ], 'I'=>\$saved[ 'I' ]));

\t\$this->TextColor = \$saved[ 'color' ];
\t\$this->FillColor = \$saved[ 'bgcolor' ];
\t\$this->colorarray = \$saved[ 'colorarray' ];
\t\$cor = \$saved[ 'colorarray' ];
\tif (\$cor) \$this->SetTColor(\$cor);
\t\$this->spanbgcolorarray = \$saved[ 'bgcolorarray' ];
\t\$cor = \$saved[ 'bgcolorarray' ];
\tif (\$cor) \$this->SetFColor(\$cor);
\t\$this->spanborddet = \$saved[ 'border' ];
}



// Used when ColActive for tables - updated to return first block with background fill OR borders
function GetFirstBlockFill() {
\t// Returns the first blocklevel that uses a bgcolor fill
\t\$startfill = 0;
\tfor (\$i=1;\$i<=\$this->blklvl;\$i++) {
\t\tif (\$this->blk[\$i]['bgcolor'] || \$this->blk[\$i]['border_left']['w'] || \$this->blk[\$i]['border_right']['w']  || \$this->blk[\$i]['border_top']['w']  || \$this->blk[\$i]['border_bottom']['w']  ) {
\t\t\t\$startfill = \$i;
\t\t\tbreak;
\t\t}
\t}
\treturn \$startfill;
}

function SetBlockFill(\$blvl) {
\tif (\$this->blk[\$blvl]['bgcolor']) {
\t\t\$this->SetFColor(\$this->blk[\$blvl]['bgcolorarray']);
\t\treturn 1;
\t}
\telse {
\t\t\$this->SetFColor(\$this->ConvertColor(255));
\t\treturn 0;
\t}
}


//-------------------------FLOWING BLOCK------------------------------------//
//The following functions were originally written by Damon Kohler           //
//--------------------------------------------------------------------------//

function saveFont() {
\t\$saved = array();
\t\$saved[ 'family' ] = \$this->FontFamily;
\t\$saved[ 'style' ] = \$this->FontStyle;
\t\$saved[ 'sizePt' ] = \$this->FontSizePt;
\t\$saved[ 'size' ] = \$this->FontSize;
\t\$saved[ 'curr' ] = &\$this->CurrentFont;
\t\$saved[ 'color' ] = \$this->TextColor;
\t\$saved[ 'spanbgcolor' ] = \$this->spanbgcolor;
\t\$saved[ 'spanbgcolorarray' ] = \$this->spanbgcolorarray;
\t\$saved[ 'bord' ] = \$this->spanborder;
\t\$saved[ 'border' ] = \$this->spanborddet;
\t\$saved[ 'HREF' ] = \$this->HREF;
\t\$saved[ 'underline' ] = \$this->U;
\t\$saved[ 'smCaps' ] = \$this->S;
\t\$saved[ 'strike' ] = \$this->strike;
\t\$saved[ 'textshadow' ] = \$this->textshadow;
\t\$saved[ 'SUP' ] = \$this->SUP;
\t\$saved[ 'SUB' ] = \$this->SUB;
\t\$saved[ 'linewidth' ] = \$this->LineWidth;
\t\$saved[ 'drawcolor' ] = \$this->DrawColor;
\t\$saved[ 'textparam' ] = \$this->textparam;
\t\$saved[ 'ReqFontStyle' ] = \$this->ReqFontStyle;
\t\$saved[ 'fontkerning' ] = \$this->kerning;
\t\$saved[ 'fixedlSpacing' ] = \$this->fixedlSpacing;
\t\$saved[ 'minwSpacing' ] = \$this->minwSpacing;
\treturn \$saved;
}

function restoreFont( &\$saved, \$write=true) {
\tif (!isset(\$saved) || empty(\$saved)) return;

\t\$this->FontFamily = \$saved[ 'family' ];
\t\$this->FontStyle = \$saved[ 'style' ];
\t\$this->FontSizePt = \$saved[ 'sizePt' ];
\t\$this->FontSize = \$saved[ 'size' ];
\t\$this->CurrentFont = &\$saved[ 'curr' ];
\t\$this->TextColor = \$saved[ 'color' ];
\t\$this->spanbgcolor = \$saved[ 'spanbgcolor' ];
\t\$this->spanbgcolorarray = \$saved[ 'spanbgcolorarray' ];
\t\$this->spanborder = \$saved[ 'bord' ];
\t\$this->spanborddet = \$saved[ 'border' ];
\t\$this->ColorFlag = (\$this->FillColor != \$this->TextColor); //Restore ColorFlag as well
\t\$this->HREF = \$saved[ 'HREF' ];
\t\$this->U = \$saved[ 'underline' ];
\t\$this->S = \$saved[ 'smCaps' ];
\t\$this->kerning = \$saved[ 'fontkerning' ];
\t\$this->fixedlSpacing = \$saved[ 'fixedlSpacing' ];
\t\$this->minwSpacing = \$saved[ 'minwSpacing' ];
\t\$this->strike = \$saved[ 'strike' ];
\t\$this->textshadow = \$saved[ 'textshadow' ];
\t\$this->SUP = \$saved[ 'SUP' ];
\t\$this->SUB = \$saved[ 'SUB' ];
\t\$this->LineWidth = \$saved[ 'linewidth' ];
\t\$this->DrawColor = \$saved[ 'drawcolor' ];
\t\$this->textparam = \$saved[ 'textparam' ];
\tif (\$write) {
\t\t\$this->SetFont(\$saved[ 'family' ],\$saved[ 'style' ].(\$this->U ? 'U' : '').(\$this->S ? 'S' : ''),\$saved[ 'sizePt' ],true,true);\t// force output
\t\t\$fontout = (sprintf('BT /F%d %.3F Tf ET', \$this->CurrentFont['i'], \$this->FontSizePt));
\t\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['Font']) && \$this->pageoutput[\$this->page]['Font'] != \$fontout) || !isset(\$this->pageoutput[\$this->page]['Font']) || \$this->keep_block_together)) { \$this->_out(\$fontout); }
\t\t\$this->pageoutput[\$this->page]['Font'] = \$fontout;
\t}
\telse
\t\t\$this->SetFont(\$saved[ 'family' ],\$saved[ 'style' ].(\$this->U ? 'U' : '').(\$this->S ? 'S' : ''),\$saved[ 'sizePt' ]);
\t\$this->ReqFontStyle = \$saved[ 'ReqFontStyle' ];
}

function newFlowingBlock( \$w, \$h, \$a = '', \$is_table = false, \$is_list = false, \$blockstate = 0, \$newblock=true, \$blockdir='ltr')
{
\tif (!\$a) {
\t\tif (\$blockdir=='rtl') { \$a = 'R'; }
\t\telse { \$a = 'L'; }
\t}
\t\$this->flowingBlockAttr[ 'width' ] = (\$w * _MPDFK);
\t// line height in user units
\t\$this->flowingBlockAttr[ 'is_table' ] = \$is_table;
\t\$this->flowingBlockAttr[ 'is_list' ] = \$is_list;
\t\$this->flowingBlockAttr[ 'height' ] = \$h;
\t\$this->flowingBlockAttr[ 'lineCount' ] = 0;
\t\$this->flowingBlockAttr[ 'align' ] = \$a;
\t\$this->flowingBlockAttr[ 'font' ] = array();
\t\$this->flowingBlockAttr[ 'content' ] = array();
\t\$this->flowingBlockAttr[ 'contentB' ] = array();
\t\$this->flowingBlockAttr[ 'contentWidth' ] = 0;
\t\$this->flowingBlockAttr[ 'blockstate' ] = \$blockstate;

\t\$this->flowingBlockAttr[ 'newblock' ] = \$newblock;
\t\$this->flowingBlockAttr[ 'valign' ] = 'M';
\t\$this->flowingBlockAttr['blockdir'] = \$blockdir;

}

function finishFlowingBlock(\$endofblock=false, \$next='') {
\t\$currentx = \$this->x;
\t//prints out the last chunk
\t\$is_table = \$this->flowingBlockAttr[ 'is_table' ];
\t\$is_list = \$this->flowingBlockAttr[ 'is_list' ];
\t\$maxWidth =& \$this->flowingBlockAttr[ 'width' ];
\t\$lineHeight =& \$this->flowingBlockAttr[ 'height' ];
\t\$align =& \$this->flowingBlockAttr[ 'align' ];
\t\$content =& \$this->flowingBlockAttr[ 'content' ];
\t\$contentB =& \$this->flowingBlockAttr[ 'contentB' ];
\t\$font =& \$this->flowingBlockAttr[ 'font' ];
\t\$contentWidth =& \$this->flowingBlockAttr[ 'contentWidth' ];
\t\$lineCount =& \$this->flowingBlockAttr[ 'lineCount' ];
\t\$valign =& \$this->flowingBlockAttr[ 'valign' ];
\t\$blockstate = \$this->flowingBlockAttr[ 'blockstate' ];

\t\$newblock = \$this->flowingBlockAttr[ 'newblock' ];
\t\$blockdir = \$this->flowingBlockAttr['blockdir'];


\t// *********** BLOCK BACKGROUND COLOR *****************//
\tif (\$this->blk[\$this->blklvl]['bgcolor'] && !\$is_table) {
\t\t\$fill = 0;
\t}
\telse {
\t\t\$this->SetFColor(\$this->ConvertColor(255));
\t\t\$fill = 0;
\t}

\t\$hanger = '';\t// mPDF 5.6.40

\t// Always right trim!
\t// Right trim content and adjust width if need to justify (later)
\t\tif (isset(\$content[count(\$content)-1]) && preg_match('/[ ]+\$/',\$content[count(\$content)-1], \$m)) {
\t\t\t\$strip = strlen(\$m[0]);
\t\t\t\$content[count(\$content)-1] = substr(\$content[count(\$content)-1],0,(strlen(\$content[count(\$content)-1])-\$strip));
\t\t\t\$this->restoreFont( \$font[ count(\$content)-1 ],false );
\t\t\t\$contentWidth -= \$this->GetStringWidth(\$m[0]) * _MPDFK;
\t\t}

\t// the amount of space taken up so far in user units
\t\$usedWidth = 0;

\t// COLS
\t\$oldcolumn = \$this->CurrCol;

\tif (\$this->ColActive && !\$is_table) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*

\t// Print out each chunk

/*-- TABLES --*/
\tif (\$is_table) {
\t\t\$ipaddingL = 0;
\t\t\$ipaddingR = 0;
\t\t\$paddingL = 0;
\t\t\$paddingR = 0;
\t}
\telse {
/*-- END TABLES --*/
\t\t\$ipaddingL = \$this->blk[\$this->blklvl]['padding_left'];
\t\t\$ipaddingR = \$this->blk[\$this->blklvl]['padding_right'];
\t\t\$paddingL = (\$ipaddingL * _MPDFK);
\t\t\$paddingR = (\$ipaddingR * _MPDFK);
\t\t\$this->cMarginL =  \$this->blk[\$this->blklvl]['border_left']['w'];
\t\t\$this->cMarginR =  \$this->blk[\$this->blklvl]['border_right']['w'];

\t\t// Added mPDF 3.0 Float DIV
\t\t\$fpaddingR = 0;
\t\t\$fpaddingL = 0;
/*-- CSS-FLOAT --*/
\t\tif (count(\$this->floatDivs)) {
\t\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl);
\t\t\tif (\$r_exists) { \$fpaddingR = \$r_width; }
\t\t\tif (\$l_exists) { \$fpaddingL = \$l_width; }
\t\t}
/*-- END CSS-FLOAT --*/

\t\t\$usey = \$this->y + 0.002;
\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$lineCount == 0) ) {
\t\t\t\$usey += \$this->blk[\$this->blklvl]['margin_top'] + \$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w'];
\t\t}
/*-- CSS-IMAGE-FLOAT --*/
\t\t// If float exists at this level
\t\tif (isset(\$this->floatmargins['R']) && \$usey <= \$this->floatmargins['R']['y1'] && \$usey >= \$this->floatmargins['R']['y0'] && !\$this->floatmargins['R']['skipline']) { \$fpaddingR += \$this->floatmargins['R']['w']; }
\t\tif (isset(\$this->floatmargins['L']) && \$usey <= \$this->floatmargins['L']['y1'] && \$usey >= \$this->floatmargins['L']['y0'] && !\$this->floatmargins['L']['skipline']) { \$fpaddingL += \$this->floatmargins['L']['w']; }
/*-- END CSS-IMAGE-FLOAT --*/
\t}\t// *TABLES*

\t\t// Set Current lineheight (correction factor)
\t\t\$lhfixed = false;
/*-- LISTS --*/
\t\tif (\$is_list) {
\t\t\tif (preg_match('/([0-9.,]+)mm/',\$this->list_lineheight[\$this->listlvl][\$this->listOcc],\$am)) {
\t\t\t\t\$lhfixed = true;
\t\t\t\t\$def_fontsize = \$this->InlineProperties['LISTITEM'][\$this->listlvl][\$this->listOcc][\$this->listnum]['size'];
\t\t\t\t\$this->lineheight_correction = \$am[1] / \$def_fontsize ;
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->lineheight_correction = \$this->list_lineheight[\$this->listlvl][\$this->listOcc];
\t\t\t}
\t\t}
\t\telse
/*-- END LISTS --*/
/*-- TABLES --*/
\t\tif (\$is_table) {
\t\t\tif (preg_match('/([0-9.,]+)mm/',\$this->table_lineheight,\$am)) {
\t\t\t\t\$lhfixed = true;
\t\t\t\t\$def_fontsize = \$this->FontSize; \t\t\t\t// needs to be default font-size for block ****
\t\t\t\t\$this->lineheight_correction = \$lineHeight / \$def_fontsize ;
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->lineheight_correction = \$this->table_lineheight;
\t\t\t}
\t\t}
\t\telse
/*-- END TABLES --*/
\t\tif (isset(\$this->blk[\$this->blklvl]['line_height']) && \$this->blk[\$this->blklvl]['line_height']) {
\t\t\tif (preg_match('/([0-9.,]+)mm/',\$this->blk[\$this->blklvl]['line_height'],\$am)) {
\t\t\t\t\$lhfixed = true;
\t\t\t\t\$def_fontsize = \$this->blk[\$this->blklvl]['InlineProperties']['size']; \t// needs to be default font-size for block ****
\t\t\t\t\$this->lineheight_correction = \$am[1] / \$def_fontsize ;
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->lineheight_correction = \$this->blk[\$this->blklvl]['line_height'];
\t\t\t}
\t\t}
\t\telse {
\t\t\t\$this->lineheight_correction = \$this->normalLineheight;
\t\t}

\t\t//  correct lineheight to maximum fontsize
\t\tif (\$lhfixed) { \$maxlineHeight = \$this->lineheight; }
\t\telse { \$maxlineHeight = 0; }
\t\t\$this->forceExactLineheight = true;
\t\t\$maxfontsize = 0;
\t\t// While we're at it, check if contains cursive text
\t\t\$checkCursive=false;
\t\tif (\$this->biDirectional) {  \$checkCursive=true; }\t// *RTL*
\t\tforeach ( \$content as \$k => \$chunk )
\t\t{
\t\t  \$this->restoreFont( \$font[ \$k ],false );
\t\t  if (!isset(\$this->objectbuffer[\$k])) {
\t\t\t// Soft Hyphens chr(173)
\t\t\tif (!\$this->usingCoreFont) {
\t\t\t      \$content[\$k] = \$chunk = str_replace(\"\\xc2\\xad\",'',\$chunk );
\t\t\t\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) {  \$checkCursive=true; }\t// *INDIC*
\t\t\t}
\t\t\telse if (\$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats') {
\t\t\t      \$content[\$k] = \$chunk = str_replace(chr(173),'',\$chunk );
\t\t\t}
\t\t\t// Special case of sub/sup carried over on its own to last line
\t\t\tif ((\$this->SUB || \$this->SUP) && count(\$content)==1) { \$actfs = \$this->FontSize*100/55; } // 55% is font change for sub/sup
\t\t\telse { \$actfs = \$this->FontSize; }
\t\t\tif (!\$lhfixed) { \$maxlineHeight = max(\$maxlineHeight,\$actfs * \$this->lineheight_correction ); }
\t\t\tif (\$lhfixed && (\$actfs > \$def_fontsize || (\$actfs > (\$lineHeight * \$this->lineheight_correction) && \$is_list))) {
\t\t\t\t\$this->forceExactLineheight = false;
\t\t\t}
\t\t\t\$maxfontsize = max(\$maxfontsize,\$actfs);
\t\t  }
\t\t}

\t\tif(isset(\$font[count(\$font)-1])) {
\t\t\t\$lastfontreqstyle = \$font[count(\$font)-1]['ReqFontStyle'];
\t\t\t\$lastfontstyle = \$font[count(\$font)-1]['style'];
\t\t}
\t\telse {
\t\t\t\$lastfontreqstyle=null;
\t\t\t\$lastfontstyle=null;
\t\t}
\t\tif (\$blockdir == 'ltr' && strpos(\$lastfontreqstyle,\"I\") !== false && strpos(\$lastfontstyle,\"I\") === false) {\t// Artificial italic
\t\t\t\$lastitalic = \$this->FontSize*0.15*_MPDFK;
\t\t}
\t\telse { \$lastitalic = 0; }


/*-- LISTS --*/
\t\tif (\$is_list && is_array(\$this->bulletarray) && count(\$this->bulletarray)) {
\t  \t\t\$actfs = \$this->bulletarray['fontsize'];
\t\t\tif (!\$lhfixed) { \$maxlineHeight = max(\$maxlineHeight,\$actfs * \$this->lineheight_correction );  }
\t\t\tif (\$lhfixed && \$actfs > \$def_fontsize) { \$this->forceExactLineheight = false; }
\t\t\t\$maxfontsize = max(\$maxfontsize,\$actfs);
\t\t}
/*-- END LISTS --*/

\t\t// when every text item checked i.e. \$maxfontsize is set properly

\t\t\$af = 0; \t// Above font
\t\t\$bf = 0; \t// Below font
\t\t\$mta = 0;\t// Maximum top-aligned
\t\t\$mba = 0;\t// Maximum bottom-aligned

\t\tforeach ( \$content as \$k => \$chunk )
\t\t{
\t\t  if (isset(\$this->objectbuffer[\$k])) {
\t\t\t\$oh = \$this->objectbuffer[\$k]['OUTER-HEIGHT'];
\t\t\t\$va = \$this->objectbuffer[\$k]['vertical-align']; // = \$objattr['vertical-align'] = set as M,T,B,S
\t\t\tif (\$lhfixed && \$oh > \$def_fontsize) { \$this->forceExactLineheight = false; }

\t\t\tif (\$va == 'BS') {\t//  (BASELINE default)
\t\t\t\t\$af = max(\$af, (\$oh - (\$maxfontsize * (0.5 + \$this->baselineC))));
\t\t\t}
\t\t\telse if (\$va == 'M') {
\t\t\t\t\$af = max(\$af, (\$oh - \$maxfontsize)/2);
\t\t\t\t\$bf = max(\$bf, (\$oh - \$maxfontsize)/2);
\t\t\t}
\t\t\telse if (\$va == 'TT') {
\t\t\t\t\$bf = max(\$bf, (\$oh - \$maxfontsize));
\t\t\t}
\t\t\telse if (\$va == 'TB') {
\t\t\t\t\$af = max(\$af, (\$oh - \$maxfontsize));
\t\t\t}
\t\t\telse if (\$va == 'T') {
\t\t\t\t\$mta = max(\$mta, \$oh);
\t\t\t}
\t\t\telse if (\$va == 'B') {
\t\t\t\t\$mba = max(\$mba, \$oh);
\t\t\t}
\t\t  }
\t\t  // mPDF 5.7.3  inline text-decoration parameters
\t\t  else if (!\$is_table && isset(\$font[\$k]['textparam']['text-baseline'])) {
\t\t\tif (\$font[\$k]['textparam']['text-baseline'] > 0) { \t// superscript
\t\t\t\t\$nh = (\$maxfontsize * \$this->baselineC) + \$font[\$k]['textparam']['text-baseline'] + (\$font[\$k]['size'] * (1-\$this->baselineC));
\t\t\t\tif (\$lhfixed && \$nh > \$def_fontsize) { \$this->forceExactLineheight = false; }
\t\t\t\t\$af = max(\$af, (\$nh-\$maxfontsize));
\t\t\t}
\t\t\telse if (\$font[\$k]['textparam']['text-baseline'] < 0) {\t// subscript
\t\t\t\t\$nh = (\$maxfontsize * (1-\$this->baselineC)) - \$font[\$k]['textparam']['text-baseline'] + (\$font[\$k]['size'] * \$this->baselineC);
\t\t\t\tif (\$lhfixed && \$nh > \$def_fontsize) { \$this->forceExactLineheight = false; }
\t\t\t\t\$bf = max(\$bf, (\$nh-\$maxfontsize));
\t\t\t}
\t\t  }
\t\t}
\t\tif ((!\$lhfixed || !\$this->forceExactLineheight) && (\$af > ((\$maxlineHeight - \$maxfontsize)/2) || \$bf > ((\$maxlineHeight - \$maxfontsize)/2))) {
\t\t\t\$maxlineHeight = \$maxfontsize + \$af + \$bf;
\t\t}
\t\telse if (!\$lhfixed) { \$af = \$bf = (\$maxlineHeight - \$maxfontsize)/2; }
\t\tif (\$mta > \$maxlineHeight) {
\t\t\t\$bf += (\$mta - \$maxlineHeight);
\t\t\t\$maxlineHeight = \$mta;
\t\t}
\t\tif (\$mba > \$maxlineHeight) {
\t\t\t\$af += (\$mba - \$maxlineHeight);
\t\t\t\$maxlineHeight = \$mba;
\t\t}

\t\t\$lineHeight = \$maxlineHeight;
\t\t// If NOT images, and maxfontsize NOT > lineHeight - this value determines text baseline positioning
\t\tif (\$lhfixed && \$af==0 && \$bf==0 && \$maxfontsize<=(\$def_fontsize * \$this->lineheight_correction * 0.8 )) {
\t\t\t\$this->linemaxfontsize = \$def_fontsize;
\t\t}
\t\telse { \$this->linemaxfontsize = \$maxfontsize; }

\t\t// Get PAGEBREAK TO TEST for height including the bottom border/padding
\t\t\$check_h = max(\$this->divheight,\$lineHeight);

\t\t// This fixes a proven bug...
\t\tif (\$endofblock && \$newblock && \$blockstate==0 && !\$content) {  \$check_h = 0; }
\t\t// but ? needs to fix potentially more widespread...
\t//\tif (!\$content) {  \$check_h = 0; }

\t\tif (\$this->blklvl > 0 && !\$is_table) {
\t\t   if (\$endofblock && \$blockstate > 1) {
\t\t\tif (\$this->blk[\$this->blklvl]['page_break_after_avoid']) {  \$check_h += \$lineHeight; }
\t\t\t\$check_h += (\$this->blk[\$this->blklvl]['padding_bottom'] + \$this->blk[\$this->blklvl]['border_bottom']['w']);
\t\t   }
\t\t   //\tmPDF 5.4.03
\t\t   if ((\$newblock && (\$blockstate==1 || \$blockstate==3) && \$lineCount == 0) || (\$endofblock && \$blockstate ==3 && \$lineCount == 0)) {
\t\t\t\$check_h += (\$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['margin_top'] + \$this->blk[\$this->blklvl]['border_top']['w']);
\t\t   }
\t\t}

\t\t// Force PAGE break if column height cannot take check-height
\t\tif (\$this->ColActive && \$check_h > (\$this->PageBreakTrigger - \$this->y0)) {
\t\t\t\$this->SetCol(\$this->NbCol-1);
\t\t}

\t\t//\tmPDF 5.4.04
\t\t// Avoid just border/background-color moved on to next page
\t\tif (\$endofblock && \$blockstate > 1 && !\$content) { \$buff = \$this->margBuffer; }
\t\telse { \$buff = 0; }


\t\t// PAGEBREAK
\t\t// mPDF 5.4.04
\t\tif(!\$is_table && (\$this->y+\$check_h) > (\$this->PageBreakTrigger + \$buff) and !\$this->InFooter and \$this->AcceptPageBreak()) {
  \t     \t\t\$bak_x=\$this->x;//Current X position
\t\t\t// WORD SPACING
\t\t\t\$ws=\$this->ws;//Word Spacing
\t\t\t\$charspacing=\$this->charspacing;//Character Spacing
\t\t\t\$this->ResetSpacing();

\t\t      \$this->AddPage(\$this->CurOrientation);

\t\t      \$this->x=\$bak_x;
\t\t\t// Added to correct for OddEven Margins
\t\t\t\$currentx += \$this->MarginCorrection;
\t\t\t\$this->x += \$this->MarginCorrection;

\t\t\t// WORD SPACING
\t\t\t\$this->SetSpacing(\$charspacing,\$ws);
\t\t}

\t\tif (\$this->keep_block_together && !\$is_table && \$this->kt_p00 < \$this->page && (\$this->y+\$check_h) > \$this->kt_y00) {
\t\t\t\$this->printdivbuffer();
\t\t\t\$this->keep_block_together = 0;
\t\t}

/*-- COLUMNS --*/
\t\t// COLS
\t\t// COLUMN CHANGE
\t\tif (\$this->CurrCol != \$oldcolumn) {
\t\t\t\$currentx += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t\t\$this->x += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t\t\$oldcolumn = \$this->CurrCol;
\t\t}


\t\tif (\$this->ColActive && !\$is_table) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }
/*-- END COLUMNS --*/

\t\t// TOP MARGIN
\t\tif (\$newblock && (\$blockstate==1 || \$blockstate==3) && (\$this->blk[\$this->blklvl]['margin_top']) && \$lineCount == 0 && !\$is_table && !\$is_list) {
\t\t\t\$this->DivLn(\$this->blk[\$this->blklvl]['margin_top'],\$this->blklvl-1,true,\$this->blk[\$this->blklvl]['margin_collapse']);
\t\t\tif (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
\t\t}

\t\tif (\$newblock && (\$blockstate==1 || \$blockstate==3) && \$lineCount == 0 && !\$is_table && !\$is_list) {
\t\t\t\$this->blk[\$this->blklvl]['y0'] = \$this->y;
\t\t\t\$this->blk[\$this->blklvl]['startpage'] = \$this->page;
\t\t\tif (\$this->blk[\$this->blklvl]['float']) { \$this->blk[\$this->blklvl]['float_start_y'] = \$this->y; } // mPDF 5.6.63
\t\t\tif (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
\t\t}

\t// ADDED for Paragraph_indent
\t\$WidthCorrection = 0;
\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && isset(\$this->blk[\$this->blklvl]['text_indent']) && (\$lineCount == 0) && (!\$is_table) && (!\$is_list) && (\$align != 'C')) {
\t\t\$ti = \$this->ConvertSize(\$this->blk[\$this->blklvl]['text_indent'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t\$WidthCorrection = (\$ti*_MPDFK);
\t}


\t// PADDING and BORDER spacing/fill
\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && ((\$this->blk[\$this->blklvl]['padding_top']) || (\$this->blk[\$this->blklvl]['border_top'])) && (\$lineCount == 0) && (!\$is_table) && (!\$is_list)) {
\t\t\t// \$state = 0 normal; 1 top; 2 bottom; 3 top and bottom
\t\t\t\$this->DivLn(\$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w'],-3,true,false,1);
\t\t\tif (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
\t\t\t\$this->x = \$currentx;
\t}


\t// Added mPDF 3.0 Float DIV
\t\$fpaddingR = 0;
\t\$fpaddingL = 0;
/*-- CSS-FLOAT --*/
\tif (count(\$this->floatDivs)) {
\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl);
\t\tif (\$r_exists) { \$fpaddingR = \$r_width; }
\t\tif (\$l_exists) { \$fpaddingL = \$l_width; }
\t}
/*-- END CSS-FLOAT --*/

\t\$usey = \$this->y + 0.002;
\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$lineCount == 0) ) {
\t\t\$usey += \$this->blk[\$this->blklvl]['margin_top'] + \$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w'];
\t}
/*-- CSS-IMAGE-FLOAT --*/
\t// If float exists at this level
\tif (isset(\$this->floatmargins['R']) && \$usey <= \$this->floatmargins['R']['y1'] && \$usey >= \$this->floatmargins['R']['y0'] && !\$this->floatmargins['R']['skipline']) { \$fpaddingR += \$this->floatmargins['R']['w']; }
\tif (isset(\$this->floatmargins['L']) && \$usey <= \$this->floatmargins['L']['y1'] && \$usey >= \$this->floatmargins['L']['y0'] && !\$this->floatmargins['L']['skipline']) { \$fpaddingL += \$this->floatmargins['L']['w']; }
/*-- END CSS-IMAGE-FLOAT --*/

\tif (\$content) {

\t\t// In FinishFlowing Block no lines are justified as it is always last line
\t\t// but if CJKorphan has allowed content width to go over max width, use J charspacing to compress line
\t\t// JUSTIFICATION J - NOT!
\t\t\$nb_carac = 0;
\t\t\$nb_spaces = 0;
\t\t\$jcharspacing = 0;
\t\t\$jws = 0;
\t\t\$inclCursive=false;
\t\t\$dottab = false; // mPDF 5.6.19
\t\tforeach ( \$content as \$k => \$chunk ) {
\t\t\tif (!isset(\$this->objectbuffer[\$k]) || (isset(\$this->objectbuffer[\$k]) && !\$this->objectbuffer[\$k])) {
\t\t\t\tif (\$this->usingCoreFont) {
\t\t\t\t      \$chunk = str_replace(chr(160),chr(32),\$chunk );
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t      \$chunk = str_replace(chr(194).chr(160),chr(32),\$chunk );
\t\t\t\t}
\t\t\t\t\$nb_carac += mb_strlen( \$chunk, \$this->mb_enc );
\t\t\t\t\$nb_spaces += mb_substr_count( \$chunk,' ', \$this->mb_enc );
\t\t\t\tif (\$checkCursive) {
\t\t\t\t\tif (preg_match(\"/([\".\$this->pregRTLchars.\"])/u\", \$chunk)) { \$inclCursive = true; }\t// *RTL*
\t\t\t\t\tif (preg_match(\"/([\".\$this->pregHIchars.\$this->pregBNchars.\$this->pregPAchars.\"])/u\", \$chunk)) { \$inclCursive = true; }\t// *INDIC*
\t\t\t\t}
\t\t\t}
\t\t\telse if (\$this->objectbuffer[\$k]['type']=='dottab') { \$dottab = \$this->objectbuffer[\$k]['outdent']; } // mPDF 5.6.19
\t\t}
\t\t// if it's justified, we need to find the char/word spacing (or if orphans have allowed length of line to go over the maxwidth)
\t\t// If \"orphans\" in fact is just a final space - ignore this
\t\t// mPDF 5.6.40
\t\t\$lastchar = mb_substr(\$content[(count(\$content)-1)],mb_strlen(\$content[(count(\$content)-1)], \$this->mb_enc)-1, 1, \$this->mb_enc);
\t\tif (preg_match(\"/[\".\$this->CJKoverflow.\"]/u\", \$lastchar)) { \$CJKoverflow = true; }
\t\telse {\$CJKoverflow = false; }
\t\tif (((((\$contentWidth + \$lastitalic) > \$maxWidth) && (\$content[count(\$content)-1] != ' ') )  ||
\t\t\t(!\$endofblock && \$align=='J' && (\$next=='image' || \$next=='select' || \$next=='input' || \$next=='textarea' || (\$next=='br' && \$this->justifyB4br))))  && !(\$CJKoverflow && \$this->allowCJKoverflow) ) {\t// mPDF 5.6.40
 \t\t  // WORD SPACING
\t\t\tlist(\$jcharspacing,\$jws) = \$this->GetJspacing(\$nb_carac,\$nb_spaces,(\$maxWidth-\$lastitalic-\$contentWidth-\$WidthCorrection-((\$this->cMarginL+\$this->cMarginR)*_MPDFK)-(\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) )),\$inclCursive);
\t\t}
/*-- CJK-FONTS --*/
\t\t// mPDF 5.6.40
\t\telse if (\$this->checkCJK && \$align=='J' && \$CJKoverflow && \$this->allowCJKoverflow && \$this->CJKforceend) {
\t\t// force-end overhang
\t\t\t\$hanger = mb_substr(\$content[count(\$content)-1],mb_strlen(\$content[count(\$content)-1],\$this->mb_enc)-1,1,\$this->mb_enc );
\t\t\tif (preg_match(\"/[\".\$this->CJKoverflow.\"]/u\", \$hanger)) {
\t\t\t\t\$content[count(\$content)-1] = mb_substr(\$content[count(\$content)-1],0,mb_strlen(\$content[count(\$content)-1],\$this->mb_enc)-1,\$this->mb_enc );
\t\t\t\t\$this->restoreFont( \$font[ count(\$content)-1 ],false );
\t\t\t\t\$contentWidth -= \$this->GetStringWidth(\$hanger) * _MPDFK;
\t\t\t\t\$nb_carac -= 1;
\t\t\t\tlist(\$jcharspacing,\$jws) = \$this->GetJspacing(\$nb_carac,\$nb_spaces,(\$maxWidth-\$lastitalic-\$contentWidth-\$WidthCorrection-((\$this->cMarginL+\$this->cMarginR)*_MPDFK)-(\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) )),\$inclCursive);
\t\t\t}
\t\t}
/*-- END CJK-FONTS --*/

\t\t// Check if will fit at word/char spacing of previous line - if so continue it
\t\t// but only allow a maximum of \$this->jSmaxWordLast and \$this->jSmaxCharLast
\t\telse if (\$contentWidth < (\$maxWidth - \$lastitalic-\$WidthCorrection - ((\$this->cMarginL+\$this->cMarginR)* _MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK))) && !\$this->fixedlSpacing) {
\t\t\tif (\$this->ws > \$this->jSmaxWordLast) {
\t\t\t\t\$jws = \$this->jSmaxWordLast;
\t\t\t}
\t\t\tif (\$this->charspacing > \$this->jSmaxCharLast) {
\t\t\t\t\$jcharspacing = \$this->jSmaxCharLast;
\t\t\t}
\t\t\t\$check = \$maxWidth - \$lastitalic-\$WidthCorrection - \$contentWidth - ((\$this->cMarginL+\$this->cMarginR)* _MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) ) - ( \$jcharspacing * \$nb_carac) - ( \$jws * \$nb_spaces);
\t\t\tif (\$check <= 0) {
\t\t\t\t\$jcharspacing = 0;
\t\t\t\t\$jws = 0;
\t\t\t}
\t\t}

\t\t\$empty = \$maxWidth - \$lastitalic-\$WidthCorrection - \$contentWidth - ((\$this->cMarginL+\$this->cMarginR)* _MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) );

\t\t\$empty -= (\$jcharspacing * \$nb_carac);
\t\t\$empty -= (\$jws * \$nb_spaces);

\t\t\$empty /= _MPDFK;

\t\tif (!\$is_table) {
\t\t\t\$this->maxPosR = max(\$this->maxPosR , (\$this->w - \$this->rMargin - \$this->blk[\$this->blklvl]['outer_right_margin'] - \$empty));
\t\t\t\$this->maxPosL = min(\$this->maxPosL , (\$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'] + \$empty));
\t\t}

\t\t\$arraysize = count(\$content);

\t\t\$margins = (\$this->cMarginL+\$this->cMarginR) + (\$ipaddingL+\$ipaddingR + \$fpaddingR + \$fpaddingR );

\t\tif (!\$is_table) { \$this->DivLn(\$lineHeight,\$this->blklvl,false); }\t// false -> don't advance y

\t\t// DIRECTIONALITY RTL
\t\t\$all_rtl = false;
\t\t\$contains_rtl = false;
/*-- RTL --*/
   \t\tif (\$blockdir == 'rtl' || \$this->biDirectional)  {
\t\t\t\$all_rtl = true;
\t\t\tforeach ( \$content as \$k => \$chunk ) {
\t\t\t\t\$reversed = \$this->magic_reverse_dir(\$chunk, false, \$blockdir);
\t\t\t\tif (\$reversed > 0) { \$contains_rtl = true; }
\t\t\t\tif (\$reversed < 2) { \$all_rtl = false; }
\t\t\t\t\$content[\$k] = \$chunk;
\t\t\t}
\t\t\tif ((\$blockdir =='rtl' && \$contains_rtl) || \$all_rtl) {
\t\t\t\t\$content = array_reverse(\$content,false);
\t\t\t\t\$contentB = array_reverse(\$contentB,false);
\t\t\t}
\t\t}
/*-- END RTL --*/

\t\t\$this->x = \$currentx + \$this->cMarginL + \$ipaddingL + \$fpaddingL;
\t\tif (\$dottab !== false && \$blockdir=='rtl') { \$this->x -= \$dottab; } // mPDF 5.6.19
\t\telse if (\$align == 'R') { \$this->x += \$empty; }
\t\telse if (\$align == 'J' && \$blockdir == 'rtl') { \$this->x += \$empty; }
\t\telse if (\$align == 'C') { \$this->x += (\$empty / 2); }

\t\t// Paragraph INDENT
\t\t\$WidthCorrection = 0;
\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && isset(\$this->blk[\$this->blklvl]['text_indent']) && (\$lineCount == 0) && (!\$is_table) && (!\$is_list) && (\$align !='C')) {
\t\t\t\$ti = \$this->ConvertSize(\$this->blk[\$this->blklvl]['text_indent'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t\t\$this->x += \$ti;
\t\t}


          foreach ( \$content as \$k => \$chunk )
          {

\t\t// FOR IMAGES
\t\tif (((\$blockdir == 'rtl') && (\$contains_rtl )) || \$all_rtl ) { \$dirk = \$arraysize-1 - \$k; } else { \$dirk = \$k; }

\t\t\$va = 'M';\t// default for text
\t\tif (isset(\$this->objectbuffer[\$dirk]) && \$this->objectbuffer[\$dirk]) {
\t\t\t\$xadj = \$this->x - \$this->objectbuffer[\$dirk]['OUTER-X'];
\t\t\t\$this->objectbuffer[\$dirk]['OUTER-X'] += \$xadj;
\t\t\t\$this->objectbuffer[\$dirk]['BORDER-X'] += \$xadj;
\t\t\t\$this->objectbuffer[\$dirk]['INNER-X'] += \$xadj;
\t\t\t\$va = \$this->objectbuffer[\$dirk]['vertical-align'];
\t\t\t\$yadj = \$this->y - \$this->objectbuffer[\$dirk]['OUTER-Y'];
\t\t\tif (\$va == 'BS') {
\t\t\t\t\$yadj += \$af + (\$this->linemaxfontsize * (0.5 + \$this->baselineC)) - \$this->objectbuffer[\$dirk]['OUTER-HEIGHT'];
\t\t\t}
\t\t\telse if (\$va == 'M' || \$va == '') {
\t\t\t\t\$yadj += \$af + (\$this->linemaxfontsize /2) - (\$this->objectbuffer[\$dirk]['OUTER-HEIGHT']/2);
\t\t\t}
\t\t\telse if (\$va == 'TB') {
\t\t\t\t\$yadj += \$af + \$this->linemaxfontsize - \$this->objectbuffer[\$dirk]['OUTER-HEIGHT'];
\t\t\t}
\t\t\telse if (\$va == 'TT') {
\t\t\t\t\$yadj += \$af;
\t\t\t}
\t\t\telse if (\$va == 'B') {
\t\t\t\t\$yadj += \$af + \$this->linemaxfontsize + \$bf - \$this->objectbuffer[\$dirk]['OUTER-HEIGHT'];
\t\t\t}
\t\t\telse if (\$va == 'T') {
\t\t\t\t\$yadj += 0;
\t\t\t}
\t\t\t\$this->objectbuffer[\$dirk]['OUTER-Y'] += \$yadj;
\t\t\t\$this->objectbuffer[\$dirk]['BORDER-Y'] += \$yadj;
\t\t\t\$this->objectbuffer[\$dirk]['INNER-Y'] += \$yadj;
\t\t}


\t\t\t// DIRECTIONALITY RTL
\t\t\tif (((\$blockdir == 'rtl') && (\$contains_rtl )) || \$all_rtl ) { \$this->restoreFont( \$font[ \$arraysize-1 - \$k ] ); }
\t\t\telse { \$this->restoreFont( \$font[ \$k ] ); }

\t\t\t// mPDF 5.6.13 Decimal alignment - set in _tableWrite
\t\t\tif (\$is_table && substr(\$align,0,1)=='D' && \$k==0 ) {
\t\t\t\t\$dp = \$this->decimal_align[substr(\$align,0,2)];
\t\t\t\t\$s = preg_split('/'.preg_quote(\$dp,'/').'/', \$content[0], 2); \t// ? needs to be /u if not core
\t\t\t\t\$s0 = \$this->GetStringWidth(\$s[0], false);
\t\t\t\t\$this->x += (\$this->decimal_offset - \$s0);
\t\t\t}

\t\t\t\$this->SetSpacing((\$this->fixedlSpacing*_MPDFK)+\$jcharspacing,(\$this->fixedlSpacing+\$this->minwSpacing)*_MPDFK+\$jws);
\t\t\t\$this->fixedlSpacing = false;
\t\t\t\$this->minwSpacing = 0;

\t\t\t// mPDF 5.6.26
\t\t\t\$save_vis = \$this->visibility;
\t\t\tif (isset(\$this->textparam['visibility']) && \$this->textparam['visibility'] && \$this->textparam['visibility'] != \$this->visibility) {
\t\t\t\t\$this->SetVisibility(\$this->textparam['visibility']);
\t\t\t}

\t \t\t// *********** SPAN BACKGROUND COLOR ***************** //
\t\t\tif (isset(\$this->spanbgcolor) && \$this->spanbgcolor) {
\t\t\t\t\$cor = \$this->spanbgcolorarray;
\t\t\t\t\$this->SetFColor(\$cor);
\t\t\t\t\$save_fill = \$fill; \$spanfill = 1; \$fill = 1;
\t\t\t}
\t\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\tif (strpos(\$contentB[\$k],'L')!==false && isset(\$this->spanborddet['L'])) \$this->x += \$this->spanborddet['L']['w'];
\t\t\t\tif (strpos(\$contentB[\$k],'L')===false) \$this->spanborddet['L']['s'] = \$this->spanborddet['L']['w'] = 0;
\t\t\t\tif (strpos(\$contentB[\$k],'R')===false) \$this->spanborddet['R']['s'] = \$this->spanborddet['R']['w'] = 0;
\t\t\t}
\t\t\t// WORD SPACING
\t\t      \$stringWidth = \$this->GetStringWidth(\$chunk ) + ( \$this->charspacing * mb_strlen(\$chunk,\$this->mb_enc ) / _MPDFK )
\t\t\t\t+ ( \$this->ws * mb_substr_count(\$chunk,' ',\$this->mb_enc ) / _MPDFK );
\t\t\tif (isset(\$this->objectbuffer[\$dirk])) {
\t\t\t\tif (\$this->objectbuffer[\$dirk]['type']=='dottab') {
\t\t\t\t\t\$this->objectbuffer[\$dirk]['OUTER-WIDTH'] +=\$empty;
\t\t\t\t\t\$this->objectbuffer[\$dirk]['OUTER-WIDTH'] +=\$this->objectbuffer[\$dirk]['outdent']; // mPDF 5.6.19
\t\t\t\t}
\t\t\t\t\$stringWidth = \$this->objectbuffer[\$dirk]['OUTER-WIDTH'];
\t\t\t}

\t\t\tif (\$stringWidth==0) { \$stringWidth = 0.000001; }
\t\t\tif (\$k == \$arraysize-1) {
\t\t\t\t// mPDF 5.6.40
\t\t\t\tif (\$this->checkCJK && \$CJKoverflow && \$align=='J' && \$this->allowCJKoverflow && \$hanger && \$this->CJKforceend) {
\t\t\t\t  // force-end overhang
\t\t\t\t\t\$this->Cell( \$stringWidth, \$lineHeight, \$chunk, '', 0, '', \$fill, \$this->HREF, \$currentx,0,0,'M', \$fill, \$af, \$bf, true );
\t\t\t\t\t\$this->Cell( \$this->GetStringWidth(\$hanger), \$lineHeight, \$hanger, '', 1, '', \$fill, \$this->HREF, \$currentx,0,0,'M', \$fill, \$af, \$bf, true );
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$this->Cell( \$stringWidth, \$lineHeight, \$chunk, '', 1, '', \$fill, \$this->HREF, \$currentx,0,0,'M', \$fill, \$af, \$bf, true );
\t\t\t\t}
\t\t\t}
\t\t\telse \$this->Cell( \$stringWidth, \$lineHeight, \$chunk, '', 0, '', \$fill, \$this->HREF, 0, 0,0,'M', \$fill, \$af, \$bf, true );//first or middle part


\t\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\tif (strpos(\$contentB[\$k],'R')!==false && \$k != \$arraysize-1)  \$this->x += \$this->spanborddet['R']['w'];
\t\t\t}
\t \t\t// *********** SPAN BACKGROUND COLOR OFF - RESET BLOCK BGCOLOR ***************** //
\t\t\tif (isset(\$spanfill) && \$spanfill) {
\t\t\t\t\$fill = \$save_fill; \$spanfill = 0;
\t\t\t\tif (\$fill) { \$this->SetFColor(\$bcor); }
\t\t\t}
\t\t\t// mPDF 5.6.26
\t\t\tif (isset(\$this->textparam['visibility']) && \$this->textparam['visibility'] && \$this->visibility != \$save_vis) {
\t\t\t\t\$this->SetVisibility(\$save_vis);
\t\t\t}

          }

\t\$this->printobjectbuffer(\$is_table, \$blockdir);

\t\$this->objectbuffer = array();

\t\$this->ResetSpacing();

/*-- LISTS --*/
\t// LIST BULLETS/NUMBERS
\tif (\$is_list && is_array(\$this->bulletarray) && (\$lineCount == 0) ) {

\t  \$savedFont = \$this->saveFont();

\t  \$bull = \$this->bulletarray;
\t  if (isset(\$bull['level']) && isset(\$bull['occur']) && isset(\$this->InlineProperties['LIST'][\$bull['level']][\$bull['occur']])) {
\t\t\$this->restoreInlineProperties(\$this->InlineProperties['LIST'][\$bull['level']][\$bull['occur']]);
\t  }
\t  if (isset(\$bull['level']) && isset(\$bull['occur']) && isset(\$bull['num']) && isset(\$this->InlineProperties['LISTITEM'][\$bull['level']][\$bull['occur']][\$bull['num']]) && \$this->InlineProperties['LISTITEM'][\$bull['level']][\$bull['occur']][\$bull['num']]) { \$this->restoreInlineProperties(\$this->InlineProperties['LISTITEM'][\$bull['level']][\$bull['occur']][\$bull['num']]); }
\t  if (isset(\$bull['font']) && \$bull['font'] == 'czapfdingbats') {
\t\t\$this->bullet = true;
\t\t\$this->SetFont('czapfdingbats','',\$this->FontSizePt/2.5);
\t  }
\t  else { \$this->SetFont(\$this->FontFamily,\$this->FontStyle,\$this->FontSizePt,true,true); }\t// force output
       //Output bullet
\t  \$this->x = \$currentx;
\t  if (isset(\$bull['x'])) { \$this->x += \$bull['x']; }
\t  \$this->y -= \$lineHeight;
\t  if (isset(\$bull['col']) && \$bull['col']) { \$this->SetTColor(\$bull['col']); }\t// mPDF 5.6.67

        if (isset(\$bull['txt'])) { \$this->Cell(\$bull['w'], \$lineHeight,\$bull['txt'],'','',\$bull['align'],0,'',0,-\$this->cMarginL, -\$this->cMarginR ); }
\t  if (isset(\$bull['font']) && \$bull['font'] == 'czapfdingbats') {
\t\t\$this->bullet = false;
\t  }
\t  \$this->x = \$currentx;\t// Reset
\t  \$this->y += \$lineHeight;

\t  if (\$this->ColActive && !\$is_table) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*

\t   \$this->restoreFont( \$savedFont );
\t  // \$font = array( \$savedFont );

\t  \$this->bulletarray = array();\t// prevents repeat of bullet/number if <li>....<br />.....</li>
\t}
/*-- END LISTS --*/


\t}\t// END IF CONTENT

/*-- CSS-IMAGE-FLOAT --*/
\t// Update values if set to skipline
\tif (\$this->floatmargins) { \$this->_advanceFloatMargins(); }


\tif (\$endofblock && \$blockstate>1) {
\t\t// If float exists at this level
\t\tif (isset(\$this->floatmargins['R']['y1'])) { \$fry1 = \$this->floatmargins['R']['y1']; }
\t\telse { \$fry1 = 0; }
\t\tif (isset(\$this->floatmargins['L']['y1'])) { \$fly1 = \$this->floatmargins['L']['y1']; }
\t\telse { \$fly1 = 0; }
\t\tif (\$this->y < \$fry1 || \$this->y < \$fly1) {
\t\t\t\$drop = max(\$fry1,\$fly1) - \$this->y;
\t\t\t\$this->DivLn(\$drop);
\t\t\t\$this->x = \$currentx;
\t\t}
\t}
/*-- END CSS-IMAGE-FLOAT --*/


\t// PADDING and BORDER spacing/fill
\tif (\$endofblock && (\$blockstate > 1) && (\$this->blk[\$this->blklvl]['padding_bottom'] || \$this->blk[\$this->blklvl]['border_bottom'] || \$this->blk[\$this->blklvl]['css_set_height']) && (!\$is_table) && (!\$is_list)) {
\t\t\t// If CSS height set, extend bottom - if on same page as block started, and CSS HEIGHT > actual height,
\t\t\t//\tand does not force pagebreak
\t\t\t\$extra = 0;
\t\t\tif (\$this->blk[\$this->blklvl]['css_set_height'] && \$this->blk[\$this->blklvl]['startpage']==\$this->page) {
\t\t\t\t// predicted height
\t\t\t\t\$h1 = (\$this->y-\$this->blk[\$this->blklvl]['y0']) + \$this->blk[\$this->blklvl]['padding_bottom'] + \$this->blk[\$this->blklvl]['border_bottom']['w'];
\t\t\t\tif (\$h1 < (\$this->blk[\$this->blklvl]['css_set_height']+\$this->blk[\$this->blklvl]['padding_bottom']+\$this->blk[\$this->blklvl]['padding_top'])) { \$extra = (\$this->blk[\$this->blklvl]['css_set_height']+\$this->blk[\$this->blklvl]['padding_bottom']+\$this->blk[\$this->blklvl]['padding_top']) - \$h1; }
\t\t\t\tif(\$this->y + \$this->blk[\$this->blklvl]['padding_bottom'] + \$this->blk[\$this->blklvl]['border_bottom']['w'] + \$extra > \$this->PageBreakTrigger) {
\t\t\t\t\t\$extra = \$this->PageBreakTrigger - (\$this->y + \$this->blk[\$this->blklvl]['padding_bottom'] + \$this->blk[\$this->blklvl]['border_bottom']['w']);
\t\t\t\t}
\t\t\t}

\t\t\t// \$state = 0 normal; 1 top; 2 bottom; 3 top and bottom
\t\t\t\$this->DivLn(\$this->blk[\$this->blklvl]['padding_bottom'] + \$this->blk[\$this->blklvl]['border_bottom']['w'] + \$extra,-3,true,false,2);
\t\t\t\$this->x = \$currentx;

\t\t\tif (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*

\t}

\t// SET Bottom y1 of block (used for painting borders)
\tif ((\$endofblock) && (\$blockstate > 1) && (!\$is_table) && (!\$is_list)) {
\t\t\$this->blk[\$this->blklvl]['y1'] = \$this->y;
\t}

\t// BOTTOM MARGIN
\tif ((\$endofblock) && (\$blockstate > 1) && (\$this->blk[\$this->blklvl]['margin_bottom']) && (!\$is_table) && (!\$is_list)) {
\t\tif(\$this->y+\$this->blk[\$this->blklvl]['margin_bottom'] < \$this->PageBreakTrigger and !\$this->InFooter) {
\t\t  \$this->DivLn(\$this->blk[\$this->blklvl]['margin_bottom'],\$this->blklvl-1,true,\$this->blk[\$this->blklvl]['margin_collapse']);
\t\t  if (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
\t\t}
\t}

\t// Reset lineheight
\t\$lineHeight = \$this->divheight;
}





function printobjectbuffer(\$is_table=false, \$blockdir=false) {
\t\tif (!\$blockdir) { \$blockdir = \$this->directionality; }
\t\tif (\$is_table && \$this->shrin_k > 1) { \$k = \$this->shrin_k; }
\t\telse { \$k = 1; }
\t\t\$save_y = \$this->y;
\t\t\$save_x = \$this->x;
\t\t\$save_currentfontfamily = \$this->FontFamily;
\t\t\$save_currentfontsize = \$this->FontSizePt;
\t\t\$save_currentfontstyle = \$this->FontStyle.(\$this->U ? 'U' : '').(\$this->S ? 'S' : '');
\t\tif (\$blockdir == 'rtl') { \$rtlalign = 'R'; } else { \$rtlalign = 'L'; }
\t\tforeach (\$this->objectbuffer AS \$ib => \$objattr) {
\t\t   if (\$objattr['type'] == 'bookmark' || \$objattr['type'] == 'indexentry' || \$objattr['type'] == 'toc') {
\t\t\t\$x = \$objattr['OUTER-X'];
\t\t\t\$y = \$objattr['OUTER-Y'];
\t\t\t\$this->y = \$y - \$this->FontSize/2;
\t\t\t\$this->x = \$x;
\t\t\tif (\$objattr['type'] == 'bookmark' ) { \$this->Bookmark(\$objattr['CONTENT'],\$objattr['bklevel'] ,\$y - \$this->FontSize); }\t// *BOOKMARKS*
\t\t\tif (\$objattr['type'] == 'indexentry') { \$this->IndexEntry(\$objattr['CONTENT']); }\t// *INDEX*
\t\t\tif (\$objattr['type'] == 'toc') { \$this->TOC_Entry(\$objattr['CONTENT'], \$objattr['toclevel'], \$objattr['toc_id']); }\t// *TOC*
\t\t   }
/*-- ANNOTATIONS --*/
\t\t   else if (\$objattr['type'] == 'annot') {
\t\t\tif (\$objattr['POS-X']) { \$x = \$objattr['POS-X']; }
\t\t\telse if (\$this->annotMargin<>0) { \$x = -\$objattr['OUTER-X']; }
\t\t\telse { \$x = \$objattr['OUTER-X']; }
\t\t\tif (\$objattr['POS-Y']) { \$y = \$objattr['POS-Y']; }
\t\t\telse { \$y = \$objattr['OUTER-Y'] - \$this->FontSize/2; }
\t\t\t// Create a dummy entry in the _out/columnBuffer with position sensitive data,
\t\t\t// linking \$y-1 in the Columnbuffer with entry in \$this->columnAnnots
\t\t\t// and when columns are split in length will not break annotation from current line
\t\t\t\$this->y = \$y-1;
\t\t\t\$this->x = \$x-1;
\t\t\t\$this->Line(\$x-1,\$y-1,\$x-1,\$y-1);
\t\t\t\$this->Annotation(\$objattr['CONTENT'], \$x , \$y , \$objattr['ICON'], \$objattr['AUTHOR'], \$objattr['SUBJECT'], \$objattr['OPACITY'], \$objattr['COLOR'], \$objattr['POPUP'], \$objattr['FILE']);
\t\t   }
/*-- END ANNOTATIONS --*/
\t\t   else {
\t\t\t\$y = \$objattr['OUTER-Y'];
\t\t\t\$x = \$objattr['OUTER-X'];
\t\t\t\$w = \$objattr['OUTER-WIDTH'];
\t\t\t\$h = \$objattr['OUTER-HEIGHT'];
\t\t\tif (isset(\$objattr['text'])) { \$texto = \$objattr['text']; }
\t\t\t\$this->y = \$y;
\t\t\t\$this->x = \$x;
\t\t\tif (isset(\$objattr['fontfamily'])) { \$this->SetFont(\$objattr['fontfamily'],'',\$objattr['fontsize'] ); }
\t\t   }

\t\t// HR
\t\t   if (\$objattr['type'] == 'hr') {
\t\t\t\$this->SetDColor(\$objattr['color']);
\t\t\tswitch(\$objattr['align']) {
      \t\t    case 'C':
      \t\t        \$empty = \$objattr['OUTER-WIDTH'] - \$objattr['INNER-WIDTH'];
      \t\t        \$empty /= 2;
      \t\t        \$x += \$empty;
     \t\t        \t  break;
      \t\t    case 'R':
      \t\t        \$empty = \$objattr['OUTER-WIDTH'] - \$objattr['INNER-WIDTH'];
      \t\t        \$x += \$empty;
      \t\t        break;
\t\t\t}
      \t\t\$oldlinewidth = \$this->LineWidth;
\t\t\t\$this->SetLineWidth(\$objattr['linewidth']/\$k );
\t\t\t\$this->y += (\$objattr['linewidth']/2) + \$objattr['margin_top']/\$k;
\t\t\t\$this->Line(\$x,\$this->y,\$x+\$objattr['INNER-WIDTH'],\$this->y);
\t\t\t\$this->SetLineWidth(\$oldlinewidth);
\t\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t   }
\t\t// IMAGE
\t\t   if (\$objattr['type'] == 'image') {
\t\t\t// mPDF 5.7.3 TRANSFORMS
\t\t\tif (isset(\$objattr['transform'])) {
\t\t\t\t\$this->_out(\"\\n\".'% BTR');\t// Begin Transform
\t\t\t}
\t\t\tif (isset(\$objattr['z-index']) && \$objattr['z-index'] > 0 && \$this->currentlayer==0) {
\t\t\t\t\$this->BeginLayer(\$objattr['z-index']);
\t\t\t}
\t\t\tif(isset(\$objattr['visibility']) && \$objattr['visibility']!='visible' && \$objattr['visibility']) {
\t\t\t\t\$this->SetVisibility(\$objattr['visibility']);
\t\t\t}
\t\t\tif (isset(\$objattr['opacity'])) { \$this->SetAlpha(\$objattr['opacity']); }
\t\t\t\$rotate = 0;
\t\t\t\$obiw = \$objattr['INNER-WIDTH'];
\t\t\t\$obih = \$objattr['INNER-HEIGHT'];
\t\t\t\$sx = \$objattr['INNER-WIDTH']*_MPDFK / \$objattr['orig_w'];
\t\t\t\$sy = abs(\$objattr['INNER-HEIGHT'])*_MPDFK / abs(\$objattr['orig_h']);
\t\t\t\$sx = (\$objattr['INNER-WIDTH']*_MPDFK / \$objattr['orig_w']);
\t\t\t\$sy = (\$objattr['INNER-HEIGHT']*_MPDFK / \$objattr['orig_h']);

\t\t\tif (isset(\$objattr['ROTATE'])) { \$rotate = \$objattr['ROTATE']; }
\t\t\tif (\$rotate==90) {
\t\t\t\t// Clockwise
\t\t\t\t\$obiw = \$objattr['INNER-HEIGHT'];
\t\t\t\t\$obih = \$objattr['INNER-WIDTH'];
\t\t\t\t\$tr = \$this->transformTranslate(0, -\$objattr['INNER-WIDTH'], true) ;
\t\t\t\t\$tr .= ' '. \$this->transformRotate(90, \$objattr['INNER-X'],(\$objattr['INNER-Y'] +\$objattr['INNER-WIDTH'] ),true) ;
\t\t\t\t\$sx = \$obiw*_MPDFK / \$objattr['orig_h'];
\t\t\t\t\$sy = \$obih*_MPDFK / \$objattr['orig_w'];
\t\t\t}
\t\t\telse if (\$rotate==-90 || \$rotate==270) {
\t\t\t\t// AntiClockwise
\t\t\t\t\$obiw = \$objattr['INNER-HEIGHT'];
\t\t\t\t\$obih = \$objattr['INNER-WIDTH'];
\t\t\t\t\$tr = \$this->transformTranslate(\$objattr['INNER-WIDTH'], (\$objattr['INNER-HEIGHT']-\$objattr['INNER-WIDTH']), true) ;
\t\t\t\t\$tr .= ' '. \$this->transformRotate(-90, \$objattr['INNER-X'],(\$objattr['INNER-Y'] +\$objattr['INNER-WIDTH'] ),true) ;
\t\t\t\t\$sx = \$obiw*_MPDFK / \$objattr['orig_h'];
\t\t\t\t\$sy = \$obih*_MPDFK / \$objattr['orig_w'];
\t\t\t}
\t\t\telse if (\$rotate==180) {
\t\t\t\t// Mirror
\t\t\t\t\$tr = \$this->transformTranslate(\$objattr['INNER-WIDTH'], -\$objattr['INNER-HEIGHT'], true) ;
\t\t\t\t\$tr .= ' '. \$this->transformRotate(180, \$objattr['INNER-X'],(\$objattr['INNER-Y'] +\$objattr['INNER-HEIGHT'] ),true) ;
\t\t\t}
\t\t\telse { \$tr = ''; }
\t\t\t\$tr = trim(\$tr);
\t\t\tif (\$tr) { \$tr .= ' '; }
\t\t\t\$gradmask = '';

\t\t\t// mPDF 5.7.3 TRANSFORMS
\t\t\t\$tr2 = '';
\t\t\tif (isset(\$objattr['transform'])) {
\t\t\t\t\$maxsize_x = \$w;
\t\t\t\t\$maxsize_y = \$h;
\t\t\t\t\$cx = \$x + \$w/2;
\t\t\t\t\$cy = \$y + \$h/2;
\t\t\t\tpreg_match_all('/(translatex|translatey|translate|scalex|scaley|scale|rotate|skewX|skewY|skew)\\((.*?)\\)/is',\$objattr['transform'],\$m);
\t\t\t\tif (count(\$m[0])) {
\t\t\t\t\tfor(\$i=0; \$i<count(\$m[0]); \$i++) {
\t\t\t\t\t\t\$c = strtolower(\$m[1][\$i]);
\t\t\t\t\t\t\$v = trim(\$m[2][\$i]);
\t\t\t\t\t\t\$vv = preg_split('/[ ,]+/',\$v);
\t\t\t\t\t\tif (\$c=='translate' && count(\$vv)) {
\t\t\t\t\t\t\t\$translate_x = \$this->ConvertSize(\$vv[0],\$maxsize_x,false,false);
\t\t\t\t\t\t\tif (count(\$vv)==2) { \$translate_y = \$this->ConvertSize(\$vv[1],\$maxsize_y,false,false); }
\t\t\t\t\t\t\telse { \$translate_y = 0; }
\t\t\t\t\t\t\t\$tr2 .= \$this->transformTranslate(\$translate_x, \$translate_y, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='translatex' && count(\$vv)) {
\t\t\t\t\t\t\t\$translate_x = \$this->ConvertSize(\$vv[0],\$maxsize_x,false,false);
\t\t\t\t\t\t\t\$tr2 .= \$this->transformTranslate(\$translate_x, 0, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='translatey' && count(\$vv)) {
\t\t\t\t\t\t\t\$translate_y = \$this->ConvertSize(\$vv[1],\$maxsize_y,false,false);
\t\t\t\t\t\t\t\$tr2 .= \$this->transformTranslate(0, \$translate_y, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='scale' && count(\$vv)) {
\t\t\t\t\t\t\t\$scale_x = \$vv[0] * 100;
\t\t\t\t\t\t\tif (count(\$vv)==2) { \$scale_y = \$vv[1] * 100; }
\t\t\t\t\t\t\telse { \$scale_y = \$scale_x; }
\t\t\t\t\t\t\t\$tr2 .= \$this->transformScale(\$scale_x, \$scale_y, \$cx, \$cy, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='scalex' && count(\$vv)) {
\t\t\t\t\t\t\t\$scale_x = \$vv[0] * 100;
\t\t\t\t\t\t\t\$tr2 .= \$this->transformScale(\$scale_x, 0, \$cx, \$cy, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='scaley' && count(\$vv)) {
\t\t\t\t\t\t\t\$scale_y = \$vv[1] * 100;
\t\t\t\t\t\t\t\$tr2 .= \$this->transformScale(0, \$scale_y, \$cx, \$cy, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='skew' && count(\$vv)) {
\t\t\t\t\t\t\t\$angle_x = \$this->ConvertAngle(\$vv[0], false);
\t\t\t\t\t\t\tif (count(\$vv)==2) { \$angle_y = \$this->ConvertAngle(\$vv[1], false); }
\t\t\t\t\t\t\telse { \$angle_y = 0; }
\t\t\t\t\t\t\t\$tr2 .= \$this->transformSkew(\$angle_x, \$angle_y, \$cx, \$cy, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='skewx' && count(\$vv)) {
\t\t\t\t\t\t\t\$angle = \$this->ConvertAngle(\$vv[0], false);
\t\t\t\t\t\t\t\$tr2 .= \$this->transformSkew(\$angle, 0, \$cx, \$cy, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='skewy' && count(\$vv)) {
\t\t\t\t\t\t\t\$angle = \$this->ConvertAngle(\$vv[0], false);
\t\t\t\t\t\t\t\$tr2 .= \$this->transformSkew(0, \$angle, \$cx, \$cy, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (\$c=='rotate' && count(\$vv)) {
\t\t\t\t\t\t\t\$angle = \$this->ConvertAngle(\$vv[0]);
\t\t\t\t\t\t\t\$tr2 .= \$this->transformRotate(\$angle, \$cx, \$cy, true).' ';
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t// mPDF 5.7.3 TRANSFORMS / BACKGROUND COLOR
\t\t\t// Transform also affects image background
\t\t\tif (\$tr2) { \$this->_out('q '.\$tr2.' '); }
\t\t\tif (isset(\$objattr['bgcolor']) && \$objattr['bgcolor']) {
\t\t\t\t\$bgcol = \$objattr['bgcolor'];
\t\t\t\t\$this->SetFColor(\$bgcol);
\t \t\t\t\$this->Rect(\$x,\$y,\$w,\$h, 'F');
\t\t\t\t\$this->SetFColor(\$this->ConvertColor(255));
\t\t\t}
\t\t\tif (\$tr2) { \$this->_out('Q'); }

/*-- BACKGROUNDS --*/
\t\t\tif (isset(\$objattr['GRADIENT-MASK'])) {
\t\t\t\t\$g = \$this->grad->parseMozGradient( \$objattr['GRADIENT-MASK'] );
\t\t\t\tif (\$g) {
\t\t\t\t\t\$dummy = \$this->grad->Gradient(\$objattr['INNER-X'], \$objattr['INNER-Y'], \$obiw, \$obih, \$g['type'], \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend'], true, true);
\t\t\t\t\t\$gradmask = '/TGS'.count(\$this->gradients).' gs ';
\t\t\t\t\t// \$this->_out(\"q \".\$tr.\$this->grad->Gradient(\$objattr['INNER-X'], \$objattr['INNER-Y'], \$obiw, \$obih, \$g['type'], \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend'], true).\" Q\");
\t\t\t\t}
\t\t\t}
/*-- END BACKGROUNDS --*/
/*-- IMAGES-WMF --*/
\t\t\tif (isset(\$objattr['itype']) && \$objattr['itype']=='wmf') {
\t\t\t\t\$outstring = sprintf('q '.\$tr.\$tr2.'%.3F 0 0 %.3F %.3F %.3F cm /FO%d Do Q', \$sx, -\$sy, \$objattr['INNER-X']*_MPDFK-\$sx*\$objattr['wmf_x'], ((\$this->h-\$objattr['INNER-Y'])*_MPDFK)+\$sy*\$objattr['wmf_y'], \$objattr['ID']);\t// mPDF 5.7.3 TRANSFORMS
\t\t\t}
\t\t\telse
/*-- END IMAGES-WMF --*/
\t\t\tif (isset(\$objattr['itype']) && \$objattr['itype']=='svg') {
\t\t\t\t\$outstring = sprintf('q '.\$tr.\$tr2.'%.3F 0 0 %.3F %.3F %.3F cm /FO%d Do Q', \$sx, -\$sy, \$objattr['INNER-X']*_MPDFK-\$sx*\$objattr['wmf_x'], ((\$this->h-\$objattr['INNER-Y'])*_MPDFK)+\$sy*\$objattr['wmf_y'], \$objattr['ID']);\t// mPDF 5.7.3 TRANSFORMS
\t\t\t}
\t\t\telse {
\t\t\t\t\$outstring = sprintf(\"q \".\$tr.\$tr2.\"%.3F 0 0 %.3F %.3F %.3F cm \".\$gradmask.\"/I%d Do Q\",\$obiw*_MPDFK, \$obih*_MPDFK, \$objattr['INNER-X'] *_MPDFK, (\$this->h-(\$objattr['INNER-Y'] +\$obih ))*_MPDFK,\$objattr['ID'] );\t// mPDF 5.7.3 TRANSFORMS
\t\t\t}
\t\t\t\$this->_out(\$outstring);
\t\t\t// LINK
\t\t\tif (isset(\$objattr['link'])) \$this->Link(\$objattr['INNER-X'],\$objattr['INNER-Y'],\$objattr['INNER-WIDTH'],\$objattr['INNER-HEIGHT'],\$objattr['link']);
\t\t\tif (isset(\$objattr['opacity'])) { \$this->SetAlpha(1); }

\t\t\t// mPDF 5.7.3 TRANSFORMS
\t\t\t// Transform also affects image borders
\t\t\tif (\$tr2) { \$this->_out('q '.\$tr2.' '); }
\t\t\tif ((isset(\$objattr['border_top']) && \$objattr['border_top']>0) || (isset(\$objattr['border_left']) && \$objattr['border_left']>0) || (isset(\$objattr['border_right']) && \$objattr['border_right']>0) || (isset(\$objattr['border_bottom']) && \$objattr['border_bottom']>0)) { \$this->PaintImgBorder(\$objattr,\$is_table); }
\t\t\tif (\$tr2) { \$this->_out('Q'); }

\t\t\tif(isset(\$objattr['visibility']) && \$objattr['visibility']!='visible' && \$objattr['visibility']) {
\t\t\t\t\$this->SetVisibility('visible');
\t\t\t}
\t\t\tif (isset(\$objattr['z-index']) && \$objattr['z-index'] > 0 && \$this->currentlayer==0) {
\t\t\t\t\$this->EndLayer();
\t\t\t}
\t\t\t// mPDF 5.7.3 TRANSFORMS
\t\t\tif (isset(\$objattr['transform'])) {
\t\t\t\t\$this->_out(\"\\n\".'% ETR');\t// Begin Transform
\t\t\t}
\t\t   }

/*-- BARCODES --*/
\t\t// BARCODE
\t\t   if (\$objattr['type'] == 'barcode') {
\t\t\t\$bgcol = \$this->ConvertColor(255);
\t\t\tif (isset(\$objattr['bgcolor']) && \$objattr['bgcolor']) {
\t\t\t\t\$bgcol = \$objattr['bgcolor'];
\t\t\t}
\t\t\t\$col = \$this->ConvertColor(0);
\t\t\tif (isset(\$objattr['color']) && \$objattr['color']) {
\t\t\t\t\$col = \$objattr['color'];
\t\t\t}
\t\t\t\$this->SetFColor(\$bgcol);
\t \t\t\$this->Rect(\$objattr['BORDER-X'], \$objattr['BORDER-Y'], \$objattr['BORDER-WIDTH'], \$objattr['BORDER-HEIGHT'], 'F');
\t\t\t\$this->SetFColor(\$this->ConvertColor(255));
\t\t\tif (isset(\$objattr['BORDER-WIDTH'])) { \$this->PaintImgBorder(\$objattr,\$is_table); }
\t\t\tif (\$objattr['btype'] == 'EAN13' || \$objattr['btype'] == 'ISBN' || \$objattr['btype'] == 'ISSN' || \$objattr['btype'] == 'UPCA' || \$objattr['btype'] == 'UPCE' || \$objattr['btype'] == 'EAN8') {
\t\t\t\t\$this->WriteBarcode(\$objattr['code'], \$objattr['showtext'], \$objattr['INNER-X'], \$objattr['INNER-Y'], \$objattr['bsize'], 0, 0, 0, 0, 0, \$objattr['bheight'], \$bgcol, \$col, \$objattr['btype'], \$objattr['bsupp'], \$objattr['bsupp_code'], \$k);
\t\t\t}
\t\t\t// QR-code
\t\t\telse if (\$objattr['btype']=='QR') {
\t\t\t\tif (!class_exists('QRcode', false)) {
\t\t\t\t\tinclude(_MPDF_PATH.'qrcode/qrcode.class.php');
\t\t\t\t}
\t\t\t\t\$this->qrcode = new QRcode(\$objattr['code'], \$objattr['errorlevel']);
\t\t\t\t\$this->qrcode->displayFPDF(\$this, \$objattr['INNER-X'], \$objattr['INNER-Y'], \$objattr['bsize']*25, array(255,255,255), array(0,0,0));
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->WriteBarcode2(\$objattr['code'], \$objattr['INNER-X'], \$objattr['INNER-Y'], \$objattr['bsize'], \$objattr['bheight'], \$bgcol, \$col, \$objattr['btype'], \$objattr['pr_ratio'], \$k);
\t\t\t}
\t\t   }
/*-- END BARCODES --*/

\t\t// TEXT CIRCLE
\t\t   if (\$objattr['type'] == 'textcircle') {
\t\t\t\$bgcol = '';\t// mPDF 5.5.14
\t\t\tif (isset(\$objattr['bgcolor']) && \$objattr['bgcolor']) {
\t\t\t\t\$bgcol = \$objattr['bgcolor'];
\t\t\t}
\t\t\t\$col = \$this->ConvertColor(0);
\t\t\tif (isset(\$objattr['color']) && \$objattr['color']) {
\t\t\t\t\$col = \$objattr['color'];
\t\t\t}
\t\t\t\$this->SetTColor(\$col);
\t\t\t\$this->SetFColor(\$bgcol);
\t \t\tif (\$bgcol) \$this->Rect(\$objattr['BORDER-X'], \$objattr['BORDER-Y'], \$objattr['BORDER-WIDTH'], \$objattr['BORDER-HEIGHT'], 'F');\t// mPDF 5.5.14
\t\t\t\$this->SetFColor(\$this->ConvertColor(255));
\t\t\tif (isset(\$objattr['BORDER-WIDTH'])) { \$this->PaintImgBorder(\$objattr,\$is_table); }
\t\t\tif (!class_exists('directw', false)) { include(_MPDF_PATH.'classes/directw.php'); }
\t\t\tif (empty(\$this->directw)) { \$this->directw = new directw(\$this); }
\t\t\t\$save_lmfs = \$this->linemaxfontsize;
\t\t\t\$this->linemaxfontsize = 0;
\t\t\tif (isset(\$objattr['top-text'])) {
\t\t\t\t\$this->directw->CircularText(\$objattr['INNER-X']+\$objattr['INNER-WIDTH']/2, \$objattr['INNER-Y']+\$objattr['INNER-HEIGHT']/2, \$objattr['r']/\$k, \$objattr['top-text'], 'top', \$objattr['fontfamily'], \$objattr['fontsize']/\$k, \$objattr['fontstyle'], \$objattr['space-width'], \$objattr['char-width'],  \$objattr['divider']);\t\t// mPDF 5.5.23
\t\t\t}
\t\t\tif (isset(\$objattr['bottom-text'])) {
\t\t\t\t\$this->directw->CircularText(\$objattr['INNER-X']+\$objattr['INNER-WIDTH']/2, \$objattr['INNER-Y']+\$objattr['INNER-HEIGHT']/2, \$objattr['r']/\$k, \$objattr['bottom-text'], 'bottom', \$objattr['fontfamily'], \$objattr['fontsize']/\$k, \$objattr['fontstyle'], \$objattr['space-width'], \$objattr['char-width'],  \$objattr['divider']);\t\t// mPDF 5.5.23
\t\t\t}
\t\t\t\$this->linemaxfontsize = \$save_lmfs;
\t\t   }

\t\t   \$this->ResetSpacing();

\t\t// DOT-TAB
\t\t   if (\$objattr['type'] == 'dottab') {
\t\t\t\t// mPDF 5.6.19
\t\t\t\tif (isset(\$objattr['fontfamily'])) { \$this->SetFont(\$objattr['fontfamily'],'',\$objattr['fontsize'] ); }
\t\t\t\t\$sp = \$this->GetStringWidth(' ');
\t\t\t\t\$nb=floor((\$w-2*\$sp)/\$this->GetStringWidth('.'));
\t\t\t\tif (\$nb>0) { \$dots=' '.str_repeat('.',\$nb).' '; }
\t\t\t\telse { \$dots=' '; }
\t\t\t\t\$col = \$this->ConvertColor(0);
\t\t\t\tif (isset(\$objattr['colorarray']) && (\$objattr['colorarray'])) {\t// mPDF 5.6.19
\t\t\t\t\t\$col = \$objattr['colorarray'];
\t\t\t\t}
\t\t\t\t\$this->SetTColor(\$col);
\t\t\t\t\$save_dh = \$this->divheight;\t// mPDF 5.6.19
\t\t\t\t\$save_sbd = \$this->spanborddet;
\t\t\t\t\$save_u = \$this->U;
\t\t\t\t\$save_s = \$this->strike;
\t\t\t\t\$this->spanborddet = '';
\t\t\t\t\$this->divheight = 0;\t// mPDF 5.6.19
\t\t\t\t\$this->U = false;
\t\t\t\t\$this->strike = false;
\t\t\t\t\$this->Cell(\$w,\$h,\$dots,0,0,'C');
\t\t\t\t\$this->spanborddet = \$save_sbd;
\t\t\t\t\$this->U = \$save_u;
\t\t\t\t\$this->strike = \$save_s;
\t\t\t\t\$this->divheight = \$save_dh;\t// mPDF 5.6.19
\t\t\t\t// mPDF 5.0
\t\t\t\t\$this->SetTColor(\$this->ConvertColor(0));
\t\t   }

/*-- FORMS --*/
\t\t// TEXT/PASSWORD INPUT
\t\t   if (\$objattr['type'] == 'input' && (\$objattr['subtype'] == 'TEXT' || \$objattr['subtype'] == 'PASSWORD')) {
\t\t\t\$this->form->print_ob_text(\$objattr,\$w,\$h,\$texto,\$rtlalign,\$k,\$blockdir);
\t\t   }

\t\t// TEXTAREA
\t\t   if (\$objattr['type'] == 'textarea') {
\t\t\t\$this->form->print_ob_textarea(\$objattr,\$w,\$h,\$texto,\$rtlalign,\$k,\$blockdir);
\t\t   }

\t\t// SELECT
\t\t   if (\$objattr['type'] == 'select') {
\t\t\t\$this->form->print_ob_select(\$objattr,\$w,\$h,\$texto,\$rtlalign,\$k,\$blockdir);
\t\t   }


\t\t// INPUT/BUTTON as IMAGE
\t\t   if (\$objattr['type'] == 'input' && \$objattr['subtype'] == 'IMAGE') {
\t\t\t\$this->form->print_ob_imageinput(\$objattr,\$w,\$h,\$texto,\$rtlalign,\$k,\$blockdir);
\t\t   }

\t\t// BUTTON
\t\t   if (\$objattr['type'] == 'input' && (\$objattr['subtype'] == 'SUBMIT' || \$objattr['subtype'] == 'RESET' || \$objattr['subtype'] == 'BUTTON')) {
\t\t\t\$this->form->print_ob_button(\$objattr,\$w,\$h,\$texto,\$rtlalign,\$k,\$blockdir);
\t\t   }

\t\t// CHECKBOX
\t\t   if (\$objattr['type'] == 'input' && (\$objattr['subtype'] == 'CHECKBOX')) {
\t\t\t\$this->form->print_ob_checkbox(\$objattr,\$w,\$h,\$texto,\$rtlalign,\$k,\$blockdir,\$x,\$y);
\t\t   }
\t\t// RADIO
\t\t   if (\$objattr['type'] == 'input' && (\$objattr['subtype'] == 'RADIO')) {
\t\t\t\$this->form->print_ob_radio(\$objattr,\$w,\$h,\$texto,\$rtlalign,\$k,\$blockdir,\$x,\$y);
\t\t   }
/*-- END FORMS --*/
\t\t}
\t\t\$this->SetFont(\$save_currentfontfamily,\$save_currentfontstyle,\$save_currentfontsize);
\t\t\$this->y = \$save_y;
\t\t\$this->x = \$save_x;
\t\tunset(\$content);
}


function WriteFlowingBlock( \$s)
{
\t\$currentx = \$this->x;
\t\$is_table = \$this->flowingBlockAttr[ 'is_table' ];
\t\$is_list = \$this->flowingBlockAttr[ 'is_list' ];
\t// width of all the content so far in points
\t\$contentWidth =& \$this->flowingBlockAttr[ 'contentWidth' ];
\t// cell width in points
\t\$maxWidth =& \$this->flowingBlockAttr[ 'width' ];
\t\$lineCount =& \$this->flowingBlockAttr[ 'lineCount' ];
\t// line height in user units
\t\$lineHeight =& \$this->flowingBlockAttr[ 'height' ];
\t\$align =& \$this->flowingBlockAttr[ 'align' ];
\t\$content =& \$this->flowingBlockAttr[ 'content' ];
\t\$contentB =& \$this->flowingBlockAttr[ 'contentB' ];
\t\$font =& \$this->flowingBlockAttr[ 'font' ];
\t\$valign =& \$this->flowingBlockAttr[ 'valign' ];
\t\$blockstate = \$this->flowingBlockAttr[ 'blockstate' ];

\t\$newblock = \$this->flowingBlockAttr[ 'newblock' ];
\t\$blockdir = \$this->flowingBlockAttr['blockdir'];
\t// *********** BLOCK BACKGROUND COLOR ***************** //
\tif (\$this->blk[\$this->blklvl]['bgcolor'] && !\$is_table) {
\t\t\$fill = 0;
\t}
\telse {
\t\t\$this->SetFColor(\$this->ConvertColor(255));
\t\t\$fill = 0;
\t}
\t\$font[] = \$this->saveFont();
\t\$content[] = '';
\t\$contentB[] = '';
\t\$currContent =& \$content[ count( \$content ) - 1 ];
\t// where the line should be cutoff if it is to be justified
\t\$cutoffWidth = \$contentWidth;

\t\$CJKoverflow = false;
\t\$hanger = '';\t// mPDF 5.6.40

\t// COLS
\t\$oldcolumn = \$this->CurrCol;

\tif (\$this->ColActive && !\$is_table) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*

/*-- TABLES --*/
   if (\$is_table) {
\t\$ipaddingL = 0;
\t\$ipaddingR = 0;
\t\$paddingL = 0;
\t\$paddingR = 0;
\t\$cpaddingadjustL = 0;
\t\$cpaddingadjustR = 0;
 \t// Added mPDF 3.0
\t\$fpaddingR = 0;
\t\$fpaddingL = 0;
  }
   else {
/*-- END TABLES --*/
\t\t\$ipaddingL = \$this->blk[\$this->blklvl]['padding_left'];
\t\t\$ipaddingR = \$this->blk[\$this->blklvl]['padding_right'];
\t\t\$paddingL = (\$ipaddingL * _MPDFK);
\t\t\$paddingR = (\$ipaddingR * _MPDFK);
\t\t\$this->cMarginL =  \$this->blk[\$this->blklvl]['border_left']['w'];
\t\t\$cpaddingadjustL = -\$this->cMarginL;
\t\t\$this->cMarginR =  \$this->blk[\$this->blklvl]['border_right']['w'];
\t\t\$cpaddingadjustR = -\$this->cMarginR;
\t\t// Added mPDF 3.0 Float DIV
\t\t\$fpaddingR = 0;
\t\t\$fpaddingL = 0;
/*-- CSS-FLOAT --*/
\t\tif (count(\$this->floatDivs)) {
\t\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl);
\t\t\tif (\$r_exists) { \$fpaddingR = \$r_width; }
\t\t\tif (\$l_exists) { \$fpaddingL = \$l_width; }
\t\t}
/*-- END CSS-FLOAT --*/

\t\t\$usey = \$this->y + 0.002;
\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$lineCount == 0) ) {
\t\t\t\$usey += \$this->blk[\$this->blklvl]['margin_top'] + \$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w'];
\t\t}
/*-- CSS-IMAGE-FLOAT --*/
\t\t// If float exists at this level
\t\tif (isset(\$this->floatmargins['R']) && \$usey <= \$this->floatmargins['R']['y1'] && \$usey >= \$this->floatmargins['R']['y0'] && !\$this->floatmargins['R']['skipline']) { \$fpaddingR += \$this->floatmargins['R']['w']; }
\t\tif (isset(\$this->floatmargins['L']) && \$usey <= \$this->floatmargins['L']['y1'] && \$usey >= \$this->floatmargins['L']['y0'] && !\$this->floatmargins['L']['skipline']) { \$fpaddingL += \$this->floatmargins['L']['w']; }
/*-- END CSS-IMAGE-FLOAT --*/
   }\t// *TABLES*

     //OBJECTS - IMAGES & FORM Elements (NB has already skipped line/page if required - in printbuffer)
      if (substr(\$s,0,3) == \"\\xbb\\xa4\\xac\") { //identifier has been identified!
\t\t\$objattr = \$this->_getObjAttr(\$s);
\t\t\$h_corr = 0;
\t\tif (\$is_table) {\t// *TABLES*
\t\t\t\$maximumW = (\$maxWidth/_MPDFK) - (\$this->cellPaddingL + \$this->cMarginL + \$this->cellPaddingR + \$this->cMarginR); \t// *TABLES*
\t\t}\t// *TABLES*
\t\telse {\t// *TABLES*
\t\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$lineCount == 0) && (!\$is_table)) { \$h_corr = \$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w']; }
\t\t\t\$maximumW = (\$maxWidth/_MPDFK) - (\$this->blk[\$this->blklvl]['padding_left'] + \$this->blk[\$this->blklvl]['border_left']['w'] + \$this->blk[\$this->blklvl]['padding_right'] + \$this->blk[\$this->blklvl]['border_right']['w'] + \$fpaddingL + \$fpaddingR );
\t\t}\t// *TABLES*
\t\t\$objattr = \$this->inlineObject(\$objattr['type'],\$this->lMargin + \$fpaddingL + (\$contentWidth/_MPDFK),(\$this->y + \$h_corr), \$objattr, \$this->lMargin,(\$contentWidth/_MPDFK),\$maximumW,\$lineHeight,true,\$is_table);

\t\t// SET LINEHEIGHT for this line ================ RESET AT END
\t\t\$lineHeight = MAX(\$lineHeight,\$objattr['OUTER-HEIGHT']);
\t\t\$this->objectbuffer[count(\$content)-1] = \$objattr;
\t\t// if (isset(\$objattr['vertical-align'])) { \$valign = \$objattr['vertical-align']; }
\t\t// else { \$valign = ''; }
\t\t\$contentWidth += (\$objattr['OUTER-WIDTH'] * _MPDFK);
\t\treturn;
\t}

\t\$lbw = \$rbw = 0;\t// Border widths
\tif (!empty(\$this->spanborddet)) {
\t\tif (isset(\$this->spanborddet['L'])) \$lbw = \$this->spanborddet['L']['w'];
\t\tif (isset(\$this->spanborddet['R'])) \$rbw = \$this->spanborddet['R']['w'];
\t}

   if (\$this->usingCoreFont) {
\t\$tmp = strlen( \$s );
   }
   else {
\t\$tmp = mb_strlen( \$s, \$this->mb_enc );
   }

   // for every character in the string
   for ( \$i = 0; \$i < \$tmp; \$i++ )  {
\t// extract the current character
\t// get the width of the character in points
\tif (\$this->usingCoreFont) {
       \t\$c = \$s[\$i];
\t\t// Soft Hyphens chr(173)
\t\t\$cw = (\$this->GetCharWidthCore(\$c) * _MPDFK);
\t\tif (\$this->kerning && \$this->useKerning && \$i > 0) {
\t\t\tif (isset(\$this->CurrentFont['kerninfo'][\$s[(\$i-1)]][\$c])) {
\t\t\t\t\$cw += (\$this->CurrentFont['kerninfo'][\$s[(\$i-1)]][\$c] * \$this->FontSizePt / 1000 );
\t\t\t}
\t\t}
\t}
\telse {
\t      \$c = mb_substr(\$s,\$i,1,\$this->mb_enc );
\t\t\$cw = (\$this->GetCharWidthNonCore(\$c, false) * _MPDFK);
\t\tif (\$this->kerning && \$this->useKerning && \$i > 0) {
\t     \t\t\$lastc = mb_substr(\$s,(\$i-1),1,\$this->mb_enc );
\t\t\t\$ulastc = \$this->UTF8StringToArray(\$lastc, false);
\t\t\t\$uc = \$this->UTF8StringToArray(\$c, false);
\t\t\tif (isset(\$this->CurrentFont['kerninfo'][\$ulastc[0]][\$uc[0]])) {
\t\t\t\t\$cw += (\$this->CurrentFont['kerninfo'][\$ulastc[0]][\$uc[0]] * \$this->FontSizePt / 1000 );
\t\t\t}
\t\t}
\t}

\tif (\$i==0) {
\t\t\$cw += \$lbw*_MPDFK;
\t\t\$contentB[(count(\$contentB)-1)] .= 'L';
\t}
\tif (\$i==(\$tmp-1)) {
\t\t\$cw += \$rbw*_MPDFK;
\t\t\$contentB[(count(\$contentB)-1)] .= 'R';
\t}
\t// mPDF 5.6.45
\tif (\$c==' ') {
\t\t\$currContent .= \$c;
\t\t\$cutoffWidth = \$contentWidth;
\t\t\$contentWidth += \$cw;
\t\tcontinue;
\t}

\t// ADDED for Paragraph_indent
\t\$WidthCorrection = 0;
\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && isset(\$this->blk[\$this->blklvl]['text_indent']) && (\$lineCount == 0) && (!\$is_table) && (!\$is_list) && (\$align != 'C')) {
\t\t\$ti = \$this->ConvertSize(\$this->blk[\$this->blklvl]['text_indent'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t\$WidthCorrection = (\$ti*_MPDFK);
\t}

\t// Added mPDF 3.0 Float DIV
\t\$fpaddingR = 0;
\t\$fpaddingL = 0;
/*-- CSS-FLOAT --*/
\tif (count(\$this->floatDivs)) {
\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl);
\t\tif (\$r_exists) { \$fpaddingR = \$r_width; }
\t\tif (\$l_exists) { \$fpaddingL = \$l_width; }
\t}
/*-- END CSS-FLOAT --*/

\t\$usey = \$this->y + 0.002;
\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$lineCount == 0) ) {
\t\t\$usey += \$this->blk[\$this->blklvl]['margin_top'] + \$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w'];
\t}

/*-- CSS-IMAGE-FLOAT --*/
\t// If float exists at this level
\tif (isset(\$this->floatmargins['R']) && \$usey <= \$this->floatmargins['R']['y1'] && \$usey >= \$this->floatmargins['R']['y0'] && !\$this->floatmargins['R']['skipline']) { \$fpaddingR += \$this->floatmargins['R']['w']; }
\tif (isset(\$this->floatmargins['L']) && \$usey <= \$this->floatmargins['L']['y1'] && \$usey >= \$this->floatmargins['L']['y0'] && !\$this->floatmargins['L']['skipline']) { \$fpaddingL += \$this->floatmargins['L']['w']; }
/*-- END CSS-IMAGE-FLOAT --*/



       // try adding another char
\tif (( \$contentWidth + \$cw > \$maxWidth - \$WidthCorrection - ((\$this->cMarginL+\$this->cMarginR)*_MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) ) +  0.001))  {// 0.001 is to correct for deviations converting mm=>pts
\t\t// it won't fit, output what we already have
\t\t\$lineCount++;

\t\t// contains any content that didn't make it into this print
\t\t\$savedContent = '';
\t\t\$savedContentB = '';
\t\t\$savedFont = array();
\t\t\$savedObj = array();
\t\t// mPDF 5.6.20
\t\t\$savedPreContent = array();
\t\t\$savedPreContentB = array();
\t\t\$savedPreFont = array();

\t\t// cut off and save any partial words at the end of the string
\t\t\$words = explode( ' ', \$currContent );
\t\t///////////////////
\t\t// HYPHENATION
\t\t\$currWord = \$words[count(\$words)-1] ;
\t\t\$success = false;

\t\t// mPDF 5.6.21   Hard Hyphens -
\t\t\$hardsuccess = false;
\t\tif (\$this->textparam['hyphens'] != 2 && preg_match(\"/\\-/\",\$currWord)) {
\t\t\t\$rem = \$maxWidth - \$WidthCorrection - ((\$this->cMarginL+\$this->cMarginR)*_MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) );
\t\t\tlist(\$hardsuccess,\$pre,\$post,\$prelength) = \$this->hardHyphenate(\$currWord, ((\$rem-\$cutoffWidth)/_MPDFK -\$this->GetCharWidth(\"-\", false)) );
\t\t\tif (\$hardsuccess) {
\t\t\t\t\$already = array_pop( \$words );
\t\t\t\t\$forward = mb_substr(\$already,\$prelength+1,mb_strlen(\$already, \$this->mb_enc), \$this->mb_enc);
\t\t\t\t\$words[] = \$pre.'-';
\t\t\t\t\$words[] = \$forward;
\t\t\t\t\$currContent = mb_substr(\$currContent,0,mb_strlen(\$currContent, \$this->mb_enc)+1-mb_strlen(\$post, \$this->mb_enc), \$this->mb_enc) . '-';
\t\t\t}
\t\t}

/*-- HYPHENATION --*/
\t\t// Soft Hyphens chr(173)
\t\telse if (\$this->textparam['hyphens'] != 2 && (!\$this->usingCoreFont && preg_match(\"/\\xc2\\xad/\",\$currWord)) || (\$this->usingCoreFont && preg_match(\"/\".chr(173).\"/\",\$currWord) && (\$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats')) ) {\t// mPDF 5.6.06
\t\t\t\$rem = \$maxWidth - \$WidthCorrection - ((\$this->cMarginL+\$this->cMarginR)*_MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) );
\t\t\tlist(\$success,\$pre,\$post,\$prelength) = \$this->softHyphenate(\$currWord, ((\$rem-\$cutoffWidth)/_MPDFK -\$this->GetCharWidth(\" \", false)) );
\t\t}

\t\tif (!\$success && !\$hardsuccess && \$this->textparam['hyphens'] == 1 ) { \t// mPDF 5.6.06\t// mPDF 5.6.21
\t\t\t// Look ahead to get current word
\t\t\tfor(\$ac = \$i; \$ac<(mb_strlen(\$s)-1); \$ac++) {
\t\t\t\t\$addc = mb_substr(\$s,\$ac,1,\$this->mb_enc );
\t\t\t\tif (\$addc == ' ') { break; }
\t\t\t\t\$currWord .= \$addc;
\t\t\t}
\t\t\t\$rem = \$maxWidth - \$WidthCorrection - ((\$this->cMarginL+\$this->cMarginR)*_MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) );
\t\t\tlist(\$success,\$pre,\$post,\$prelength) = \$this->hyphenateWord(\$currWord, ((\$rem-\$cutoffWidth)/_MPDFK -\$this->GetCharWidth(\" \", false)) );
\t\t}
\t\tif (\$success) {
\t\t\t\$already = array_pop( \$words );
\t\t\t\$forward = mb_substr(\$already,\$prelength,mb_strlen(\$already, \$this->mb_enc), \$this->mb_enc);
\t\t\t\$words[] = \$pre.'-';
\t\t\t\$words[] = \$forward;
\t\t\t\$currContent = mb_substr(\$currContent,0,mb_strlen(\$currContent, \$this->mb_enc)+1-mb_strlen(\$post, \$this->mb_enc), \$this->mb_enc) . '-';
\t\t}
/*-- END HYPHENATION --*/

\t\t// mPDF 5.6.13 Decimal alignment (cancel if wraps to > 1 line)
\t\tif (\$is_table && substr(\$align,0,1)=='D' ) { \$align=substr(\$align,2,1); }

/*-- CJK-FONTS --*/
\t\t// mPDF 5.6.42
\t\tif (\$this->checkCJK) {
\t\t\t\$lastchar = mb_substr(\$words[(count(\$words)-1)],mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)-1, 1, \$this->mb_enc);
\t\t}
\t\t// Next character is suitable to add as overhanging or squeezed punctuation
\t\tif (\$this->checkCJK && preg_match(\"/[\".\$this->CJKoverflow.\"]/u\", \$c) && \$this->allowCJKorphans && !\$CJKoverflow) {
\t\t\t// add character onto this line
\t\t\t\$currContent .= \$c;
\t\t\t\$cutoffWidth = \$contentWidth;
\t\t\t\$contentWidth += \$cw;
\t\t\t\$CJKoverflow = true;
\t\t\tcontinue;
\t\t}
\t\t// Last character that fits is not allowed to end a line - move lastchar(s) to start of next line
\t\telse if (\$this->checkCJK && preg_match(\"/[\".\$this->CJKleading.\"]/u\", \$lastchar)) {
\t\t\t//move lastchar(s) to next line
\t\t\t\$m0 = \$lastchar;
\t\t\t\$m1 = \$c;
\t\t\twhile(preg_match(\"/[\".\$this->CJKleading.\"]/u\", \$m0) && mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)>2) {
\t\t\t\t// trim last letter off word[0]
\t\t\t\t\$words[(count(\$words)-1)] = mb_substr(\$words[(count(\$words)-1)],0,mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)-1, \$this->mb_enc);
\t\t\t\t// and add it to savedContent for next line
\t\t\t\t\$savedContent = \$m0.\$savedContent;
\t\t\t\t\$m1 = \$lastchar;
\t\t\t\t\$lastchar = mb_substr(\$words[(count(\$words)-1)],mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)-1, 1, \$this->mb_enc);
\t\t\t\t\$m0 = \$lastchar;
\t\t\t}
\t\t\t\$lastContent = '';
\t\t\tfor ( \$w = 0; \$w < count( \$words ) ; \$w++) { \$lastContent .= \$words[ \$w ].\" \"; }
\t\t\t\$savedFont = \$this->saveFont();
\t\t\t// replace the current content with the cropped version
\t\t\t\$currContent = rtrim( \$lastContent );
\t\t}
\t\t// Next character is not allowed to start a new line
\t\telse if (\$this->checkCJK && preg_match(\"/[\".\$this->CJKfollowing.\"]/u\", \$c)) {
\t\t\t// try squeezing another character(s) onto this line = Oikomi
\t\t\tif (\$this->allowCJKorphans && !\$CJKoverflow) {\t// mPDF 5.6.40
\t\t\t      \$lookahead = mb_substr(\$s,\$i+1,1,\$this->mb_enc );
\t\t\t\t//if lookahead is not another following char
\t\t\t\tif (!\$lookahead || (\$lookahead && !preg_match(\"/[\".\$this->CJKfollowing.\"]/u\", \$lookahead))) {
\t\t\t\t\t\$currContent .= \$c;
\t\t\t\t\t\$cutoffWidth = \$contentWidth;
\t\t\t\t\t\$contentWidth += \$cw;
\t\t\t\t\tif (\$this->allowCJKoverflow && preg_match(\"/[\".\$this->CJKoverflow.\"]/u\", \$c)) { \$CJKoverflow = true; }
\t\t\t\t\tcontinue;
\t\t\t\t}
\t\t\t}
\t\t\t// or move lastchar(s) to next line to keep \$c company = Oidashi
\t\t\t\$m0 = \$lastchar;
\t\t\t\$m1 = \$c;
\t\t\twhile(preg_match(\"/[\".\$this->CJKfollowing.\"]/u\", \$m1) && mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)>2) {
\t\t\t\t// trim last letter off word[0]
\t\t\t\t\$words[(count(\$words)-1)] = mb_substr(\$words[(count(\$words)-1)],0,mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)-1, \$this->mb_enc);
\t\t\t\t// and add it to savedContent for next line
\t\t\t\t\$savedContent = \$m0.\$savedContent;
\t\t\t\t\$m1 = \$lastchar;
\t\t\t\t\$lastchar = mb_substr(\$words[(count(\$words)-1)],mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)-1, 1, \$this->mb_enc);
\t\t\t\t\$m0 = \$lastchar;
\t\t\t}
\t\t\t\$lastContent = '';
\t\t\tfor ( \$w = 0; \$w < count( \$words ) ; \$w++) { \$lastContent .= \$words[ \$w ].\" \"; }
\t\t\t\$savedFont = \$this->saveFont();
\t\t\t// replace the current content with the cropped version
\t\t\t\$currContent = rtrim( \$lastContent );
\t\t}
\t\t// mPDF 5.6.42
\t  \telse if (\$this->checkCJK && preg_match(\"/([\".\$this->pregCJKchars.\"]+[0-9\\x{ff10}-\\x{ff19}]+\$)/u\", \$words[0])) {
\t\t\t\$lookahead = mb_substr(\$s,\$i,16,\$this->mb_enc );
\t\t\t//and if lookahead starts with a few numerals
\t\t\tif (\$lookahead && (preg_match(\"/^([0-9\\x{ff10}-\\x{ff19}]+[\".\$this->pregCJKchars.\"]+)/u\", \$lookahead) || preg_match(\"/^([0-9\\x{ff10}-\\x{ff19}]+\$)/u\", \$lookahead)) ) {
\t\t\t\t// or move lastchar(s) to next line to keep numerals together
\t\t\t\t\$m0 = \$lastchar;
\t\t\t\twhile(preg_match(\"/[0-9\\x{ff10}-\\x{ff19}]/u\", \$m0) && mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)>2) {
\t\t\t\t\t// trim last letter off word[0]
\t\t\t\t\t\$words[(count(\$words)-1)] = mb_substr(\$words[(count(\$words)-1)],0,mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)-1, \$this->mb_enc);
\t\t\t\t\t// and add it to savedContent for next line
\t\t\t\t\t\$savedContent = \$m0.\$savedContent;
\t\t\t\t\t\$lastchar = mb_substr(\$words[(count(\$words)-1)],mb_strlen(\$words[(count(\$words)-1)], \$this->mb_enc)-1, 1, \$this->mb_enc);
\t\t\t\t\t\$m0 = \$lastchar;
\t\t\t\t}
\t\t\t}
\t\t\t\$lastContent = '';
\t\t\tfor ( \$w = 0; \$w < count( \$words ) ; \$w++) { \$lastContent .= \$words[ \$w ].\" \"; }
\t\t\t\$savedFont = \$this->saveFont();
\t\t\t// replace the current content with the cropped version
\t\t\t\$currContent = rtrim( \$lastContent );
\t\t}
\t\telse
/*-- END CJK-FONTS --*/
\t\t// if it looks like we didn't finish any words for this chunk
\t\tif ( count( \$words ) == 1 ) {
\t\t  // TO correct for error when word too wide for page - but only when one long word from left to right margin
\t\t  if (count(\$content) == 1 && \$currContent != ' ') {
\t\t\t\$lastchar = mb_substr(\$words[0],mb_strlen(\$words[0], \$this->mb_enc)-1, 1, \$this->mb_enc);
\t\t\t\$lastContent = \$words[0];
\t\t\t\$savedFont = \$this->saveFont();
\t\t\t// replace the current content with the cropped version
\t\t\t\$currContent = rtrim( \$lastContent );
\t\t  }
\t\t  // mPDF 5.6.20
\t\t  else if (\tcount(\$content)>1
\t\t\t\t&& (!isset(\$this->objectbuffer[(count(\$content)-1)]) && !isset(\$this->objectbuffer[(count(\$content)-2)]))
\t\t\t\t&& substr(\$content[count(\$content)-2],-1,1) != ' '
\t\t\t\t&& substr(\$currContent,0,1) != ' '
\t\t\t) {
\t\t\t// Go back to find a space in a previous chunk of content
\t\t\t\$found = false;
\t\t\tfor (\$ix=count(\$content)-1;\$ix>=0;\$ix--) {
\t\t\t\t// mPDF 5.6.29
\t\t\t\tif (\$this->usingCoreFont && preg_match('/[ '.chr(173).']/',\$content[\$ix],\$m)) { \$match = \$m[0]; \$found = \$ix; break; }
\t\t\t\telse if (!\$this->usingCoreFont) {
\t\t\t\t\tif (preg_match('/[ ]/',\$content[\$ix])) { \$match = ' '; \$found = \$ix; break; }
\t\t\t\t\telse if (preg_match('/[\\x{00AD}]/u',\$content[\$ix])) {
\t\t\t\t\t\t// even though it is UTF-8 replace it temporarily with chr(173)
\t\t\t\t\t\t\$content[\$ix] = preg_replace('/[\\x{00AD}]/u',chr(173),\$content[\$ix]);
\t\t\t\t\t\t\$match = chr(173); \$found = \$ix; break;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\tif (\$found !== false) {
\t\t\t\t\$charpos = strrpos(\$content[\$found],\$match);\t// mPDF 5.6.29
\t\t\t\tfor (\$ix=count(\$content)-1;\$ix>\$found;\$ix--) {
\t\t\t\t\t// save and crop off any subsequent chunks
\t\t\t\t\t\$savedPreContent[] = array_pop(\$content);
\t\t\t\t\t\$savedPreContentB[] = array_pop(\$contentB);
\t\t\t\t\t\$savedPreFont[] = array_pop(\$font);
\t\t\t\t}
\t\t\t\tif (substr(\$content[count(\$content)-1],\$charpos+1,strlen(\$content[count(\$content)-1])-1) != '') {
\t\t\t\t\t\$savedPreContent[] = substr(\$content[count(\$content)-1],\$charpos+1,strlen(\$content[count(\$content)-1])-1);
\t\t\t\t\t\$savedPreContentB[] = preg_replace('/L/','',\$contentB[count(\$content)-1]);\t// ???
\t\t\t\t\t\$savedPreFont[] = \$font[count(\$content)-1];
\t\t\t\t}
\t\t\t\t\$savedContent = '';
\t\t\t\t\$savedContentB = '';
\t\t\t\t\$savedFont = array();

\t\t\t\t\$currContent =& \$content[ count( \$content ) - 1 ];
\t\t\t\t\$currContent = substr(\$currContent,0,\$charpos);
\t\t\t\tif (\$match == chr(173)) { \$currContent .= '-'; }\t// mPDF 5.6.29
\t\t\t\tif (strpos(\$contentB[(count(\$contentB)-1)],'R')!==false) {\t\t\t// ???
\t\t\t\t\t\$contentB[count(\$content)-1] = preg_replace('/R/','',\$contentB[count(\$content)-1]);\t// ???
\t\t\t\t}

\t\t\t\t\$currContent = rtrim( \$currContent );
\t\t\t}
\t\t\telse {
\t\t\t\t\$savedContent = array_pop( \$content );
\t\t\t\t\$savedContentB = array_pop(\$contentB);
\t\t\t\t\$savedFont = array_pop( \$font );
\t\t\t\t\$currContent =& \$content[ count( \$content ) - 1 ];
\t\t\t\t\$currContent = rtrim( \$currContent );
\t\t\t}
\t\t  }
\t\t  else {
\t\t\t// save and crop off the content currently on the stack
\t\t\t\$savedContent = array_pop( \$content );
\t\t\t\$savedContentB = array_pop(\$contentB);\t// mPDF 5.6.20
\t\t\t\$savedFont = array_pop( \$font );

\t\t\t// mPDF 5.7.2
\t\t\t// e.g: |first chunk |second chunk |[IndexEntry]|doesntfit
\t\t\tif (isset(\$this->objectbuffer[(count(\$content)-1)]) && \$this->objectbuffer[(count(\$content)-1)]['OUTER-WIDTH'] < 0.001) {
\t\t\t\t\$savedObj = \$this->objectbuffer[(count(\$content)-1)];
\t\t\t\tarray_pop( \$content );
\t\t\t\tarray_pop( \$contentB );
\t\t\t\tarray_pop( \$font );
\t\t\t\tarray_pop( \$this->objectbuffer );
\t\t\t}

\t\t\t// trim any trailing spaces off the last bit of content
\t\t\t\$currContent =& \$content[ count( \$content ) - 1 ];
\t\t\t\$currContent = rtrim( \$currContent );
\t\t  }
\t\t}
\t\telse {\t// otherwise, we need to find which bit to cut off
\t\t  \$lastContent = '';
              for ( \$w = 0; \$w < count( \$words ) - 1; \$w++) { \$lastContent .= \$words[ \$w ].\" \"; }
              \$savedContent = \$words[ count( \$words ) - 1 ];
              \$savedFont = \$this->saveFont();
              // replace the current content with the cropped version
              \$currContent = rtrim( \$lastContent );
\t\t}
\t\t// CJK - strip CJK space at end of line
\t\t// &#x3000; = \\xe3\\x80\\x80 = CJK space
\t\tif (\$this->checkCJK) { \$currContent = preg_replace(\"/\\xe3\\x80\\x80\$/\",'',\$currContent) ; }\t// *CJK-FONTS*


\t\tif (isset(\$this->objectbuffer[(count(\$content)-1)]) && \$this->objectbuffer[(count(\$content)-1)]['type']=='dottab') {
\t\t\t\$savedObj = array_pop( \$this->objectbuffer );
\t\t\t\$contentWidth -= (\$this->objectbuffer[(count(\$content)-1)]['OUTER-WIDTH'] * _MPDFK);
\t\t}

\t\t// Set Current lineheight (correction factor)
\t\t\$lhfixed = false;
/*-- LISTS --*/
\t\tif (\$is_list) {
\t\t\tif (preg_match('/([0-9.,]+)mm/',\$this->list_lineheight[\$this->listlvl][\$this->listOcc],\$am)) {
\t\t\t\t\$lhfixed = true;
\t\t\t\t\$def_fontsize = \$this->InlineProperties['LISTITEM'][\$this->listlvl][\$this->listOcc][\$this->listnum]['size'];
\t\t\t\t\$this->lineheight_correction = \$am[1] / \$def_fontsize ;
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->lineheight_correction = \$this->list_lineheight[\$this->listlvl][\$this->listOcc];
\t\t\t}
\t\t}
\t\telse
/*-- END LISTS --*/
/*-- TABLES --*/
\t\tif (\$is_table) {
\t\t\tif (preg_match('/([0-9.,]+)mm/',\$this->table_lineheight,\$am)) {
\t\t\t\t\$lhfixed = true;
\t\t\t\t\$def_fontsize = \$this->FontSize; \t\t\t\t// needs to be default font-size for block ****
\t\t\t\t\$this->lineheight_correction = \$lineHeight / \$def_fontsize ;
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->lineheight_correction = \$this->table_lineheight;
\t\t\t}
\t\t}
\t\telse
/*-- END TABLES --*/
\t\tif (isset(\$this->blk[\$this->blklvl]['line_height']) && \$this->blk[\$this->blklvl]['line_height']) {
\t\t\tif (preg_match('/([0-9.,]+)mm/',\$this->blk[\$this->blklvl]['line_height'],\$am)) {
\t\t\t\t\$lhfixed = true;
\t\t\t\t\$def_fontsize = \$this->blk[\$this->blklvl]['InlineProperties']['size']; \t// needs to be default font-size for block ****
\t\t\t\t\$this->lineheight_correction = \$am[1] / \$def_fontsize ;
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->lineheight_correction = \$this->blk[\$this->blklvl]['line_height'];
\t\t\t}
\t\t}
\t\telse {
\t\t\t\$this->lineheight_correction = \$this->normalLineheight;
\t\t}
\t\t// update \$contentWidth and \$cutoffWidth since they changed with cropping
\t\t// Also correct lineheight to maximum fontsize (not for tables)
\t\t\$contentWidth = 0;
\t\t//  correct lineheight to maximum fontsize
\t\tif (\$lhfixed) { \$maxlineHeight = \$this->lineheight; }
\t\telse { \$maxlineHeight = 0; }
\t\t\$this->forceExactLineheight = true;
\t\t\$maxfontsize = 0;
\t\t// While we're at it, check for cursive text
\t\t\$checkCursive=false;
\t\tif (\$this->biDirectional) {  \$checkCursive=true; }\t// *RTL*
\t\tforeach ( \$content as \$k => \$chunk )
\t\t{
              \$this->restoreFont( \$font[ \$k ]);
\t\t  if (!isset(\$this->objectbuffer[\$k])) {
\t\t\t// mPDF 5.6.40
\t\t\tif (\$this->checkCJK && \$k == count(\$content)-1 && \$CJKoverflow && \$align=='J' && \$this->allowCJKoverflow && \$this->CJKforceend) {
\t\t\t  // force-end overhang
\t\t\t\t\$hanger = mb_substr(\$chunk,mb_strlen(\$chunk,\$this->mb_enc)-1,1,\$this->mb_enc );
\t\t\t\t\$content[\$k] = \$chunk = mb_substr(\$chunk,0,mb_strlen(\$chunk,\$this->mb_enc)-1,\$this->mb_enc );
\t\t\t}
\t\t\tif (!\$this->usingCoreFont) {
\t\t\t      \$content[\$k] = \$chunk = str_replace(\"\\xc2\\xad\",'',\$chunk );
\t\t\t\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) {  \$checkCursive=true; }\t// *INDIC*
\t\t\t}
\t\t\t// Soft Hyphens chr(173)
\t\t\telse if (\$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats') {
\t\t\t      \$content[\$k] = \$chunk = str_replace(chr(173),'',\$chunk );
\t\t\t}
\t\t\t\$contentWidth += \$this->GetStringWidth( \$chunk ) * _MPDFK;
\t\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\tif (strpos(\$contentB[\$k],'L')!==false) \$contentWidth += \$this->spanborddet['L']['w'] * _MPDFK;
\t\t\t\tif (strpos(\$contentB[\$k],'R')!==false) \$contentWidth += \$this->spanborddet['R']['w'] * _MPDFK;
\t\t\t}
\t\t\tif (!\$lhfixed) { \$maxlineHeight = max(\$maxlineHeight,\$this->FontSize * \$this->lineheight_correction ); }
\t\t\tif (\$lhfixed && (\$this->FontSize > \$def_fontsize || (\$this->FontSize > (\$lineHeight * \$this->lineheight_correction) && \$is_list))) {
\t\t\t\t\$this->forceExactLineheight = false;
\t\t\t}
\t\t\t\$maxfontsize = max(\$maxfontsize,\$this->FontSize);
\t\t  }
\t\t}

\t\t\$lastfontreqstyle = \$font[count(\$font)-1]['ReqFontStyle'];
\t\t\$lastfontstyle = \$font[count(\$font)-1]['style'];
\t\tif (\$blockdir == 'ltr' && strpos(\$lastfontreqstyle,\"I\") !== false && strpos(\$lastfontstyle,\"I\") === false) {\t// Artificial italic
\t\t\t\$lastitalic = \$this->FontSize*0.15*_MPDFK;
\t\t}
\t\telse { \$lastitalic = 0; }


/*-- LISTS --*/
\t\tif (\$is_list && is_array(\$this->bulletarray) && \$this->bulletarray) {
\t  \t\t\$actfs = \$this->bulletarray['fontsize'];
\t\t\tif (!\$lhfixed) { \$maxlineHeight = max(\$maxlineHeight,\$actfs * \$this->lineheight_correction );  }
\t\t\tif (\$lhfixed && \$actfs > \$def_fontsize) { \$this->forceExactLineheight = false; }
\t\t\t\$maxfontsize = max(\$maxfontsize,\$actfs);
\t\t}
/*-- END LISTS --*/

\t\t// when every text item checked i.e. \$maxfontsize is set properly

\t\t\$af = 0; \t// Above font
\t\t\$bf = 0; \t// Below font
\t\t\$mta = 0;\t// Maximum top-aligned
\t\t\$mba = 0;\t// Maximum bottom-aligned

\t\tforeach ( \$content as \$k => \$chunk ) {
\t\t  if (isset(\$this->objectbuffer[\$k]) && \$this->objectbuffer[\$k]) {
\t\t\t\$contentWidth += \$this->objectbuffer[\$k]['OUTER-WIDTH'] * _MPDFK;
\t\t\t\$oh = \$this->objectbuffer[\$k]['OUTER-HEIGHT'];
\t\t\t\$va = \$this->objectbuffer[\$k]['vertical-align']; // = \$objattr['vertical-align'] = set as M,T,B,S
\t\t\tif (\$lhfixed && \$oh > \$def_fontsize) { \$this->forceExactLineheight = false; }

\t\t\tif (\$va == 'BS') {\t//  (BASELINE default)
\t\t\t\t\$af = max(\$af, (\$oh - (\$maxfontsize * (0.5 + \$this->baselineC))));
\t\t\t}
\t\t\telse if (\$va == 'M') {
\t\t\t\t\$af = max(\$af, (\$oh - \$maxfontsize)/2);
\t\t\t\t\$bf = max(\$bf, (\$oh - \$maxfontsize)/2);
\t\t\t}
\t\t\telse if (\$va == 'TT') {
\t\t\t\t\$bf = max(\$bf, (\$oh - \$maxfontsize));
\t\t\t}
\t\t\telse if (\$va == 'TB') {
\t\t\t\t\$af = max(\$af, (\$oh - \$maxfontsize));
\t\t\t}
\t\t\telse if (\$va == 'T') {
\t\t\t\t\$mta = max(\$mta, \$oh);
\t\t\t}
\t\t\telse if (\$va == 'B') {
\t\t\t\t\$mba = max(\$mba, \$oh);
\t\t\t}
\t\t  }
\t\t  // mPDF 5.7.3  inline text-decoration parameters
\t\t  else if (!\$is_table && isset(\$font[\$k]['textparam']['text-baseline'])) {
\t\t\tif (\$font[\$k]['textparam']['text-baseline'] > 0) { \t// superscript
\t\t\t\t\$nh = (\$maxfontsize * \$this->baselineC) + \$font[\$k]['textparam']['text-baseline'] + (\$font[\$k]['size'] * (1-\$this->baselineC));
\t\t\t\tif (\$lhfixed && \$nh > \$def_fontsize) { \$this->forceExactLineheight = false; }
\t\t\t\t\$af = max(\$af, (\$nh-\$maxfontsize));
\t\t\t}
\t\t\telse if (\$font[\$k]['textparam']['text-baseline'] < 0) {\t// subscript
\t\t\t\t\$nh = (\$maxfontsize * (1-\$this->baselineC)) - \$font[\$k]['textparam']['text-baseline'] + (\$font[\$k]['size'] * \$this->baselineC);
\t\t\t\tif (\$lhfixed && \$nh > \$def_fontsize) { \$this->forceExactLineheight = false; }
\t\t\t\t\$bf = max(\$bf, (\$nh-\$maxfontsize));
\t\t\t}
\t\t  }
\t\t}
\t\tif ((!\$lhfixed || !\$this->forceExactLineheight) && (\$af > ((\$maxlineHeight - \$maxfontsize)/2) || \$bf > ((\$maxlineHeight - \$maxfontsize)/2))) {
\t\t\t\$maxlineHeight = \$maxfontsize + \$af + \$bf;
\t\t}
\t\telse if (!\$lhfixed) { \$af = \$bf = (\$maxlineHeight - \$maxfontsize)/2; }

\t\tif (\$mta > \$maxlineHeight) {
\t\t\t\$bf += (\$mta - \$maxlineHeight);
\t\t\t\$maxlineHeight = \$mta;
\t\t}
\t\tif (\$mba > \$maxlineHeight) {
\t\t\t\$af += (\$mba - \$maxlineHeight);
\t\t\t\$maxlineHeight = \$mba;
\t\t}


\t\t\$lineHeight = \$maxlineHeight;
\t\t\$cutoffWidth = \$contentWidth;
\t\t// If NOT images, and maxfontsize NOT > lineHeight - this value determines text baseline positioning
\t\tif (\$lhfixed && \$af==0 && \$bf==0 && \$maxfontsize<=(\$def_fontsize * \$this->lineheight_correction * 0.8 )) {
\t\t\t\$this->linemaxfontsize = \$def_fontsize;
\t\t}
\t\telse { \$this->linemaxfontsize = \$maxfontsize; }


\t\t\$inclCursive=false;
\t\tforeach ( \$content as \$k => \$chunk ) {
\t\t\tif (!isset(\$this->objectbuffer[\$k]) || (isset(\$this->objectbuffer[\$k]) && !\$this->objectbuffer[\$k])) {
\t\t\t\tif (\$this->usingCoreFont) {
\t\t\t\t      \$content[\$k] = str_replace(chr(160),chr(32),\$chunk );
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t      \$content[\$k] = str_replace(chr(194).chr(160),chr(32),\$chunk );
\t\t\t\t\tif (\$checkCursive) {
\t\t\t\t\t\tif (preg_match(\"/([\".\$this->pregRTLchars.\"])/u\", \$chunk)) { \$inclCursive = true; }\t// *RTL*
\t\t\t\t\t\tif (preg_match(\"/([\".\$this->pregHIchars.\$this->pregBNchars.\$this->pregPAchars.\"])/u\", \$chunk)) { \$inclCursive = true; }\t// *INDIC*
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t}

\t\t// JUSTIFICATION J
\t\t\$jcharspacing = 0;
\t\t\$jws = 0;
\t\t\$nb_carac = 0;
\t\t\$nb_spaces = 0;
\t\t// if it's justified, we need to find the char/word spacing (or if orphans have allowed length of line to go over the maxwidth)
\t\tif ( (\$align == 'J' && !\$CJKoverflow) || ((\$cutoffWidth + \$lastitalic > \$maxWidth - \$WidthCorrection - ((\$this->cMarginL+\$this->cMarginR)*_MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) ) +  0.001) && (!\$CJKoverflow || (\$CJKoverflow && !\$this->allowCJKoverflow))) || \$CJKoverflow && \$align=='J' && \$this->allowCJKoverflow && \$hanger && \$this->CJKforceend) {   // 0.001 is to correct for deviations converting mm=>pts\t// mPDF 5.6.40
\t\t  // JUSTIFY J (Use character spacing)
 \t\t  // WORD SPACING
\t\t\tforeach ( \$content as \$k => \$chunk ) {
\t\t\t\tif (!isset(\$this->objectbuffer[\$k]) || (isset(\$this->objectbuffer[\$k]) && !\$this->objectbuffer[\$k])) {
\t\t\t\t\t\$nb_carac += mb_strlen( \$chunk, \$this->mb_enc ) ;
\t\t\t\t\t\$nb_spaces += mb_substr_count( \$chunk,' ', \$this->mb_enc ) ;
\t\t\t\t}
\t\t\t}
\t\t\tlist(\$jcharspacing,\$jws) = \$this->GetJspacing(\$nb_carac,\$nb_spaces,(\$maxWidth-\$lastitalic-\$cutoffWidth-\$WidthCorrection-((\$this->cMarginL+\$this->cMarginR)*_MPDFK)-(\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) )),\$inclCursive);
\t\t}


\t\t// WORD SPACING
\t\t\$empty = \$maxWidth - \$lastitalic-\$WidthCorrection - \$contentWidth - ((\$this->cMarginL+\$this->cMarginR)* _MPDFK) - (\$paddingL+\$paddingR +((\$fpaddingL + \$fpaddingR) * _MPDFK) );

\t\t\$empty -= (\$jcharspacing * \$nb_carac);
\t\t\$empty -= (\$jws * \$nb_spaces);

\t\t\$empty /= _MPDFK;
\t\t\$b = ''; //do not use borders
\t\t// Get PAGEBREAK TO TEST for height including the top border/padding
\t\t\$check_h = max(\$this->divheight,\$lineHeight);
\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$this->blklvl > 0) && (\$lineCount == 1) && (!\$is_table) && (!\$is_list)) {
\t\t\t\$check_h += (\$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['margin_top'] + \$this->blk[\$this->blklvl]['border_top']['w']);
\t\t}

\t\tif (\$this->ColActive && \$check_h > (\$this->PageBreakTrigger - \$this->y0)) {
\t\t\t\$this->SetCol(\$this->NbCol-1);
\t\t}

\t\t// PAGEBREAK
\t\t// 'If' below used in order to fix \"first-line of other page with justify on\" bug
\t\tif(!\$is_table && (\$this->y+\$check_h) > \$this->PageBreakTrigger and !\$this->InFooter and \$this->AcceptPageBreak()) {
\t\t\t\$bak_x=\$this->x;//Current X position

\t\t\t// WORD SPACING
\t\t\t\$ws=\$this->ws;//Word Spacing
\t\t\t\$charspacing=\$this->charspacing;//Character Spacing
\t\t\t\$this->ResetSpacing();

\t\t      \$this->AddPage(\$this->CurOrientation);

\t\t      \$this->x = \$bak_x;
\t\t\t// Added to correct for OddEven Margins
\t\t\t\$currentx += \$this->MarginCorrection;
\t\t\t\$this->x += \$this->MarginCorrection;

\t\t\t// WORD SPACING
\t\t\t\$this->SetSpacing(\$charspacing,\$ws);
\t\t}

\t\tif (\$this->keep_block_together && !\$is_table && \$this->kt_p00 < \$this->page && (\$this->y+\$check_h) > \$this->kt_y00) {
\t\t\t\$this->printdivbuffer();
\t\t\t\$this->keep_block_together = 0;
\t\t}

\t\tif (\$this->kwt && !\$is_table) {\t// mPDF 5.7+
\t\t\t\$this->printkwtbuffer();
\t\t\t\$this->kwt = false;
\t\t}

/*-- COLUMNS --*/
\t\t// COLS
\t\t// COLUMN CHANGE
\t\tif (\$this->CurrCol != \$oldcolumn) {
\t\t\t\$currentx += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t\t\$this->x += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t\t\$oldcolumn = \$this->CurrCol;
\t\t}

\t\tif (\$this->ColActive && !\$is_table) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
/*-- END COLUMNS --*/

\t\t// TOP MARGIN
\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$this->blk[\$this->blklvl]['margin_top']) && (\$lineCount == 1) && (!\$is_table) && (!\$is_list)) {
\t\t\t\$this->DivLn(\$this->blk[\$this->blklvl]['margin_top'],\$this->blklvl-1,true,\$this->blk[\$this->blklvl]['margin_collapse']);
\t\t\tif (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
\t\t}


\t\t// Update y0 for top of block (used to paint border)
\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$lineCount == 1) && (!\$is_table) && (!\$is_list)) {
\t\t\t\$this->blk[\$this->blklvl]['y0'] = \$this->y;
\t\t\t\$this->blk[\$this->blklvl]['startpage'] = \$this->page;
\t\t\tif (\$this->blk[\$this->blklvl]['float']) { \$this->blk[\$this->blklvl]['float_start_y'] = \$this->y; } // mPDF 5.6.63
\t\t}

\t\t// TOP PADDING and BORDER spacing/fill
\t\tif ((\$newblock) && (\$blockstate==1 || \$blockstate==3) && ((\$this->blk[\$this->blklvl]['padding_top']) || (\$this->blk[\$this->blklvl]['border_top'])) && (\$lineCount == 1) && (!\$is_table) && (!\$is_list)) {
\t\t\t// \$state = 0 normal; 1 top; 2 bottom; 3 top and bottom
\t\t\t\$this->DivLn(\$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w'],-3,true,false,1);
\t\t\tif (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
\t\t}

\t\t\$arraysize = count(\$content);

\t\t\$margins = (\$this->cMarginL+\$this->cMarginR) + (\$ipaddingL+\$ipaddingR + \$fpaddingR + \$fpaddingR );

\t\t// PAINT BACKGROUND FOR THIS LINE
\t\tif (!\$is_table) { \$this->DivLn(\$lineHeight,\$this->blklvl,false); }\t// false -> don't advance y

\t\t\$this->x = \$currentx + \$this->cMarginL + \$ipaddingL + \$fpaddingL ;
\t\tif (\$align == 'R') { \$this->x += \$empty; }
\t\telse if (\$align == 'C') { \$this->x += (\$empty / 2); }

\t\t// Paragraph INDENT
\t\tif (isset(\$this->blk[\$this->blklvl]['text_indent']) && (\$newblock) && (\$blockstate==1 || \$blockstate==3) && (\$lineCount == 1) && (!\$is_table) && (\$blockdir !='rtl') && (\$align !='C')) {
\t\t\t\$ti = \$this->ConvertSize(\$this->blk[\$this->blklvl]['text_indent'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t\t\$this->x += \$ti;
\t\t}

\t\t// DIRECTIONALITY RTL
\t\t\$all_rtl = false;
\t\t\$contains_rtl = false;
/*-- RTL --*/
   \t\tif (\$blockdir == 'rtl' || \$this->biDirectional)  {
\t\t\t\$all_rtl = true;
\t\t\tforeach ( \$content as \$k => \$chunk ) {
\t\t\t\t\$reversed = \$this->magic_reverse_dir(\$chunk, false, \$blockdir);

\t\t\t\tif (\$reversed > 0) { \$contains_rtl = true; }
\t\t\t\tif (\$reversed < 2) { \$all_rtl = false; }
\t\t\t\t\$content[\$k] = \$chunk;
\t\t\t}
\t\t\tif ((\$blockdir =='rtl' && \$contains_rtl) || \$all_rtl) {
\t\t\t\t\$content = array_reverse(\$content,false);
\t\t\t\t\$contentB = array_reverse(\$contentB,false);
\t\t\t}
\t\t}
/*-- END RTL --*/

\t\tforeach ( \$content as \$k => \$chunk ) {

\t\t\t// FOR IMAGES - UPDATE POSITION
\t\t\tif ((\$blockdir =='rtl' && \$contains_rtl) || \$all_rtl) { \$dirk = \$arraysize-1 - \$k ; } else { \$dirk = \$k; }

\t\t\t\$va = 'M';\t// default for text
\t\t\tif (isset(\$this->objectbuffer[\$dirk]) && \$this->objectbuffer[\$dirk]) {
\t\t\t  \$xadj = \$this->x - \$this->objectbuffer[\$dirk]['OUTER-X'] ;
\t\t\t  \$this->objectbuffer[\$dirk]['OUTER-X'] += \$xadj;
\t\t\t  \$this->objectbuffer[\$dirk]['BORDER-X'] += \$xadj;
\t\t\t  \$this->objectbuffer[\$dirk]['INNER-X'] += \$xadj;
\t\t\t  \$va = \$this->objectbuffer[\$dirk]['vertical-align'];
\t\t\t  \$yadj = \$this->y - \$this->objectbuffer[\$dirk]['OUTER-Y'];
\t\t\t  if (\$va == 'BS') {
\t\t\t\t\$yadj += \$af + (\$this->linemaxfontsize * (0.5 + \$this->baselineC)) - \$this->objectbuffer[\$dirk]['OUTER-HEIGHT'];
\t\t\t  }
\t\t\t  else if (\$va == 'M' || \$va == '') {
\t\t\t\t\$yadj += \$af + (\$this->linemaxfontsize /2) - (\$this->objectbuffer[\$dirk]['OUTER-HEIGHT']/2);
\t\t\t  }
\t\t\t  else if (\$va == 'TB') {
\t\t\t\t\$yadj += \$af + \$this->linemaxfontsize - \$this->objectbuffer[\$dirk]['OUTER-HEIGHT'];
\t\t\t  }
\t\t\t  else if (\$va == 'TT') {
\t\t\t\t\$yadj += \$af;
\t\t\t  }
\t\t\t  else if (\$va == 'B') {
\t\t\t\t\$yadj += \$af + \$this->linemaxfontsize + \$bf - \$this->objectbuffer[\$dirk]['OUTER-HEIGHT'];
\t\t\t  }
\t\t\t  else if (\$va == 'T') {
\t\t\t\t\$yadj += 0;
\t\t\t  }
\t\t\t  \$this->objectbuffer[\$dirk]['OUTER-Y'] += \$yadj;
\t\t\t  \$this->objectbuffer[\$dirk]['BORDER-Y'] += \$yadj;
\t\t\t  \$this->objectbuffer[\$dirk]['INNER-Y'] += \$yadj;
\t\t\t}

\t\t\t// DIRECTIONALITY RTL
\t\t\tif (((\$blockdir == 'rtl') && (\$contains_rtl )) || (\$all_rtl )) { \$this->restoreFont(\$font[\$arraysize-1 - \$k]); }
\t\t\telse { \$this->restoreFont( \$font[ \$k ] ); }

\t\t\t\$this->SetSpacing((\$this->fixedlSpacing*_MPDFK)+\$jcharspacing,(\$this->fixedlSpacing+\$this->minwSpacing)*_MPDFK+\$jws);
\t\t\t// Now unset these values so they don't influence GetStringwidth below or in fn. Cell
\t\t\t\$this->fixedlSpacing = false;
\t\t\t\$this->minwSpacing = 0;

\t\t\t// mPDF 5.6.26
\t\t\t\$save_vis = \$this->visibility;
\t\t\tif (isset(\$this->textparam['visibility']) && \$this->textparam['visibility'] && \$this->textparam['visibility'] != \$this->visibility) {
\t\t\t\t\$this->SetVisibility(\$this->textparam['visibility']);
\t\t\t}
\t \t\t// *********** SPAN BACKGROUND COLOR ***************** //
\t\t\tif (\$this->spanbgcolor) {
\t\t\t\t\$cor = \$this->spanbgcolorarray;
\t\t\t\t\$this->SetFColor(\$cor);
\t\t\t\t\$save_fill = \$fill; \$spanfill = 1; \$fill = 1;
\t\t\t}
\t\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\tif (strpos(\$contentB[\$k],'L')!==false) \$this->x += \$this->spanborddet['L']['w'];
\t\t\t\tif (strpos(\$contentB[\$k],'L')===false) \$this->spanborddet['L']['s'] = \$this->spanborddet['L']['w'] = 0;
\t\t\t\tif (strpos(\$contentB[\$k],'R')===false) \$this->spanborddet['R']['s'] = \$this->spanborddet['R']['w'] = 0;
\t\t\t}

\t\t\t// WORD SPACING
\t\t      \$stringWidth = \$this->GetStringWidth(\$chunk );
\t\t\t\$stringWidth += ( \$this->charspacing * mb_strlen(\$chunk,\$this->mb_enc ) / _MPDFK );
\t\t\t\$stringWidth += ( \$this->ws * mb_substr_count(\$chunk,' ',\$this->mb_enc ) / _MPDFK );
\t\t\tif (isset(\$this->objectbuffer[\$dirk])) { \$stringWidth = \$this->objectbuffer[\$dirk]['OUTER-WIDTH'];  }

\t\t\tif (\$stringWidth==0) { \$stringWidth = 0.000001; }
\t\t\tif (\$k == \$arraysize-1) {
\t\t\t\t\$stringWidth -= ( \$this->charspacing / _MPDFK );
\t\t\t\t// mPDF 5.6.40
\t\t\t\tif (\$this->checkCJK && \$CJKoverflow && \$align=='J' && \$this->allowCJKoverflow && \$hanger && \$this->CJKforceend) {
\t\t\t\t  // force-end overhang
\t\t\t\t\t\$this->Cell( \$stringWidth, \$lineHeight, \$chunk, '', 0, '', \$fill, \$this->HREF, \$currentx,0,0,'M', \$fill, \$af, \$bf, true );
\t\t\t\t\t\$this->Cell( \$this->GetStringWidth(\$hanger), \$lineHeight, \$hanger, '', 1, '', \$fill, \$this->HREF, \$currentx,0,0,'M', \$fill, \$af, \$bf, true );
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$this->Cell( \$stringWidth, \$lineHeight, \$chunk, '', 1, '', \$fill, \$this->HREF, \$currentx,0,0,'M', \$fill, \$af, \$bf, true ); //mono-style line or last part (skips line)
\t\t\t\t}

\t\t\t}
\t\t\telse \$this->Cell( \$stringWidth, \$lineHeight, \$chunk, '', 0, '', \$fill, \$this->HREF, 0, 0,0,'M', \$fill, \$af, \$bf, true );//first or middle part

\t\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\tif (strpos(\$contentB[\$k],'R')!==false && \$k != \$arraysize-1)  \$this->x += \$this->spanborddet['R']['w'];
\t\t\t}
\t \t\t// *********** SPAN BACKGROUND COLOR OFF - RESET BLOCK BGCOLOR ***************** //
\t\t\tif (isset(\$spanfill) && \$spanfill) {
\t\t\t\t\$fill = \$save_fill; \$spanfill = 0;
\t\t\t\tif (\$fill) { \$this->SetFColor(\$bcor); }
\t\t\t}
\t\t\t// mPDF 5.6.26
\t\t\tif (isset(\$this->textparam['visibility']) && \$this->textparam['visibility'] && \$this->visibility != \$save_vis) {
\t\t\t\t\$this->SetVisibility(\$save_vis);
\t\t\t}

\t\t}
\t\tif (!\$is_table) {
\t\t\t\$this->maxPosR = max(\$this->maxPosR , (\$this->w - \$this->rMargin - \$this->blk[\$this->blklvl]['outer_right_margin']));
\t\t\t\$this->maxPosL = min(\$this->maxPosL , (\$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin']));
\t\t}

\t\t// move on to the next line, reset variables, tack on saved content and current char

\t\t\$this->printobjectbuffer(\$is_table, \$blockdir);
\t\t\$this->objectbuffer = array();

/*-- LISTS --*/
\t\t// LIST BULLETS/NUMBERS
\t\tif (\$is_list && is_array(\$this->bulletarray) && (\$lineCount == 1) ) {

\t\t  \$this->ResetSpacing();

\t\t  \$bull = \$this->bulletarray;
\t  \t  if (isset(\$bull['level']) && isset(\$bull['occur']) && isset(\$this->InlineProperties['LIST'][\$bull['level']][\$bull['occur']])) {
\t\t\t\$this->restoreInlineProperties(\$this->InlineProperties['LIST'][\$bull['level']][\$bull['occur']]);
\t\t  }
\t\t  if (isset(\$bull['level']) && isset(\$bull['occur']) && isset(\$bull['num']) && isset(\$this->InlineProperties['LISTITEM'][\$bull['level']][\$bull['occur']][\$bull['num']]) && \$this->InlineProperties['LISTITEM'][\$bull['level']][\$bull['occur']][\$bull['num']]) { \$this->restoreInlineProperties(\$this->InlineProperties['LISTITEM'][\$bull['level']][\$bull['occur']][\$bull['num']]); }
\t  \t  if (isset(\$bull['font']) && \$bull['font'] == 'czapfdingbats') {
\t\t\t\$this->bullet = true;
\t\t\t\$this->SetFont('czapfdingbats','',\$this->FontSizePt/2.5);
\t\t  }
\t\t  else { \$this->SetFont(\$this->FontFamily,\$this->FontStyle,\$this->FontSizePt,true,true); }\t// force output
\t        //Output bullet
\t  \t  \$this->x = \$currentx;
\t \t  if (isset(\$bull['x'])) { \$this->x += \$bull['x']; }
\t\t  \$this->y -= \$lineHeight;
\t\t  if (isset(\$bull['col']) && \$bull['col']) { \$this->SetTColor(\$bull['col']); }\t// mPDF 5.6.67
\t\t  if (isset(\$bull['txt'])) { \$this->Cell(\$bull['w'], \$lineHeight,\$bull['txt'],'','',\$bull['align'],0,'',0,-\$this->cMarginL, -\$this->cMarginR ); }
\t  \t  if (isset(\$bull['font']) && \$bull['font'] == 'czapfdingbats') {
\t\t\t\$this->bullet = false;
\t\t  }
\t\t  \$this->x = \$currentx;\t// Reset
\t\t  \$this->y += \$lineHeight;

\t\t  if (\$this->ColActive && !\$is_table) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*

\t\t  \$this->bulletarray = array();\t// prevents repeat of bullet/number if <li>....<br />.....</li>
\t\t}
/*-- END LISTS --*/


/*-- CSS-IMAGE-FLOAT --*/
\t\t// Update values if set to skipline
\t\tif (\$this->floatmargins) { \$this->_advanceFloatMargins(); }
/*-- END CSS-IMAGE-FLOAT --*/

\t\t// Reset lineheight
\t\t\$lineHeight = \$this->divheight;
\t\t\$valign = 'M';

\t\t\$font = array();
\t\t\$content = array();
\t\t\$contentB = array();
\t\t\$contentWidth = 0;
\t\tif (!empty(\$savedObj)) {
\t\t\t\$this->objectbuffer[] = \$savedObj;
\t\t\t\$font[] = \$savedFont;
\t\t\t\$content[] = '';
\t\t\t\$contentB[] = '';
\t\t\t\$contentWidth += \$savedObj['OUTER-WIDTH'] * _MPDFK;
\t\t}
\t\t// mPDF 5.6.20
\t\tif (count(\$savedPreContent) > 0) {
\t\t\tfor(\$ix=count(\$savedPreContent)-1;\$ix>=0;\$ix--) {
\t\t\t\t\$font[] = \$savedPreFont[\$ix];
\t\t\t\t\$content[] = \$savedPreContent[\$ix];
\t\t\t\t\$contentB[] = \$savedPreContentB[\$ix];
\t\t\t\t\$this->restoreFont( \$savedPreFont[\$ix] );
\t\t\t\t\$lbw = \$rbw = 0;\t// Border widths
\t\t\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\t\t\$lbw = \$this->spanborddet['L']['w'];
\t\t\t\t\t\$rbw = \$this->spanborddet['R']['w'];
\t\t\t\t}
\t\t\t\tif (\$ix>0) {
\t\t\t\t\t\$contentWidth += \$this->GetStringWidth( \$savedPreContent[\$ix] ) * _MPDFK;
\t\t\t\t\tif (strpos(\$savedPreContentB[\$ix],'L')!==false) \$contentWidth += \$lbw;
\t\t\t\t\tif (strpos(\$savedPreContentB[\$ix],'R')!==false) \$contentWidth += \$rbw;
\t\t\t\t}
\t\t\t}
\t\t\t\$savedPreContent = array();
\t\t\t\$savedPreContentB = array();
\t\t\t\$savedPreFont = array();
\t\t\t\$content[ (count(\$content)-1) ] .= \$c;
\t\t}
\t\telse {
\t\t\t\$font[] = \$savedFont;
\t\t\t\$content[] = \$savedContent . \$c;
\t\t\t\$contentB[] = \$savedContentB ;
\t\t}

\t\t\$currContent =& \$content[ (count(\$content)-1) ];

\t\t// CJK - strip CJK space at end of line
\t\t// &#x3000; = \\xe3\\x80\\x80 = CJK space
\t\tif (\$this->checkCJK && \$currContent == \"\\xe3\\x80\\x80\") { \$currContent = '' ; }\t// *CJK-FONTS*

\t\t\$this->restoreFont( \$savedFont );
\t\t\$lbw = \$rbw = 0;\t// Border widths
\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\$lbw = \$this->spanborddet['L']['w'];
\t\t\t\$rbw = \$this->spanborddet['R']['w'];
\t\t}
\t\t\$contentWidth += \$this->GetStringWidth( \$currContent ) * _MPDFK;
\t\tif (strpos(\$savedContentB,'L')!==false) \$contentWidth += \$lbw;
\t\t\$cutoffWidth = \$contentWidth;
\t\t\$CJKoverflow = false;
\t\t\$hanger = '';\t// mPDF 5.6.40
      }
      // another character will fit, so add it on
\telse {
\t\t\$contentWidth += \$cw;
\t\t\$currContent .= \$c;
\t}
    }
    unset(\$content);
    unset(\$contentB);
}
//----------------------END OF FLOWING BLOCK------------------------------------//


/*-- CSS-IMAGE-FLOAT --*/
// Update values if set to skipline
function _advanceFloatMargins() {
\t// Update floatmargins - L
\tif (isset(\$this->floatmargins['L']) && \$this->floatmargins['L']['skipline'] && \$this->floatmargins['L']['y0'] != \$this->y) {
\t\t\$yadj = \$this->y - \$this->floatmargins['L']['y0'];
\t\t\$this->floatmargins['L']['y0'] = \$this->y;
\t\t\$this->floatmargins['L']['y1'] += \$yadj;

\t\t// Update objattr in floatbuffer
\t\tif (\$this->floatbuffer[\$this->floatmargins['L']['id']]['border_left']['w']) {
\t\t\t\$this->floatbuffer[\$this->floatmargins['L']['id']]['BORDER-Y'] += \$yadj;
\t\t}
\t\t\$this->floatbuffer[\$this->floatmargins['L']['id']]['INNER-Y'] += \$yadj;
\t\t\$this->floatbuffer[\$this->floatmargins['L']['id']]['OUTER-Y'] += \$yadj;

\t\t// Unset values
\t\t\$this->floatbuffer[\$this->floatmargins['L']['id']]['skipline'] = false;
\t\t\$this->floatmargins['L']['skipline'] = false;
\t\t\$this->floatmargins['L']['id'] = '';
\t}
\t// Update floatmargins - R
\tif (isset(\$this->floatmargins['R']) && \$this->floatmargins['R']['skipline'] && \$this->floatmargins['R']['y0'] != \$this->y) {
\t\t\$yadj = \$this->y - \$this->floatmargins['R']['y0'];
\t\t\$this->floatmargins['R']['y0'] = \$this->y;
\t\t\$this->floatmargins['R']['y1'] += \$yadj;

\t\t// Update objattr in floatbuffer
\t\tif (\$this->floatbuffer[\$this->floatmargins['R']['id']]['border_left']['w']) {
\t\t\t\$this->floatbuffer[\$this->floatmargins['R']['id']]['BORDER-Y'] += \$yadj;
\t\t}
\t\t\$this->floatbuffer[\$this->floatmargins['R']['id']]['INNER-Y'] += \$yadj;
\t\t\$this->floatbuffer[\$this->floatmargins['R']['id']]['OUTER-Y'] += \$yadj;

\t\t// Unset values
\t\t\$this->floatbuffer[\$this->floatmargins['R']['id']]['skipline'] = false;
\t\t\$this->floatmargins['R']['skipline'] = false;
\t\t\$this->floatmargins['R']['id'] = '';
\t}
}
/*-- END CSS-IMAGE-FLOAT --*/



////////////////////////////////////////////////////////////////////////////////
// ADDED forcewrap - to call from inline OBJECT functions to breakwords if necessary in cell
////////////////////////////////////////////////////////////////////////////////
function WordWrap(&\$text, \$maxwidth, \$forcewrap = 0) {
    \$biggestword=0;
    \$toonarrow=false;

    \$text = trim(\$text);

    if (\$text==='') return 0;
    \$space = \$this->GetCharWidth(' ',false);
    \$lines = explode(\"\\n\", \$text);
    \$text = '';
    \$count = 0;
    foreach (\$lines as \$line) {
\t\$words = explode(' ', \$line);
\t\$width = 0;
\tforeach (\$words as \$word) {
\t\t\$word = trim(\$word);
\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\t//Warn user that maxwidth is insufficient
\t\tif (\$wordwidth > \$maxwidth + 0.0001) {
\t\t\tif (\$wordwidth > \$biggestword) { \$biggestword = \$wordwidth; }
\t\t\t\$toonarrow=true;
\t\t\t// ADDED
\t\t\tif (\$forcewrap) {
\t\t\t  while(\$wordwidth > \$maxwidth) {
\t\t\t\t\$chw = 0;\t// check width
\t\t\t\tfor ( \$i = 0; \$i < mb_strlen(\$word, \$this->mb_enc ); \$i++ ) {
\t\t\t\t\t\$chw = \$this->GetStringWidth(mb_substr(\$word,0,\$i+1,\$this->mb_enc ));
\t\t\t\t\tif (\$chw > \$maxwidth ) {
\t\t\t\t\t\tif (\$text) {
\t\t\t\t\t\t\t\$text = rtrim(\$text).\"\\n\".mb_substr(\$word,0,\$i,\$this->mb_enc );
\t\t\t\t\t\t\t\$count++;
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$text = mb_substr(\$word,0,\$i,\$this->mb_enc );
\t\t\t\t\t\t}
\t\t\t\t\t\t\$word = mb_substr(\$word,\$i,mb_strlen(\$word, \$this->mb_enc )-\$i,\$this->mb_enc );
\t\t\t\t\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\t\t\t\t\t\$width = \$maxwidth;
\t\t\t\t\t\tbreak;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t  }
\t\t\t}
\t\t}

\t\tif (\$width + \$wordwidth  < \$maxwidth - 0.0001) {
\t\t\t\$width += \$wordwidth + \$space;
\t\t\t\$text .= \$word.' ';
\t\t}
\t\telse {
\t\t\t\$width = \$wordwidth + \$space;
\t\t\t\$text = rtrim(\$text).\"\\n\".\$word.' ';
\t\t\t\$count++;
            }
\t}
\t\$text .= \"\\n\";
\t\$count++;
    }
    \$text = rtrim(\$text);

    //Return -(wordsize) if word is bigger than maxwidth

\t// ADDED
\tif (\$forcewrap) { return \$count; }
      if ((\$toonarrow) && (\$this->table_error_report)) {
\t\t\$this->Error(\"Word is too long to fit in table - \".\$this->table_error_report_param);
\t}
    if (\$toonarrow) return -\$biggestword;
    else return \$count;
}

/*-- END HTML-CSS --*/

function _SetTextRendering(\$mode) {
\tif (!((\$mode == 0) || (\$mode == 1) || (\$mode == 2)))
\t\$this->Error(\"Text rendering mode should be 0, 1 or 2 (value : \$mode)\");
\t\$tr = (\$mode.' Tr');
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['TextRendering']) && \$this->pageoutput[\$this->page]['TextRendering'] != \$tr) || !isset(\$this->pageoutput[\$this->page]['TextRendering']) || \$this->keep_block_together)) { \$this->_out(\$tr); }
\t\$this->pageoutput[\$this->page]['TextRendering'] = \$tr;

}

function SetTextOutline(\$params=array()) {\t// mPDF 5.6.07
  if (isset(\$params['outline-s']) && \$params['outline-s'])
  {
    \$this->SetLineWidth(\$params['outline-WIDTH']);
    \$this->SetDColor(\$params['outline-COLOR']);
    \$tr = ('2 Tr');
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['TextRendering']) && \$this->pageoutput[\$this->page]['TextRendering'] != \$tr) || !isset(\$this->pageoutput[\$this->page]['TextRendering']) || \$this->keep_block_together)) { \$this->_out(\$tr); }
\t\$this->pageoutput[\$this->page]['TextRendering'] = \$tr;
  }
  else //Now resets all values
  {
    \$this->SetLineWidth(0.2);
    \$this->SetDColor(\$this->ConvertColor(0));
    \$this->_SetTextRendering(0);
    \$tr = ('0 Tr');
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['TextRendering']) && \$this->pageoutput[\$this->page]['TextRendering'] != \$tr) || !isset(\$this->pageoutput[\$this->page]['TextRendering']) || \$this->keep_block_together)) { \$this->_out(\$tr); }
\t\$this->pageoutput[\$this->page]['TextRendering'] = \$tr;
  }
}

function Image(\$file,\$x,\$y,\$w=0,\$h=0,\$type='',\$link='',\$paint=true, \$constrain=true, \$watermark=false, \$shownoimg=true, \$allowvector=true) {
\t\$orig_srcpath = \$file;
\t\$this->GetFullPath(\$file);

\t\$info=\$this->_getImage(\$file, true, \$allowvector, \$orig_srcpath );
\tif(!\$info && \$paint) {
\t\t\$info = \$this->_getImage(\$this->noImageFile);
\t\tif (\$info) {
\t\t\t\$file = \$this->noImageFile;
\t\t\t\$w = (\$info['w'] * (25.4/\$this->dpi)); \t// 14 x 16px
\t\t\t\$h = (\$info['h'] * (25.4/\$this->dpi)); \t// 14 x 16px
\t\t}
\t}
\tif(!\$info) return false;
\t//Automatic width and height calculation if needed
\tif(\$w==0 and \$h==0) {
/*-- IMAGES-WMF --*/
           if (\$info['type']=='wmf') {
\t\t\t// WMF units are twips (1/20pt)
\t\t\t// divide by 20 to get points
\t\t\t// divide by k to get user units
\t\t\t\$w = abs(\$info['w'])/(20*_MPDFK);
\t\t\t\$h = abs(\$info['h']) / (20*_MPDFK);
\t\t}
\t\telse
/*-- END IMAGES-WMF --*/
           if (\$info['type']=='svg') {
\t\t\t// returned SVG units are pts
\t\t\t// divide by k to get user units (mm)
\t\t\t\$w = abs(\$info['w'])/_MPDFK;
\t\t\t\$h = abs(\$info['h']) /_MPDFK;
\t\t}
\t\telse {
\t\t\t//Put image at default image dpi
\t\t\t\$w=(\$info['w']/_MPDFK) * (72/\$this->img_dpi);
\t\t\t\$h=(\$info['h']/_MPDFK) * (72/\$this->img_dpi);
\t\t}
\t}
\tif(\$w==0)\t\$w=abs(\$h*\$info['w']/\$info['h']);
\tif(\$h==0)\t\$h=abs(\$w*\$info['h']/\$info['w']);

/*-- WATERMARK --*/
\tif (\$watermark) {
\t  \$maxw = \$this->w;
\t  \$maxh = \$this->h;
\t  // Size = D PF or array
\t  if (is_array(\$this->watermark_size)) {
\t\t\$w = \$this->watermark_size[0];
\t\t\$h = \$this->watermark_size[1];
\t  }
\t  else if (!is_string(\$this->watermark_size)) {
\t\t\$maxw -= \$this->watermark_size*2;
\t\t\$maxh -= \$this->watermark_size*2;
\t\t\$w = \$maxw;
\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t\tif (\$h > \$maxh )  {
\t\t\t\$h = \$maxh ; \$w=abs(\$h*\$info['w']/\$info['h']);
\t\t}
\t  }
\t  else if (\$this->watermark_size == 'F') {
\t\tif (\$this->ColActive) { \$maxw = \$this->w - (\$this->DeflMargin + \$this->DefrMargin); }
\t\telse { \$maxw = \$this->pgwidth; }
\t\t\$maxh = \$this->h - (\$this->tMargin + \$this->bMargin);
\t\t\$w = \$maxw;
\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t\tif (\$h > \$maxh )  {
\t\t\t\$h = \$maxh ; \$w=abs(\$h*\$info['w']/\$info['h']);
\t\t}
\t  }
\t  else  if (\$this->watermark_size == 'P') {\t// Default P
\t\t\$w = \$maxw;
\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t\tif (\$h > \$maxh )  {
\t\t\t\$h = \$maxh ; \$w=abs(\$h*\$info['w']/\$info['h']);
\t\t}
\t  }
\t  // Automatically resize to maximum dimensions of page if too large
\t  if (\$w > \$maxw) {
\t\t\$w = \$maxw;
\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t  }
\t  if (\$h > \$maxh )  {
\t\t\$h = \$maxh ;
\t\t\$w=abs(\$h*\$info['w']/\$info['h']);
\t  }
\t  // Position
\t  if (is_array(\$this->watermark_pos)) {
\t\t\$x = \$this->watermark_pos[0];
\t\t\$y = \$this->watermark_pos[1];
\t  }
\t  else if (\$this->watermark_pos == 'F')  {\t// centred on printable area
\t\tif (\$this->ColActive) {\t// *COLUMNS*
\t\t\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) { \$xadj = \$this->DeflMargin-\$this->DefrMargin; }\t// *COLUMNS*
\t\t\telse { \$xadj = 0; }\t// *COLUMNS*
\t\t\t\$x = (\$this->DeflMargin - \$xadj + (\$this->w - (\$this->DeflMargin + \$this->DefrMargin))/2) - (\$w/2);\t// *COLUMNS*
\t\t}\t// *COLUMNS*
\t\telse { \t// *COLUMNS*
\t\t\t\$x = (\$this->lMargin + (\$this->pgwidth)/2) - (\$w/2);
\t\t}\t// *COLUMNS*
\t\t\$y = (\$this->tMargin + (\$this->h - (\$this->tMargin + \$this->bMargin))/2) - (\$h/2);
\t  }
\t  else {\t// default P - centred on whole page
\t\t\$x = (\$this->w/2) - (\$w/2);
\t\t\$y = (\$this->h/2) - (\$h/2);
\t  }
/*-- IMAGES-WMF --*/
\t  if (\$info['type']=='wmf') {
\t\t\$sx = \$w*_MPDFK / \$info['w'];
\t\t\$sy = -\$h*_MPDFK / \$info['h'];
\t\t\$outstring = sprintf('q %.3F 0 0 %.3F %.3F %.3F cm /FO%d Do Q', \$sx, \$sy, \$x*_MPDFK-\$sx*\$info['x'], ((\$this->h-\$y)*_MPDFK)-\$sy*\$info['y'], \$info['i']);
\t  }
\t  else
/*-- END IMAGES-WMF --*/
\t  if (\$info['type']=='svg') {
\t\t\$sx = \$w*_MPDFK / \$info['w'];
\t\t\$sy = -\$h*_MPDFK / \$info['h'];
\t\t\$outstring = sprintf('q %.3F 0 0 %.3F %.3F %.3F cm /FO%d Do Q', \$sx, \$sy, \$x*_MPDFK-\$sx*\$info['x'], ((\$this->h-\$y)*_MPDFK)-\$sy*\$info['y'], \$info['i']);
\t  }
\t  else {
\t\t\$outstring = sprintf(\"q %.3F 0 0 %.3F %.3F %.3F cm /I%d Do Q\",\$w*_MPDFK,\$h*_MPDFK,\$x*_MPDFK,(\$this->h-(\$y+\$h))*_MPDFK,\$info['i']);
\t  }

\t  if (\$this->watermarkImgBehind) {
\t\t\$outstring = \$this->watermarkImgAlpha . \"\\n\" . \$outstring . \"\\n\" . \$this->SetAlpha(1, 'Normal', true) . \"\\n\";
\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', \"\\n\".\$outstring.\"\\n\".'\\\\1', \$this->pages[\$this->page]);
\t  }
\t  else { \$this->_out(\$outstring); }

\t  return 0;
\t}\t// end of IF watermark
/*-- END WATERMARK --*/

\tif (\$constrain) {
\t  // Automatically resize to maximum dimensions of page if too large
\t  if (isset(\$this->blk[\$this->blklvl]['inner_width']) && \$this->blk[\$this->blklvl]['inner_width']) { \$maxw = \$this->blk[\$this->blklvl]['inner_width']; }
\t  else { \$maxw = \$this->pgwidth; }
\t  if (\$w > \$maxw) {
\t\t\$w = \$maxw;
\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t  }
\t  if (\$h > \$this->h - (\$this->tMargin + \$this->bMargin + 1))  {  // see below - +10 to avoid drawing too close to border of page
   \t\t\$h = \$this->h - (\$this->tMargin + \$this->bMargin + 1) ;
\t\tif (\$this->fullImageHeight) { \$h = \$this->fullImageHeight; }
\t\t\$w=abs(\$h*\$info['w']/\$info['h']);
\t  }


\t  //Avoid drawing out of the paper(exceeding width limits).
\t  //if ( (\$x + \$w) > \$this->fw ) {
\t  if ( (\$x + \$w) > \$this->w ) {
\t\t\$x = \$this->lMargin;
\t\t\$y += 5;
\t  }

\t  \$changedpage = false;
\t  \$oldcolumn = \$this->CurrCol;
\t  //Avoid drawing out of the page.
\t  if(\$y+\$h>\$this->PageBreakTrigger and !\$this->InFooter and \$this->AcceptPageBreak()) {
\t\t\$this->AddPage(\$this->CurOrientation);
\t\t// Added to correct for OddEven Margins
\t\t\$x=\$x +\$this->MarginCorrection;
\t\t\$y = \$this->tMargin;\t// mPDF 5.7.3
\t\t\$changedpage = true;
\t  }
/*-- COLUMNS --*/
\t  // COLS
\t  // COLUMN CHANGE
\t  if (\$this->CurrCol != \$oldcolumn) {
\t\t\$y = \$this->y0;
\t\t\$x += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t\$this->x += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t  }
/*-- END COLUMNS --*/
\t}\t// end of IF constrain

/*-- IMAGES-WMF --*/
\tif (\$info['type']=='wmf') {
\t\t\$sx = \$w*_MPDFK / \$info['w'];
\t\t\$sy = -\$h*_MPDFK / \$info['h'];
\t\t\$outstring = sprintf('q %.3F 0 0 %.3F %.3F %.3F cm /FO%d Do Q', \$sx, \$sy, \$x*_MPDFK-\$sx*\$info['x'], ((\$this->h-\$y)*_MPDFK)-\$sy*\$info['y'], \$info['i']);
\t}
\telse
/*-- END IMAGES-WMF --*/
\tif (\$info['type']=='svg') {
\t\t\$sx = \$w*_MPDFK / \$info['w'];
\t\t\$sy = -\$h*_MPDFK / \$info['h'];
\t\t\$outstring = sprintf('q %.3F 0 0 %.3F %.3F %.3F cm /FO%d Do Q', \$sx, \$sy, \$x*_MPDFK-\$sx*\$info['x'], ((\$this->h-\$y)*_MPDFK)-\$sy*\$info['y'], \$info['i']);
\t}
\telse {
\t\t\$outstring = sprintf(\"q %.3F 0 0 %.3F %.3F %.3F cm /I%d Do Q\",\$w*_MPDFK,\$h*_MPDFK,\$x*_MPDFK,(\$this->h-(\$y+\$h))*_MPDFK,\$info['i']);
\t}

\tif(\$paint) {
\t\t\$this->_out(\$outstring);
\t\tif(\$link) \$this->Link(\$x,\$y,\$w,\$h,\$link);

\t\t// Avoid writing text on top of the image. // THIS WAS OUTSIDE THE if (\$paint) bit!!!!!!!!!!!!!!!!
\t\t\$this->y = \$y + \$h;
\t}

\t//Return width-height array
\t\$sizesarray['WIDTH'] = \$w;
\t\$sizesarray['HEIGHT'] = \$h;
\t\$sizesarray['X'] = \$x; //Position before painting image
\t\$sizesarray['Y'] = \$y; //Position before painting image
\t\$sizesarray['OUTPUT'] = \$outstring;

\t\$sizesarray['IMAGE_ID'] = \$info['i'];
\t\$sizesarray['itype'] = \$info['type'];
\t\$sizesarray['set-dpi'] = \$info['set-dpi'];
\treturn \$sizesarray;
}



//=============================================================
//=============================================================
//=============================================================
//=============================================================
//=============================================================
/*-- HTML-CSS --*/

function _getObjAttr(\$t) {
\t\$c = explode(\"\\xbb\\xa4\\xac\",\$t,2);
\t\$c = explode(\",\",\$c[1],2);
\tforeach(\$c as \$v) {
\t\t\$v = explode(\"=\",\$v,2);
\t\t\$sp[\$v[0]] = \$v[1];
\t}
\treturn (unserialize(\$sp['objattr']));
}


function inlineObject(\$type,\$x,\$y,\$objattr,\$Lmargin,\$widthUsed,\$maxWidth,\$lineHeight,\$paint=false,\$is_table=false)
{
   if (\$is_table) { \$k = \$this->shrin_k; } else { \$k = 1; }

   // NB \$x is only used when paint=true
\t// Lmargin not used
   \$w = 0;
   if (isset(\$objattr['width'])) { \$w = \$objattr['width']/\$k; }
   \$h = 0;
   if (isset(\$objattr['height'])) { \$h = abs(\$objattr['height']/\$k); }
   \$widthLeft = \$maxWidth - \$widthUsed;
   \$maxHeight = \$this->h - (\$this->tMargin + \$this->bMargin + 10) ;
   if (\$this->fullImageHeight) { \$maxHeight = \$this->fullImageHeight; }
   // For Images
   if (isset(\$objattr['border_left'])) {
\t\$extraWidth = (\$objattr['border_left']['w'] + \$objattr['border_right']['w'] + \$objattr['margin_left']+ \$objattr['margin_right'])/\$k;
\t\$extraHeight = (\$objattr['border_top']['w'] + \$objattr['border_bottom']['w'] + \$objattr['margin_top']+ \$objattr['margin_bottom'])/\$k;

\tif (\$type == 'image' || \$type == 'barcode' || \$type == 'textcircle') {
\t\t\$extraWidth += (\$objattr['padding_left'] + \$objattr['padding_right'])/\$k;
\t\t\$extraHeight += (\$objattr['padding_top'] + \$objattr['padding_bottom'])/\$k;
\t}
   }

   if (!isset(\$objattr['vertical-align'])) { \$objattr['vertical-align'] = 'M'; }

   if (\$type == 'image' || (isset(\$objattr['subtype']) && \$objattr['subtype'] == 'IMAGE')) {
    if (isset(\$objattr['itype']) && (\$objattr['itype'] == 'wmf' || \$objattr['itype'] == 'svg')) {
\t\$file = \$objattr['file'];
 \t\$info=\$this->formobjects[\$file];
    }
    else if (isset(\$objattr['file'])) {
\t\$file = \$objattr['file'];
\t\$info=\$this->images[\$file];
    }
   }
    if (\$type == 'annot' || \$type == 'bookmark' || \$type == 'indexentry' || \$type == 'toc') {
\t\$w = 0.00001;
\t\$h = 0.00001;
   }

   // TEST whether need to skipline
   if (!\$paint) {
\tif (\$type == 'hr') {\t// always force new line
\t\tif ((\$y + \$h + \$lineHeight > \$this->PageBreakTrigger) && !\$this->InFooter && !\$is_table) { return array(-2, \$w ,\$h ); } // New page + new line
\t\telse { return array(1, \$w ,\$h ); } // new line
\t}
\telse {
\t\tif (\$widthUsed > 0 && \$w > \$widthLeft && (!\$is_table || \$type != 'image')) { \t// New line needed
\t\t\tif ((\$y + \$h + \$lineHeight > \$this->PageBreakTrigger) && !\$this->InFooter) { return array(-2,\$w ,\$h ); } // New page + new line
\t\t\treturn array(1,\$w ,\$h ); // new line
\t\t}
\t\telse if (\$widthUsed > 0 && \$w > \$widthLeft && \$is_table) { \t// New line needed in TABLE
\t\t\treturn array(1,\$w ,\$h ); // new line
\t\t}
\t\t// Will fit on line but NEW PAGE REQUIRED
\t\telse if ((\$y + \$h > \$this->PageBreakTrigger) && !\$this->InFooter && !\$is_table) { return array(-1,\$w ,\$h ); }
\t\telse { return array(0,\$w ,\$h ); }
\t}
   }

   if (\$type == 'annot' || \$type == 'bookmark' || \$type == 'indexentry' || \$type == 'toc') {
\t\$w = 0.00001;
\t\$h = 0.00001;
\t\$objattr['BORDER-WIDTH'] = 0;
\t\$objattr['BORDER-HEIGHT'] = 0;
\t\$objattr['BORDER-X'] = \$x;
\t\$objattr['BORDER-Y'] = \$y;
\t\$objattr['INNER-WIDTH'] = 0;
\t\$objattr['INNER-HEIGHT'] = 0;
\t\$objattr['INNER-X'] = \$x;
\t\$objattr['INNER-Y'] = \$y;
  }

  if (\$type == 'image') {
\t// Automatically resize to width remaining
\tif (\$w > \$widthLeft  && !\$is_table) {
\t\t\$w = \$widthLeft ;
\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t}
\t\$img_w = \$w - \$extraWidth ;
\t\$img_h = \$h - \$extraHeight ;

\t\$objattr['BORDER-WIDTH'] = \$img_w + \$objattr['padding_left']/\$k + \$objattr['padding_right']/\$k + ((\$objattr['border_left']['w']/\$k + \$objattr['border_right']['w']/\$k)/2) ;
\t\$objattr['BORDER-HEIGHT'] = \$img_h + \$objattr['padding_top']/\$k + \$objattr['padding_bottom']/\$k + ((\$objattr['border_top']['w']/\$k + \$objattr['border_bottom']['w']/\$k)/2) ;
\t\$objattr['BORDER-X'] = \$x + \$objattr['margin_left']/\$k + ((\$objattr['border_left']['w']/\$k)/2) ;
\t\$objattr['BORDER-Y'] = \$y + \$objattr['margin_top']/\$k + ((\$objattr['border_top']['w']/\$k)/2) ;
\t\$objattr['INNER-WIDTH'] = \$img_w;
\t\$objattr['INNER-HEIGHT'] = \$img_h;
\t\$objattr['INNER-X'] = \$x + \$objattr['padding_left']/\$k + \$objattr['margin_left']/\$k + (\$objattr['border_left']['w']/\$k);
\t\$objattr['INNER-Y'] = \$y + \$objattr['padding_top']/\$k + \$objattr['margin_top']/\$k + (\$objattr['border_top']['w']/\$k) ;
\t\$objattr['ID'] = \$info['i'];
   }

   if (\$type == 'input' && \$objattr['subtype'] == 'IMAGE') {
\t\$img_w = \$w - \$extraWidth ;
\t\$img_h = \$h - \$extraHeight ;
\t\$objattr['BORDER-WIDTH'] = \$img_w + ((\$objattr['border_left']['w']/\$k + \$objattr['border_right']['w']/\$k)/2) ;
\t\$objattr['BORDER-HEIGHT'] = \$img_h + ((\$objattr['border_top']['w']/\$k + \$objattr['border_bottom']['w']/\$k)/2) ;
\t\$objattr['BORDER-X'] = \$x + \$objattr['margin_left']/\$k + ((\$objattr['border_left']['w']/\$k)/2) ;
\t\$objattr['BORDER-Y'] = \$y + \$objattr['margin_top']/\$k + ((\$objattr['border_top']['w']/\$k)/2) ;
\t\$objattr['INNER-WIDTH'] = \$img_w;
\t\$objattr['INNER-HEIGHT'] = \$img_h;
\t\$objattr['INNER-X'] = \$x + \$objattr['margin_left']/\$k + (\$objattr['border_left']['w']/\$k);
\t\$objattr['INNER-Y'] = \$y + \$objattr['margin_top']/\$k + (\$objattr['border_top']['w']/\$k) ;
\t\$objattr['ID'] = \$info['i'];
   }

  if (\$type == 'barcode' || \$type == 'textcircle') {
\t\$b_w = \$w - \$extraWidth ;
\t\$b_h = \$h - \$extraHeight ;
\t\$objattr['BORDER-WIDTH'] = \$b_w + \$objattr['padding_left']/\$k + \$objattr['padding_right']/\$k + ((\$objattr['border_left']['w']/\$k + \$objattr['border_right']['w']/\$k)/2) ;
\t\$objattr['BORDER-HEIGHT'] = \$b_h + \$objattr['padding_top']/\$k + \$objattr['padding_bottom']/\$k + ((\$objattr['border_top']['w']/\$k + \$objattr['border_bottom']['w']/\$k)/2) ;
\t\$objattr['BORDER-X'] = \$x + \$objattr['margin_left']/\$k + ((\$objattr['border_left']['w']/\$k)/2) ;
\t\$objattr['BORDER-Y'] = \$y + \$objattr['margin_top']/\$k + ((\$objattr['border_top']['w']/\$k)/2) ;
\t\$objattr['INNER-X'] = \$x + \$objattr['padding_left']/\$k + \$objattr['margin_left']/\$k + (\$objattr['border_left']['w']/\$k);
\t\$objattr['INNER-Y'] = \$y + \$objattr['padding_top']/\$k + \$objattr['margin_top']/\$k + (\$objattr['border_top']['w']/\$k) ;
\t\$objattr['INNER-WIDTH'] = \$b_w;
\t\$objattr['INNER-HEIGHT'] = \$b_h;
   }


   if (\$type == 'textarea') {
\t// Automatically resize to width remaining
\tif (\$w > \$widthLeft && !\$is_table) {
\t\t\$w = \$widthLeft ;
\t}
\tif ((\$y + \$h > \$this->PageBreakTrigger) && !\$this->InFooter) {
\t\t\$h=\$this->h - \$y - \$this->bMargin;
\t}
   }

   if (\$type == 'hr') {
\tif (\$is_table) {
\t\t\$objattr['INNER-WIDTH'] = \$maxWidth * \$objattr['W-PERCENT']/100;
\t\t\$objattr['width'] = \$objattr['INNER-WIDTH'];
\t\t\$w = \$maxWidth;
\t}
\telse {
\t\tif (\$w>\$maxWidth) { \$w = \$maxWidth; }
\t\t\$objattr['INNER-WIDTH'] = \$w;
\t\t\$w = \$maxWidth;
\t}
  }



   if ((\$type == 'select') || (\$type == 'input' && (\$objattr['subtype'] == 'TEXT' || \$objattr['subtype'] == 'PASSWORD'))) {
\t// Automatically resize to width remaining
\tif (\$w > \$widthLeft && !\$is_table) {
\t\t\$w = \$widthLeft;
\t}
   }

   if (\$type == 'textarea' || \$type == 'select' || \$type == 'input') {
\tif (isset(\$objattr['fontsize'])) \$objattr['fontsize'] /= \$k;
\tif (isset(\$objattr['linewidth'])) \$objattr['linewidth'] /= \$k;
   }

   if (!isset(\$objattr['BORDER-Y'])) { \$objattr['BORDER-Y'] = 0; }
   if (!isset(\$objattr['BORDER-X'])) { \$objattr['BORDER-X'] = 0; }
   if (!isset(\$objattr['INNER-Y'])) { \$objattr['INNER-Y'] = 0; }
   if (!isset(\$objattr['INNER-X'])) { \$objattr['INNER-X'] = 0; }

   //Return width-height array
   \$objattr['OUTER-WIDTH'] = \$w;
   \$objattr['OUTER-HEIGHT'] = \$h;
   \$objattr['OUTER-X'] = \$x;
   \$objattr['OUTER-Y'] = \$y;
   return \$objattr;
}

/*-- END HTML-CSS --*/

//=============================================================
//=============================================================
//=============================================================
//=============================================================
//=============================================================

function SetLineJoin(\$mode=0)
{
\t\$s=sprintf('%d j',\$mode);
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['LineJoin']) && \$this->pageoutput[\$this->page]['LineJoin'] != \$s) || !isset(\$this->pageoutput[\$this->page]['LineJoin']) || \$this->keep_block_together)) { \$this->_out(\$s); }
\t\$this->pageoutput[\$this->page]['LineJoin'] = \$s;

}
function SetLineCap(\$mode=2) {
\t\$s=sprintf('%d J',\$mode);
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['LineCap']) && \$this->pageoutput[\$this->page]['LineCap'] != \$s) || !isset(\$this->pageoutput[\$this->page]['LineCap']) || \$this->keep_block_together)) { \$this->_out(\$s); }
\t\$this->pageoutput[\$this->page]['LineCap'] = \$s;

}

function SetDash(\$black=false,\$white=false)
{
        if(\$black and \$white) \$s=sprintf('[%.3F %.3F] 0 d',\$black*_MPDFK,\$white*_MPDFK);
        else \$s='[] 0 d';
\tif(\$this->page>0 && ((isset(\$this->pageoutput[\$this->page]['Dash']) && \$this->pageoutput[\$this->page]['Dash'] != \$s) || !isset(\$this->pageoutput[\$this->page]['Dash']) || \$this->keep_block_together)) { \$this->_out(\$s); }
\t\$this->pageoutput[\$this->page]['Dash'] = \$s;

}

function SetDisplayPreferences(\$preferences) {
\t// String containing any or none of /HideMenubar/HideToolbar/HideWindowUI/DisplayDocTitle/CenterWindow/FitWindow
    \$this->DisplayPreferences .= \$preferences;
}


function Ln(\$h='',\$collapsible=0)
{
// Added collapsible to allow collapsible top-margin on new page
\t//Line feed; default value is last cell height
\t\$this->x = \$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'];
\tif (\$collapsible && (\$this->y==\$this->tMargin) && (!\$this->ColActive)) { \$h = 0; }
\tif(is_string(\$h)) \$this->y+=\$this->lasth;
\telse \$this->y+=\$h;
}

/*-- HTML-CSS --*/
// \$state = 0 normal; 1 top; 2 bottom; 3 top and bottom
function DivLn(\$h,\$level=-3,\$move_y=true,\$collapsible=false,\$state=0) {
  // this->x is returned as it was
  // adds lines (y) where DIV bgcolors are filled in
  // allows .00001 as nominal height used for bookmarks/annotations etc.
  if (\$collapsible && (sprintf(\"%0.4f\", \$this->y)==sprintf(\"%0.4f\", \$this->tMargin)) && (!\$this->ColActive)) { return; }
  if (\$collapsible && (sprintf(\"%0.4f\", \$this->y)==sprintf(\"%0.4f\", \$this->y0)) && (\$this->ColActive) && \$this->CurrCol == 0) { return; }\t// *COLUMNS*

\t// Still use this method if columns or page-break-inside: avoid, as it allows repositioning later
\t// otherwise, now uses PaintDivBB()
  if (!\$this->ColActive && !\$this->keep_block_together && !\$this->kwt) {
\tif (\$move_y && !\$this->ColActive) { \$this->y += \$h; }
\treturn;
  }

  if (\$level == -3) { \$level = \$this->blklvl; }
  \$firstblockfill = \$this->GetFirstBlockFill();
  if (\$firstblockfill && \$this->blklvl > 0 && \$this->blklvl >= \$firstblockfill) {
\t\$last_x = 0;
\t\$last_w = 0;
\t\$last_fc = \$this->FillColor;
\t\$bak_x = \$this->x;
\t\$bak_h = \$this->divheight;
\t\$this->divheight = 0;\t// Temporarily turn off divheight - as Cell() uses it to check for PageBreak
\tfor (\$blvl=\$firstblockfill;\$blvl<=\$level;\$blvl++) {
\t\t\$this->SetBlockFill(\$blvl);
\t\t\$this->x = \$this->lMargin + \$this->blk[\$blvl]['outer_left_margin'];
\t\tif (\$last_x != \$this->lMargin + \$this->blk[\$blvl]['outer_left_margin'] || \$last_w != \$this->blk[\$blvl]['width'] || \$last_fc != \$this->FillColor || \$this->blk[\$blvl]['border_top']['s'] || \$this->blk[\$blvl]['border_bottom']['s'] || \$this->blk[\$blvl]['border_left']['s'] || \$this->blk[\$blvl]['border_right']['s']) {\t// mPDF 5.6.55
\t\t\t\$x = \$this->x;
\t\t\t\$this->Cell( (\$this->blk[\$blvl]['width']), \$h, '', '', 0, '', 1);
\t\t\tif (!\$this->keep_block_together && !\$this->writingHTMLheader && !\$this->writingHTMLfooter) {
\t\t\t\t\$this->x = \$x;
\t\t\t\t// \$state = 0 normal; 1 top; 2 bottom; 3 top and bottom
\t\t\t\tif (\$blvl == \$this->blklvl) { \$this->PaintDivLnBorder(\$state,\$blvl,\$h); }
\t\t\t\telse { \$this->PaintDivLnBorder(0,\$blvl,\$h); }
\t\t\t}
\t\t}
\t\t\$last_x = \$this->lMargin + \$this->blk[\$blvl]['outer_left_margin'];
\t\t\$last_w = \$this->blk[\$blvl]['width'];
\t\t\$last_fc = \$this->FillColor;
\t}
\t// Reset current block fill
\tif (isset(\$this->blk[\$this->blklvl]['bgcolorarray'])) {
\t\t\$bcor = \$this->blk[\$this->blklvl]['bgcolorarray'];
\t\t\$this->SetFColor(\$bcor);
\t}
\t\$this->x = \$bak_x;
\t\$this->divheight = \$bak_h;
  }
  if (\$move_y) { \$this->y += \$h; }
}
/*-- END HTML-CSS --*/


function SetX(\$x)
{
\t//Set x position
\tif(\$x >= 0)\t\$this->x=\$x;
\telse \$this->x = \$this->w + \$x;
}

function SetY(\$y)
{
\t//Set y position and reset x
\t\$this->x=\$this->lMargin;
\tif(\$y>=0)
\t\t\$this->y=\$y;
\telse
\t\t\$this->y=\$this->h+\$y;
}

function SetXY(\$x,\$y)
{
\t//Set x and y positions
\t\$this->SetY(\$y);
\t\$this->SetX(\$x);
}


function Output(\$name='',\$dest='')
{
\t//Output PDF to some destination
\tif (\$this->showStats) {
\t\techo '<div>Generated in '.sprintf('%.2F',(microtime(true) - \$this->time0)).' seconds</div>';
\t}
\t//Finish document if necessary
\tif (\$this->progressBar) { \$this->UpdateProgressBar(1,'100','Finished'); }\t// *PROGRESS-BAR*
\tif(\$this->state < 3) \$this->Close();
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'100','Finished'); }\t// *PROGRESS-BAR*
\t// fn. error_get_last is only in PHP>=5.2
\tif (\$this->debug && function_exists('error_get_last') && error_get_last()) {
\t   \$e = error_get_last();
\t   if ((\$e['type'] < 2048 && \$e['type'] != 8) || (intval(\$e['type']) & intval(ini_get(\"error_reporting\")))) {
\t\techo \"<p>Error message detected - PDF file generation aborted.</p>\";
\t\techo \$e['message'].'<br />';
\t\techo 'File: '.\$e['file'].'<br />';
\t\techo 'Line: '.\$e['line'].'<br />';
\t\texit;
\t   }
\t}


\tif ((\$this->PDFA || \$this->PDFX) && \$this->encrypted) { \$this->Error(\"PDFA1-b or PDFX/1-a does not permit encryption of documents.\"); }
\tif (count(\$this->PDFAXwarnings) && ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto))) {
\t\tif (\$this->PDFA) {
\t\t\techo '<div>WARNING - This file could not be generated as it stands as a PDFA1-b compliant file.</div>';
\t\t\techo '<div>These issues can be automatically fixed by mPDF using <i>\$mpdf-&gt;PDFAauto=true;</i></div>';
\t\t\techo '<div>Action that mPDF will take to automatically force PDFA1-b compliance are shown in brackets.</div>';
\t\t}
\t\telse {
\t\t\techo '<div>WARNING - This file could not be generated as it stands as a PDFX/1-a compliant file.</div>';
\t\t\techo '<div>These issues can be automatically fixed by mPDF using <i>\$mpdf-&gt;PDFXauto=true;</i></div>';
\t\t\techo '<div>Action that mPDF will take to automatically force PDFX/1-a compliance are shown in brackets.</div>';
\t\t}
\t\techo '<div>Warning(s) generated:</div><ul>';
\t\t\$this->PDFAXwarnings = array_unique(\$this->PDFAXwarnings);
\t\tforeach(\$this->PDFAXwarnings AS \$w) {
\t\t\techo '<li>'.\$w.'</li>';
\t\t}
\t\techo '</ul>';
\t\texit;
\t}

\tif (\$this->showStats) {
\t\techo '<div>Compiled in '.sprintf('%.2F',(microtime(true) - \$this->time0)).' seconds (total)</div>';
\t\techo '<div>Peak Memory usage '.number_format((memory_get_peak_usage(true)/(1024*1024)),2).' MB</div>';
\t\techo '<div>PDF file size '.number_format((strlen(\$this->buffer)/1024)).' kB</div>';
\t\techo '<div>Number of fonts '.count(\$this->fonts).'</div>';
\t\texit;
\t}


\tif(is_bool(\$dest)) \$dest=\$dest ? 'D' : 'F';
\t\$dest=strtoupper(\$dest);
\tif(\$dest=='') {
\t\tif(\$name=='') {
\t\t\t\$name='mpdf.pdf';
\t\t\t\$dest='I';
\t\t}
\t\telse { \$dest='F'; }
\t}

/*-- PROGRESS-BAR --*/
\tif (\$this->progressBar && (\$dest=='D' || \$dest=='I')) {
\t\tif(\$name=='') { \$name='mpdf.pdf'; }
\t\t\$tempfile = '_tempPDF'.uniqid(rand(1,100000),true);
\t\t//Save to local file
\t\t\$f=fopen(_MPDF_TEMP_PATH.\$tempfile.'.pdf','wb');
\t\tif(!\$f) \$this->Error('Unable to create temporary output file: '.\$tempfile.'.pdf');
\t\tfwrite(\$f,\$this->buffer,strlen(\$this->buffer));
\t\tfclose(\$f);
\t\t\$this->UpdateProgressBar(3,'','Finished');

\t\techo '<script type=\"text/javascript\">

\t\tvar form = document.createElement(\"form\");
\t\tform.setAttribute(\"method\", \"post\");
\t\tform.setAttribute(\"action\", \"'._MPDF_URI.'includes/out.php\");

\t\tvar hiddenField = document.createElement(\"input\");
\t\thiddenField.setAttribute(\"type\", \"hidden\");
\t\thiddenField.setAttribute(\"name\", \"filename\");
\t\thiddenField.setAttribute(\"value\", \"'.\$tempfile.'\");
\t\tform.appendChild(hiddenField);

\t\tvar hiddenField = document.createElement(\"input\");
\t\thiddenField.setAttribute(\"type\", \"hidden\");
\t\thiddenField.setAttribute(\"name\", \"dest\");
\t\thiddenField.setAttribute(\"value\", \"'.\$dest.'\");
\t\tform.appendChild(hiddenField);

\t\tvar hiddenField = document.createElement(\"input\");
\t\thiddenField.setAttribute(\"type\", \"hidden\");
\t\thiddenField.setAttribute(\"name\", \"opname\");
\t\thiddenField.setAttribute(\"value\", \"'.\$name.'\");
\t\tform.appendChild(hiddenField);

\t\tvar hiddenField = document.createElement(\"input\");
\t\thiddenField.setAttribute(\"type\", \"hidden\");
\t\thiddenField.setAttribute(\"name\", \"path\");
\t\thiddenField.setAttribute(\"value\", \"'.urlencode(_MPDF_TEMP_PATH).'\");
\t\tform.appendChild(hiddenField);

\t\tdocument.body.appendChild(form);
\t\tform.submit();

      \t</script>
\t\t</div>
\t\t</body>
\t\t</html>';
\t\texit;
\t}
\telse {
\t\tif (\$this->progressBar) { \$this->UpdateProgressBar(3,'','Finished'); }
/*-- END PROGRESS-BAR --*/

\t\tswitch(\$dest) {
\t\t   case 'I':
\t\t\tif (\$this->debug && !\$this->allow_output_buffering && ob_get_contents()) { echo \"<p>Output has already been sent from the script - PDF file generation aborted.</p>\"; exit; }
\t\t\t//Send to standard output
\t\t\tif(PHP_SAPI!='cli') {
\t\t\t\t//We send to a browser
\t\t\t\theader('Content-Type: application/pdf');
\t\t\t\tif(headers_sent())
\t\t\t\t\t\$this->Error('Some data has already been output to browser, can\\'t send PDF file');
\t\t\t\tif (!isset(\$_SERVER['HTTP_ACCEPT_ENCODING']) OR empty(\$_SERVER['HTTP_ACCEPT_ENCODING'])) {
\t\t\t\t\t// don't use length if server using compression
\t\t\t\t\theader('Content-Length: '.strlen(\$this->buffer));
\t\t\t\t}
\t\t\t\theader('Content-disposition: inline; filename=\"'.\$name.'\"');
\t\t\t\theader('Cache-Control: public, must-revalidate, max-age=0');
\t\t\t\theader('Pragma: public');
\t\t\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT');
\t\t\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');
\t\t\t}
\t\t\techo \$this->buffer;
\t\t\tbreak;
\t\t   case 'D':
\t\t\t//Download file
\t\t\theader('Content-Description: File Transfer');
\t\t\tif (headers_sent())
\t\t\t\t\$this->Error('Some data has already been output to browser, can\\'t send PDF file');
\t\t\theader('Content-Transfer-Encoding: binary');
\t\t\theader('Cache-Control: public, must-revalidate, max-age=0');
\t\t\theader('Pragma: public');
\t\t\theader('Expires: Sat, 26 Jul 1997 05:00:00 GMT');
\t\t\theader('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');
\t\t\theader('Content-Type: application/force-download');
\t\t\theader('Content-Type: application/octet-stream', false);
\t\t\theader('Content-Type: application/download', false);
\t\t\theader('Content-Type: application/pdf', false);
\t\t\tif (!isset(\$_SERVER['HTTP_ACCEPT_ENCODING']) OR empty(\$_SERVER['HTTP_ACCEPT_ENCODING'])) {
\t\t\t\t// don't use length if server using compression
\t\t\t\theader('Content-Length: '.strlen(\$this->buffer));
\t\t\t}
\t\t\theader('Content-disposition: attachment; filename=\"'.\$name.'\"');
 \t\t\techo \$this->buffer;
\t\t\tbreak;
\t\t   case 'F':
\t\t\t//Save to local file
\t\t\t\$f=fopen(\$name,'wb');
\t\t\tif(!\$f) \$this->Error('Unable to create output file: '.\$name);
\t\t\tfwrite(\$f,\$this->buffer,strlen(\$this->buffer));
\t\t\tfclose(\$f);
\t\t\tbreak;
\t\t   case 'S':
\t\t\t//Return as a string
\t\t\treturn \$this->buffer;
\t\t   default:
\t\t\t\$this->Error('Incorrect output destination: '.\$dest);
\t\t}

\t}\t// *PROGRESS-BAR*
\t//======================================================================================================
\t// DELETE OLD TMP FILES - Housekeeping
\t// Delete any files in tmp/ directory that are >1 hrs old
\t\t\$interval = 3600;
\t\tif (\$handle = @opendir(preg_replace('/\\/\$/','',_MPDF_TEMP_PATH))) {\t// mPDF 5.7.3
\t\t   while (false !== (\$file = readdir(\$handle))) {
\t\t\tif ((\$file != \"..\") && (\$file != \".\") && !is_dir(\$file) && ((filemtime(_MPDF_TEMP_PATH.\$file)+\$interval) < time()) && (substr(\$file, 0, 1) !== '.') && (\$file !='dummy.txt')) { // mPDF 5.7.3
\t\t\t\t@unlink(_MPDF_TEMP_PATH.\$file);
\t\t\t}
\t\t   }
\t\t   closedir(\$handle);
\t\t}
\t//==============================================================================================================

\treturn '';
}


// *****************************************************************************
//                                                                             *
//                             Protected methods                               *
//                                                                             *
// *****************************************************************************
function _dochecks()
{
\t//Check for locale-related bug
\tif(1.1==1)
\t\t\$this->Error('Don\\'t alter the locale before including mPDF');
\t//Check for decimal separator
\tif(sprintf('%.1f',1.0)!='1.0')
\t\tsetlocale(LC_NUMERIC,'C');
\t// mPDF 5.4.11
\t\$mqr=ini_get(\"magic_quotes_runtime\");
\tif (\$mqr) { \$this->Error('mPDF requires magic_quotes_runtime to be turned off e.g. by using ini_set(\"magic_quotes_runtime\", 0);'); }
}

function _begindoc()
{
\t//Start document
\t\$this->state=1;
\t\$this->_out('%PDF-'.\$this->pdf_version);
\t\$this->_out('%'.chr(226).chr(227).chr(207).chr(211));\t// 4 chars > 128 to show binary file
}


/*-- HTMLHEADERS-FOOTERS --*/
function _puthtmlheaders() {
\t\$this->state=2;
\t\$nb=\$this->page;
\tfor(\$n=1;\$n<=\$nb;\$n++) {
\t  if (\$this->mirrorMargins && \$n%2==0) { \$OE = 'E'; }\t// EVEN
\t  else { \$OE = 'O'; }
\t  \$this->page = \$n;
\t  if (isset(\$this->saveHTMLHeader[\$n][\$OE])) {
\t\t\$html = \$this->saveHTMLHeader[\$n][\$OE]['html'];
\t\t\$this->lMargin = \$this->saveHTMLHeader[\$n][\$OE]['ml'];
\t\t\$this->rMargin = \$this->saveHTMLHeader[\$n][\$OE]['mr'];
\t\t\$this->tMargin = \$this->saveHTMLHeader[\$n][\$OE]['mh'];
\t\t\$this->bMargin = \$this->saveHTMLHeader[\$n][\$OE]['mf'];
\t\t\$this->margin_header = \$this->saveHTMLHeader[\$n][\$OE]['mh'];
\t\t\$this->margin_footer = \$this->saveHTMLHeader[\$n][\$OE]['mf'];
\t\t\$this->w = \$this->saveHTMLHeader[\$n][\$OE]['pw'];
\t\t\$this->h = \$this->saveHTMLHeader[\$n][\$OE]['ph'];
\t\t\$rotate = (isset(\$this->saveHTMLHeader[\$n][\$OE]['rotate']) ? \$this->saveHTMLHeader[\$n][\$OE]['rotate'] : null);
\t\t\$this->Reset();
\t\t\$this->pageoutput[\$n] = array();
\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\$this->x = \$this->lMargin;
\t\t\$this->y = \$this->margin_header;
\t\t// mPDF 5.6.47
\t\t\$pn = \$this->docPageNum(\$n);
\t\tif (\$pn)
\t\t\t\$pnstr = \$this->pagenumPrefix.\$pn.\$this->pagenumSuffix;
\t\telse { \$pnstr = ''; }
\t\t\$html = str_replace('{PAGENO}',\$pnstr,\$html);
\t\t\$pnt = \$this->docPageNumTotal(\$n);
\t\tif (\$pnt)
\t\t\t\$pntstr = \$this->nbpgPrefix.\$pnt.\$this->nbpgSuffix;
\t\telse { \$pntstr = ''; }
\t\t\$html = str_replace(\$this->aliasNbPgGp,\$pntstr,\$html );\t// {nbpg}
\t\t\$html = str_replace(\$this->aliasNbPg,\$nb,\$html );\t// {nb}
\t\t\$html = preg_replace_callback('/\\{DATE\\s+(.*?)\\}/', array(\$this, 'date_callback') ,\$html );\t// mPDF 5.7

\t\t\$this->HTMLheaderPageLinks = array();
\t\t\$this->HTMLheaderPageAnnots = array();
\t\t\$this->HTMLheaderPageForms = array();
\t\t\$this->pageBackgrounds = array();

\t\t\$this->writingHTMLheader = true;
\t\t\$this->WriteHTML(\$html , 4);\t// parameter 4 saves output to \$this->headerbuffer
\t\t\$this->writingHTMLheader = false;
\t\t\$this->Reset();
\t\t\$this->pageoutput[\$n] = array();

\t\t\$s = \$this->PrintPageBackgrounds();
\t\t\$this->headerbuffer = \$s . \$this->headerbuffer;
\t\t\$os = '';
\t\tif (\$rotate) {
\t\t\t\$os .= sprintf('q 0 -1 1 0 0 %.3F cm ',(\$this->w*_MPDFK));
\t\t}
\t\t\$os .= \$this->headerbuffer ;
\t\tif (\$rotate) {
\t\t\t\$os .= ' Q' . \"\\n\";
\t\t}

\t\t// Writes over the page background but behind any other output on page
\t\t\$os = preg_replace('/\\\\\\\\/','\\\\\\\\\\\\\\\\',\$os);
\t\t\$this->pages[\$n] = preg_replace('/(___HEADER___MARKER'.\$this->uniqstr.')/', \"\\n\".\$os.\"\\n\".'\\\\1', \$this->pages[\$n]);

\t\t\$lks = \$this->HTMLheaderPageLinks;
\t\tforeach(\$lks AS \$lk) {
\t\t\tif (\$rotate) {
\t\t\t\t\$lw = \$lk[2];
\t\t\t\t\$lh = \$lk[3];
\t\t\t\t\$lk[2] = \$lh;
\t\t\t\t\$lk[3] = \$lw;\t// swap width and height
\t\t\t\t\$ax = \$lk[0]/_MPDFK;
\t\t\t\t\$ay = \$lk[1]/_MPDFK;
\t\t\t\t\$bx = \$ay-(\$lh/_MPDFK);
\t\t\t\t\$by = \$this->w-\$ax;
\t\t\t\t\$lk[0] = \$bx*_MPDFK;
\t\t\t\t\$lk[1] = (\$this->h-\$by)*_MPDFK - \$lw;
\t\t\t}
\t\t\t\$this->PageLinks[\$n][]=\$lk;
\t\t}
/*-- FORMS --*/
\t\tforeach(\$this->HTMLheaderPageForms AS \$f) {
\t\t\t\$this->form->forms[\$f['n']] = \$f;
\t\t}
/*-- END FORMS --*/


\t  }
\t  if (isset(\$this->saveHTMLFooter[\$n][\$OE])) {
\t\t\$html = \$this->saveHTMLFooter[\$this->page][\$OE]['html'];
\t\t\$this->lMargin = \$this->saveHTMLFooter[\$n][\$OE]['ml'];
\t\t\$this->rMargin = \$this->saveHTMLFooter[\$n][\$OE]['mr'];
\t\t\$this->tMargin = \$this->saveHTMLFooter[\$n][\$OE]['mh'];
\t\t\$this->bMargin = \$this->saveHTMLFooter[\$n][\$OE]['mf'];
\t\t\$this->margin_header = \$this->saveHTMLFooter[\$n][\$OE]['mh'];
\t\t\$this->margin_footer = \$this->saveHTMLFooter[\$n][\$OE]['mf'];
\t\t\$this->w = \$this->saveHTMLFooter[\$n][\$OE]['pw'];
\t\t\$this->h = \$this->saveHTMLFooter[\$n][\$OE]['ph'];
\t\t\$rotate = (isset(\$this->saveHTMLFooter[\$n][\$OE]['rotate']) ? \$this->saveHTMLFooter[\$n][\$OE]['rotate'] : null);
\t\t\$this->Reset();
\t\t\$this->pageoutput[\$n] = array();
\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\$this->x = \$this->lMargin;
\t\t\$top_y = \$this->y = \$this->h - \$this->margin_footer;

\t\t// if bottom-margin==0, corrects to avoid division by zero
\t\tif (\$this->y == \$this->h) { \$top_y = \$this->y = (\$this->h - 0.1); }
\t\t// mPDF 5.6.47
\t\t\$pn = \$this->docPageNum(\$n);
\t\tif (\$pn)
\t\t\t\$pnstr = \$this->pagenumPrefix.\$pn.\$this->pagenumSuffix;
\t\telse { \$pnstr = ''; }
\t\t\$html = str_replace('{PAGENO}',\$pnstr,\$html);
\t\t\$pnt = \$this->docPageNumTotal(\$n);
\t\tif (\$pnt)
\t\t\t\$pntstr = \$this->nbpgPrefix.\$pnt.\$this->nbpgSuffix;
\t\telse { \$pntstr = ''; }
\t\t\$html = str_replace(\$this->aliasNbPgGp,\$pntstr,\$html );\t// {nbpg}
\t\t\$html = str_replace(\$this->aliasNbPg,\$nb,\$html );\t// {nb}
\t\t\$html = preg_replace_callback('/\\{DATE\\s+(.*?)\\}/', array(\$this, 'date_callback') ,\$html );\t// mPDF 5.7


\t\t\$this->HTMLheaderPageLinks = array();
\t\t\$this->HTMLheaderPageAnnots = array();
\t\t\$this->HTMLheaderPageForms = array();
\t\t\$this->pageBackgrounds = array();

\t\t\$this->writingHTMLfooter = true;
\t\t\$this->InFooter = true;
\t\t\$this->WriteHTML(\$html , 4);\t// parameter 4 saves output to \$this->headerbuffer
\t\t\$this->InFooter = false;
\t\t\$this->Reset();
\t\t\$this->pageoutput[\$n] = array();

\t\t\$fheight = \$this->y - \$top_y;
\t\t\$adj = -\$fheight;

\t\t\$s = \$this->PrintPageBackgrounds(-\$adj);
\t\t\$this->headerbuffer = \$s . \$this->headerbuffer;
\t\t\$this->writingHTMLfooter = false;\t// mPDF 5.7.3  (moved after PrintPageBackgrounds so can adjust position of images in footer)

\t\t\$os = '';
\t\t\$os .= \$this->StartTransform(true).\"\\n\";
\t\tif (\$rotate) {
\t\t\t\$os .= sprintf('q 0 -1 1 0 0 %.3F cm ',(\$this->w*_MPDFK));
\t\t}
\t\t\$os .= \$this->transformTranslate(0, \$adj, true).\"\\n\";
\t\t\$os .= \$this->headerbuffer ;
\t\tif (\$rotate) {
\t\t\t\$os .= ' Q' . \"\\n\";
\t\t}
\t\t\$os .= \$this->StopTransform(true).\"\\n\";
\t\t// Writes over the page background but behind any other output on page
\t\t\$os = preg_replace('/\\\\\\\\/','\\\\\\\\\\\\\\\\',\$os);
\t\t\$this->pages[\$n] = preg_replace('/(___HEADER___MARKER'.\$this->uniqstr.')/', \"\\n\".\$os.\"\\n\".'\\\\1', \$this->pages[\$n]);

\t\t\$lks = \$this->HTMLheaderPageLinks;
\t\tforeach(\$lks AS \$lk) {
\t\t\t\$lk[1] -= \$adj*_MPDFK;
\t\t\tif (\$rotate) {
\t\t\t\t\$lw = \$lk[2];
\t\t\t\t\$lh = \$lk[3];
\t\t\t\t\$lk[2] = \$lh;
\t\t\t\t\$lk[3] = \$lw;\t// swap width and height

\t\t\t\t\$ax = \$lk[0]/_MPDFK;
\t\t\t\t\$ay = \$lk[1]/_MPDFK;
\t\t\t\t\$bx = \$ay-(\$lh/_MPDFK);
\t\t\t\t\$by = \$this->w-\$ax;
\t\t\t\t\$lk[0] = \$bx*_MPDFK;
\t\t\t\t\$lk[1] = (\$this->h-\$by)*_MPDFK - \$lw;
\t\t\t}
\t\t\t\$this->PageLinks[\$n][]=\$lk;
\t\t}
/*-- FORMS --*/
\t\tforeach(\$this->HTMLheaderPageForms AS \$f) {
\t\t\t\$f['y'] += \$adj;
\t\t\t\$this->form->forms[\$f['n']] = \$f;
\t\t}
/*-- END FORMS --*/
\t  }
\t}
\t\$this->page=\$nb;
\t\$this->state=1;
}
/*-- END HTMLHEADERS-FOOTERS --*/


function _putpages()
{
\t\$nb=\$this->page;
\t\$filter=(\$this->compress) ? '/Filter /FlateDecode ' : '';

\tif(\$this->DefOrientation=='P') {
\t\t\$defwPt=\$this->fwPt;
\t\t\$defhPt=\$this->fhPt;
\t}
\telse {
\t\t\$defwPt=\$this->fhPt;
\t\t\$defhPt=\$this->fwPt;
\t}
\t\$annotid=(3+2*\$nb);

\t// Active Forms
\t\$totaladdnum = 0;
\tfor(\$n=1;\$n<=\$nb;\$n++) {
\t\tif (isset(\$this->PageLinks[\$n])) { \$totaladdnum += count(\$this->PageLinks[\$n]); }
/*-- ANNOTATIONS --*/
\t\tif (isset(\$this->PageAnnots[\$n])) {
\t\t\tforeach (\$this->PageAnnots[\$n] as \$k => \$pl) {
\t\t\t\tif (!empty(\$pl['opt']['popup']) || !empty(\$pl['opt']['file'])) { \$totaladdnum += 2 ; }
\t\t\t\telse { \$totaladdnum++; }
\t\t\t}
\t\t}
/*-- END ANNOTATIONS --*/

/*-- FORMS --*/
\t\tif ( count(\$this->form->forms) > 0 ) {
\t\t\t\$this->form->countPageForms(\$n, \$totaladdnum);
\t\t}
/*-- END FORMS --*/
\t}
/*-- FORMS --*/
\t// Make a note in the radio button group of the obj_id it will have
\t\$ctr = 0;
\tif (count(\$this->form->form_radio_groups)) {
\t\tforeach(\$this->form->form_radio_groups AS \$name=>\$frg) {
\t\t\t\$this->form->form_radio_groups[\$name]['obj_id'] = \$annotid + \$totaladdnum + \$ctr;
\t\t\t\$ctr++;
\t\t}
\t}
/*-- END FORMS --*/

\t// Select unused fonts (usually default font)
\t\$unused = array();
\tforeach(\$this->fonts as \$fk=>\$font) {
\t   if (!\$font['used'] && (\$font['type']=='TTF')) {
\t\t\$unused[] = \$fk;
\t   }
\t}


\tfor(\$n=1;\$n<=\$nb;\$n++)
\t{
\t\t\$thispage = \$this->pages[\$n];
//\t\tunset(\$this->pages[\$n]);\t// mPDF 5.6.47
\t\tif(isset(\$this->OrientationChanges[\$n])) {
\t\t\t\$hPt=\$this->pageDim[\$n]['w']*_MPDFK;
\t\t\t\$wPt=\$this->pageDim[\$n]['h']*_MPDFK;
\t\t\t\$owidthPt_LR = \$this->pageDim[\$n]['outer_width_TB']*_MPDFK;
\t\t\t\$owidthPt_TB = \$this->pageDim[\$n]['outer_width_LR']*_MPDFK;
\t\t}
\t\telse {
\t\t\t\$wPt=\$this->pageDim[\$n]['w']*_MPDFK;
\t\t\t\$hPt=\$this->pageDim[\$n]['h']*_MPDFK;
\t\t\t\$owidthPt_LR = \$this->pageDim[\$n]['outer_width_LR']*_MPDFK;
\t\t\t\$owidthPt_TB = \$this->pageDim[\$n]['outer_width_TB']*_MPDFK;
\t\t}
\t\t// Remove references to unused fonts (usually default font)
\t\tforeach(\$unused as \$fk) {
\t\t\tif (\$this->fonts[\$fk]['sip'] || \$this->fonts[\$fk]['smp']) {
\t\t\t\tforeach(\$this->fonts[\$fk]['subsetfontids'] AS \$k => \$fid) {
\t\t\t\t\t\t\$thispage = preg_replace('/\\s\\/F'.\$fid.' \\d[\\d.]* Tf\\s/is',' ',\$thispage);
\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t\t\t\$thispage = preg_replace('/\\s\\/F'.\$this->fonts[\$fk]['i'].' \\d[\\d.]* Tf\\s/is',' ',\$thispage);
\t\t\t}
\t\t}
\t\t//Replace number of pages
\t\tif(!empty(\$this->aliasNbPg)) {
\t\t\tif (!\$this->onlyCoreFonts) { \$s1 = \$this->UTF8ToUTF16BE(\$this->aliasNbPg, false); }
\t\t\t\$s2 = \$this->aliasNbPg;
\t\t\tif (!\$this->onlyCoreFonts) { \$r1 = \$this->UTF8ToUTF16BE(\$nb, false); }
\t\t\t\$r2 = \$nb;
\t\t\tif (preg_match_all('/{mpdfheadernbpg (C|R) ff=(\\S*) fs=(\\S*) fz=(.*?)}/',\$thispage,\$m)) {
\t\t\t\tfor(\$hi=0;\$hi<count(\$m[0]);\$hi++) {
\t\t\t\t\t\$pos = \$m[1][\$hi];
\t\t\t\t\t\$hff = \$m[2][\$hi];
\t\t\t\t\t\$hfst = \$m[3][\$hi];
\t\t\t\t\t\$hfsz = \$m[4][\$hi];
\t\t\t\t\t\$this->SetFont(\$hff,\$hfst,\$hfsz, false);
\t\t\t\t\t\$x1 = \$this->GetStringWidth(\$this->aliasNbPg);
\t\t\t\t\t\$x2 = \$this->GetStringWidth(\$nb);
\t\t\t\t\t\$xadj = \$x1 - \$x2;
\t\t\t\t\tif (\$pos=='C') { \$xadj /= 2; }
\t\t\t\t\t\$rep = sprintf(' q 1 0 0 1 %.3F 0 cm ', \$xadj*_MPDFK);
\t\t\t\t\t\$thispage = str_replace(\$m[0][\$hi], \$rep, \$thispage);
\t\t\t\t}
\t\t\t}
\t\t\tif (!\$this->onlyCoreFonts) { \$thispage=str_replace(\$s1,\$r1,\$thispage); }
\t\t\t\$thispage=str_replace(\$s2,\$r2,\$thispage);

\t\t\t// And now for any SMP/SIP fonts subset using <HH> format
\t\t\t\$r = '';
\t\t\t\$nstr = \"\$nb\";
\t\t\tfor(\$i=0;\$i<strlen(\$nstr);\$i++) {
\t\t\t\t\$r .= sprintf(\"%02s\", strtoupper(dechex(intval(\$nstr[\$i])+48)));
\t\t\t}
\t\t\t\$thispage=str_replace(\$this->aliasNbPgHex,\$r,\$thispage);

\t\t}
\t\t//Replace number of pages in group
\t\tif(!empty(\$this->aliasNbPgGp)) {
\t\t\tif (!\$this->onlyCoreFonts) { \$s1 = \$this->UTF8ToUTF16BE(\$this->aliasNbPgGp, false); }
\t\t\t\$s2 = \$this->aliasNbPgGp;
\t\t\t\$nbt = \$this->docPageNumTotal(\$n);
\t\t\tif (!\$this->onlyCoreFonts) { \$r1 = \$this->UTF8ToUTF16BE(\$nbt, false); }
\t\t\t\$r2 = \$nbt;
\t\t\tif (preg_match_all('/{mpdfheadernbpggp (C|R) ff=(\\S*) fs=(\\S*) fz=(.*?)}/',\$thispage,\$m)) {
\t\t\t\tfor(\$hi=0;\$hi<count(\$m[0]);\$hi++) {
\t\t\t\t\t\$pos = \$m[1][\$hi];
\t\t\t\t\t\$hff = \$m[2][\$hi];
\t\t\t\t\t\$hfst = \$m[3][\$hi];
\t\t\t\t\t\$hfsz = \$m[4][\$hi];
\t\t\t\t\t\$this->SetFont(\$hff,\$hfst,\$hfsz, false);
\t\t\t\t\t\$x1 = \$this->GetStringWidth(\$this->aliasNbPgGp);
\t\t\t\t\t\$x2 = \$this->GetStringWidth(\$nbt);
\t\t\t\t\t\$xadj = \$x1 - \$x2;
\t\t\t\t\tif (\$pos=='C') { \$xadj /= 2; }
\t\t\t\t\t\$rep = sprintf(' q 1 0 0 1 %.3F 0 cm ', \$xadj*_MPDFK);
\t\t\t\t\t\$thispage = str_replace(\$m[0][\$hi], \$rep, \$thispage);
\t\t\t\t}
\t\t\t}
\t\t\tif (!\$this->onlyCoreFonts) { \$thispage=str_replace(\$s1,\$r1,\$thispage); }
\t\t\t\$thispage=str_replace(\$s2,\$r2,\$thispage);

\t\t\t// And now for any SMP/SIP fonts subset using <HH> format
\t\t\t\$r = '';
\t\t\t\$nstr = \"\$nbt\";
\t\t\tfor(\$i=0;\$i<strlen(\$nstr);\$i++) {
\t\t\t\t\$r .= sprintf(\"%02s\", strtoupper(dechex(intval(\$nstr[\$i])+48)));
\t\t\t}
\t\t\t\$thispage=str_replace(\$this->aliasNbPgGpHex,\$r,\$thispage);

\t\t}
\t\t\$thispage = preg_replace('/(\\s*___BACKGROUND___PATTERNS'.\$this->uniqstr.'\\s*)/', \" \", \$thispage);
\t\t\$thispage = preg_replace('/(\\s*___HEADER___MARKER'.\$this->uniqstr.'\\s*)/', \" \", \$thispage);
\t\t\$thispage = preg_replace('/(\\s*___PAGE___START'.\$this->uniqstr.'\\s*)/', \" \", \$thispage);
\t\t\$thispage = preg_replace('/(\\s*___TABLE___BACKGROUNDS'.\$this->uniqstr.'\\s*)/', \" \", \$thispage);
\t\t// mPDF 5.7.3 TRANSFORMS
\t\twhile (preg_match('/(\\% BTR(.*?)\\% ETR)/is', \$thispage, \$m)) {
\t\t\t\$thispage = preg_replace('/(\\% BTR.*?\\% ETR)/is', '', \$thispage, 1).\"\\n\".\$m[2];
\t\t}

\t\t//Page
\t\t\$this->_newobj();
\t\t\$this->_out('<</Type /Page');
\t\t\$this->_out('/Parent 1 0 R');
\t\tif(isset(\$this->OrientationChanges[\$n])) {
\t\t\t\$this->_out(sprintf('/MediaBox [0 0 %.3F %.3F]',\$hPt,\$wPt));
\t\t\t//If BleedBox is defined, it must be larger than the TrimBox, but smaller than the MediaBox
\t\t\t\$bleedMargin = \$this->pageDim[\$n]['bleedMargin']*_MPDFK;
\t\t\tif (\$bleedMargin && (\$owidthPt_TB || \$owidthPt_LR)) {
\t\t\t\t\$x0 = \$owidthPt_TB-\$bleedMargin;
\t\t\t\t\$y0 = \$owidthPt_LR-\$bleedMargin;
\t\t\t\t\$x1 = \$hPt-\$owidthPt_TB+\$bleedMargin;
\t\t\t\t\$y1 = \$wPt-\$owidthPt_LR+\$bleedMargin;
\t\t\t\t\$this->_out(sprintf('/BleedBox [%.3F %.3F %.3F %.3F]', \$x0, \$y0, \$x1, \$y1));
\t\t\t}
\t\t\t\$this->_out(sprintf('/TrimBox [%.3F %.3F %.3F %.3F]', \$owidthPt_TB, \$owidthPt_LR, (\$hPt-\$owidthPt_TB), (\$wPt-\$owidthPt_LR)));
\t\t\tif (isset(\$this->OrientationChanges[\$n]) && \$this->displayDefaultOrientation) {
\t\t\t\tif (\$this->DefOrientation=='P') { \$this->_out('/Rotate 270'); }
\t\t\t\telse { \$this->_out('/Rotate 90'); }
\t\t\t}
\t\t}
\t\t//else if(\$wPt != \$defwPt || \$hPt != \$defhPt) {
\t\telse {
\t\t\t\$this->_out(sprintf('/MediaBox [0 0 %.3F %.3F]',\$wPt,\$hPt));
\t\t\t\$bleedMargin = \$this->pageDim[\$n]['bleedMargin']*_MPDFK;
\t\t\tif (\$bleedMargin && (\$owidthPt_TB || \$owidthPt_LR)) {
\t\t\t\t\$x0 = \$owidthPt_LR-\$bleedMargin;
\t\t\t\t\$y0 = \$owidthPt_TB-\$bleedMargin;
\t\t\t\t\$x1 = \$wPt-\$owidthPt_LR+\$bleedMargin;
\t\t\t\t\$y1 = \$hPt-\$owidthPt_TB+\$bleedMargin;
\t\t\t\t\$this->_out(sprintf('/BleedBox [%.3F %.3F %.3F %.3F]', \$x0, \$y0, \$x1, \$y1));
\t\t\t}
\t\t\t\$this->_out(sprintf('/TrimBox [%.3F %.3F %.3F %.3F]', \$owidthPt_LR, \$owidthPt_TB, (\$wPt-\$owidthPt_LR), (\$hPt-\$owidthPt_TB)));
\t\t}
\t\t\$this->_out('/Resources 2 0 R');

\t\t// Important to keep in RGB colorSpace when using transparency
\t\tif (!\$this->PDFA && !\$this->PDFX) {
\t\t\tif (\$this->restrictColorSpace == 3)
\t\t\t\t\$this->_out('/Group << /Type /Group /S /Transparency /CS /DeviceCMYK >> ');
\t\t\telse if (\$this->restrictColorSpace == 1)
\t\t\t\t\$this->_out('/Group << /Type /Group /S /Transparency /CS /DeviceGray >> ');
\t\t\telse
\t\t\t\t\$this->_out('/Group << /Type /Group /S /Transparency /CS /DeviceRGB >> ');
\t\t}

\t\t\$annotsnum = 0;
\t\t\$embeddedfiles = array();\t// mPDF 5.7.2 /EmbeddedFiles

\t\tif (isset(\$this->PageLinks[\$n])) { \$annotsnum += count(\$this->PageLinks[\$n]); }
/*-- ANNOTATIONS --*/
\t\tif (isset(\$this->PageAnnots[\$n])) {
\t\t\tforeach (\$this->PageAnnots[\$n] as \$k => \$pl) {
\t\t\t\tif (!empty(\$pl['opt']['file'])) { \$embeddedfiles[\$annotsnum+1] = true ; }\t// mPDF 5.7.2 /EmbeddedFiles
\t\t\t\tif (!empty(\$pl['opt']['popup']) || !empty(\$pl['opt']['file'])) { \$annotsnum += 2 ; }
\t\t\t\telse { \$annotsnum++; }
\t\t\t\t\$this->PageAnnots[\$n][\$k]['pageobj'] = \$this->n;
\t\t\t}
\t\t}
/*-- END ANNOTATIONS --*/

/*-- FORMS --*/
\t\t// Active Forms
\t\t\$formsnum = 0;
\t\tif ( count(\$this->form->forms) > 0 ) {
\t\t\tforeach( \$this->form->forms as \$val ) {
\t\t\t\tif ( \$val['page'] == \$n )
\t\t\t\t\t\$formsnum++;
\t\t\t}
\t\t}
/*-- END FORMS --*/
\t\tif (\$annotsnum || \$formsnum) {
\t\t\t\$s = '/Annots [ ';
\t\t\tfor(\$i=0;\$i<\$annotsnum;\$i++) {
\t\t\t\tif (!isset(\$embeddedfiles[\$i])) { \$s .= (\$annotid + \$i) . ' 0 R '; }\t// mPDF 5.7.2 /EmbeddedFiles
\t\t\t}
\t\t\t\$annotid += \$annotsnum;
/*-- FORMS --*/
\t\t\tif ( count(\$this->form->forms) > 0 ) {
\t\t\t\t\$this->form->addFormIds(\$n, \$s, \$annotid);
\t\t\t}
/*-- END FORMS --*/
\t\t\t\$s .= '] ';
\t\t\t\$this->_out(\$s);
\t\t}

\t\t\$this->_out('/Contents '.(\$this->n+1).' 0 R>>');
\t\t\$this->_out('endobj');

\t\t//Page content
\t\t\$this->_newobj();
\t\t\$p=(\$this->compress) ? gzcompress(\$thispage) : \$thispage;
\t\t\$this->_out('<<'.\$filter.'/Length '.strlen(\$p).'>>');
\t\t\$this->_putstream(\$p);
\t\t\$this->_out('endobj');
\t}
\t\$this->_putannots();\t// mPDF 5.7.2

\t//Pages root
\t\$this->offsets[1]=strlen(\$this->buffer);
\t\$this->_out('1 0 obj');
\t\$this->_out('<</Type /Pages');
\t\$kids='/Kids [';
\tfor(\$i=0;\$i<\$nb;\$i++)
\t\t\$kids.=(3+2*\$i).' 0 R ';
\t\$this->_out(\$kids.']');
\t\$this->_out('/Count '.\$nb);
\t\$this->_out(sprintf('/MediaBox [0 0 %.3F %.3F]',\$defwPt,\$defhPt));
\t\$this->_out('>>');
\t\$this->_out('endobj');
}


function _putannots() {\t// mPDF 5.7.2
\t\$filter=(\$this->compress) ? '/Filter /FlateDecode ' : '';
\t\$nb=\$this->page;
\tfor(\$n=1;\$n<=\$nb;\$n++)
\t{
\t\t\$annotobjs = array();
\t\tif(isset(\$this->PageLinks[\$n]) || isset(\$this->PageAnnots[\$n]) || count(\$this->form->forms) > 0 ) {
\t\t\t\$wPt=\$this->pageDim[\$n]['w']*_MPDFK;
\t\t\t\$hPt=\$this->pageDim[\$n]['h']*_MPDFK;

\t\t\t//Links
\t\t\tif(isset(\$this->PageLinks[\$n])) {
\t\t\t   foreach(\$this->PageLinks[\$n] as \$key => \$pl) {
\t\t\t\t\$this->_newobj();
\t\t\t\t\$annot='';
\t\t\t\t\$rect=sprintf('%.3F %.3F %.3F %.3F',\$pl[0],\$pl[1],\$pl[0]+\$pl[2],\$pl[1]-\$pl[3]);
\t\t\t\t\$annot .= '<</Type /Annot /Subtype /Link /Rect ['.\$rect.']';
\t\t\t\t\$annot .= ' /Contents '.\$this->_UTF16BEtextstring(\$pl[4]);
\t\t\t\t\$annot .= ' /NM '.\$this->_textstring(sprintf('%04u-%04u', \$n, \$key));
\t\t\t\t\$annot .= ' /M '.\$this->_textstring('D:'.date('YmdHis'));
\t\t\t\t\$annot .= ' /Border [0 0 0]';
\t\t\t\t// Use this (instead of /Border) to specify border around link
\t\t//\t\t\$annot .= ' /BS <</W 1';\t// Width on points; 0 = no line
\t\t//\t\t\$annot .= ' /S /D';\t\t// style - [S]olid, [D]ashed, [B]eveled, [I]nset, [U]nderline
\t\t//\t\t\$annot .= ' /D [3 2]';\t\t// Dash array - if dashed
\t\t//\t\t\$annot .= ' >>';
\t\t//\t\t\$annot .= ' /C [1 0 0]';\t// Color RGB

\t\t\t\tif (\$this->PDFA || \$this->PDFX) { \$annot .= ' /F 28'; }
\t\t\t\tif (strpos(\$pl[4],'@')===0) {
\t\t\t\t\t\$p=substr(\$pl[4],1);
\t\t\t\t\t//\t\$h=isset(\$this->OrientationChanges[\$p]) ? \$wPt : \$hPt;
\t\t\t\t\t\$htarg=\$this->pageDim[\$p]['h']*_MPDFK;
\t\t\t\t\t\$annot.=sprintf(' /Dest [%d 0 R /XYZ 0 %.3F null]>>',1+2*\$p,\$htarg);
\t\t\t\t}
\t\t\t\telse if(is_string(\$pl[4])) {
\t\t\t\t\t\$annot .= ' /A <</S /URI /URI '.\$this->_textstring(\$pl[4]).'>> >>';
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$l=\$this->links[\$pl[4]];
\t\t\t\t\t// may not be set if #link points to non-existent target
\t\t\t\t\tif (isset(\$this->pageDim[\$l[0]]['h'])) { \$htarg=\$this->pageDim[\$l[0]]['h']*_MPDFK; }
\t\t\t\t\telse { \$htarg=\$this->h*_MPDFK; } // doesn't really matter
\t\t\t\t\t\$annot.=sprintf(' /Dest [%d 0 R /XYZ 0 %.3F null]>>',1+2*\$l[0],\$htarg-\$l[1]*_MPDFK);
\t\t\t\t}
\t\t\t\t\$this->_out(\$annot);
\t\t\t\t\$this->_out('endobj');
\t\t\t   }
\t\t\t}


/*-- ANNOTATIONS --*/
\t\t\tif(isset(\$this->PageAnnots[\$n])) {
\t\t\t   foreach (\$this->PageAnnots[\$n] as \$key => \$pl) {
\t\t\t\tif (\$pl['opt']['file']) { \$FileAttachment=true; }
\t\t\t\telse { \$FileAttachment=false; }
\t\t\t\t\$this->_newobj();
\t\t\t\t\$annot='';
\t\t\t\t\$pl['opt'] = array_change_key_case(\$pl['opt'], CASE_LOWER);
\t\t\t\t\$x = \$pl['x'];
\t\t\t\tif (\$this->annotMargin <> 0 || \$x==0 || \$x<0) {\t// Odd page
\t\t\t\t   \$x = (\$wPt/_MPDFK) - \$this->annotMargin;
\t\t\t\t}
\t\t\t\t\$w = \$h = 0;
\t\t\t\t\$a = \$x * _MPDFK;
\t\t\t\t\$b = \$hPt - (\$pl['y']  * _MPDFK);
\t\t\t\t\$annot .= '<</Type /Annot ';
\t\t\t\tif (\$FileAttachment) {
\t\t\t\t\t\$annot .= '/Subtype /FileAttachment';
\t\t\t\t\t// Need to set a size for FileAttachment icons
\t\t\t\t\tif (\$pl['opt']['icon']=='Paperclip') { \$w=8.235; \$h=20; }\t// 7,17
\t\t\t\t\telse if (\$pl['opt']['icon']=='Tag') { \$w=20; \$h=16; }
\t\t\t\t\telse if (\$pl['opt']['icon']=='Graph') { \$w=20; \$h=20; }
\t\t\t\t\telse { \$w=14; \$h=20; } \t// PushPin
\t\t\t\t\t\$f = \$pl['opt']['file'];
\t\t\t\t\t\$f = preg_replace('/^.*\\//', '', \$f);
\t\t\t\t\t\$f = preg_replace('/[^a-zA-Z0-9._]/', '', \$f);
\t\t\t\t\t\$annot .= '/FS <</Type /Filespec /F ('.\$f.')';
\t\t\t\t\t\$annot .= '/EF <</F '.(\$this->n+1).' 0 R>>';
\t\t\t\t\t\$annot .= '>>';
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$annot .= '/Subtype /Text';
\t\t\t\t}
\t\t\t\t\$rect = sprintf('%.3F %.3F %.3F %.3F', \$a, \$b-\$h, \$a+\$w, \$b);
\t\t\t\t\$annot .= '/Rect ['.\$rect.']';

\t\t\t\t// contents = description of file in free text
\t\t\t\t\$annot .= ' /Contents '.\$this->_UTF16BEtextstring(\$pl['txt']);
\t\t\t\t\$annot .= ' /NM '.\$this->_textstring(sprintf('%04u-%04u', \$n, (2000 + \$key)));
\t\t\t\t\$annot .= ' /M '.\$this->_textstring('D:'.date('YmdHis'));
\t\t\t\t\$annot .= ' /CreationDate '.\$this->_textstring('D:'.date('YmdHis'));
\t\t\t\t\$annot .= ' /Border [0 0 0]';
\t\t\t\tif (\$this->PDFA || \$this->PDFX) {
\t\t\t\t\t\$annot .= ' /F 28';
\t\t\t\t\t\$annot .= ' /CA 1';
\t\t\t\t}
\t\t\t\telse if (\$pl['opt']['ca']>0) { \$annot .= ' /CA '.\$pl['opt']['ca']; }

\t\t\t\t\$annotcolor = ' /C [';
\t\t\t\tif (isset(\$pl['opt']['c']) AND \$pl['opt']['c']) {
\t\t\t\t\t\$col = \$pl['opt']['c'];
\t\t\t\t\tif (\$col{0}==3 || \$col{0}==5) { \$annotcolor .= sprintf(\"%.3F %.3F %.3F\", ord(\$col{1})/255,ord(\$col{2})/255,ord(\$col{3})/255); }
\t\t\t\t\telse if (\$col{0}==1) { \$annotcolor .= sprintf(\"%.3F\", ord(\$col{1})/255); }
\t\t\t\t\telse if (\$col{0}==4 || \$col{0}==6) { \$annotcolor .= sprintf(\"%.3F %.3F %.3F %.3F\", ord(\$col{1})/100,ord(\$col{2})/100,ord(\$col{3})/100,ord(\$col{4})/100); }
\t\t\t\t\telse { \$annotcolor .= '1 1 0'; }
\t\t\t\t}
\t\t\t\telse { \$annotcolor .= '1 1 0'; }
\t\t\t\t\$annotcolor .= ']';
\t\t\t\t\$annot .= \$annotcolor;
\t\t\t\t// Usually Author
\t\t\t\t// Use as Title for fileattachment
\t\t\t\tif (isset(\$pl['opt']['t']) AND is_string(\$pl['opt']['t'])) {
\t\t\t\t\t\$annot .= ' /T '.\$this->_UTF16BEtextstring(\$pl['opt']['t']);
\t\t\t\t}
\t\t\t\tif (\$FileAttachment) {
\t\t\t\t\t\$iconsapp = array('Paperclip', 'Graph', 'PushPin', 'Tag');
\t\t\t\t}
\t\t\t\telse { \$iconsapp = array('Comment', 'Help', 'Insert', 'Key', 'NewParagraph', 'Note', 'Paragraph'); }
\t\t\t\tif (isset(\$pl['opt']['icon']) AND in_array(\$pl['opt']['icon'], \$iconsapp)) {
\t\t\t\t\t\$annot .= ' /Name /'.\$pl['opt']['icon'];
\t\t\t\t}
\t\t\t\telse if (\$FileAttachment) { \$annot .= ' /Name /PushPin'; }
\t\t\t\telse { \$annot .= ' /Name /Note'; }
\t\t\t\tif (!\$FileAttachment) {
\t\t\t\t\t// /Subj is PDF 1.5 spec.
\t\t\t\t\tif (isset(\$pl['opt']['subj']) && !\$this->PDFA && !\$this->PDFX) {
\t\t\t\t\t\t\$annot .= ' /Subj '.\$this->_UTF16BEtextstring(\$pl['opt']['subj']);
\t\t\t\t\t}
\t\t\t\t\tif (!empty(\$pl['opt']['popup'])) {
\t\t\t\t\t\t\$annot .= ' /Open true';
\t\t\t\t\t\t\$annot .= ' /Popup '.(\$this->n+1).' 0 R';
\t\t\t\t\t}
\t\t\t\t\telse { \$annot .= ' /Open false'; }
\t\t\t\t}
\t\t\t\t\$annot .= ' /P '.\$pl['pageobj'].' 0 R';
\t\t\t\t\$annot .= '>>';
\t\t\t\t\$this->_out(\$annot);
\t\t\t\t\$this->_out('endobj');

\t\t\t\tif (\$FileAttachment) {
\t\t\t\t\t\$file = @file_get_contents(\$pl['opt']['file']) or die('mPDF Error: Cannot access file attachment - '.\$pl['opt']['file']);
\t\t\t\t\t\$filestream = gzcompress(\$file);
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<</Type /EmbeddedFile');
\t\t\t\t\t\$this->_out('/Length '.strlen(\$filestream));
\t\t\t\t\t\$this->_out('/Filter /FlateDecode');
\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\$this->_putstream(\$filestream);
\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t}
\t\t\t\telse if (!empty(\$pl['opt']['popup'])) {
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$annot='';
\t\t\t\t\tif (is_array(\$pl['opt']['popup']) && isset(\$pl['opt']['popup'][0])) { \$x = \$pl['opt']['popup'][0] * _MPDFK; }
\t\t\t\t\telse { \$x = \$pl['x'] * _MPDFK; }
\t\t\t\t\tif (is_array(\$pl['opt']['popup']) && isset(\$pl['opt']['popup'][1])) { \$y = \$hPt - (\$pl['opt']['popup'][1] * _MPDFK); }
\t\t\t\t\telse { \$y = \$hPt - (\$pl['y']  * _MPDFK); }
\t\t\t\t\tif (is_array(\$pl['opt']['popup']) && isset(\$pl['opt']['popup'][2])) { \$w = \$pl['opt']['popup'][2] * _MPDFK; }
\t\t\t\t\telse { \$w = 180; }
\t\t\t\t\tif (is_array(\$pl['opt']['popup']) && isset(\$pl['opt']['popup'][3])) { \$h = \$pl['opt']['popup'][3] * _MPDFK; }
\t\t\t\t\telse { \$h = 120; }
\t\t\t\t\t\$rect = sprintf('%.3F %.3F %.3F %.3F', \$x, \$y-\$h, \$x+\$w, \$y);
\t\t\t\t\t\$annot .= '<</Type /Annot /Subtype /Popup /Rect ['.\$rect.']';
\t\t\t\t\t\$annot .= ' /M '.\$this->_textstring('D:'.date('YmdHis'));
\t\t\t\t\tif (\$this->PDFA || \$this->PDFX) { \$annot .= ' /F 28'; }
\t\t\t\t\t\$annot .= ' /Parent '.(\$this->n-1).' 0 R';
\t\t\t\t\t\$annot .= '>>';
\t\t\t\t\t\$this->_out(\$annot);
\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t}
\t\t\t   }
\t\t\t}
/*-- END ANNOTATIONS --*/

/*-- FORMS --*/
\t\t\t// Active Forms
\t\t\tif ( count(\$this->form->forms) > 0 ) {
\t\t\t\t\$this->form->_putFormItems(\$n, \$hPt);
\t\t\t}
/*-- END FORMS --*/
\t\t}
\t}
/*-- FORMS --*/
\t// Active Forms - Radio Button Group entries
\t// Output Radio Button Group form entries (radio_on_obj_id already determined)
\tif (count(\$this->form->form_radio_groups)) {
\t\t\$this->form->_putRadioItems(\$n);
\t}
/*-- END FORMS --*/
}


/*-- ANNOTATIONS --*/
function Annotation(\$text, \$x=0, \$y=0, \$icon='Note', \$author='', \$subject='', \$opacity=0, \$colarray=false, \$popup='', \$file='') {
\tif (is_array(\$colarray) && count(\$colarray)==3) { \$colarray = \$this->ConvertColor('rgb('.\$colarray[0].','.\$colarray[1].','.\$colarray[2].')'); }
\tif (\$colarray === false) { \$colarray = \$this->ConvertColor('yellow'); }
\tif (\$x==0) { \$x = \$this->x; }
\tif (\$y==0) { \$y = \$this->y; }
\t\$page = \$this->page;
\tif (\$page < 1) {\t// Document has not been started - assume it's for first page
\t\t\$page = 1;
\t\tif (\$x==0) { \$x = \$this->lMargin; }
\t\tif (\$y==0) { \$y = \$this->tMargin; }
\t}

\tif (\$this->PDFA || \$this->PDFX) {
\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"Annotation markers cannot be semi-transparent in PDFA1-b or PDFX/1-a, so they may make underlying text unreadable. (Annotation markers moved to right margin)\"; }
\t\t\$x = (\$this->w) - \$this->rMargin*0.66;
\t}
\tif (!\$this->annotMargin) { \$y -= \$this->FontSize / 2; }

\tif (!\$opacity && \$this->annotMargin) { \$opacity = 1; }
\telse if (!\$opacity) { \$opacity = \$this->annotOpacity; }

\t\$an = array('txt' => \$text, 'x' => \$x, 'y' => \$y, 'opt' => array('Icon'=>\$icon, 'T'=>\$author, 'Subj'=>\$subject, 'C'=>\$colarray, 'CA'=>\$opacity, 'popup'=>\$popup, 'file'=>\$file));

\tif (\$this->keep_block_together) {\t// Save to array - don't write yet
\t\t\$this->ktAnnots[\$this->page][]= \$an;
\t\treturn;
\t}
\telse if (\$this->table_rotate) {
\t\t\$this->tbrot_Annots[\$this->page][]= \$an;
\t\treturn;
\t}
\telse if (\$this->kwt) {
\t\t\$this->kwt_Annots[\$this->page][]= \$an;
\t\treturn;
\t}
\t// mPDF 5.0
\tif (\$this->writingHTMLheader || \$this->writingHTMLfooter) {
\t\t\$this->HTMLheaderPageAnnots[]= \$an;
\t\treturn;
\t}
\t//Put an Annotation on the page
\t\$this->PageAnnots[\$page][] = \$an;
/*-- COLUMNS --*/
\t// Save cross-reference to Column buffer
\t\$ref = count(\$this->PageAnnots[\$this->page])-1;
\t\$this->columnAnnots[\$this->CurrCol][INTVAL(\$this->x)][INTVAL(\$this->y)] = \$ref;
/*-- END COLUMNS --*/
}
/*-- END ANNOTATIONS --*/


function _putfonts() {
\t\$nf=\$this->n;
\tforeach(\$this->FontFiles as \$fontkey=>\$info) {
\t   // TrueType embedded
\t   if (isset(\$info['type']) && \$info['type']=='TTF' && !\$info['sip'] && !\$info['smp']) {
\t\t\$used = true;
\t\t\$asSubset = false;
\t\tforeach(\$this->fonts AS \$k=>\$f) {
\t\t\tif (\$f['fontkey'] == \$fontkey && \$f['type']=='TTF') {
\t\t\t\t\$used = \$f['used'];
\t\t\t\tif (\$used) {
\t\t\t\t\t\$nChars = (ord(\$f['cw'][0]) << 8) + ord(\$f['cw'][1]);
\t\t\t\t\t\$usage = intval(count(\$f['subset'])*100 / \$nChars);
\t\t\t\t\t\$fsize = \$info['length1'];
\t\t\t\t\t// Always subset the very large TTF files
\t\t\t\t\tif (\$fsize > (\$this->maxTTFFilesize *1024)) { \$asSubset = true; }
\t\t\t\t\telse if (\$usage < \$this->percentSubset) { \$asSubset = true; }
\t\t\t\t}
\t\t\t\tif (\$f['unAGlyphs']) \$aaSubset = true;\t// mPDF 5.4.05
\t\t\t\tif (\$this->PDFA || \$this->PDFX)  \$asSubset = false;
\t\t\t\t\$this->fonts[\$k]['asSubset'] = \$asSubset;
\t\t\t\tbreak;
\t\t\t}
\t\t}
\t\tif (\$used && !\$asSubset) {
\t\t\t//Font file embedding
\t\t\t\$this->_newobj();
\t\t\t\$this->FontFiles[\$fontkey]['n']=\$this->n;
\t\t\t\$font='';
\t\t\t\$originalsize = \$info['length1'];
\t\t\tif (\$this->repackageTTF || \$this->fonts[\$fontkey]['TTCfontID']>0) {
\t\t\t\t// First see if there is a cached compressed file
\t\t\t\tif (file_exists(_MPDF_TTFONTDATAPATH.\$fontkey.'.ps.z')) {
\t\t\t\t\t\$f=fopen(_MPDF_TTFONTDATAPATH.\$fontkey.'.ps.z','rb');
\t\t\t\t\tif(!\$f) { \$this->Error('Font file .ps.z not found'); }
\t\t\t\t\twhile(!feof(\$f)) { \$font .= fread(\$f, 2048); }
\t\t\t\t\tfclose(\$f);
\t\t\t\t\tinclude(_MPDF_TTFONTDATAPATH.\$fontkey.'.ps.php');\t// sets \$originalsize (of repackaged font)
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\tif (!class_exists('TTFontFile', false)) { include(_MPDF_PATH .'classes/ttfontsuni.php'); }
\t\t\t\t\t\$ttf = new TTFontFile();
\t\t\t\t\t\$font = \$ttf->repackageTTF(\$this->FontFiles[\$fontkey]['ttffile'], \$this->fonts[\$fontkey]['TTCfontID'], \$this->debugfonts, \$this->fonts[\$fontkey]['unAGlyphs']);\t// mPDF 5.4.05

\t\t\t\t\t\$originalsize = strlen(\$font);
\t\t\t\t\t\$font = gzcompress(\$font);
\t\t\t\t\tunset(\$ttf);
\t\t\t\t\tif (is_writable(dirname(_MPDF_TTFONTDATAPATH.'x'))) {
\t\t\t\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$fontkey.'.ps.z',\"wb\");
\t\t\t\t\t\tfwrite(\$fh,\$font,strlen(\$font));
\t\t\t\t\t\tfclose(\$fh);
\t\t\t\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$fontkey.'.ps.php',\"wb\");
\t\t\t\t\t\t\$len = \"<?php \\n\";
\t\t\t\t\t\t\$len.='\$originalsize='.\$originalsize.\";\\n\";
\t\t\t\t\t\t\$len.=\"?>\";
\t\t\t\t\t\tfwrite(\$fh,\$len,strlen(\$len));
\t\t\t\t\t\tfclose(\$fh);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t\t\t// First see if there is a cached compressed file
\t\t\t\tif (file_exists(_MPDF_TTFONTDATAPATH.\$fontkey.'.z')) {
\t\t\t\t\t\$f=fopen(_MPDF_TTFONTDATAPATH.\$fontkey.'.z','rb');
\t\t\t\t\tif(!\$f) { \$this->Error('Font file not found'); }
\t\t\t\t\twhile(!feof(\$f)) { \$font .= fread(\$f, 2048); }
\t\t\t\t\tfclose(\$f);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$f=fopen(\$this->FontFiles[\$fontkey]['ttffile'],'rb');
\t\t\t\t\tif(!\$f) { \$this->Error('Font file not found'); }
\t\t\t\t\twhile(!feof(\$f)) { \$font .= fread(\$f, 2048); }
\t\t\t\t\tfclose(\$f);
\t\t\t\t\t\$font = gzcompress(\$font);
\t\t\t\t\tif (is_writable(dirname(_MPDF_TTFONTDATAPATH.'x'))) {
\t\t\t\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$fontkey.'.z',\"wb\");
\t\t\t\t\t\tfwrite(\$fh,\$font,strlen(\$font));
\t\t\t\t\t\tfclose(\$fh);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}

\t\t\t\$this->_out('<</Length '.strlen(\$font));
\t\t\t\$this->_out('/Filter /FlateDecode');
\t\t\t\$this->_out('/Length1 '.\$originalsize);
\t\t\t\$this->_out('>>');
\t\t\t\$this->_putstream(\$font);
\t\t\t\$this->_out('endobj');
\t\t}
\t   }
\t}

\t\$nfonts = count(\$this->fonts);
\t\$fctr = 1;
\tforeach(\$this->fonts as \$k=>\$font) {
\t\t//Font objects
\t\t\$type=\$font['type'];
\t\t\$name=\$font['name'];
\t\tif ((!isset(\$font['used']) || !\$font['used']) && \$type=='TTF') { continue; }
\t\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,intval(\$fctr*100/\$nfonts),'Writing Fonts'); \$fctr++; }\t// *PROGRESS-BAR*
\t\tif (isset(\$font['asSubset'])) { \$asSubset = \$font['asSubset']; }
\t\telse { \$asSubset = ''; }
/*-- CJK-FONTS --*/
\t\tif(\$type=='Type0') { \t// = Adobe CJK Fonts
\t\t\t\$this->fonts[\$k]['n']=\$this->n+1;
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Type /Font');
\t\t\t\$this->_putType0(\$font);
\t\t}
\t\telse
/*-- END CJK-FONTS --*/
\t\tif(\$type=='core') {
\t\t\t//Standard font
\t\t\t\$this->fonts[\$k]['n']=\$this->n+1;
\t\t\tif (\$this->PDFA || \$this->PDFX) { \$this->Error('Core fonts are not allowed in PDF/A1-b or PDFX/1-a files (Times, Helvetica, Courier etc.)'); }
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Type /Font');
\t\t\t\$this->_out('/BaseFont /'.\$name);
\t\t\t\$this->_out('/Subtype /Type1');
\t\t\tif(\$name!='Symbol' && \$name!='ZapfDingbats') {
\t\t\t\t\$this->_out('/Encoding /WinAnsiEncoding');
\t\t\t}
\t\t\t\$this->_out('>>');
\t\t\t\$this->_out('endobj');
\t\t}
\t\t// TrueType embedded SUBSETS for SIP (CJK extB containing Supplementary Ideographic Plane 2)
\t\t// Or Unicode Plane 1 - Supplementary Multilingual Plane
\t\telse if (\$type=='TTF' && (\$font['sip'] || \$font['smp'])) {
\t\t   if (!\$font['used']) { continue; }
\t\t   \$ssfaid=\"AA\";
\t\t   if (!class_exists('TTFontFile', false)) { include(_MPDF_PATH .'classes/ttfontsuni.php'); }
\t\t   \$ttf = new TTFontFile();
\t\t   for(\$sfid=0;\$sfid<count(\$font['subsetfontids']);\$sfid++) {
\t\t\t\$this->fonts[\$k]['n'][\$sfid]=\$this->n+1;\t\t// NB an array for subset
\t\t\t\$subsetname = 'MPDF'.\$ssfaid.'+'.\$font['name'];
\t\t\t\$ssfaid++;
\t\t\t\$subset = \$font['subsets'][\$sfid];
\t\t\tunset(\$subset[0]);
\t\t\t\$ttfontstream = \$ttf->makeSubsetSIP(\$font['ttffile'], \$subset, \$font['TTCfontID'], \$this->debugfonts);
\t\t\t\$ttfontsize = strlen(\$ttfontstream);
\t\t\t\$fontstream = gzcompress(\$ttfontstream);
\t\t\t\$widthstring = '';
\t\t\t\$toUnistring = '';
\t\t\tforeach(\$font['subsets'][\$sfid] AS \$cp=>\$u) {
\t\t\t\t\$w = \$this->_getCharWidth(\$font['cw'], \$u);
\t\t\t\tif (\$w !== false) {
\t\t\t\t\t\$widthstring .= \$w.' ';
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$widthstring .= round(\$ttf->defaultWidth).' ';
\t\t\t\t}
\t\t\t\tif (\$u > 65535) {
\t\t\t\t\t\$utf8 = chr((\$u>>18)+240).chr(((\$u>>12)&63)+128).chr(((\$u>>6)&63)+128) .chr((\$u&63)+128);
\t\t\t\t\t\$utf16 = mb_convert_encoding(\$utf8, 'UTF-16BE', 'UTF-8');
\t\t\t\t\t\$l1 = ord(\$utf16[0]);
\t\t\t\t\t\$h1 = ord(\$utf16[1]);
\t\t\t\t\t\$l2 = ord(\$utf16[2]);
\t\t\t\t\t\$h2 = ord(\$utf16[3]);
\t\t\t\t\t\$toUnistring .= sprintf(\"<%02s> <%02s%02s%02s%02s>\\n\", strtoupper(dechex(\$cp)), strtoupper(dechex(\$l1)), strtoupper(dechex(\$h1)), strtoupper(dechex(\$l2)), strtoupper(dechex(\$h2)));
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$toUnistring .= sprintf(\"<%02s> <%04s>\\n\", strtoupper(dechex(\$cp)), strtoupper(dechex(\$u)));
\t\t\t\t}
\t\t\t}

\t\t\t//Additional Type1 or TrueType font
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Type /Font');
\t\t\t\$this->_out('/BaseFont /'.\$subsetname);
\t\t\t\$this->_out('/Subtype /TrueType');
\t\t\t\$this->_out('/FirstChar 0 /LastChar '.(count(\$font['subsets'][\$sfid])-1));
\t\t\t\$this->_out('/Widths '.(\$this->n+1).' 0 R');
\t\t\t\$this->_out('/FontDescriptor '.(\$this->n+2).' 0 R');
\t\t\t\$this->_out('/ToUnicode '.(\$this->n + 3).' 0 R');
\t\t\t\$this->_out('>>');
\t\t\t\$this->_out('endobj');

\t\t\t//Widths
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('['.\$widthstring.']');
\t\t\t\$this->_out('endobj');

\t\t\t//Descriptor
\t\t\t\$this->_newobj();
\t\t\t\$s='<</Type /FontDescriptor /FontName /'.\$subsetname.\"\\n\";
\t\t\tforeach(\$font['desc'] as \$kd=>\$v) {
\t\t\t\tif (\$kd == 'Flags') { \$v = \$v | 4; \$v = \$v & ~32; }\t// SYMBOLIC font flag
\t\t\t\t\$s.=' /'.\$kd.' '.\$v.\"\\n\";
\t\t\t}
\t\t\t\$s.='/FontFile2 '.(\$this->n + 2).' 0 R';
\t\t\t\$this->_out(\$s.'>>');
\t\t\t\$this->_out('endobj');

\t\t\t// ToUnicode
\t\t\t\$this->_newobj();
\t\t\t\$toUni = \"/CIDInit /ProcSet findresource begin\\n\";
\t\t\t\$toUni .= \"12 dict begin\\n\";
\t\t\t\$toUni .= \"begincmap\\n\";
\t\t\t\$toUni .= \"/CIDSystemInfo\\n\";
\t\t\t\$toUni .= \"<</Registry (Adobe)\\n\";
\t\t\t\$toUni .= \"/Ordering (UCS)\\n\";
\t\t\t\$toUni .= \"/Supplement 0\\n\";
\t\t\t\$toUni .= \">> def\\n\";
\t\t\t\$toUni .= \"/CMapName /Adobe-Identity-UCS def\\n\";
\t\t\t\$toUni .= \"/CMapType 2 def\\n\";
\t\t\t\$toUni .= \"1 begincodespacerange\\n\";
\t\t\t\$toUni .= \"<00> <FF>\\n\";
\t\t\t\$toUni .= \"endcodespacerange\\n\";
\t\t\t\$toUni .= count(\$font['subsets'][\$sfid]).\" beginbfchar\\n\";
\t\t\t\$toUni .= \$toUnistring;
\t\t\t\$toUni .= \"endbfchar\\n\";
\t\t\t\$toUni .= \"endcmap\\n\";
\t\t\t\$toUni .= \"CMapName currentdict /CMap defineresource pop\\n\";
\t\t\t\$toUni .= \"end\\n\";
\t\t\t\$toUni .= \"end\\n\";

\t\t\t\$this->_out('<</Length '.(strlen(\$toUni)).'>>');
\t\t\t\$this->_putstream(\$toUni);
\t\t\t\$this->_out('endobj');

\t\t\t//Font file
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Length '.strlen(\$fontstream));
\t\t\t\$this->_out('/Filter /FlateDecode');
\t\t\t\$this->_out('/Length1 '.\$ttfontsize);
\t\t\t\$this->_out('>>');
\t\t\t\$this->_putstream(\$fontstream);
\t\t\t\$this->_out('endobj');
\t\t   }\t// foreach subset
\t\t   unset(\$ttf);
\t\t}
\t\t// TrueType embedded SUBSETS or FULL
\t\telse if (\$type=='TTF') {
\t\t\t\$this->fonts[\$k]['n']=\$this->n+1;
\t\t\tif (\$asSubset ) {
\t\t\t\t\$ssfaid=\"A\";
\t\t\t\tif (!class_exists('TTFontFile', false)) { include(_MPDF_PATH .'classes/ttfontsuni.php'); }
\t\t\t\t\$ttf = new TTFontFile();
\t\t\t\t\$fontname = 'MPDFA'.\$ssfaid.'+'.\$font['name'];
\t\t\t\t\$subset = \$font['subset'];
\t\t\t\tunset(\$subset[0]);
\t\t\t\t\$ttfontstream = \$ttf->makeSubset(\$font['ttffile'], \$subset, \$font['TTCfontID'], \$this->debugfonts, \$font['unAGlyphs']);\t// mPDF 5.4.05
\t\t\t\t\$ttfontsize = strlen(\$ttfontstream);
\t\t\t\t\$fontstream = gzcompress(\$ttfontstream);
\t\t\t\t\$codeToGlyph = \$ttf->codeToGlyph;
\t\t\t\tunset(\$codeToGlyph[0]);
\t\t\t}
\t\t\telse { \$fontname = \$font['name']; }
\t\t\t// Type0 Font
\t\t\t// A composite font - a font composed of other fonts, organized hierarchically
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Type /Font');
\t\t\t\$this->_out('/Subtype /Type0');
\t\t\t\$this->_out('/BaseFont /'.\$fontname.'');
\t\t\t\$this->_out('/Encoding /Identity-H');
\t\t\t\$this->_out('/DescendantFonts ['.(\$this->n + 1).' 0 R]');
\t\t\t\$this->_out('/ToUnicode '.(\$this->n + 2).' 0 R');
\t\t\t\$this->_out('>>');
\t\t\t\$this->_out('endobj');

\t\t\t// CIDFontType2
\t\t\t// A CIDFont whose glyph descriptions are based on TrueType font technology
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Type /Font');
\t\t\t\$this->_out('/Subtype /CIDFontType2');
\t\t\t\$this->_out('/BaseFont /'.\$fontname.'');
\t\t\t\$this->_out('/CIDSystemInfo '.(\$this->n + 2).' 0 R');
\t\t\t\$this->_out('/FontDescriptor '.(\$this->n + 3).' 0 R');
\t\t\tif (isset(\$font['desc']['MissingWidth'])){
\t\t\t\t\$this->_out('/DW '.\$font['desc']['MissingWidth'].'');
\t\t\t}

\t\t\tif (!\$asSubset && file_exists(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cw')) {
\t\t\t\t\t\$w = '';
\t\t\t\t\t\$w=file_get_contents(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cw');
\t\t\t\t\t\$this->_out(\$w);
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->_putTTfontwidths(\$font, \$asSubset, \$ttf->maxUni);
\t\t\t}

\t\t\t\$this->_out('/CIDToGIDMap '.(\$this->n + 4).' 0 R');
\t\t\t\$this->_out('>>');
\t\t\t\$this->_out('endobj');

\t\t\t// ToUnicode
\t\t\t\$this->_newobj();
\t\t\t\$toUni = \"/CIDInit /ProcSet findresource begin\\n\";
\t\t\t\$toUni .= \"12 dict begin\\n\";
\t\t\t\$toUni .= \"begincmap\\n\";
\t\t\t\$toUni .= \"/CIDSystemInfo\\n\";
\t\t\t\$toUni .= \"<</Registry (Adobe)\\n\";
\t\t\t\$toUni .= \"/Ordering (UCS)\\n\";
\t\t\t\$toUni .= \"/Supplement 0\\n\";
\t\t\t\$toUni .= \">> def\\n\";
\t\t\t\$toUni .= \"/CMapName /Adobe-Identity-UCS def\\n\";
\t\t\t\$toUni .= \"/CMapType 2 def\\n\";
\t\t\t\$toUni .= \"1 begincodespacerange\\n\";
\t\t\t\$toUni .= \"<0000> <FFFF>\\n\";
\t\t\t\$toUni .= \"endcodespacerange\\n\";
\t\t\t\$toUni .= \"1 beginbfrange\\n\";
\t\t\t\$toUni .= \"<0000> <FFFF> <0000>\\n\";
\t\t\t\$toUni .= \"endbfrange\\n\";
\t\t\t\$toUni .= \"endcmap\\n\";
\t\t\t\$toUni .= \"CMapName currentdict /CMap defineresource pop\\n\";
\t\t\t\$toUni .= \"end\\n\";
\t\t\t\$toUni .= \"end\\n\";
\t\t\t\$this->_out('<</Length '.(strlen(\$toUni)).'>>');
\t\t\t\$this->_putstream(\$toUni);
\t\t\t\$this->_out('endobj');


\t\t\t// CIDSystemInfo dictionary
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Registry (Adobe)');
\t\t\t\$this->_out('/Ordering (UCS)');
\t\t\t\$this->_out('/Supplement 0');
\t\t\t\$this->_out('>>');
\t\t\t\$this->_out('endobj');

\t\t\t// Font descriptor
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Type /FontDescriptor');
\t\t\t\$this->_out('/FontName /'.\$fontname);
\t\t\tforeach(\$font['desc'] as \$kd=>\$v) {
\t\t\t\tif (\$asSubset && \$kd == 'Flags') { \$v = \$v | 4; \$v = \$v & ~32; }\t// SYMBOLIC font flag
\t\t\t\t\$this->_out(' /'.\$kd.' '.\$v);
\t\t\t}
\t\t\tif (\$font['panose']) {
\t\t\t\t\$this->_out(' /Style << /Panose <'.\$font['panose'].'> >>');
\t\t\t}
\t\t\tif (\$asSubset ) {
\t\t\t\t\$this->_out('/FontFile2 '.(\$this->n + 2).' 0 R');
\t\t\t}
\t\t\telse if (\$font['fontkey']) {
\t\t\t\t// obj ID of a stream containing a TrueType font program
\t\t\t\t\$this->_out('/FontFile2 '.\$this->FontFiles[\$font['fontkey']]['n'].' 0 R');
\t\t\t}
\t\t\t\$this->_out('>>');
\t\t\t\$this->_out('endobj');

\t\t\t// Embed CIDToGIDMap
\t\t\t// A specification of the mapping from CIDs to glyph indices
\t\t\tif (\$asSubset ) {
\t\t\t\t\$cidtogidmap = '';
\t\t\t\t\$cidtogidmap = str_pad('', 256*256*2, \"\\x00\");
\t\t\t\tforeach(\$codeToGlyph as \$cc=>\$glyph) {
\t\t\t\t\t\$cidtogidmap[\$cc*2] = chr(\$glyph >> 8);
\t\t\t\t\t\$cidtogidmap[\$cc*2 + 1] = chr(\$glyph & 0xFF);
\t\t\t\t}
\t\t\t\t\$cidtogidmap = gzcompress(\$cidtogidmap);
\t\t\t}
\t\t\telse {
\t\t\t\t// First see if there is a cached CIDToGIDMapfile
\t\t\t\t\$cidtogidmap = '';
\t\t\t\tif (file_exists(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cgm')) {
\t\t\t\t\t\$f=fopen(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cgm','rb');
\t\t\t\t\twhile(!feof(\$f)) { \$cidtogidmap .= fread(\$f, 2048); }
\t\t\t\t\tfclose(\$f);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\tif (!class_exists('TTFontFile', false)) { include(_MPDF_PATH .'classes/ttfontsuni.php'); }
\t\t\t\t\t\$ttf = new TTFontFile();
\t\t\t\t\t\$charToGlyph = \$ttf->getCTG(\$font['ttffile'], \$font['TTCfontID'], \$this->debugfonts, \$font['unAGlyphs']);\t// mPDF 5.4.05
\t\t\t\t\t\$cidtogidmap = str_pad('', 256*256*2, \"\\x00\");
\t\t\t\t\tforeach(\$charToGlyph as \$cc=>\$glyph) {
\t\t\t\t\t\t\$cidtogidmap[\$cc*2] = chr(\$glyph >> 8);
\t\t\t\t\t\t\$cidtogidmap[\$cc*2 + 1] = chr(\$glyph & 0xFF);
\t\t\t\t\t}
\t\t\t\t\tunset(\$ttf);
\t\t\t\t\t\$cidtogidmap = gzcompress(\$cidtogidmap);
\t\t\t\t\tif (is_writable(dirname(_MPDF_TTFONTDATAPATH.'x'))) {
\t\t\t\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cgm',\"wb\");
\t\t\t\t\t\tfwrite(\$fh,\$cidtogidmap,strlen(\$cidtogidmap));
\t\t\t\t\t\tfclose(\$fh);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t\$this->_newobj();
\t\t\t\$this->_out('<</Length '.strlen(\$cidtogidmap).'');
\t\t\t\$this->_out('/Filter /FlateDecode');
\t\t\t\$this->_out('>>');
\t\t\t\$this->_putstream(\$cidtogidmap);
\t\t\t\$this->_out('endobj');

\t\t\t//Font file
\t\t\tif (\$asSubset ) {
\t\t\t\t\$this->_newobj();
\t\t\t\t\$this->_out('<</Length '.strlen(\$fontstream));
\t\t\t\t\$this->_out('/Filter /FlateDecode');
\t\t\t\t\$this->_out('/Length1 '.\$ttfontsize);
\t\t\t\t\$this->_out('>>');
\t\t\t\t\$this->_putstream(\$fontstream);
\t\t\t\t\$this->_out('endobj');
\t\t\t\tunset(\$ttf);
\t\t\t}
\t\t}
\t\telse { \$this->Error('Unsupported font type: '.\$type.' ('.\$name.')'); }
\t}
}



function _putTTfontwidths(&\$font, \$asSubset, \$maxUni) {
\tif (\$asSubset && file_exists(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cw127.php')) {
\t\tinclude(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cw127.php') ;
\t\t\$startcid = 128;
\t}
\telse {
\t\t\$rangeid = 0;
\t\t\$range = array();
\t\t\$prevcid = -2;
\t\t\$prevwidth = -1;
\t\t\$interval = false;
\t\t\$startcid = 1;
\t}
\tif (\$asSubset) { \$cwlen = \$maxUni + 1; }
\telse { \$cwlen = (strlen(\$font['cw'])/2); }

\t// for each character
\tfor (\$cid=\$startcid; \$cid<\$cwlen; \$cid++) {
\t\tif (\$cid==128 && \$asSubset && (!file_exists(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cw127.php'))) {
\t\t\tif (is_writable(dirname(_MPDF_TTFONTDATAPATH.'x'))) {
\t\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cw127.php',\"wb\");
\t\t\t\t\$cw127='<?php'.\"\\n\";
\t\t\t\t\$cw127.='\$rangeid='.\$rangeid.\";\\n\";
\t\t\t\t\$cw127.='\$prevcid='.\$prevcid.\";\\n\";
\t\t\t\t\$cw127.='\$prevwidth='.\$prevwidth.\";\\n\";
\t\t\t\tif (\$interval) { \$cw127.='\$interval=true'.\";\\n\"; }
\t\t\t\telse { \$cw127.='\$interval=false'.\";\\n\"; }
\t\t\t\t\$cw127.='\$range='.var_export(\$range,true).\";\\n\";
\t\t\t\t\$cw127.=\"?>\";
\t\t\t\tfwrite(\$fh,\$cw127,strlen(\$cw127));
\t\t\t\tfclose(\$fh);
\t\t\t}
\t\t}
\t\tif (\$font['cw'][\$cid*2] == \"\\00\" && \$font['cw'][\$cid*2+1] == \"\\00\") { continue; }
\t\t\$width = (ord(\$font['cw'][\$cid*2]) << 8) + ord(\$font['cw'][\$cid*2+1]);
\t\tif (\$width == 65535) { \$width = 0; }
\t\tif (\$asSubset && \$cid > 255 && (!isset(\$font['subset'][\$cid]) || !\$font['subset'][\$cid])) {
\t\t\tcontinue;
\t\t}
\t\tif (!isset(\$font['dw']) || (isset(\$font['dw']) && \$width != \$font['dw'])) {
\t\t\tif (\$cid == (\$prevcid + 1)) {
\t\t\t\t// consecutive CID
\t\t\t\tif (\$width == \$prevwidth) {
\t\t\t\t\tif (\$width == \$range[\$rangeid][0]) {
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t} else {
\t\t\t\t\t\tarray_pop(\$range[\$rangeid]);
\t\t\t\t\t\t// new range
\t\t\t\t\t\t\$rangeid = \$prevcid;
\t\t\t\t\t\t\$range[\$rangeid] = array();
\t\t\t\t\t\t\$range[\$rangeid][] = \$prevwidth;
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t}
\t\t\t\t\t\$interval = true;
\t\t\t\t\t\$range[\$rangeid]['interval'] = true;
\t\t\t\t} else {
\t\t\t\t\tif (\$interval) {
\t\t\t\t\t\t// new range
\t\t\t\t\t\t\$rangeid = \$cid;
\t\t\t\t\t\t\$range[\$rangeid] = array();
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t} else {
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t}
\t\t\t\t\t\$interval = false;
\t\t\t\t}
\t\t\t} else {
\t\t\t\t// new range
\t\t\t\t\$rangeid = \$cid;
\t\t\t\t\$range[\$rangeid] = array();
\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\$interval = false;
\t\t\t}
\t\t\t\$prevcid = \$cid;
\t\t\t\$prevwidth = \$width;
\t\t}
\t}
\t\$w = \$this->_putfontranges(\$range);
\t\$this->_out(\$w);
\tif (!\$asSubset) {
\t\tif (is_writable(dirname(_MPDF_TTFONTDATAPATH.'x'))) {
\t\t\t\$fh = fopen(_MPDF_TTFONTDATAPATH.\$font['fontkey'].'.cw',\"wb\");
\t\t\tfwrite(\$fh,\$w,strlen(\$w));
\t\t\tfclose(\$fh);
\t\t}
\t}
}

function _putfontranges(&\$range) {
\t// optimize ranges
\t\$prevk = -1;
\t\$nextk = -1;
\t\$prevint = false;
\tforeach (\$range as \$k => \$ws) {
\t\t\$cws = count(\$ws);
\t\tif ((\$k == \$nextk) AND (!\$prevint) AND ((!isset(\$ws['interval'])) OR (\$cws < 4))) {
\t\t\tif (isset(\$range[\$k]['interval'])) {
\t\t\t\tunset(\$range[\$k]['interval']);
\t\t\t}
\t\t\t\$range[\$prevk] = array_merge(\$range[\$prevk], \$range[\$k]);
\t\t\tunset(\$range[\$k]);
\t\t} else {
\t\t\t\$prevk = \$k;
\t\t}
\t\t\$nextk = \$k + \$cws;
\t\tif (isset(\$ws['interval'])) {
\t\t\tif (\$cws > 3) {
\t\t\t\t\$prevint = true;
\t\t\t} else {
\t\t\t\t\$prevint = false;
\t\t\t}
\t\t\tunset(\$range[\$k]['interval']);
\t\t\t--\$nextk;
\t\t} else {
\t\t\t\$prevint = false;
\t\t}
\t}
\t// output data
\t\$w = '';
\tforeach (\$range as \$k => \$ws) {
\t\tif (count(array_count_values(\$ws)) == 1) {
\t\t\t// interval mode is more compact
\t\t\t\$w .= ' '.\$k.' '.(\$k + count(\$ws) - 1).' '.\$ws[0];
\t\t} else {
\t\t\t// range mode
\t\t\t\$w .= ' '.\$k.' [ '.implode(' ', \$ws).' ]' . \"\\n\";
\t\t}
\t}
\treturn '/W ['.\$w.' ]';
}


function _putfontwidths(&\$font, \$cidoffset=0) {
\tksort(\$font['cw']);
\tunset(\$font['cw'][65535]);
\t\$rangeid = 0;
\t\$range = array();
\t\$prevcid = -2;
\t\$prevwidth = -1;
\t\$interval = false;
\t// for each character
\tforeach (\$font['cw'] as \$cid => \$width) {
\t\t\$cid -= \$cidoffset;
\t\tif (!isset(\$font['dw']) || (isset(\$font['dw']) && \$width != \$font['dw'])) {
\t\t\tif (\$cid == (\$prevcid + 1)) {
\t\t\t\t// consecutive CID
\t\t\t\tif (\$width == \$prevwidth) {
\t\t\t\t\tif (\$width == \$range[\$rangeid][0]) {
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t} else {
\t\t\t\t\t\tarray_pop(\$range[\$rangeid]);
\t\t\t\t\t\t// new range
\t\t\t\t\t\t\$rangeid = \$prevcid;
\t\t\t\t\t\t\$range[\$rangeid] = array();
\t\t\t\t\t\t\$range[\$rangeid][] = \$prevwidth;
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t}
\t\t\t\t\t\$interval = true;
\t\t\t\t\t\$range[\$rangeid]['interval'] = true;
\t\t\t\t} else {
\t\t\t\t\tif (\$interval) {
\t\t\t\t\t\t// new range
\t\t\t\t\t\t\$rangeid = \$cid;
\t\t\t\t\t\t\$range[\$rangeid] = array();
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t} else {
\t\t\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\t}
\t\t\t\t\t\$interval = false;
\t\t\t\t}
\t\t\t} else {
\t\t\t\t// new range
\t\t\t\t\$rangeid = \$cid;
\t\t\t\t\$range[\$rangeid] = array();
\t\t\t\t\$range[\$rangeid][] = \$width;
\t\t\t\t\$interval = false;
\t\t\t}
\t\t\t\$prevcid = \$cid;
\t\t\t\$prevwidth = \$width;
\t\t}
\t}
\t\$this->_out(\$this->_putfontranges(\$range));
}


/*-- CJK-FONTS --*/

// from class PDF_Chinese CJK EXTENSIONS
function _putType0(&\$font)
{
\t//Type0
\t\$this->_out('/Subtype /Type0');
\t\$this->_out('/BaseFont /'.\$font['name'].'-'.\$font['CMap']);
\t\$this->_out('/Encoding /'.\$font['CMap']);
\t\$this->_out('/DescendantFonts ['.(\$this->n+1).' 0 R]');
\t\$this->_out('>>');
\t\$this->_out('endobj');
\t//CIDFont
\t\$this->_newobj();
\t\$this->_out('<</Type /Font');
\t\$this->_out('/Subtype /CIDFontType0');
\t\$this->_out('/BaseFont /'.\$font['name']);

\t\$cidinfo = '/Registry '.\$this->_textstring('Adobe');
\t\$cidinfo .= ' /Ordering '.\$this->_textstring(\$font['registry']['ordering']);
\t\$cidinfo .= ' /Supplement '.\$font['registry']['supplement'];
\t\$this->_out('/CIDSystemInfo <<'.\$cidinfo.'>>');

\t\$this->_out('/FontDescriptor '.(\$this->n+1).' 0 R');
\tif (isset(\$font['MissingWidth'])){
\t\t\$this->_out('/DW '.\$font['MissingWidth'].'');
\t}
\t\$this->_putfontwidths(\$font, 31);
\t\$this->_out('>>');
\t\$this->_out('endobj');

\t//Font descriptor
\t\$this->_newobj();
\t\$s = '<</Type /FontDescriptor /FontName /'.\$font['name'];
\tforeach (\$font['desc'] as \$k => \$v) {
\t\tif (\$k != 'Style') {
\t\t\t\$s .= ' /'.\$k.' '.\$v.'';
\t\t}
\t}
\t\$this->_out(\$s.'>>');
\t\$this->_out('endobj');
}
/*-- END CJK-FONTS --*/



function _putimages()
{
\t\$filter=(\$this->compress) ? '/Filter /FlateDecode ' : '';
\treset(\$this->images);
\twhile(list(\$file,\$info)=each(\$this->images)) {
\t\t\$this->_newobj();
\t\t\$this->images[\$file]['n']=\$this->n;
\t\t\$this->_out('<</Type /XObject');
\t\t\$this->_out('/Subtype /Image');
\t\t\$this->_out('/Width '.\$info['w']);
\t\t\$this->_out('/Height '.\$info['h']);
\t\tif (isset(\$info['masked'])) {
\t\t\t\$this->_out('/SMask '.(\$this->n - 1).' 0 R');
\t\t}
\t\tif(\$info['cs']=='Indexed') {
\t\t\tif (\$this->PDFX || (\$this->PDFA && \$this->restrictColorSpace==3)) { \$this->Error(\"PDFA1-b and PDFX/1-a files do not permit using mixed colour space (\".\$file.\").\"); }
\t\t\t\$this->_out('/ColorSpace [/Indexed /DeviceRGB '.(strlen(\$info['pal'])/3-1).' '.(\$this->n+1).' 0 R]');
\t\t}
\t\telse {
\t\t\t\$this->_out('/ColorSpace /'.\$info['cs']);
\t\t\tif(\$info['cs']=='DeviceCMYK') {
\t\t\t\tif (\$this->PDFA && \$this->restrictColorSpace!=3) { \$this->Error(\"PDFA1-b does not permit Images using mixed colour space (\".\$file.\").\"); }
\t\t\t\tif(\$info['type']=='jpg') { \$this->_out('/Decode [1 0 1 0 1 0 1 0]'); }
\t\t\t}
\t\t\telse if (\$info['cs']=='DeviceRGB' && (\$this->PDFX || (\$this->PDFA && \$this->restrictColorSpace==3))) { \$this->Error(\"PDFA1-b and PDFX/1-a files do not permit using mixed colour space (\".\$file.\").\"); }
\t\t}
\t\t\$this->_out('/BitsPerComponent '.\$info['bpc']);
\t\tif (isset(\$info['f']) && \$info['f']) { \$this->_out('/Filter /'.\$info['f']); }
\t\tif(isset(\$info['parms'])) { \$this->_out(\$info['parms']); }
\t\tif(isset(\$info['trns']) and is_array(\$info['trns'])) {
\t\t\t\$trns='';
\t\t\tfor(\$i=0;\$i<count(\$info['trns']);\$i++)
\t\t\t\t\$trns.=\$info['trns'][\$i].' '.\$info['trns'][\$i].' ';
\t\t\t\$this->_out('/Mask ['.\$trns.']');
\t\t}
\t\t\$this->_out('/Length '.strlen(\$info['data']).'>>');
\t\t\$this->_putstream(\$info['data']);

\t\tunset(\$this->images[\$file]['data']);
\t\t\$this->_out('endobj');
\t\t//Palette
\t\tif(\$info['cs']=='Indexed') {
\t\t\t\$this->_newobj();
\t\t\t\$pal=(\$this->compress) ? gzcompress(\$info['pal']) : \$info['pal'];
\t\t\t\$this->_out('<<'.\$filter.'/Length '.strlen(\$pal).'>>');
\t\t\t\$this->_putstream(\$pal);
\t\t\t\$this->_out('endobj');
\t\t}
\t}
}

function _putinfo()
{
\t\$this->_out('/Producer '.\$this->_UTF16BEtextstring('mPDF '.mPDF_VERSION));
\tif(!empty(\$this->title))
\t\t\$this->_out('/Title '.\$this->_UTF16BEtextstring(\$this->title));
\tif(!empty(\$this->subject))
\t\t\$this->_out('/Subject '.\$this->_UTF16BEtextstring(\$this->subject));
\tif(!empty(\$this->author))
\t\t\$this->_out('/Author '.\$this->_UTF16BEtextstring(\$this->author));
\tif(!empty(\$this->keywords))
\t\t\$this->_out('/Keywords '.\$this->_UTF16BEtextstring(\$this->keywords));
\tif(!empty(\$this->creator))
\t\t\$this->_out('/Creator '.\$this->_UTF16BEtextstring(\$this->creator));

\t\$z = date('O'); // +0200
\t\$offset = substr(\$z,0,3).\"'\".substr(\$z,3,2).\"'\";
\t\$this->_out('/CreationDate '.\$this->_textstring(date('YmdHis').\$offset));
\t\$this->_out('/ModDate '.\$this->_textstring(date('YmdHis').\$offset));
\tif (\$this->PDFX) {
\t\t\$this->_out('/Trapped/False');
\t\t\$this->_out('/GTS_PDFXVersion(PDF/X-1a:2003)');
\t}
}

function _putmetadata() {
\t\$this->_newobj();
\t\$this->MetadataRoot = \$this->n;
\t\$Producer = 'mPDF '.mPDF_VERSION;
\t\$z = date('O'); // +0200
\t\$offset = substr(\$z,0,3).':'.substr(\$z,3,2);
\t\$CreationDate = date('Y-m-d\\TH:i:s').\$offset;\t// 2006-03-10T10:47:26-05:00 2006-06-19T09:05:17Z
\t\$uuid = sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xffff), mt_rand(0, 0xffff),
\t\t\tmt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000,
\t\t\tmt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)  );


\t\$m = '<?xpacket begin=\"'.chr(239).chr(187).chr(191).'\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>'.\"\\n\";\t// begin = FEFF BOM
\t\$m .= ' <x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"3.1-701\">'.\"\\n\";
\t\$m .= '  <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">'.\"\\n\";
\t\$m .= '   <rdf:Description rdf:about=\"uuid:'.\$uuid.'\" xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">'.\"\\n\";
\t\$m .= '    <pdf:Producer>'.\$Producer.'</pdf:Producer>'.\"\\n\";
\tif(!empty(\$this->keywords)) { \$m .= '    <pdf:Keywords>'.\$this->keywords.'</pdf:Keywords>'.\"\\n\"; }
\t\$m .= '   </rdf:Description>'.\"\\n\";

\t\$m .= '   <rdf:Description rdf:about=\"uuid:'.\$uuid.'\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">'.\"\\n\";
\t\$m .= '    <xmp:CreateDate>'.\$CreationDate.'</xmp:CreateDate>'.\"\\n\";
\t\$m .= '    <xmp:ModifyDate>'.\$CreationDate.'</xmp:ModifyDate>'.\"\\n\";
\t\$m .= '    <xmp:MetadataDate>'.\$CreationDate.'</xmp:MetadataDate>'.\"\\n\";
\tif(!empty(\$this->creator)) { \$m .= '    <xmp:CreatorTool>'.\$this->creator.'</xmp:CreatorTool>'.\"\\n\"; }
\t\$m .= '   </rdf:Description>'.\"\\n\";

\t// DC elements
\t\$m .= '   <rdf:Description rdf:about=\"uuid:'.\$uuid.'\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">'.\"\\n\";
\t\$m .= '    <dc:format>application/pdf</dc:format>'.\"\\n\";
\tif(!empty(\$this->title)) {
\t\t\$m .= '    <dc:title>
     <rdf:Alt>
      <rdf:li xml:lang=\"x-default\">'.\$this->title.'</rdf:li>
     </rdf:Alt>
    </dc:title>'.\"\\n\";
\t}
\tif(!empty(\$this->keywords)) {
\t\t\$m .= '    <dc:subject>
     <rdf:Bag>
      <rdf:li>'.\$this->keywords.'</rdf:li>
     </rdf:Bag>
    </dc:subject>'.\"\\n\";
\t}
\tif(!empty(\$this->subject)) {
\t\t\$m .= '    <dc:description>
     <rdf:Alt>
      <rdf:li xml:lang=\"x-default\">'.\$this->subject.'</rdf:li>
     </rdf:Alt>
    </dc:description>'.\"\\n\";
\t}
\tif(!empty(\$this->author)) {
\t\t\$m .= '    <dc:creator>
     <rdf:Seq>
      <rdf:li>'.\$this->author.'</rdf:li>
     </rdf:Seq>
    </dc:creator>'.\"\\n\";
\t}
\t\$m .= '   </rdf:Description>'.\"\\n\";


\t// This bit is specific to PDFX-1a
\tif (\$this->PDFX) {
\t\t\$m .= '   <rdf:Description rdf:about=\"uuid:'.\$uuid.'\" xmlns:pdfx=\"http://ns.adobe.com/pdfx/1.3/\" pdfx:Apag_PDFX_Checkup=\"1.3\" pdfx:GTS_PDFXConformance=\"PDF/X-1a:2003\" pdfx:GTS_PDFXVersion=\"PDF/X-1:2003\"/>'.\"\\n\";
\t}

\t// This bit is specific to PDFA-1b
\telse if (\$this->PDFA) {
\t\t\$m .= '   <rdf:Description rdf:about=\"uuid:'.\$uuid.'\" xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\" >'.\"\\n\";
\t\t\$m .= '    <pdfaid:part>1</pdfaid:part>'.\"\\n\";
\t\t\$m .= '    <pdfaid:conformance>B</pdfaid:conformance>'.\"\\n\";
\t\t\$m .= '    <pdfaid:amd>2005</pdfaid:amd>'.\"\\n\";
\t\t\$m .= '   </rdf:Description>'.\"\\n\";
\t}

\t\$m .= '   <rdf:Description rdf:about=\"uuid:'.\$uuid.'\" xmlns:xmpMM=\"http://ns.adobe.com/xap/1.0/mm/\">'.\"\\n\";
\t\$m .= '    <xmpMM:DocumentID>uuid:'.\$uuid.'</xmpMM:DocumentID>'.\"\\n\";
\t\$m .= '   </rdf:Description>'.\"\\n\";
\t\$m .= '  </rdf:RDF>'.\"\\n\";
\t\$m .= ' </x:xmpmeta>'.\"\\n\";
\t\$m .= str_repeat(str_repeat(' ',100).\"\\n\",20);\t// 2-4kB whitespace padding required
\t\$m .= '<?xpacket end=\"w\"?>';\t// \"r\" read only
\t\$this->_out('<</Type/Metadata/Subtype/XML/Length '.strlen(\$m).'>>');
\t\$this->_putstream(\$m);
\t\$this->_out('endobj');
}

function _putoutputintent() {
\t\$this->_newobj();
\t\$this->OutputIntentRoot = \$this->n;
\t\$this->_out('<</Type /OutputIntent');

\tif (\$this->PDFA) {
\t\t\$this->_out('/S /GTS_PDFA1');
\t\tif (\$this->ICCProfile) {
\t\t\t\$this->_out('/Info ('.preg_replace('/_/',' ',\$this->ICCProfile).')');
\t\t\t\$this->_out('/OutputConditionIdentifier (Custom)');
\t\t\t\$this->_out('/OutputCondition ()');
\t\t}
\t\telse {
\t\t\t\$this->_out('/Info (sRGB IEC61966-2.1)');
\t\t\t\$this->_out('/OutputConditionIdentifier (sRGB IEC61966-2.1)');
\t\t\t\$this->_out('/OutputCondition ()');
\t\t}
\t\t\$this->_out('/DestOutputProfile '.(\$this->n+1).' 0 R');
\t}
\telse if (\$this->PDFX) {\t// always a CMYK profile
\t\t\$this->_out('/S /GTS_PDFX');
\t\tif (\$this->ICCProfile) {
\t\t\t\$this->_out('/Info ('.preg_replace('/_/',' ',\$this->ICCProfile).')');
\t\t\t\$this->_out('/OutputConditionIdentifier (Custom)');
\t\t\t\$this->_out('/OutputCondition ()');
\t\t\t\$this->_out('/DestOutputProfile '.(\$this->n+1).' 0 R');
\t\t}
\t\telse {
\t\t\t\$this->_out('/Info (CGATS TR 001)');
\t\t\t\$this->_out('/OutputConditionIdentifier (CGATS TR 001)');
\t\t\t\$this->_out('/OutputCondition (CGATS TR 001 (SWOP))');
\t\t\t\$this->_out('/RegistryName (http://www.color.org)');
\t\t}
\t}
\t\$this->_out('>>');
\t\$this->_out('endobj');

\tif (\$this->PDFX && !\$this->ICCProfile) { return; } // no ICCProfile embedded

\t\$this->_newobj();
\tif (\$this->ICCProfile)
\t\t\$s = file_get_contents(_MPDF_PATH.'iccprofiles/'.\$this->ICCProfile.'.icc');
\telse
\t\t\$s = file_get_contents(_MPDF_PATH.'iccprofiles/sRGB_IEC61966-2-1.icc');
\tif (\$this->compress) { \$s = gzcompress(\$s); }
\t\$this->_out('<<');
\tif (\$this->PDFX || (\$this->PDFA && \$this->restrictColorSpace == 3)) { \$this->_out('/N 4'); }
\telse { \$this->_out('/N 3'); }
\tif (\$this->compress)
\t\t\$this->_out('/Filter /FlateDecode ');
\t\$this->_out('/Length '.strlen(\$s).'>>');
\t\$this->_putstream(\$s);
\t\$this->_out('endobj');
}


function _putcatalog() {
\t\$this->_out('/Type /Catalog');
\t\$this->_out('/Pages 1 0 R');
\tif(\$this->ZoomMode=='fullpage')\t\$this->_out('/OpenAction [3 0 R /Fit]');
\telseif(\$this->ZoomMode=='fullwidth') \$this->_out('/OpenAction [3 0 R /FitH null]');
\telseif(\$this->ZoomMode=='real')\t\$this->_out('/OpenAction [3 0 R /XYZ null null 1]');
\telseif(!is_string(\$this->ZoomMode))\t\$this->_out('/OpenAction [3 0 R /XYZ null null '.(\$this->ZoomMode/100).']');
\telse\t\$this->_out('/OpenAction [3 0 R /XYZ null null null]');
\tif(\$this->LayoutMode=='single')\t\$this->_out('/PageLayout /SinglePage');
\telseif(\$this->LayoutMode=='continuous')\t\$this->_out('/PageLayout /OneColumn');
\telseif(\$this->LayoutMode=='twoleft')\t\$this->_out('/PageLayout /TwoColumnLeft');
\telseif(\$this->LayoutMode=='tworight')\t\$this->_out('/PageLayout /TwoColumnRight');
\telseif(\$this->LayoutMode=='two') {
\t  if (\$this->mirrorMargins) { \$this->_out('/PageLayout /TwoColumnRight'); }
\t  else { \$this->_out('/PageLayout /TwoColumnLeft'); }
\t}

/*-- BOOKMARKS --*/
\tif(count(\$this->BMoutlines)>0) {
\t      \$this->_out('/Outlines '.\$this->OutlineRoot.' 0 R');
\t      \$this->_out('/PageMode /UseOutlines');
\t}
/*-- END BOOKMARKS --*/
\tif(is_int(strpos(\$this->DisplayPreferences,'FullScreen'))) \$this->_out('/PageMode /FullScreen');

\t// Metadata
\tif (\$this->PDFA || \$this->PDFX) {
\t\t\$this->_out('/Metadata '.\$this->MetadataRoot.' 0 R');
\t}
\t// OutputIntents
\tif (\$this->PDFA || \$this->PDFX || \$this->ICCProfile) {
\t\t\$this->_out('/OutputIntents ['.\$this->OutputIntentRoot.' 0 R]');
\t}

/*-- FORMS --*/
\tif (count(\$this->form->forms)>0) {
\t\t\$this->form->_putFormsCatalog();
\t}
/*-- END FORMS --*/
\tif ( isset(\$this->js) ) {
\t\t\$this->_out('/Names << /JavaScript '.(\$this->n_js).' 0 R >> ');
\t}

\tif(\$this->DisplayPreferences || \$this->directionality == 'rtl' || \$this->mirrorMargins) {
\t\t\$this->_out('/ViewerPreferences<<');
\t\tif(is_int(strpos(\$this->DisplayPreferences,'HideMenubar'))) \$this->_out('/HideMenubar true');
\t\tif(is_int(strpos(\$this->DisplayPreferences,'HideToolbar'))) \$this->_out('/HideToolbar true');
\t\tif(is_int(strpos(\$this->DisplayPreferences,'HideWindowUI'))) \$this->_out('/HideWindowUI true');
\t\tif(is_int(strpos(\$this->DisplayPreferences,'DisplayDocTitle'))) \$this->_out('/DisplayDocTitle true');
\t\tif(is_int(strpos(\$this->DisplayPreferences,'CenterWindow'))) \$this->_out('/CenterWindow true');
\t\tif(is_int(strpos(\$this->DisplayPreferences,'FitWindow'))) \$this->_out('/FitWindow true');
\t\t// /PrintScaling is PDF 1.6 spec.
\t\tif(is_int(strpos(\$this->DisplayPreferences,'NoPrintScaling')) && !\$this->PDFA && !\$this->PDFX)
\t\t\t\$this->_out('/PrintScaling /None');
\t\tif(\$this->directionality == 'rtl') \$this->_out('/Direction /R2L');
\t\t// /Duplex is PDF 1.7 spec.
\t\tif(\$this->mirrorMargins && !\$this->PDFA && !\$this->PDFX) {
\t\t\t// if (\$this->DefOrientation=='P') \$this->_out('/Duplex /DuplexFlipShortEdge');
\t\t\t\$this->_out('/Duplex /DuplexFlipLongEdge');\t// PDF v1.7+
\t\t}
\t\t\$this->_out('>>');
\t}
\t// mPDF 5.6.01
\tif(\$this->open_layer_pane && (\$this->hasOC || count(\$this->layers)))
\t\t\$this->_out('/PageMode /UseOC');

\t// mPDF 5.6.01
\tif (\$this->hasOC || count(\$this->layers)) {
\t\t\$p = \$v = \$h = \$l = \$loff = \$lall = \$as = '';\t// mPDF 5.6.28
\t\tif (\$this->hasOC) {
\t\t\tif ((\$this->hasOC & 1) == 1) \$p=\$this->n_ocg_print.' 0 R';
\t\t\tif ((\$this->hasOC & 2) == 2) \$v=\$this->n_ocg_view.' 0 R';
\t\t\tif ((\$this->hasOC & 4) == 4) \$h=\$this->n_ocg_hidden.' 0 R';
\t\t\t\$as=\"<</Event /Print /OCGs [\$p \$v \$h] /Category [/Print]>> <</Event /View /OCGs [\$p \$v \$h] /Category [/View]>>\";
\t\t}

\t\tif(count(\$this->layers)) {
\t\t\tforeach(\$this->layers as \$k=>\$layer) {\t// mPDF 5.6.28
\t\t\t\tif (strtolower(\$this->layerDetails[\$k]['state'])=='hidden') { \$loff .= \$layer['n'].' 0 R '; }
\t\t\t\telse { \$l .= \$layer['n'].' 0 R '; }
\t\t\t\t\$lall .= \$layer['n'].' 0 R ';
\t\t\t}
\t\t}
\t\t\$this->_out(\"/OCProperties <</OCGs [\$p \$v \$h \$lall] /D <</ON [\$p \$l] /OFF [\$v \$h \$loff] \");\t// mPDF 5.6.28
\t\t\$this->_out(\"/Order [\$v \$p \$h \$lall] \");\t// mPDF 5.6.28
\t\tif (\$as) \$this->_out(\"/AS [\$as] \");
\t\t\$this->_out(\">>>>\");

\t}

}

// Inactive function left for backwards compatability
function SetUserRights(\$enable=true, \$annots=\"\", \$form=\"\", \$signature=\"\") {
\t// Does nothing
}

function _enddoc() {
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'10','Writing Headers & Footers'); }\t// *PROGRESS-BAR*
\t\$this->_puthtmlheaders();\t// *HTMLHEADERS-FOOTERS*
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'20','Writing Pages'); }\t// *PROGRESS-BAR*
\t// Remove references to unused fonts (usually default font)
\tforeach(\$this->fonts as \$fk=>\$font) {
\t   if (!\$font['used'] && (\$font['type']=='TTF')) {
\t\tif (\$font['sip'] || \$font['smp']) {
\t\t\tforeach(\$font['subsetfontids'] AS \$k => \$fid) {
\t\t\t\tforeach(\$this->pages AS \$pn=>\$page) {
\t\t\t\t\t\$this->pages[\$pn] = preg_replace('/\\s\\/F'.\$fid.' \\d[\\d.]* Tf\\s/is',' ',\$this->pages[\$pn]);
\t\t\t\t}
\t\t\t}
\t\t}
\t\telse {
\t\t\t\tforeach(\$this->pages AS \$pn=>\$page) {
\t\t\t\t\t\$this->pages[\$pn] = preg_replace('/\\s\\/F'.\$font['i'].' \\d[\\d.]* Tf\\s/is',' ',\$this->pages[\$pn]);
\t\t\t\t}
\t\t}
\t   }
\t}

\t// mPDF 5.6.01 - LAYERS
\tif (count(\$this->layers)) {
\t  foreach(\$this->pages AS \$pn=>\$page) {
\t\tpreg_match_all('/\\/OCZ-index \\/ZI(\\d+) BDC(.*?)(EMCZ)-index/is',\$this->pages[\$pn],\$m1);
\t\tpreg_match_all('/\\/OCBZ-index \\/ZI(\\d+) BDC(.*?)(EMCBZ)-index/is',\$this->pages[\$pn],\$m2);
\t\tpreg_match_all('/\\/OCGZ-index \\/ZI(\\d+) BDC(.*?)(EMCGZ)-index/is',\$this->pages[\$pn],\$m3);
\t\t\$m = array();
\t\tfor (\$i=0;\$i<4;\$i++) {
\t\t\t\$m[\$i] = array_merge(\$m1[\$i],\$m2[\$i],\$m3[\$i]);
\t\t}
\t\tif (count(\$m[0])) {
\t\t\t\$sortarr = array();
\t\t\tfor(\$i=0;\$i<count(\$m[0]);\$i++) {
\t\t\t\t\$key = \$m[1][\$i]*2;
\t\t\t\tif (\$m[3][\$i]=='EMCZ') \$key +=2;\t// background first then gradient then normal
\t\t\t\telse if (\$m[3][\$i]=='EMCGZ') \$key +=1;
\t\t\t\t\$sortarr[\$i] = \$key;
\t\t\t}
\t\t\tasort(\$sortarr);
\t\t\tforeach(\$sortarr AS \$i=>\$k) {
\t\t\t\t\$this->pages[\$pn] = str_replace(\$m[0][\$i],'',\$this->pages[\$pn] );
\t\t\t\t\$this->pages[\$pn] .= \"\\n\".\$m[0][\$i].\"\\n\";
\t\t\t}
\t\t\t\$this->pages[\$pn] = preg_replace('/\\/OC[BG]{0,1}Z-index \\/ZI(\\d+) BDC/is','/OC /ZI\\\\1 BDC ',\$this->pages[\$pn]);
\t\t\t\$this->pages[\$pn] = preg_replace('/EMC[BG]{0,1}Z-index/is','EMC',\$this->pages[\$pn]);
\t\t}
\t  }
\t}

\t\$this->_putpages();
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'30','Writing document resources'); }\t// *PROGRESS-BAR*

\t\$this->_putresources();
\t//Info
\t\$this->_newobj();
\t\$this->InfoRoot = \$this->n;
\t\$this->_out('<<');
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'80','Writing document info'); }\t// *PROGRESS-BAR*
\t\$this->_putinfo();
\t\$this->_out('>>');
\t\$this->_out('endobj');

\t// METADATA
\tif (\$this->PDFA || \$this->PDFX) { \$this->_putmetadata(); }
\t// OUTPUTINTENT
\tif (\$this->PDFA || \$this->PDFX || \$this->ICCProfile) { \$this->_putoutputintent(); }

\t//Catalog
\t\$this->_newobj();
\t\$this->_out('<<');
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'90','Writing document catalog'); }\t// *PROGRESS-BAR*
\t\$this->_putcatalog();
\t\$this->_out('>>');
\t\$this->_out('endobj');
\t//Cross-ref
\t\$o=strlen(\$this->buffer);
\t\$this->_out('xref');
\t\$this->_out('0 '.(\$this->n+1));
\t\$this->_out('0000000000 65535 f ');
\tfor(\$i=1; \$i <= \$this->n ; \$i++)
\t\t\$this->_out(sprintf('%010d 00000 n ',\$this->offsets[\$i]));
\t//Trailer
\t\$this->_out('trailer');
\t\$this->_out('<<');
\t\$this->_puttrailer();
\t\$this->_out('>>');
\t\$this->_out('startxref');
\t\$this->_out(\$o);

\t\$this->buffer .= '%%EOF';
\t\$this->state=3;
/*-- IMPORTS --*/

\tif (\$this->enableImports && count(\$this->parsers) > 0) {
\t  \tforeach (\$this->parsers as \$k => \$_){
\t\t\t\$this->parsers[\$k]->closeFile();
\t\t\t\$this->parsers[\$k] = null;
\t\t\tunset(\$this->parsers[\$k]);
\t\t}
\t}
/*-- END IMPORTS --*/
}

function _beginpage(\$orientation,\$mgl='',\$mgr='',\$mgt='',\$mgb='',\$mgh='',\$mgf='',\$ohname='',\$ehname='',\$ofname='',\$efname='',\$ohvalue=0,\$ehvalue=0,\$ofvalue=0,\$efvalue=0,\$pagesel='',\$newformat='') {
\tif (!(\$pagesel && \$this->page==1 && (sprintf(\"%0.4f\", \$this->y)==sprintf(\"%0.4f\", \$this->tMargin)))) {
\t\t\$this->page++;
\t\t\$this->pages[\$this->page]='';
\t}
\t\$this->state=2;
\t\$resetHTMLHeadersrequired = false;

\tif (\$newformat) { \$this->_setPageSize(\$newformat, \$orientation); }
/*-- CSS-PAGE --*/
\t// Paged media (page-box)

\tif (\$pagesel || (isset(\$this->page_box['using']) && \$this->page_box['using'])) {
\t\tif (\$pagesel || \$this->page==1) { \$first = true; }
\t\telse { \$first = false; }
\t\tif (\$this->mirrorMargins && (\$this->page % 2==0)) { \$oddEven = 'E'; }
\t\telse { \$oddEven = 'O'; }
\t\tif (\$pagesel) { \$psel = \$pagesel; }
\t\telse if (\$this->page_box['current']) { \$psel = \$this->page_box['current']; }
\t\telse { \$psel = ''; }
\t\tlist(\$orientation,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$hname,\$fname,\$bg,\$resetpagenum,\$pagenumstyle,\$suppress,\$marks,\$newformat) = \$this->SetPagedMediaCSS(\$psel, \$first, \$oddEven);
\t\tif (\$this->mirrorMargins && (\$this->page % 2==0)) {
\t\t\tif (\$hname) { \$ehvalue = 1; \$ehname = \$hname; } else { \$ehvalue = -1; }
\t\t\tif (\$fname) { \$efvalue = 1; \$efname = \$fname; } else { \$efvalue = -1; }
\t\t}
\t\telse {
\t\t\tif (\$hname) { \$ohvalue = 1; \$ohname = \$hname; } else { \$ohvalue = -1; }
\t\t\tif (\$fname) { \$ofvalue = 1; \$ofname = \$fname; } else { \$ofvalue = -1; }
\t\t}
\t\tif (\$resetpagenum || \$pagenumstyle || \$suppress) {
\t\t\t\$this->PageNumSubstitutions[] = array('from'=>(\$this->page), 'reset'=> \$resetpagenum, 'type'=>\$pagenumstyle, 'suppress'=>\$suppress);
\t\t}
  \t\t// PAGED MEDIA - CROP / CROSS MARKS from @PAGE
\t\t\$this->show_marks = \$marks;

\t\t// Background color
\t\tif (isset(\$bg['BACKGROUND-COLOR'])) {
\t\t\t\$cor = \$this->ConvertColor(\$bg['BACKGROUND-COLOR']);
\t\t\tif (\$cor) {
\t\t\t\t\$this->bodyBackgroundColor = \$cor;
\t\t\t}
\t\t}
\t\telse { \$this->bodyBackgroundColor = false; }

/*-- BACKGROUNDS --*/
\t\tif (isset(\$bg['BACKGROUND-GRADIENT'])) {
\t\t\t\$this->bodyBackgroundGradient = \$bg['BACKGROUND-GRADIENT'];
\t\t}
\t\telse { \$this->bodyBackgroundGradient = false; }

\t\t// Tiling Patterns
\t\tif (isset(\$bg['BACKGROUND-IMAGE']) && \$bg['BACKGROUND-IMAGE']) {
\t\t\t\$ret = \$this->SetBackground(\$bg, \$this->pgwidth);
\t\t\tif (\$ret) { \$this->bodyBackgroundImage = \$ret; }
\t\t}
\t\telse { \$this->bodyBackgroundImage = false; }
/*-- END BACKGROUNDS --*/

\t\t\$this->page_box['current'] = \$psel;
\t\t\$this->page_box['using'] = true;
\t}
/*-- END CSS-PAGE --*/

\t//Page orientation
\tif(!\$orientation)
\t\t\$orientation=\$this->DefOrientation;
\telse {
\t\t\$orientation=strtoupper(substr(\$orientation,0,1));
\t\tif(\$orientation!=\$this->DefOrientation)
\t\t\t\$this->OrientationChanges[\$this->page]=true;
\t}
\tif(\$orientation!=\$this->CurOrientation || \$newformat) {

\t\t//Change orientation
\t\tif(\$orientation=='P') {
\t\t\t\$this->wPt=\$this->fwPt;
\t\t\t\$this->hPt=\$this->fhPt;
\t\t\t\$this->w=\$this->fw;
\t\t\t\$this->h=\$this->fh;
\t\t   if ((\$this->forcePortraitHeaders || \$this->forcePortraitMargins) && \$this->DefOrientation=='P') {
\t\t\t\$this->tMargin = \$this->orig_tMargin;
\t\t\t\$this->bMargin = \$this->orig_bMargin;
\t\t\t\$this->DeflMargin = \$this->orig_lMargin;
\t\t\t\$this->DefrMargin = \$this->orig_rMargin;
\t\t\t\$this->margin_header = \$this->orig_hMargin;
\t\t\t\$this->margin_footer = \$this->orig_fMargin;
\t\t   }
\t\t   else { \$resetHTMLHeadersrequired = true; }\t// *HTMLHEADERS-FOOTERS*
\t\t}
\t\telse {
\t\t\t\$this->wPt=\$this->fhPt;
\t\t\t\$this->hPt=\$this->fwPt;
\t\t\t\$this->w=\$this->fh;
\t\t\t\$this->h=\$this->fw;
\t\t   if ((\$this->forcePortraitHeaders || \$this->forcePortraitMargins) && \$this->DefOrientation=='P') {
\t\t\t\$this->tMargin = \$this->orig_lMargin;
\t\t\t\$this->bMargin = \$this->orig_rMargin;
\t\t\t\$this->DeflMargin = \$this->orig_bMargin;
\t\t\t\$this->DefrMargin = \$this->orig_tMargin;
\t\t\t\$this->margin_header = \$this->orig_hMargin;
\t\t\t\$this->margin_footer = \$this->orig_fMargin;
\t\t   }
\t\t   else { \$resetHTMLHeadersrequired = true; }\t// *HTMLHEADERS-FOOTERS*

\t\t}
\t\t\$this->CurOrientation=\$orientation;
\t\t\$this->ResetMargins();
\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\$this->PageBreakTrigger=\$this->h-\$this->bMargin;
\t}

\t\$this->pageDim[\$this->page]['w']=\$this->w ;
\t\$this->pageDim[\$this->page]['h']=\$this->h ;

\t\$this->pageDim[\$this->page]['outer_width_LR'] = isset(\$this->page_box['outer_width_LR']) ? \$this->page_box['outer_width_LR'] : 0;
\t\$this->pageDim[\$this->page]['outer_width_TB'] = isset(\$this->page_box['outer_width_TB']) ? \$this->page_box['outer_width_TB'] : 0;
\tif (!isset(\$this->page_box['outer_width_LR']) && !isset(\$this->page_box['outer_width_TB'])) {
\t\t\$this->pageDim[\$this->page]['bleedMargin'] = 0;
\t}
\telse if (\$this->bleedMargin <= \$this->page_box['outer_width_LR'] && \$this->bleedMargin <= \$this->page_box['outer_width_TB']) {
\t\t\$this->pageDim[\$this->page]['bleedMargin'] = \$this->bleedMargin;
\t}
\telse {
\t\t\$this->pageDim[\$this->page]['bleedMargin'] = min(\$this->page_box['outer_width_LR'], \$this->page_box['outer_width_TB'])-0.01;
\t}

\t// If Page Margins are re-defined
\t// strlen()>0 is used to pick up (integer) 0, (string) '0', or set value
\tif ((strlen(\$mgl)>0 && \$this->DeflMargin != \$mgl) || (strlen(\$mgr)>0 && \$this->DefrMargin != \$mgr) || (strlen(\$mgt)>0 && \$this->tMargin != \$mgt) || (strlen(\$mgb)>0 && \$this->bMargin != \$mgb) || (strlen(\$mgh)>0 && \$this->margin_header!=\$mgh) || (strlen(\$mgf)>0 && \$this->margin_footer!=\$mgf)) {
\t\tif (strlen(\$mgl)>0)  \$this->DeflMargin = \$mgl;
\t\tif (strlen(\$mgr)>0)  \$this->DefrMargin = \$mgr;
\t\tif (strlen(\$mgt)>0)  \$this->tMargin = \$mgt;
\t\tif (strlen(\$mgb)>0)  \$this->bMargin = \$mgb;
\t\tif (strlen(\$mgh)>0)  \$this->margin_header=\$mgh;
\t\tif (strlen(\$mgf)>0)  \$this->margin_footer=\$mgf;
\t\t\$this->ResetMargins();
\t\t\$this->SetAutoPageBreak(\$this->autoPageBreak,\$this->bMargin);
\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\$resetHTMLHeadersrequired = true; \t// *HTMLHEADERS-FOOTERS*
\t}

\t\$this->ResetMargins();
\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\$this->SetAutoPageBreak(\$this->autoPageBreak,\$this->bMargin);

\t// Reset column top margin
\t\$this->y0 = \$this->tMargin;

\t\$this->x=\$this->lMargin;
\t\$this->y=\$this->tMargin;
\t\$this->FontFamily='';

\t// HEADERS AND FOOTERS
\tif (\$ohvalue<0 || strtoupper(\$ohvalue)=='OFF') {
\t\t\$this->HTMLHeader = '';
\t\t\$this->headerDetails['odd'] = array();
\t\t\$resetHTMLHeadersrequired = true;\t// *HTMLHEADERS-FOOTERS*
\t}
\telse if (\$ohname && \$ohvalue>0) {
/*-- HTMLHEADERS-FOOTERS --*/
\t   if (preg_match('/^html_(.*)\$/i',\$ohname,\$n)) {
\t\tif (isset(\$this->pageHTMLheaders[\$n[1]])) { \$this->HTMLHeader = \$this->pageHTMLheaders[\$n[1]]; }
\t\telse { \$this->HTMLHeader = ''; }
\t\t\$this->headerDetails['odd'] = array();
\t\t\$resetHTMLHeadersrequired = true;
\t   }
\t   else {
/*-- END HTMLHEADERS-FOOTERS --*/
\t\tif (isset(\$this->pageheaders[\$ohname])) { \$this->headerDetails['odd'] = \$this->pageheaders[\$ohname]; }
\t\telse if (\$ohname!='_default') { \$this->headerDetails['odd'] = array(); }
\t\t\$this->HTMLHeader = '';
/*-- HTMLHEADERS-FOOTERS --*/
\t\t\$resetHTMLHeadersrequired = false;
\t   }
/*-- END HTMLHEADERS-FOOTERS --*/
\t}

\tif (\$ehvalue<0 || strtoupper(\$ehvalue)=='OFF') {
\t\t\$this->HTMLHeaderE = '';
\t\t\$this->headerDetails['even'] = array();
\t\t\$resetHTMLHeadersrequired = true;\t// *HTMLHEADERS-FOOTERS*
\t}
\telse if (\$ehname && \$ehvalue>0) {
/*-- HTMLHEADERS-FOOTERS --*/
\t   if (preg_match('/^html_(.*)\$/i',\$ehname,\$n)) {
\t\tif (isset(\$this->pageHTMLheaders[\$n[1]])) { \$this->HTMLHeaderE = \$this->pageHTMLheaders[\$n[1]]; }
\t\telse { \$this->HTMLHeaderE = ''; }
\t\t\$this->headerDetails['even'] = array();
\t\t\$resetHTMLHeadersrequired = true;
\t   }
\t   else {
/*-- END HTMLHEADERS-FOOTERS --*/
\t\tif (isset(\$this->pageheaders[\$ehname])) { \$this->headerDetails['even'] = \$this->pageheaders[\$ehname]; }
\t\telse if (\$ehname!='_default') { \$this->headerDetails['even'] = array(); }
\t\t\$this->HTMLHeaderE = '';
/*-- HTMLHEADERS-FOOTERS --*/
\t\t\$resetHTMLHeadersrequired = false;
\t   }
/*-- END HTMLHEADERS-FOOTERS --*/
\t}

\tif (\$ofvalue<0 || strtoupper(\$ofvalue)=='OFF') {
\t\t\$this->HTMLFooter = '';
\t\t\$this->footerDetails['odd'] = array();
\t\t\$resetHTMLHeadersrequired = true;\t// *HTMLHEADERS-FOOTERS*
\t}
\telse if (\$ofname && \$ofvalue>0) {
/*-- HTMLHEADERS-FOOTERS --*/
\t   if (preg_match('/^html_(.*)\$/i',\$ofname,\$n)) {
\t\tif (isset(\$this->pageHTMLfooters[\$n[1]])) { \$this->HTMLFooter = \$this->pageHTMLfooters[\$n[1]]; }
\t\telse { \$this->HTMLFooter = ''; }
\t\t\$this->footerDetails['odd'] = array();
\t\t\$resetHTMLHeadersrequired = true;
\t   }
\t   else {
/*-- END HTMLHEADERS-FOOTERS --*/
\t\tif (isset(\$this->pagefooters[\$ofname])) { \$this->footerDetails['odd'] = \$this->pagefooters[\$ofname]; }
\t\telse if (\$ofname!='_default') { \$this->footerDetails['odd'] = array(); }
\t\t\$this->HTMLFooter = '';
/*-- HTMLHEADERS-FOOTERS --*/
\t\t\$resetHTMLHeadersrequired = true;
\t   }
/*-- END HTMLHEADERS-FOOTERS --*/
\t}

\tif (\$efvalue<0 || strtoupper(\$efvalue)=='OFF') {
\t\t\$this->HTMLFooterE = '';
\t\t\$this->footerDetails['even'] = array();
\t\t\$resetHTMLHeadersrequired = true;\t// *HTMLHEADERS-FOOTERS*
\t}
\telse if (\$efname && \$efvalue>0) {
/*-- HTMLHEADERS-FOOTERS --*/
\t   if (preg_match('/^html_(.*)\$/i',\$efname,\$n)) {
\t\tif (isset(\$this->pageHTMLfooters[\$n[1]])) { \$this->HTMLFooterE = \$this->pageHTMLfooters[\$n[1]]; }
\t\telse { \$this->HTMLFooterE = ''; }
\t\t\$this->footerDetails['even'] = array();
\t\t\$resetHTMLHeadersrequired = true;
\t   }
\t   else {
/*-- END HTMLHEADERS-FOOTERS --*/
\t\tif (isset(\$this->pagefooters[\$efname])) { \$this->footerDetails['even'] = \$this->pagefooters[\$efname]; }
\t\telse if (\$efname!='_default') { \$this->footerDetails['even'] = array(); }
\t\t\$this->HTMLFooterE = '';
/*-- HTMLHEADERS-FOOTERS --*/
\t\t\$resetHTMLHeadersrequired = true;
\t   }
/*-- END HTMLHEADERS-FOOTERS --*/
\t}
/*-- HTMLHEADERS-FOOTERS --*/
\tif (\$resetHTMLHeadersrequired) {
\t\t\$this->SetHTMLHeader(\$this->HTMLHeader );
\t\t\$this->SetHTMLHeader(\$this->HTMLHeaderE ,'E');
\t\t\$this->SetHTMLFooter(\$this->HTMLFooter );
\t\t\$this->SetHTMLFooter(\$this->HTMLFooterE ,'E');
\t}
/*-- END HTMLHEADERS-FOOTERS --*/


\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\$this->_setAutoHeaderHeight(\$this->headerDetails['even'], \$this->HTMLHeaderE);
\t\t\$this->_setAutoFooterHeight(\$this->footerDetails['even'], \$this->HTMLFooterE);
\t}
\telse {\t// ODD or DEFAULT
\t\t\$this->_setAutoHeaderHeight(\$this->headerDetails['odd'], \$this->HTMLHeader);
\t\t\$this->_setAutoFooterHeight(\$this->footerDetails['odd'], \$this->HTMLFooter);
\t}
\t// Reset column top margin
\t\$this->y0 = \$this->tMargin;

\t\$this->x=\$this->lMargin;
\t\$this->y=\$this->tMargin;
}



function _setAutoHeaderHeight(&\$det, &\$htmlh) {
  if (\$this->setAutoTopMargin=='pad') {
\tif (isset(\$htmlh['h']) && \$htmlh['h']) { \$h = \$htmlh['h']; }\t// 5.7.3
\telse if (\$det) { \$h = \$this->_getHFHeight(\$det,'H'); }
\telse { \$h = 0; }
\t\$this->tMargin = \$this->margin_header + \$h + \$this->orig_tMargin;
  }
  else if (\$this->setAutoTopMargin=='stretch') {
\tif (isset(\$htmlh['h']) && \$htmlh['h']) { \$h = \$htmlh['h']; }\t// 5.7.3
\telse if (\$det) { \$h = \$this->_getHFHeight(\$det,'H'); }
\telse { \$h = 0; }
\t\$this->tMargin = max(\$this->orig_tMargin, \$this->margin_header + \$h + \$this->autoMarginPadding);
  }
}


function _setAutoFooterHeight(&\$det, &\$htmlf) {
  if (\$this->setAutoBottomMargin=='pad') {
\tif (isset(\$htmlf['h']) && \$htmlf['h']) { \$h = \$htmlf['h']; }\t// 5.7.3
\telse if (\$det) { \$h = \$this->_getHFHeight(\$det,'F'); }
\telse { \$h = 0; }
\t\$this->bMargin = \$this->margin_footer + \$h + \$this->orig_bMargin;
\t\$this->PageBreakTrigger=\$this->h-\$this->bMargin ;
  }
  else if (\$this->setAutoBottomMargin=='stretch') {
\tif (isset(\$htmlf['h']) && \$htmlf['h']) { \$h = \$htmlf['h']; }\t// 5.7.3
\telse if (\$det) { \$h = \$this->_getHFHeight(\$det,'F'); }
\telse { \$h = 0; }
\t\$this->bMargin = max(\$this->orig_bMargin, \$this->margin_footer + \$h + \$this->autoMarginPadding);
\t\$this->PageBreakTrigger=\$this->h-\$this->bMargin ;
  }
}

function _getHFHeight(&\$det,\$end) {
\t\$h = 0;
\tif(count(\$det)) {
\t\tforeach(array('L','C','R') AS \$pos) {
\t\t  if (isset(\$det[\$pos]['content']) && \$det[\$pos]['content']) {
\t\t\tif (isset(\$det[\$pos]['font-size']) && \$det[\$pos]['font-size']) { \$hfsz = \$det[\$pos]['font-size']; }
\t\t\telse { \$hfsz = \$this->default_font_size; }
\t\t\t\$h = max(\$h,\$hfsz/_MPDFK);
\t\t  }
\t\t}
\t\tif (\$det['line'] && \$end=='H') { \$h += \$h/_MPDFK*\$this->header_line_spacing; }
\t\telse if (\$det['line'] && \$end=='F') { \$h += \$h/_MPDFK*\$this->footer_line_spacing; }
   \t}
\treturn \$h;
}


function _endpage() {
/*-- CSS-IMAGE-FLOAT --*/
\t\$this->printfloatbuffer();
/*-- END CSS-IMAGE-FLOAT --*/

\tif(\$this->visibility!='visible')
\t\t\$this->SetVisibility('visible');
\t\$this->EndLayer();\t// mPDF 5.6.01
\t//End of page contents
\t\$this->state=1;
}

function _newobj(\$obj_id=false,\$onlynewobj=false) {
\t\tif (!\$obj_id) {
\t\t\t\$obj_id = ++\$this->n;
\t\t}
\t\t//Begin a new object
\t\tif (!\$onlynewobj) {
\t\t\t\$this->offsets[\$obj_id] = strlen(\$this->buffer);
\t\t\t\$this->_out(\$obj_id.' 0 obj');
\t\t\t\$this->_current_obj_id = \$obj_id; // for later use with encryption
\t\t}
}

function _dounderline(\$x,\$y,\$txt) {
\t// Now print line exactly where \$y secifies - called from Text() and Cell() - adjust  position there
\t// WORD SPACING
      \$w =(\$this->GetStringWidth(\$txt)*_MPDFK) + (\$this->charspacing * mb_strlen( \$txt, \$this->mb_enc ))
\t\t + ( \$this->ws * mb_substr_count( \$txt, ' ', \$this->mb_enc ));
\t//Draw a line
\treturn sprintf('%.3F %.3F m %.3F %.3F l S',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,(\$x*_MPDFK)+\$w,(\$this->h-\$y)*_MPDFK);
}


function _imageError(\$file, \$firsttime, \$msg) {
\t// Save re-trying image URL's which have already failed
\t\$this->failedimages[\$file] = true;
\tif (\$firsttime && (\$this->showImageErrors || \$this->debug)) {
\t\t\t\$this->Error(\"IMAGE Error (\".\$file.\"): \".\$msg);
\t}
\treturn false;
}


function _getImage(&\$file, \$firsttime=true, \$allowvector=true, \$orig_srcpath=false) {
\t// firsttime i.e. whether to add to this->images - use false when calling iteratively
\t// Image Data passed directly as var:varname
\tif (preg_match('/var:\\s*(.*)/',\$file, \$v)) {
\t\t\$data = \$this->\$v[1];
\t\t\$file = md5(\$data);
\t}
\t// mPDF 5.5.13
\tif (preg_match('/data:image\\/(gif|jpeg|png);base64,(.*)/',\$file, \$v)) {
\t\t\$type = \$v[1];
\t\t\$data = base64_decode(\$v[2]);
\t\t\$file = md5(\$data);
\t}

\t// mPDF 5.6.02
\tif (\$firsttime && \$file && substr(\$file,0,5)!='data:') { \$file = urlencode_part(\$file); }
\tif (\$firsttime && \$orig_srcpath && substr(\$orig_srcpath,0,5)!='data:') { \$orig_srcpath = urlencode_part(\$orig_srcpath); }

\t\$ppUx = 0;
\tif (\$orig_srcpath && isset(\$this->images[\$orig_srcpath])) { \$file=\$orig_srcpath; return \$this->images[\$orig_srcpath]; }
\tif (isset(\$this->images[\$file])) { return \$this->images[\$file]; }
\telse if (\$orig_srcpath && isset(\$this->formobjects[\$orig_srcpath])) { \$file=\$orig_srcpath; return \$this->formobjects[\$file]; }
\telse if (isset(\$this->formobjects[\$file])) { return \$this->formobjects[\$file]; }
\t// Save re-trying image URL's which have already failed
\telse if (\$firsttime && isset(\$this->failedimages[\$file])) { return \$this->_imageError(\$file, \$firsttime, ''); }
\tif (empty(\$data)) {
\t\t\$type = '';
\t\t\$data = '';

 \t\tif (\$orig_srcpath && \$this->basepathIsLocal && \$check = @fopen(\$orig_srcpath,\"rb\")) {
\t\t\tfclose(\$check);
\t\t\t\$file=\$orig_srcpath;
\t\t\t\$data = file_get_contents(\$file);
\t\t\t\$type = \$this->_imageTypeFromString(\$data);
\t\t}
\t\tif (!\$data && \$check = @fopen(\$file,\"rb\")) {
\t\t\tfclose(\$check);
\t\t\t\$data = file_get_contents(\$file);
\t\t\t\$type = \$this->_imageTypeFromString(\$data);
\t\t}
\t\tif ((!\$data || !\$type) && !ini_get('allow_url_fopen') ) {\t// only worth trying if remote file and !ini_get('allow_url_fopen')
\t\t\t\$this->file_get_contents_by_socket(\$file, \$data);\t// needs full url?? even on local (never needed for local)
\t\t\tif (\$data) { \$type = \$this->_imageTypeFromString(\$data); }
\t\t}
\t\tif ((!\$data || !\$type) && !ini_get('allow_url_fopen') && function_exists(\"curl_init\")) {
\t\t\t\$this->file_get_contents_by_curl(\$file, \$data);\t\t// needs full url?? even on local (never needed for local)
\t\t\tif (\$data) { \$type = \$this->_imageTypeFromString(\$data); }
\t\t}

\t}
\tif (!\$data) { return \$this->_imageError(\$file, \$firsttime, 'Could not find image file'); }
\tif (empty(\$type)) { \$type = \$this->_imageTypeFromString(\$data); }
\tif ((\$type == 'wmf' || \$type == 'svg') && !\$allowvector) { return \$this->_imageError(\$file, \$firsttime, 'WMF or SVG image file not supported in this context'); }

\t// SVG
\tif (\$type == 'svg') {
\t\tif (!class_exists('SVG', false)) { include(_MPDF_PATH .'classes/svg.php'); }
\t\t\$svg = new SVG(\$this);
\t\t\$family=\$this->FontFamily;
\t\t\$style=\$this->FontStyle;
\t\t\$size=\$this->FontSizePt;
\t\t\$info = \$svg->ImageSVG(\$data);
\t\t//Restore font
\t\tif(\$family) \$this->SetFont(\$family,\$style,\$size,false);
\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing SVG file'); }
\t\t\$info['type']='svg';
\t\t\$info['i']=count(\$this->formobjects)+1;
\t\t\$this->formobjects[\$file]=\$info;
\t\treturn \$info;
\t}

\t// JPEG
\tif (\$type == 'jpeg' || \$type == 'jpg') {
\t\t\$hdr = \$this->_jpgHeaderFromString(\$data);
\t\tif (!\$hdr) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing JPG header'); }
\t\t\$a = \$this->_jpgDataFromHeader(\$hdr);
\t\t\$j = strpos(\$data,'JFIF');
\t\tif (\$j) {
\t\t\t//Read resolution
\t\t\t\$unitSp=ord(substr(\$data,(\$j+7),1));
\t\t\tif (\$unitSp > 0) {
\t\t\t\t\$ppUx=\$this->_twobytes2int(substr(\$data,(\$j+8),2));\t// horizontal pixels per meter, usually set to zero
\t\t\t\tif (\$unitSp == 2) {\t// = dots per cm (if == 1 set as dpi)
\t\t\t\t\t\$ppUx=round(\$ppUx/10 *25.4);
\t\t\t\t}
\t\t\t}
\t\t}
\t\tif (\$a[2] == 'DeviceCMYK' && ((\$this->PDFA && \$this->restrictColorSpace!=3) || \$this->restrictColorSpace==2)) {
\t\t\t// convert to RGB image
\t\t\tif (!function_exists(\"gd_info\")) { \$this->Error(\"JPG image may not use CMYK color space (\".\$file.\").\"); }
\t\t\tif (\$this->PDFA && !\$this->PDFAauto) { \$this->PDFAXwarnings[] = \"JPG image may not use CMYK color space - \".\$file.\" - (Image converted to RGB. NB This will alter the colour profile of the image.)\"; }
\t\t\t\$im = @imagecreatefromstring(\$data);
\t\t\tif (\$im) {
\t\t\t\t\$tempfile = _MPDF_TEMP_PATH.'_tempImgPNG'.md5(\$file).RAND(1,10000).'.png';
\t\t\t\timageinterlace(\$im, false);
\t\t\t\t\$check = @imagepng(\$im, \$tempfile);
\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary file ('.\$tempfile.') whilst using GD library to parse JPG(CMYK) image'); }
\t\t\t\t\$info = \$this->_getImage(\$tempfile, false);
\t\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file ('.\$tempfile.') created with GD library to parse JPG(CMYK) image'); }
\t\t\t\timagedestroy(\$im);
\t\t\t\tunlink(\$tempfile);
\t\t\t\t\$info['type']='jpg';
\t\t\t\tif (\$firsttime) {
\t\t\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\t\t\$this->images[\$file]=\$info;
\t\t\t\t}
\t\t\t\treturn \$info;
\t\t\t}
\t\t\telse { return \$this->_imageError(\$file, \$firsttime, 'Error creating GD image file from JPG(CMYK) image'); }
\t\t}
\t\telse if (\$a[2] == 'DeviceRGB' && (\$this->PDFX || \$this->restrictColorSpace==3)) {
\t\t\t// Convert to CMYK image stream - nominally returned as type='png'
\t\t\t\$info = \$this->_convImage(\$data, \$a[2], 'DeviceCMYK', \$a[0], \$a[1], \$ppUx, false);
\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"JPG image may not use RGB color space - \".\$file.\" - (Image converted to CMYK. NB This will alter the colour profile of the image.)\"; }
\t\t}
\t\telse if ((\$a[2] == 'DeviceRGB' || \$a[2] == 'DeviceCMYK') && \$this->restrictColorSpace==1) {
\t\t\t// Convert to Grayscale image stream - nominally returned as type='png'
\t\t\t\$info = \$this->_convImage(\$data, \$a[2], 'DeviceGray', \$a[0], \$a[1], \$ppUx, false);
\t\t}
\t\telse {
\t\t\t\$info = array('w'=>\$a[0],'h'=>\$a[1],'cs'=>\$a[2],'bpc'=>\$a[3],'f'=>'DCTDecode','data'=>\$data, 'type'=>'jpg');
\t\t\tif (\$ppUx) { \$info['set-dpi'] = \$ppUx; }
\t\t}
\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing or converting JPG image'); }

\t\tif (\$firsttime) {
\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\$this->images[\$file]=\$info;
\t\t}
\t\treturn \$info;
\t}

\t// PNG
\telse if (\$type == 'png') {
\t\t//Check signature
\t\tif(substr(\$data,0,8)!=chr(137).'PNG'.chr(13).chr(10).chr(26).chr(10)) {
\t\t\treturn \$this->_imageError(\$file, \$firsttime, 'Error parsing PNG identifier');
\t\t}
\t\t//Read header chunk
\t\tif(substr(\$data,12,4)!='IHDR') {
\t\t\treturn \$this->_imageError(\$file, \$firsttime, 'Incorrect PNG file (no IHDR block found)');
\t\t}

\t\t\$w=\$this->_fourbytes2int(substr(\$data,16,4));
\t\t\$h=\$this->_fourbytes2int(substr(\$data,20,4));
\t\t\$bpc=ord(substr(\$data,24,1));
\t\t\$errpng = false;
\t\t\$pngalpha = false;
\t\tif(\$bpc>8) { \$errpng = 'not 8-bit depth'; }
\t\t\$ct=ord(substr(\$data,25,1));
\t\tif(\$ct==0) { \$colspace='DeviceGray'; }
\t\telseif(\$ct==2) { \$colspace='DeviceRGB'; }
\t\telseif(\$ct==3) { \$colspace='Indexed'; }
\t\telseif(\$ct==4) { \$colspace='DeviceGray';  \$errpng = 'alpha channel'; \$pngalpha = true; }
\t\telse { \$colspace='DeviceRGB'; \$errpng = 'alpha channel'; \$pngalpha = true; }
\t\tif(ord(substr(\$data,26,1))!=0) { \$errpng = 'compression method'; }
\t\tif(ord(substr(\$data,27,1))!=0) { \$errpng = 'filter method'; }
\t\tif(ord(substr(\$data,28,1))!=0) { \$errpng = 'interlaced file'; }
\t\t\$j = strpos(\$data,'pHYs');
\t\tif (\$j) {
\t\t\t//Read resolution
\t\t\t\$unitSp=ord(substr(\$data,(\$j+12),1));
\t\t\tif (\$unitSp == 1) {
\t\t\t\t\$ppUx=\$this->_fourbytes2int(substr(\$data,(\$j+4),4));\t// horizontal pixels per meter, usually set to zero
\t\t\t\t\$ppUx=round(\$ppUx/1000 *25.4);
\t\t\t}
\t\t}
\t\tif ((\$colspace == 'DeviceRGB' || \$colspace == 'Indexed') && (\$this->PDFX || \$this->restrictColorSpace==3)) {
\t\t\t// Convert to CMYK image stream - nominally returned as type='png'
\t\t\t\$info = \$this->_convImage(\$data, \$colspace, 'DeviceCMYK', \$w, \$h, \$ppUx, \$pngalpha);
\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"PNG image may not use RGB color space - \".\$file.\" - (Image converted to CMYK. NB This will alter the colour profile of the image.)\"; }
\t\t}
\t\telse if ((\$colspace == 'DeviceRGB' || \$colspace == 'Indexed') && \$this->restrictColorSpace==1) {
\t\t\t// Convert to Grayscale image stream - nominally returned as type='png'
\t\t\t\$info = \$this->_convImage(\$data, \$colspace, 'DeviceGray', \$w, \$h, \$ppUx, \$pngalpha);
\t\t}
\t\telse if ((\$this->PDFA || \$this->PDFX) && \$pngalpha) {
\t\t\t// Remove alpha channel
\t\t\tif (\$this->restrictColorSpace==1) {\t// Grayscale
\t\t\t\t\$info = \$this->_convImage(\$data, \$colspace, 'DeviceGray', \$w, \$h, \$ppUx, \$pngalpha);
\t\t\t}
\t\t\telse if (\$this->restrictColorSpace==3) {\t// CMYK
\t\t\t\t\$info = \$this->_convImage(\$data, \$colspace, 'DeviceCMYK', \$w, \$h, \$ppUx, \$pngalpha);
\t\t\t}
\t\t\telse if (\$this->PDFA ) {\t// RGB
\t\t\t\t\$info = \$this->_convImage(\$data, \$colspace, 'DeviceRGB', \$w, \$h, \$ppUx, \$pngalpha);
\t\t\t}
\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"Transparency (alpha channel) not permitted in PDFA or PDFX files - \".\$file.\" - (Image converted to one without transparency.)\"; }
\t\t}
\t\telse if (\$errpng || \$pngalpha) {
\t\t\tif (function_exists('gd_info')) { \$gd = gd_info(); }
\t\t\telse {\$gd = array(); }
\t\t\tif (!isset(\$gd['PNG Support'])) { return \$this->_imageError(\$file, \$firsttime, 'GD library required for PNG image ('.\$errpng.')'); }
\t\t\t\$im = imagecreatefromstring(\$data);
\t\t\tif (!\$im) { return \$this->_imageError(\$file, \$firsttime, 'Error creating GD image from PNG file ('.\$errpng.')'); }
\t\t\t\$w = imagesx(\$im);
\t\t\t\$h = imagesy(\$im);
\t\t\tif (\$im) {
\t\t\t   \$tempfile = _MPDF_TEMP_PATH.'_tempImgPNG'.RAND(1,10000).'.png';
\t\t\t   // Alpha channel set
               if (\$pngalpha && \$this->png_alpha_use_white_matte) {
\t\t\t\t\$imgmat = imagecreatetruecolor(\$w, \$h);
                imagesavealpha(\$imgmat, false);
                imageinterlace(\$imgmat, false);
                imagefill(\$imgmat, 0, 0, imagecolorallocate(\$imgmat, 255, 255, 255));
                imagecopy(\$imgmat, \$im, 0, 0, 0, 0, \$w, \$h);
                ob_start();
\t\t\t\t\$check = @imagepng(\$imgmat);
                if (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary image object whilst using GD library to parse PNG image'); }
                \$this->_tempimg = ob_get_contents();
                \$this->_tempimglnk = 'var:_tempimg';
                ob_end_clean();
                \$info = \$this->_getImage(\$this->_tempimglnk, false);
                if (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file image object created with GD library to parse PNG image'); }
                imagedestroy(\$imgmat);
               }
               elseif (\$pngalpha) {
\t\t\t\tif (\$this->PDFA) { \$this->Error(\"PDFA1-b does not permit images with alpha channel transparency (\".\$file.\").\"); }
\t\t\t\t\$imgalpha = imagecreate(\$w, \$h);
\t\t\t\t// generate gray scale pallete
\t\t\t\tfor (\$c = 0; \$c < 256; ++\$c) { ImageColorAllocate(\$imgalpha, \$c, \$c, \$c); }
\t\t\t\t// extract alpha channel
\t\t\t\t\$gammacorr = 2.2;\t// gamma correction
                \$_gammas = array(0 => 255);
                for (\$_i = 1; \$_i < 127; \$_i++)
                    \$_gammas[127 - \$_i] = pow((127 - \$alpha) / 127, \$gammacorr) * 255;
\t\t\t\tfor (\$xpx = 0; \$xpx < \$w; ++\$xpx) {
\t\t\t\t\tfor (\$ypx = 0; \$ypx < \$h; ++\$ypx) {
\t\t\t\t\t\t//\$colorindex = imagecolorat(\$im, \$xpx, \$ypx);
\t\t\t\t\t\t//\$col = imagecolorsforindex(\$im, \$colorindex);
\t\t\t\t\t\t//\$gamma2 = (pow((((127 - \$col['alpha']) * 255 / 127) / 255), \$gammacorr) * 255);
\t\t\t\t\t\t//\$alpha = (imagecolorat(\$im, \$xpx, \$ypx) & 0x7F000000) >> 24;
\t\t\t\t\t\t\$alpha = imagecolorat(\$im, \$xpx, \$ypx) >> 24;
\t\t\t\t\t\tif (\$alpha < 127) {
\t\t\t\t\t\t\timagesetpixel(\$imgalpha, \$xpx, \$ypx, \$_gammas[\$alpha]);
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\t// create temp alpha file
\t \t\t \t\$tempfile_alpha = _MPDF_TEMP_PATH.'_tempMskPNG'.RAND(1,10000).'.png';
\t\t\t\tif (!is_writable(\$tempfile_alpha)) {
\t\t\t\t\tob_start();
\t\t\t\t\t\$check = @imagepng(\$imgalpha);
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary image object whilst using GD library to parse PNG image'); }
\t\t\t\t\timagedestroy(\$imgalpha);
\t\t\t\t\t\$this->_tempimg = ob_get_contents();
\t\t\t\t\t\$this->_tempimglnk = 'var:_tempimg';
\t\t\t\t\tob_end_clean();
\t\t\t\t\t// extract image without alpha channel
\t\t\t\t\t\$imgplain = imagecreatetruecolor(\$w, \$h);
\t\t\t\t\timagecopy(\$imgplain, \$im, 0, 0, 0, 0, \$w, \$h);
\t\t\t\t\t// create temp image file
\t\t\t\t\t\$minfo = \$this->_getImage(\$this->_tempimglnk, false);
\t\t\t\t\tif (!\$minfo) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file image object created with GD library to parse PNG image'); }
\t\t\t\t\tob_start();
\t\t\t\t\t\$check = @imagepng(\$imgplain);
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary image object whilst using GD library to parse PNG image'); }
\t\t\t\t\t\$this->_tempimg = ob_get_contents();
\t\t\t\t\t\$this->_tempimglnk = 'var:_tempimg';
\t\t\t\t\tob_end_clean();
\t\t\t\t\t\$info = \$this->_getImage(\$this->_tempimglnk, false);
\t\t\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file image object created with GD library to parse PNG image'); }
\t\t\t\t\timagedestroy(\$imgplain);
\t\t\t\t\t\$imgmask = count(\$this->images)+1;
\t\t\t\t\t\$minfo['cs'] = 'DeviceGray';
\t\t\t\t\t\$minfo['i']=\$imgmask ;
\t\t\t\t\t\$this->images[\$tempfile_alpha] = \$minfo;

\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$check = @imagepng(\$imgalpha, \$tempfile_alpha);
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Failed to create temporary image file ('.\$tempfile_alpha.') parsing PNG image with alpha channel ('.\$errpng.')'); }
\t\t\t\t\timagedestroy(\$imgalpha);

\t\t\t\t\t// extract image without alpha channel
\t\t\t\t\t\$imgplain = imagecreatetruecolor(\$w, \$h);
\t\t\t\t\timagecopy(\$imgplain, \$im, 0, 0, 0, 0, \$w, \$h);

\t\t\t\t\t// create temp image file
\t\t\t\t\t\$check = @imagepng(\$imgplain, \$tempfile);
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Failed to create temporary image file ('.\$tempfile.') parsing PNG image with alpha channel ('.\$errpng.')'); }
\t\t\t\t\timagedestroy(\$imgplain);
\t\t\t\t\t// embed mask image
\t\t\t\t\t\$minfo = \$this->_getImage(\$tempfile_alpha, false);
\t\t\t\t\tunlink(\$tempfile_alpha);
\t\t\t\t\tif (!\$minfo) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file ('.\$tempfile_alpha.') created with GD library to parse PNG image'); }
\t\t\t\t\t\$imgmask = count(\$this->images)+1;
\t\t\t\t\t\$minfo['cs'] = 'DeviceGray';
\t\t\t\t\t\$minfo['i']=\$imgmask ;
\t\t\t\t\t\$this->images[\$tempfile_alpha] = \$minfo;
\t\t\t\t\t// embed image, masked with previously embedded mask
\t\t\t\t\t\$info = \$this->_getImage(\$tempfile, false);
\t\t\t\t\tunlink(\$tempfile);
\t\t\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file ('.\$tempfile.') created with GD library to parse PNG image'); }

\t\t\t\t}
\t\t\t\t\$info['masked'] = \$imgmask;
\t\t\t\tif (\$ppUx) { \$info['set-dpi'] = \$ppUx; }
\t\t\t\t\$info['type']='png';
\t\t\t\tif (\$firsttime) {
\t\t\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\t\t\$this->images[\$file]=\$info;
\t\t\t\t}
\t\t\t\treturn \$info;
\t\t\t   }
\t\t\t   else { \t// No alpha/transparency set
\t\t\t\timagealphablending(\$im, false);
\t\t\t\timagesavealpha(\$im, false);
\t\t\t\timageinterlace(\$im, false);
\t\t\t\tif (!is_writable(\$tempfile)) {
\t\t\t\t\tob_start();
\t\t\t\t\t\$check = @imagepng(\$im);
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary image object whilst using GD library to parse PNG image'); }
\t\t\t\t\t\$this->_tempimg = ob_get_contents();
\t\t\t\t\t\$this->_tempimglnk = 'var:_tempimg';
\t\t\t\t\tob_end_clean();
\t\t\t\t\t\$info = \$this->_getImage(\$this->_tempimglnk, false);
\t\t\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file image object created with GD library to parse PNG image'); }
\t\t\t\t\timagedestroy(\$im);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$check = @imagepng(\$im, \$tempfile );
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Failed to create temporary image file ('.\$tempfile.') parsing PNG image ('.\$errpng.')'); }
\t\t\t\t\timagedestroy(\$im);
\t\t\t\t\t\$info = \$this->_getImage(\$tempfile, false) ;
\t\t\t\t\tunlink(\$tempfile );
\t\t\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file ('.\$tempfile.') created with GD library to parse PNG image'); }
\t\t\t\t}
\t\t\t\tif (\$ppUx) { \$info['set-dpi'] = \$ppUx; }
\t\t\t\t\$info['type']='png';
\t\t\t\tif (\$firsttime) {
\t\t\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\t\t\$this->images[\$file]=\$info;
\t\t\t\t}
\t\t\t\treturn \$info;
\t\t\t   }
\t\t\t}
\t\t}

\t\telse {
\t\t\t\$parms='/DecodeParms <</Predictor 15 /Colors '.(\$ct==2 ? 3 : 1).' /BitsPerComponent '.\$bpc.' /Columns '.\$w.'>>';
\t\t\t//Scan chunks looking for palette, transparency and image data
\t\t\t\$pal='';
\t\t\t\$trns='';
\t\t\t\$pngdata='';
\t\t\t\$p = 33;
\t\t\tdo {
\t\t\t\t\$n=\$this->_fourbytes2int(substr(\$data,\$p,4));\t\$p += 4;
\t\t\t\t\$type=substr(\$data,\$p,4);\t\$p += 4;
\t\t\t\tif(\$type=='PLTE') {
\t\t\t\t\t//Read palette
\t\t\t\t\t\$pal=substr(\$data,\$p,\$n);\t\$p += \$n;
\t\t\t\t\t\$p += 4;
\t\t\t\t}
\t\t\t\telseif(\$type=='tRNS') {
\t\t\t\t\t//Read transparency info
\t\t\t\t\t\$t=substr(\$data,\$p,\$n);\t\$p += \$n;
\t\t\t\t\tif(\$ct==0) \$trns=array(ord(substr(\$t,1,1)));
\t\t\t\t\telseif(\$ct==2) \$trns=array(ord(substr(\$t,1,1)),ord(substr(\$t,3,1)),ord(substr(\$t,5,1)));
\t\t\t\t\telse
\t\t\t\t\t{
\t\t\t\t\t\t\$pos=strpos(\$t,chr(0));
\t\t\t\t\t\tif(is_int(\$pos)) \$trns=array(\$pos);
\t\t\t\t\t}
\t\t\t\t\t\$p += 4;
\t\t\t\t}
\t\t\t\telseif(\$type=='IDAT') {
\t\t\t\t\t\$pngdata.=substr(\$data,\$p,\$n);\t\$p += \$n;
\t\t\t\t\t\$p += 4;
\t\t\t\t}
\t\t\t\telseif(\$type=='IEND') { break; }
\t\t\t\telse if (preg_match('/[a-zA-Z]{4}/',\$type)) { \$p += \$n+4; }
\t\t\t\telse { return \$this->_imageError(\$file, \$firsttime, 'Error parsing PNG image data'); }
\t\t\t}
\t\t\twhile(\$n);
\t\t\tif (!\$pngdata) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing PNG image data - no IDAT data found'); }
\t\t\tif(\$colspace=='Indexed' and empty(\$pal)) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing PNG image data - missing colour palette'); }
\t\t\t\$info = array('w'=>\$w,'h'=>\$h,'cs'=>\$colspace,'bpc'=>\$bpc,'f'=>'FlateDecode','parms'=>\$parms,'pal'=>\$pal,'trns'=>\$trns,'data'=>\$pngdata);
\t\t\t\$info['type']='png';
\t\t\tif (\$ppUx) { \$info['set-dpi'] = \$ppUx; }
\t\t}

\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing or converting PNG image'); }

\t\tif (\$firsttime) {
\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\$this->images[\$file]=\$info;
\t\t}
\t\treturn \$info;
\t}

\t// GIF
\telse if (\$type == 'gif') {
\tif (function_exists('gd_info')) { \$gd = gd_info(); }
\t\telse {\$gd = array(); }
\t\tif (isset(\$gd['GIF Read Support']) && \$gd['GIF Read Support']) {
\t\t\t\$im = @imagecreatefromstring(\$data);
\t\t\tif (\$im) {
\t\t\t\t\$tempfile = _MPDF_TEMP_PATH.'_tempImgPNG'.md5(\$file).RAND(1,10000).'.png';
\t\t\t\timagealphablending(\$im, false);
\t\t\t\timagesavealpha(\$im, false);
\t\t\t\timageinterlace(\$im, false);
\t\t\t\tif (!is_writable(\$tempfile)) {
\t\t\t\t\tob_start();
\t\t\t\t\t\$check = @imagepng(\$im);
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary image object whilst using GD library to parse GIF image'); }
\t\t\t\t\t\$this->_tempimg = ob_get_contents();
\t\t\t\t\t\$this->_tempimglnk = 'var:_tempimg';
\t\t\t\t\tob_end_clean();
\t\t\t\t\t\$info = \$this->_getImage(\$this->_tempimglnk, false);
\t\t\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file image object created with GD library to parse GIF image'); }
\t\t\t\t\timagedestroy(\$im);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$check = @imagepng(\$im, \$tempfile);
\t\t\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary file ('.\$tempfile.') whilst using GD library to parse GIF image'); }
\t\t\t\t\t\$info = \$this->_getImage(\$tempfile, false);
\t\t\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file ('.\$tempfile.') created with GD library to parse GIF image'); }
\t\t\t\t\timagedestroy(\$im);
\t\t\t\t\tunlink(\$tempfile);
\t\t\t\t}
\t\t\t\t\$info['type']='gif';
\t\t\t\tif (\$firsttime) {
\t\t\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\t\t\$this->images[\$file]=\$info;
\t\t\t\t}
\t\t\t\treturn \$info;
\t\t\t}
\t\t\telse { return \$this->_imageError(\$file, \$firsttime, 'Error creating GD image file from GIF image'); }
\t\t}

\t\tif (!class_exists('gif', false)) {
\t\t\tinclude_once(_MPDF_PATH.'classes/gif.php');
\t\t}
\t\t\$gif=new CGIF();

\t\t\$h=0;
\t\t\$w=0;
\t\t\$gif->loadFile(\$data, 0);

\t\tif(isset(\$gif->m_img->m_gih->m_bLocalClr) && \$gif->m_img->m_gih->m_bLocalClr) {
\t\t\t\$nColors = \$gif->m_img->m_gih->m_nTableSize;
\t\t\t\$pal = \$gif->m_img->m_gih->m_colorTable->toString();
\t\t\tif((isset(\$bgColor)) and \$bgColor != -1) {\t// mPDF 5.7.3
\t\t\t\t\$bgColor = \$gif->m_img->m_gih->m_colorTable->colorIndex(\$bgColor);
\t\t\t}
\t\t\t\$colspace='Indexed';
\t\t} elseif(isset(\$gif->m_gfh->m_bGlobalClr) && \$gif->m_gfh->m_bGlobalClr) {
\t\t\t\$nColors = \$gif->m_gfh->m_nTableSize;
\t\t\t\$pal = \$gif->m_gfh->m_colorTable->toString();
\t\t\tif((isset(\$bgColor)) and \$bgColor != -1) {
\t\t\t\t\$bgColor = \$gif->m_gfh->m_colorTable->colorIndex(\$bgColor);
\t\t\t}
\t\t\t\$colspace='Indexed';
\t\t} else {
\t\t\t\$nColors = 0;
\t\t\t\$bgColor = -1;
\t\t\t\$colspace='DeviceGray';
\t\t\t\$pal='';
\t\t}

\t\t\$trns='';
\t\tif(isset(\$gif->m_img->m_bTrans) && \$gif->m_img->m_bTrans && (\$nColors > 0)) {
\t\t\t\$trns=array(\$gif->m_img->m_nTrans);
\t\t}
\t\t\$gifdata=\$gif->m_img->m_data;
\t\t\$w=\$gif->m_gfh->m_nWidth;
\t\t\$h=\$gif->m_gfh->m_nHeight;
\t\t\$gif->ClearData();

\t\tif(\$colspace=='Indexed' and empty(\$pal)) {
\t\t\treturn \$this->_imageError(\$file, \$firsttime, 'Error parsing GIF image - missing colour palette');
\t\t}
\t\tif (\$this->compress) {
\t\t\t\$gifdata=gzcompress(\$gifdata);
\t\t\t\$info = array( 'w'=>\$w, 'h'=>\$h, 'cs'=>\$colspace, 'bpc'=>8, 'f'=>'FlateDecode', 'pal'=>\$pal, 'trns'=>\$trns, 'data'=>\$gifdata);
\t\t}
\t\telse {
\t\t\t\$info = array( 'w'=>\$w, 'h'=>\$h, 'cs'=>\$colspace, 'bpc'=>8, 'pal'=>\$pal, 'trns'=>\$trns, 'data'=>\$gifdata);
\t\t}
\t\t\$info['type']='gif';
\t\tif (\$firsttime) {
\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\$this->images[\$file]=\$info;
\t\t}
\t\treturn \$info;
\t}

/*-- IMAGES-BMP --*/
\t// BMP (Windows Bitmap)
\telse if (\$type == 'bmp') {
\t\tif (!class_exists('bmp', false)) { include(_MPDF_PATH.'classes/bmp.php'); }
\t\tif (empty(\$this->bmp)) { \$this->bmp = new bmp(\$this); }
\t\t\$info = \$this->bmp->_getBMPimage(\$data, \$file);
\t\tif (isset(\$info['error'])) {
\t\t\treturn \$this->_imageError(\$file, \$firsttime, \$info['error']);
\t\t}
\t\tif (\$firsttime) {
\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\$this->images[\$file]=\$info;
\t\t}
\t\treturn \$info;
\t}
/*-- END IMAGES-BMP --*/
/*-- IMAGES-WMF --*/
\t// WMF
\telse if (\$type == 'wmf') {
\t\tif (!class_exists('wmf', false)) { include(_MPDF_PATH.'classes/wmf.php'); }
\t\tif (empty(\$this->wmf)) { \$this->wmf = new wmf(\$this); }
\t\t\$wmfres = \$this->wmf->_getWMFimage(\$data);
\t  if (\$wmfres[0]==0) {
\t\tif (\$wmfres[1]) { return \$this->_imageError(\$file, \$firsttime, \$wmfres[1]); }
\t\treturn \$this->_imageError(\$file, \$firsttime, 'Error parsing WMF image');
\t  }
\t  \$info = array('x'=>\$wmfres[2][0],'y'=>\$wmfres[2][1],'w'=>\$wmfres[3][0],'h'=>\$wmfres[3][1],'data'=>\$wmfres[1]);
\t  \$info['i']=count(\$this->formobjects)+1;
\t  \$info['type']='wmf';
\t  \$this->formobjects[\$file]=\$info;
\t  return \$info;
\t}
/*-- END IMAGES-WMF --*/

\t// UNKNOWN TYPE - try GD imagecreatefromstring
\telse {
\t\tif (function_exists('gd_info')) { \$gd = gd_info(); }
\t\telse {\$gd = array(); }
\t\tif (isset(\$gd['PNG Support']) && \$gd['PNG Support']) {
\t\t\t\$im = @imagecreatefromstring(\$data);
\t\t\tif (!\$im) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing image file - image type not recognised, and not supported by GD imagecreate'); }
\t\t\t\$tempfile = _MPDF_TEMP_PATH.'_tempImgPNG'.md5(\$file).RAND(1,10000).'.png';
\t\t\timagealphablending(\$im, false);
\t\t\timagesavealpha(\$im, false);
\t\t\timageinterlace(\$im, false);
\t\t\t\$check = @imagepng(\$im, \$tempfile);
\t\t\tif (!\$check) { return \$this->_imageError(\$file, \$firsttime, 'Error creating temporary file ('.\$tempfile.') whilst using GD library to parse unknown image type'); }
\t\t\t\$info = \$this->_getImage(\$tempfile, false);
\t\t\timagedestroy(\$im);
\t\t\tunlink(\$tempfile);
\t\t\tif (!\$info) { return \$this->_imageError(\$file, \$firsttime, 'Error parsing temporary file ('.\$tempfile.') created with GD library to parse unknown image type'); }
\t\t\t\$info['type']='png';
\t\t\tif (\$firsttime) {
\t\t\t\t\$info['i']=count(\$this->images)+1;
\t\t\t\t\$this->images[\$file]=\$info;
\t\t\t}
\t\t\treturn \$info;
\t\t}
\t}

\treturn \$this->_imageError(\$file, \$firsttime, 'Error parsing image file - image type not recognised');
}
//==============================================================
function _convImage(&\$data, \$colspace, \$targetcs, \$w, \$h, \$dpi, \$mask) {
\tif (\$this->PDFA || \$this->PDFX) { \$mask=false; }
\t\$im = @imagecreatefromstring(\$data);
\t\$info = array();
\tif (\$im) {
\t\t\$imgdata = '';
\t\t\$mimgdata = '';
\t\t\$minfo = array();
\t\t//Read transparency info
\t\t\$trns=array();
\t\t\$trnsrgb = false;
\t\tif (!\$this->PDFA && !\$this->PDFX) {
\t\t   \$p = strpos(\$data,'tRNS');
\t\t   if (\$p) {
\t\t\t\$n=\$this->_fourbytes2int(substr(\$data,(\$p-4),4));
\t\t\t\$t = substr(\$data,(\$p+4),\$n);
\t\t\tif (\$colspace=='DeviceGray') {
\t\t\t\t\$trns=array(ord(substr(\$t,1,1)));
\t\t\t\t\$trnsrgb = array(\$trns[0],\$trns[0],\$trns[0]);
\t\t\t}
\t\t\telse if (\$colspace=='DeviceRGB') {
\t\t\t\t\$trns=array(ord(substr(\$t,1,1)),ord(substr(\$t,3,1)),ord(substr(\$t,5,1)));
\t\t\t\t\$trnsrgb = \$trns;
\t\t\t\tif (\$targetcs=='DeviceCMYK') {
\t\t\t\t\t\$col = \$this->rgb2cmyk(array(3,\$trns[0],\$trns[1],\$trns[2]));
\t\t\t\t\t\$c1 = intval(\$col[1]*2.55);
\t\t\t\t\t\$c2 = intval(\$col[2]*2.55);
\t\t\t\t\t\$c3 = intval(\$col[3]*2.55);
\t\t\t\t\t\$c4 = intval(\$col[4]*2.55);
\t\t\t\t\t\$trns = array(\$c1,\$c2,\$c3,\$c4);
\t\t\t\t}
\t\t\t\telse if (\$targetcs=='DeviceGray') {
\t\t\t\t\t\$c = intval((\$trns[0] * .21) + (\$trns[1] * .71) + (\$trns[2] * .07));
\t\t\t\t\t\$trns = array(\$c);
\t\t\t\t}
\t\t\t}
\t\t\telse {\t// Indexed
\t\t\t\t\$pos = strpos(\$t,chr(0));
\t\t\t\tif (is_int(\$pos)) {
\t\t\t\t\t\$pal = imagecolorsforindex(\$im, \$pos);
\t\t\t\t\t\$r = \$pal['red'];
\t\t\t\t\t\$g = \$pal['green'];
\t\t\t\t\t\$b = \$pal['blue'];
\t\t\t\t\t\$trns=array(\$r,\$g,\$b);\t// ****
\t\t\t\t\t\$trnsrgb = \$trns;
\t\t\t\t\tif (\$targetcs=='DeviceCMYK') {
\t\t\t\t\t\t\$col = \$this->rgb2cmyk(array(3,\$r,\$g,\$b));
\t\t\t\t\t\t\$c1 = intval(\$col[1]*2.55);
\t\t\t\t\t\t\$c2 = intval(\$col[2]*2.55);
\t\t\t\t\t\t\$c3 = intval(\$col[3]*2.55);
\t\t\t\t\t\t\$c4 = intval(\$col[4]*2.55);
\t\t\t\t\t\t\$trns = array(\$c1,\$c2,\$c3,\$c4);
\t\t\t\t\t}
\t\t\t\t\telse if (\$targetcs=='DeviceGray') {
\t\t\t\t\t\t\$c = intval((\$r * .21) + (\$g * .71) + (\$b * .07));
\t\t\t\t\t\t\$trns = array(\$c);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t   }
\t\t}
\t\tfor (\$i = 0; \$i < \$h; \$i++) {
\t\t\tfor (\$j = 0; \$j < \$w; \$j++) {
\t\t\t\t\$rgb = imagecolorat(\$im, \$j, \$i);
\t\t\t\t\$r = (\$rgb >> 16) & 0xFF;
\t\t\t\t\$g = (\$rgb >> 8) & 0xFF;
\t\t\t\t\$b = \$rgb & 0xFF;
\t\t\t\tif (\$colspace=='Indexed') {
\t\t\t\t\t\$pal = imagecolorsforindex(\$im, \$rgb);
\t\t\t\t\t\$r = \$pal['red'];
\t\t\t\t\t\$g = \$pal['green'];
\t\t\t\t\t\$b = \$pal['blue'];
\t\t\t\t}

\t\t\t\tif (\$targetcs=='DeviceCMYK') {
\t\t\t\t\t\$col = \$this->rgb2cmyk(array(3,\$r,\$g,\$b));
\t\t\t\t\t\$c1 = intval(\$col[1]*2.55);
\t\t\t\t\t\$c2 = intval(\$col[2]*2.55);
\t\t\t\t\t\$c3 = intval(\$col[3]*2.55);
\t\t\t\t\t\$c4 = intval(\$col[4]*2.55);
\t\t\t\t\tif (\$trnsrgb) {
\t\t\t\t\t\t// original pixel was not set as transparent but processed color does match
\t\t\t\t\t\tif (\$trnsrgb!=array(\$r,\$g,\$b) && \$trns==array(\$c1,\$c2,\$c3,\$c4)) {
\t\t\t\t\t\t\tif (\$c4==0) { \$c4=1; } else { \$c4--; }
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\t\$imgdata .= chr(\$c1).chr(\$c2).chr(\$c3).chr(\$c4);
\t\t\t\t}
\t\t\t\telse if (\$targetcs=='DeviceGray') {
\t\t\t\t\t\$c = intval((\$r * .21) + (\$g * .71) + (\$b * .07));
\t\t\t\t\tif (\$trnsrgb) {
\t\t\t\t\t\t// original pixel was not set as transparent but processed color does match
\t\t\t\t\t\tif (\$trnsrgb!=array(\$r,\$g,\$b) && \$trns==array(\$c)) {
\t\t\t\t\t\t\tif (\$c==0) { \$c=1; } else { \$c--; }
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\t\$imgdata .= chr(\$c);
\t\t\t\t}
\t\t\t\telse if (\$targetcs=='DeviceRGB') {
\t\t\t\t\t\$imgdata .= chr(\$r).chr(\$g).chr(\$b);
\t\t\t\t}
\t\t\t\tif (\$mask) {
\t\t\t\t\t// mPDF 5.7.2 Gamma correction
\t\t\t\t\t\$alpha = (\$rgb & 0x7F000000) >> 24;
\t\t\t\t\tif (\$alpha < 127) { \$mimgdata .= chr(255-(\$alpha * 2)); }
\t\t\t\t\telse { \$mimgdata .= chr(0); }
\t\t\t\t}
\t\t\t}
\t\t}

\t\tif (\$targetcs=='DeviceGray') { \$ncols = 1; }
\t\telse if (\$targetcs=='DeviceRGB') { \$ncols = 3; }
\t\telse if (\$targetcs=='DeviceCMYK') { \$ncols = 4; }

\t\t\$imgdata = gzcompress(\$imgdata);
\t\t\$info = array('w'=>\$w,'h'=>\$h,'cs'=>\$targetcs,'bpc'=>8,'f'=>'FlateDecode','data'=>\$imgdata, 'type'=>'png',
\t\t\t'parms'=>'/DecodeParms <</Colors '.\$ncols.' /BitsPerComponent 8 /Columns '.\$w.'>>');
\t\tif (\$dpi) { \$info['set-dpi'] = \$dpi; }
\t\tif (\$mask) {
\t\t\t\$mimgdata = gzcompress(\$mimgdata);
\t\t\t\$minfo = array('w'=>\$w,'h'=>\$h,'cs'=>'DeviceGray','bpc'=>8,'f'=>'FlateDecode','data'=>\$mimgdata, 'type'=>'png',
\t\t\t'parms'=>'/DecodeParms <</Colors '.\$ncols.' /BitsPerComponent 8 /Columns '.\$w.'>>');
\t\t\tif (\$dpi) { \$minfo['set-dpi'] = \$dpi; }
\t\t\t\$tempfile = '_tempImgPNG'.md5(\$file).RAND(1,10000).'.png';
\t\t\t\$imgmask = count(\$this->images)+1;
\t\t\t\$minfo['i']=\$imgmask ;
\t\t\t\$this->images[\$tempfile] = \$minfo;
\t\t\t\$info['masked'] = \$imgmask;
\t\t}
\t\telse if (\$trns) { \$info['trns'] = \$trns; }
\t\timagedestroy(\$im);
\t}
\treturn \$info;
}




function _fourbytes2int(\$s) {
\t//Read a 4-byte integer from string
\treturn (ord(\$s[0])<<24) + (ord(\$s[1])<<16) + (ord(\$s[2])<<8) + ord(\$s[3]);
}

function _twobytes2int(\$s) {
\t//Read a 2-byte integer from string
\treturn (ord(substr(\$s, 0, 1))<<8) + ord(substr(\$s, 1, 1));
}

function _jpgHeaderFromString(&\$data) {
\t\$p = 4;
\t\$p += \$this->_twobytes2int(substr(\$data, \$p, 2));\t// Length of initial marker block
\t\$marker = substr(\$data, \$p, 2);
\twhile(\$marker != chr(255).chr(192) && \$marker != chr(255).chr(194) && \$p<strlen(\$data)) {
\t\t// Start of frame marker (FFC0) or (FFC2) mPDF 4.4.004
\t\t\$p += (\$this->_twobytes2int(substr(\$data, \$p+2, 2))) + 2;\t// Length of marker block
\t\t\$marker = substr(\$data, \$p, 2);
\t}
\tif (\$marker != chr(255).chr(192) && \$marker != chr(255).chr(194)) { return false; }
\treturn substr(\$data, \$p+2, 10);
}

function _jpgDataFromHeader(\$hdr) {
\t\$bpc = ord(substr(\$hdr, 2, 1));
\tif (!\$bpc) { \$bpc = 8; }
\t\$h = \$this->_twobytes2int(substr(\$hdr, 3, 2));
\t\$w = \$this->_twobytes2int(substr(\$hdr, 5, 2));
\t\$channels = ord(substr(\$hdr, 7, 1));
\tif (\$channels==3) { \$colspace='DeviceRGB'; }
\telseif(\$channels==4) { \$colspace='DeviceCMYK'; }
\telse { \$colspace='DeviceGray'; }
\treturn array(\$w, \$h, \$colspace, \$bpc);
}

function file_get_contents_by_curl(\$url, &\$data) {
\t\$timeout = 5;
\t\$ch = curl_init(\$url);
\tcurl_setopt(\$ch, CURLOPT_HEADER, 0);
\tcurl_setopt(\$ch, CURLOPT_NOBODY, 0);
\tcurl_setopt ( \$ch , CURLOPT_RETURNTRANSFER , 1 );
\tcurl_setopt ( \$ch , CURLOPT_CONNECTTIMEOUT , \$timeout );
\t\$data = curl_exec(\$ch);
\tcurl_close(\$ch);
}


function file_get_contents_by_socket(\$url, &\$data) {
\t// mPDF 5.7.3
\t\$timeout = 1;
\t\$p = parse_url(\$url);
\t\$file = \$p['path'];
\tif (\$p['scheme']=='https') {
\t\t\$prefix = 'ssl://';
\t\t\$port = (\$p['port'] ? \$p['port'] : 443);
\t}
\telse {
\t\t\$prefix = '';
\t\t\$port = (\$p['port'] ? \$p['port'] : 80);
\t}
\tif (\$p['query']) { \$file .= '?'.\$p['query']; }
\tif(!(\$fh = @fsockopen(\$prefix.\$p['host'], \$port, \$errno, \$errstr, \$timeout))) { return false; }

\t\$getstring =
\t\t\"GET \".\$file.\" HTTP/1.0 \\r\\n\" .
\t\t\"Host: \".\$p['host'].\" \\r\\n\" .
\t\t\"Connection: close\\r\\n\\r\\n\";
\tfwrite(\$fh, \$getstring);
\t// Get rid of HTTP header
\t\$s = fgets(\$fh, 1024);
\tif (!\$s) { return false; }
\t\$httpheader .= \$s;
\twhile (!feof(\$fh)) {
\t\t\$s = fgets(\$fh, 1024);
\t\tif ( \$s == \"\\r\\n\" ) { break; }
\t}
\t\$data = '';
\twhile (!feof(\$fh)) {
\t\t\$data .= fgets(\$fh, 1024);
\t}
\tfclose(\$fh);
}

//==============================================================

function _imageTypeFromString(&\$data) {
\t\$type = '';
\tif (substr(\$data, 6, 4)== 'JFIF' || substr(\$data, 6, 4)== 'Exif' || substr(\$data, 0, 2)== chr(255).chr(216)) { // 0xFF 0xD8\t// mpDF 5.7.2
\t\t\$type = 'jpeg';
\t}
\telse if (substr(\$data, 0, 6)== \"GIF87a\" || substr(\$data, 0, 6)== \"GIF89a\") {
\t\t\$type = 'gif';
\t}
\telse if (substr(\$data, 0, 8)== chr(137).'PNG'.chr(13).chr(10).chr(26).chr(10)) {
\t\t\$type = 'png';
\t}
/*-- IMAGES-WMF --*/
\telse if (substr(\$data, 0, 4)== chr(215).chr(205).chr(198).chr(154)) {
\t\t\$type = 'wmf';
\t}
/*-- END IMAGES-WMF --*/
\telse if (preg_match('/<svg.*<\\/svg>/is',\$data)) {
\t\t\$type = 'svg';
\t}
\t// BMP images
\telse if (substr(\$data, 0, 2)== \"BM\") {
\t\t\$type = 'bmp';
\t}
\treturn \$type;
}
//==============================================================

// Moved outside WMF as also needed for SVG
function _putformobjects() {
\treset(\$this->formobjects);
\twhile(list(\$file,\$info)=each(\$this->formobjects)) {
\t\t\$this->_newobj();
\t\t\$this->formobjects[\$file]['n']=\$this->n;
\t\t\$this->_out('<</Type /XObject');
\t\t\$this->_out('/Subtype /Form');
\t\t\$this->_out('/Group '.(\$this->n+1).' 0 R');
\t\t\$this->_out('/BBox ['.\$info['x'].' '.\$info['y'].' '.(\$info['w']+\$info['x']).' '.(\$info['h']+\$info['y']).']');
\t\tif (\$this->compress)
\t\t\t\$this->_out('/Filter /FlateDecode');
\t\t\$data=(\$this->compress) ? gzcompress(\$info['data']) : \$info['data'];
\t\t\$this->_out('/Length '.strlen(\$data).'>>');
\t\t\$this->_putstream(\$data);
\t\tunset(\$this->formobjects[\$file]['data']);
\t\t\$this->_out('endobj');
\t\t// Required for SVG transparency (opacity) to work
\t\t\$this->_newobj();
\t\t\$this->_out('<</Type /Group');
\t\t\$this->_out('/S /Transparency');
\t\t\$this->_out('>>');
\t\t\$this->_out('endobj');
\t}
}

function _freadint(\$f)
{
\t//Read a 4-byte integer from file
\t\$i=ord(fread(\$f,1))<<24;
\t\$i+=ord(fread(\$f,1))<<16;
\t\$i+=ord(fread(\$f,1))<<8;
\t\$i+=ord(fread(\$f,1));
\treturn \$i;
}

function _UTF16BEtextstring(\$s) {
\t\$s = \$this->UTF8ToUTF16BE(\$s, true);
/*-- ENCRYPTION --*/
\tif (\$this->encrypted) {
\t\t\$s = \$this->_RC4(\$this->_objectkey(\$this->_current_obj_id), \$s);
\t}
/*-- END ENCRYPTION --*/
\treturn '('. \$this->_escape(\$s).')';
}

function _textstring(\$s) {
/*-- ENCRYPTION --*/
\tif (\$this->encrypted) {
\t\t\$s = \$this->_RC4(\$this->_objectkey(\$this->_current_obj_id), \$s);
\t}
/*-- END ENCRYPTION --*/
\treturn '('. \$this->_escape(\$s).')';
}


function _escape(\$s)
{
\t// the chr(13) substitution fixes the Bugs item #1421290.
\treturn strtr(\$s, array(')' => '\\\\)', '(' => '\\\\(', '\\\\' => '\\\\\\\\', chr(13) => '\\r'));
}

function _putstream(\$s) {
/*-- ENCRYPTION --*/
\tif (\$this->encrypted) {
\t\t\$s = \$this->_RC4(\$this->_objectkey(\$this->_current_obj_id), \$s);
\t}
/*-- END ENCRYPTION --*/
\t\$this->_out('stream');
\t\$this->_out(\$s);
\t\$this->_out('endstream');
}


function _out(\$s,\$ln=true) {
\tif(\$this->state==2) {
\t   if (\$this->bufferoutput) {
\t\t\$this->headerbuffer.= \$s.\"\\n\";
\t   }
/*-- COLUMNS --*/
\t   else if ((\$this->ColActive) && !\$this->processingHeader && !\$this->processingFooter) {
\t\t// Captures everything in buffer for columns; Almost everything is sent from fn. Cell() except:
\t\t// Images sent from Image() or
\t\t// later sent as _out(\$textto) in printbuffer
\t\t// Line()
\t\tif (preg_match('/q \\d+\\.\\d\\d+ 0 0 (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ cm \\/(I|FO)\\d+ Do Q/',\$s,\$m)) {\t// Image data
\t\t\t\$h = (\$m[1]/_MPDFK);
\t\t\t// Update/overwrite the lowest bottom of printing y value for a column
\t\t\t\$this->ColDetails[\$this->CurrCol]['bottom_margin'] = \$this->y+\$h;
\t\t}
/*-- TABLES --*/
\t\telse if (preg_match('/\\d+\\.\\d\\d+ \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ ([\\-]{0,1}\\d+\\.\\d\\d+) re/',\$s,\$m) && \$this->tableLevel>0) { // Rect in table
\t\t\t\$h = (\$m[1]/_MPDFK);
\t\t\t// Update/overwrite the lowest bottom of printing y value for a column
\t\t\t\$this->ColDetails[\$this->CurrCol]['bottom_margin'] = max(\$this->ColDetails[\$this->CurrCol]['bottom_margin'],(\$this->y+\$h));
\t\t}
/*-- END TABLES --*/
\t\telse { \t// Td Text Set in Cell()
\t\t\tif (isset(\$this->ColDetails[\$this->CurrCol]['bottom_margin'])) { \$h = \$this->ColDetails[\$this->CurrCol]['bottom_margin'] - \$this->y; }
\t\t\telse { \$h = 0; }
\t\t}
\t\tif (\$h < 0) { \$h = -\$h; }
\t\t\$this->columnbuffer[] = array(
\t\t's' => \$s,\t\t\t\t\t\t\t// Text string to output
\t\t'col' => \$this->CurrCol, \t\t\t\t// Column when printed
\t\t'x' => \$this->x, \t\t\t\t\t\t// x when printed
\t\t'y' => \$this->y,\t\t\t\t\t \t// this->y when printed (after column break)
\t\t'h' => \$h\t\t\t\t\t\t \t// actual y at bottom when printed = y+h
\t\t);
\t   }
/*-- END COLUMNS --*/
/*-- TABLES --*/
\t   else if (\$this->table_rotate && !\$this->processingHeader && !\$this->processingFooter) {
\t\t// Captures eveything in buffer for rotated tables;
\t\t\$this->tablebuffer .= \$s . \"\\n\";
\t   }
/*-- END TABLES --*/
\t   else if (\$this->kwt && !\$this->processingHeader && !\$this->processingFooter) {
\t\t// Captures eveything in buffer for keep-with-table (h1-6);
\t\t\$this->kwt_buffer[] = array(
\t\t's' => \$s,\t\t\t\t\t\t\t// Text string to output
\t\t'x' => \$this->x, \t\t\t\t\t\t// x when printed
\t\t'y' => \$this->y,\t\t\t\t\t \t// y when printed
\t\t);
\t   }
\t   else if ((\$this->keep_block_together) && !\$this->processingHeader && !\$this->processingFooter) {
\t\tif (!isset(\$this->ktBlock[\$this->page]['bottom_margin'])) {
\t\t\t\$this->ktBlock[\$this->page]['bottom_margin'] = \$this->y;
\t\t}

\t\t// Captures eveything in buffer;
\t\tif (preg_match('/q \\d+\\.\\d\\d+ 0 0 (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ cm \\/(I|FO)\\d+ Do Q/',\$s,\$m)) {\t// Image data
\t\t\t\$h = (\$m[1]/_MPDFK);
\t\t\t// Update/overwrite the lowest bottom of printing y value for Keep together block
\t\t\t\$this->ktBlock[\$this->page]['bottom_margin'] = \$this->y+\$h;
\t\t}
\t\telse { \t// Td Text Set in Cell()
\t\t\tif (isset(\$this->ktBlock[\$this->page]['bottom_margin'])) { \$h = \$this->ktBlock[\$this->page]['bottom_margin'] - \$this->y; }
\t\t\telse { \$h = 0; }
\t\t}
\t\tif (\$h < 0) { \$h = -\$h; }
\t\t\$this->divbuffer[] = array(
\t\t'page' => \$this->page,
\t\t's' => \$s,\t\t\t\t\t\t\t// Text string to output
\t\t'x' => \$this->x, \t\t\t\t\t\t// x when printed
\t\t'y' => \$this->y,\t\t\t\t\t \t// y when printed (after column break)
\t\t'h' => \$h\t\t\t\t\t\t \t// actual y at bottom when printed = y+h
\t\t);
\t   }
\t   else {
\t\t\$this->pages[\$this->page] .= \$s.(\$ln == true ? \"\\n\" : '');
\t   }

\t}
\telse {
\t\t\$this->buffer .= \$s.(\$ln == true ? \"\\n\" : '');
\t}
}

/*-- WATERMARK --*/
// add a watermark
function watermark( \$texte, \$angle=45, \$fontsize=96, \$alpha=0.2 ) {
\tif (\$this->PDFA || \$this->PDFX) { \$this->Error('PDFA and PDFX do not permit transparency, so mPDF does not allow Watermarks!'); }
\tif (!\$this->watermark_font) { \$this->watermark_font = \$this->default_font; }
      \$this->SetFont( \$this->watermark_font, \"B\", \$fontsize, false );\t// Don't output
\t\$texte= \$this->purify_utf8_text(\$texte);
\tif (\$this->text_input_as_HTML) {
\t\t\$texte= \$this->all_entities_to_utf8(\$texte);
\t}
\tif (\$this->usingCoreFont) { \$texte = mb_convert_encoding(\$texte,\$this->mb_enc,'UTF-8'); }
\t// DIRECTIONALITY
\t\$this->magic_reverse_dir(\$texte, true, \$this->directionality);\t// *RTL*
\t// Font-specific ligature substitution for Indic fonts
\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) \$this->ConvertIndic(\$texte);\t// *INDIC*

\t\$this->SetAlpha(\$alpha);

\t\$this->SetTColor(\$this->ConvertColor(0));
\t\$szfont = \$fontsize;
\t\$loop   = 0;
\t\$maxlen = (min(\$this->w,\$this->h) );\t// sets max length of text as 7/8 width/height of page
\twhile ( \$loop == 0 )
\t{
       \$this->SetFont( \$this->watermark_font, \"B\", \$szfont, false );\t// Don't output
\t \$offset =  ((sin(deg2rad(\$angle))) * (\$szfont/_MPDFK));

       \$strlen = \$this->GetStringWidth(\$texte);
       if ( \$strlen > \$maxlen - \$offset  )
          \$szfont --;
       else
          \$loop ++;
\t}

\t\$this->SetFont( \$this->watermark_font, \"B\", \$szfont-0.1, true, true);\t// Output The -0.1 is because SetFont above is not written to PDF
\t\t\t\t\t\t\t\t\t\t\t// Repeating it will not output anything as mPDF thinks it is set
\t\$adj = ((cos(deg2rad(\$angle))) * (\$strlen/2));
\t\$opp = ((sin(deg2rad(\$angle))) * (\$strlen/2));
\t\$wx = (\$this->w/2) - \$adj + \$offset/3;
\t\$wy = (\$this->h/2) + \$opp;
\t\$this->Rotate(\$angle,\$wx,\$wy);
\t\$this->Text(\$wx,\$wy,\$texte);
\t\$this->Rotate(0);
\t\$this->SetTColor(\$this->ConvertColor(0));

\t\$this->SetAlpha(1);

}

function watermarkImg( \$src, \$alpha=0.2 ) {
\tif (\$this->PDFA || \$this->PDFX) { \$this->Error('PDFA and PDFX do not permit transparency, so mPDF does not allow Watermarks!'); }
\tif (\$this->watermarkImgBehind) { \$this->watermarkImgAlpha = \$this->SetAlpha(\$alpha, 'Normal', true); }
\telse { \$this->SetAlpha(\$alpha, \$this->watermarkImgAlphaBlend); }
\t\$this->Image(\$src,0,0,0,0,'','', true, true, true);
\tif (!\$this->watermarkImgBehind) { \$this->SetAlpha(1); }
}
/*-- END WATERMARK --*/


function Rotate(\$angle,\$x=-1,\$y=-1)
{
\tif(\$x==-1)
\t\t\$x=\$this->x;
\tif(\$y==-1)
\t\t\$y=\$this->y;
\tif(\$this->angle!=0)
\t\t\$this->_out('Q');
\t\$this->angle=\$angle;
\tif(\$angle!=0)
\t{
\t\t\$angle*=M_PI/180;
\t\t\$c=cos(\$angle);
\t\t\$s=sin(\$angle);
\t\t\$cx=\$x*_MPDFK;
\t\t\$cy=(\$this->h-\$y)*_MPDFK;
\t\t\$this->_out(sprintf('q %.5F %.5F %.5F %.5F %.3F %.3F cm 1 0 0 1 %.3F %.3F cm',\$c,\$s,-\$s,\$c,\$cx,\$cy,-\$cx,-\$cy));
\t}
}



function CircularText(\$x, \$y, \$r, \$text, \$align='top', \$fontfamily='', \$fontsize=0, \$fontstyle='', \$kerning=120, \$fontwidth=100, \$divider) {\t// mPDF 5.5.23
\tif (!class_exists('directw', false)) { include(_MPDF_PATH.'classes/directw.php'); }
\tif (empty(\$this->directw)) { \$this->directw = new directw(\$this); }
\t\$this->directw->CircularText(\$x, \$y, \$r, \$text, \$align, \$fontfamily, \$fontsize, \$fontstyle, \$kerning, \$fontwidth, \$divider);\t// mPDF 5.5.23
}


// From Invoice
function RoundedRect(\$x, \$y, \$w, \$h, \$r, \$style = '')
{
\t\$hp = \$this->h;
\tif(\$style=='F')
\t\t\$op='f';
\telseif(\$style=='FD' or \$style=='DF')
\t\t\$op='B';
\telse
\t\t\$op='S';
\t\$MyArc = 4/3 * (sqrt(2) - 1);
\t\$this->_out(sprintf('%.3F %.3F m',(\$x+\$r)*_MPDFK,(\$hp-\$y)*_MPDFK ));
\t\$xc = \$x+\$w-\$r ;
\t\$yc = \$y+\$r;
\t\$this->_out(sprintf('%.3F %.3F l', \$xc*_MPDFK,(\$hp-\$y)*_MPDFK ));

\t\$this->_Arc(\$xc + \$r*\$MyArc, \$yc - \$r, \$xc + \$r, \$yc - \$r*\$MyArc, \$xc + \$r, \$yc);
\t\$xc = \$x+\$w-\$r ;
\t\$yc = \$y+\$h-\$r;
\t\$this->_out(sprintf('%.3F %.3F l',(\$x+\$w)*_MPDFK,(\$hp-\$yc)*_MPDFK));
\t\$this->_Arc(\$xc + \$r, \$yc + \$r*\$MyArc, \$xc + \$r*\$MyArc, \$yc + \$r, \$xc, \$yc + \$r);
\t\$xc = \$x+\$r ;
\t\$yc = \$y+\$h-\$r;
\t\$this->_out(sprintf('%.3F %.3F l',\$xc*_MPDFK,(\$hp-(\$y+\$h))*_MPDFK));
\t\$this->_Arc(\$xc - \$r*\$MyArc, \$yc + \$r, \$xc - \$r, \$yc + \$r*\$MyArc, \$xc - \$r, \$yc);
\t\$xc = \$x+\$r ;
\t\$yc = \$y+\$r;
\t\$this->_out(sprintf('%.3F %.3F l',(\$x)*_MPDFK,(\$hp-\$yc)*_MPDFK ));
\t\$this->_Arc(\$xc - \$r, \$yc - \$r*\$MyArc, \$xc - \$r*\$MyArc, \$yc - \$r, \$xc, \$yc - \$r);
\t\$this->_out(\$op);
}

function _Arc(\$x1, \$y1, \$x2, \$y2, \$x3, \$y3)
{
\t\$h = \$this->h;
\t\$this->_out(sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c ', \$x1*_MPDFK, (\$h-\$y1)*_MPDFK,
\t\t\t\t\t\t\$x2*_MPDFK, (\$h-\$y2)*_MPDFK, \$x3*_MPDFK, (\$h-\$y3)*_MPDFK));
}




//====================================================



/*-- DIRECTW --*/
function Shaded_box( \$text,\$font='',\$fontstyle='B',\$szfont='',\$width='70%',\$style='DF',\$radius=2.5,\$fill='#FFFFFF',\$color='#000000',\$pad=2 ) {
\t// F (shading - no line),S (line, no shading),DF (both)
\tif (!class_exists('directw', false)) { include(_MPDF_PATH.'classes/directw.php'); }
\tif (empty(\$this->directw)) { \$this->directw = new directw(\$this); }
\t\$this->directw->Shaded_box( \$text,\$font,\$fontstyle,\$szfont,\$width,\$style,\$radius,\$fill,\$color,\$pad);
}
/*-- END DIRECTW --*/


function UTF8StringToArray(\$str, \$addSubset=true) {
   \$out = array();
   \$len = strlen(\$str);
   for (\$i = 0; \$i < \$len; \$i++) {
\t\$uni = -1;
      \$h = ord(\$str[\$i]);
      if ( \$h <= 0x7F )
         \$uni = \$h;
      elseif ( \$h >= 0xC2 ) {
         if ( (\$h <= 0xDF) && (\$i < \$len -1) )
            \$uni = (\$h & 0x1F) << 6 | (ord(\$str[++\$i]) & 0x3F);
         elseif ( (\$h <= 0xEF) && (\$i < \$len -2) )
            \$uni = (\$h & 0x0F) << 12 | (ord(\$str[++\$i]) & 0x3F) << 6 | (ord(\$str[++\$i]) & 0x3F);
         elseif ( (\$h <= 0xF4) && (\$i < \$len -3) )
            \$uni = (\$h & 0x0F) << 18 | (ord(\$str[++\$i]) & 0x3F) << 12 | (ord(\$str[++\$i]) & 0x3F) << 6 | (ord(\$str[++\$i]) & 0x3F);
      }
\tif (\$uni >= 0) {
\t\t\$out[] = \$uni;
\t\tif (\$addSubset && isset(\$this->CurrentFont['subset'])) {
\t\t\t\$this->CurrentFont['subset'][\$uni] = \$uni;
\t\t}
\t}
   }
   return \$out;
}


//Convert utf-8 string to <HHHHHH> for Font Subsets
function UTF8toSubset(\$str) {
\t\$ret = '<';
\t\$str = preg_replace('/'.preg_quote(\$this->aliasNbPg,'/').'/', chr(7), \$str );
\t\$str = preg_replace('/'.preg_quote(\$this->aliasNbPgGp,'/').'/', chr(8), \$str );
\t\$unicode = \$this->UTF8StringToArray(\$str);
\t\$orig_fid = \$this->CurrentFont['subsetfontids'][0];
\t\$last_fid = \$this->CurrentFont['subsetfontids'][0];
\tforeach(\$unicode as \$c) {
\t   if (\$c == 7 || \$c == 8) {
\t\t\tif (\$orig_fid != \$last_fid) {
\t\t\t\t\$ret .= '> Tj /F'.\$orig_fid.' '.\$this->FontSizePt.' Tf <';
\t\t\t\t\$last_fid = \$orig_fid;
\t\t\t}
\t\t\tif (\$c == 7) { \$ret .= \$this->aliasNbPgHex; }
\t\t\telse { \$ret .= \$this->aliasNbPgGpHex; }
\t\t\tcontinue;
\t   }
\t   for (\$i=0; \$i<99; \$i++) {
\t\t// return c as decimal char
\t\t\$init = array_search(\$c, \$this->CurrentFont['subsets'][\$i]);
\t\tif (\$init!==false) {
\t\t\tif (\$this->CurrentFont['subsetfontids'][\$i] != \$last_fid) {
\t\t\t\t\$ret .= '> Tj /F'.\$this->CurrentFont['subsetfontids'][\$i].' '.\$this->FontSizePt.' Tf <';
\t\t\t\t\$last_fid = \$this->CurrentFont['subsetfontids'][\$i];
\t\t\t}
\t\t\t\$ret .= sprintf(\"%02s\", strtoupper(dechex(\$init)));
\t\t\tbreak;
\t\t}
\t\t// TrueType embedded SUBSETS
\t\telse if (count(\$this->CurrentFont['subsets'][\$i]) < 255) {
\t\t\t\$n = count(\$this->CurrentFont['subsets'][\$i]);
\t\t\t\$this->CurrentFont['subsets'][\$i][\$n] = \$c;
\t\t\tif (\$this->CurrentFont['subsetfontids'][\$i] != \$last_fid) {
\t\t\t\t\$ret .= '> Tj /F'.\$this->CurrentFont['subsetfontids'][\$i].' '.\$this->FontSizePt.' Tf <';
\t\t\t\t\$last_fid = \$this->CurrentFont['subsetfontids'][\$i];
\t\t\t}
\t\t\t\$ret .= sprintf(\"%02s\", strtoupper(dechex(\$n)));
\t\t\tbreak;
\t\t}
\t\telse if (!isset(\$this->CurrentFont['subsets'][(\$i+1)])) {
\t\t\t// TrueType embedded SUBSETS
\t\t\t\$this->CurrentFont['subsets'][(\$i+1)] = array(0=>0);
\t\t\t\$new_fid = count(\$this->fonts)+\$this->extraFontSubsets+1;
\t\t\t\$this->CurrentFont['subsetfontids'][(\$i+1)] = \$new_fid;
\t\t\t\$this->extraFontSubsets++;
\t\t}
\t   }
\t}
\t\$ret .= '>';
\tif (\$last_fid != \$orig_fid) {
\t\t\$ret .= ' Tj /F'.\$orig_fid.' '.\$this->FontSizePt.' Tf <> ';
\t}
\treturn \$ret;
}


// Converts UTF-8 strings to UTF16-BE.
function UTF8ToUTF16BE(\$str, \$setbom=true) {
\tif (\$this->checkSIP && preg_match(\"/([\\x{20000}-\\x{2FFFF}])/u\", \$str)) {
\t   if (!in_array(\$this->currentfontfamily, array('gb','big5','sjis','uhc','gbB','big5B','sjisB','uhcB','gbI','big5I','sjisI','uhcI',
\t\t'gbBI','big5BI','sjisBI','uhcBI'))) {
\t\t\$str = preg_replace(\"/[\\x{20000}-\\x{2FFFF}]/u\", chr(0), \$str);
\t   }
\t}
\tif (\$this->checkSMP && preg_match(\"/([\\x{10000}-\\x{1FFFF}])/u\", \$str )) {
\t\t\$str = preg_replace(\"/[\\x{10000}-\\x{1FFFF}]/u\", chr(0), \$str );
\t}
\t\$outstr = \"\"; // string to be returned
\tif (\$setbom) {
\t\t\$outstr .= \"\\xFE\\xFF\"; // Byte Order Mark (BOM)
\t}
\t\$outstr .= mb_convert_encoding(\$str, 'UTF-16BE', 'UTF-8');
\treturn \$outstr;
}





// ====================================================
// ====================================================
/*-- CJK-FONTS --*/

// from class PDF_Chinese CJK EXTENSIONS
function AddCIDFont(\$family,\$style,\$name,&\$cw,\$CMap,\$registry,\$desc)
{
\t\$fontkey=strtolower(\$family).strtoupper(\$style);
\tif(isset(\$this->fonts[\$fontkey]))
\t\t\$this->Error(\"Font already added: \$family \$style\");
\t\$i=count(\$this->fonts)+\$this->extraFontSubsets+1;
\t\$name=str_replace(' ','',\$name);
\tif (\$family == 'sjis') { \$up = -120; } else { \$up = -130; }
\t// ? 'up' and 'ut' do not seem to be referenced anywhere
\t\$this->fonts[\$fontkey]=array('i'=>\$i,'type'=>'Type0','name'=>\$name,'up'=>\$up,'ut'=>40,'cw'=>\$cw,'CMap'=>\$CMap,'registry'=>\$registry,'MissingWidth'=>1000,'desc'=>\$desc);
}

function AddCJKFont(\$family) {

\tif (\$this->PDFA || \$this->PDFX) {
\t\t\$this->Error(\"Adobe CJK fonts cannot be embedded in mPDF (required for PDFA1-b and PDFX/1-a).\");
\t}
\tif (\$family == 'big5') { \$this->AddBig5Font(); }
\telse if (\$family == 'gb') { \$this->AddGBFont(); }
\telse if (\$family == 'sjis') { \$this->AddSJISFont(); }
\telse if (\$family == 'uhc') { \$this->AddUHCFont(); }
}

function AddBig5Font()
{
\t//Add Big5 font with proportional Latin
\t\$family='big5';
\t\$name='MSungStd-Light-Acro';
\t\$cw=\$this->Big5_widths;
\t\$CMap='UniCNS-UTF16-H';
\t\$registry=array('ordering'=>'CNS1','supplement'=>4);
\t\$desc = array(
\t'Ascent' => 880,
\t'Descent' => -120,
\t'CapHeight' => 880,
\t'Flags' => 6,
\t'FontBBox' => '[-160 -249 1015 1071]',
\t'ItalicAngle' => 0,
\t'StemV' => 93,
\t);
\t\$this->AddCIDFont(\$family,'',\$name,\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'B',\$name.',Bold',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'I',\$name.',Italic',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'BI',\$name.',BoldItalic',\$cw,\$CMap,\$registry,\$desc);
}


function AddGBFont()
{
\t//Add GB font with proportional Latin
\t\$family='gb';
\t\$name='STSongStd-Light-Acro';
\t\$cw=\$this->GB_widths;
\t\$CMap='UniGB-UTF16-H';
\t\$registry=array('ordering'=>'GB1','supplement'=>4);
\t\$desc = array(
\t'Ascent' => 752,
\t'Descent' => -271,
\t'CapHeight' => 737,
\t'Flags' => 6,
\t'FontBBox' => '[-25 -254 1000 880]',
\t'ItalicAngle' => 0,
\t'StemV' => 58,
\t'Style' => '<< /Panose <000000000400000000000000> >>',
\t);
\t\$this->AddCIDFont(\$family,'',\$name,\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'B',\$name.',Bold',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'I',\$name.',Italic',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'BI',\$name.',BoldItalic',\$cw,\$CMap,\$registry,\$desc);
}


function AddSJISFont()
{
\t//Add SJIS font with proportional Latin
\t\$family='sjis';
\t\$name='KozMinPro-Regular-Acro';
\t\$cw=\$this->SJIS_widths;
\t\$CMap='UniJIS-UTF16-H';
\t\$registry=array('ordering'=>'Japan1','supplement'=>5);
\t\$desc = array(
\t'Ascent' => 880,
\t'Descent' => -120,
\t'CapHeight' => 740,
\t'Flags' => 6,
\t'FontBBox' => '[-195 -272 1110 1075]',
\t'ItalicAngle' => 0,
\t'StemV' => 86,
\t'XHeight' => 502,
\t);
\t\$this->AddCIDFont(\$family,'',\$name,\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'B',\$name.',Bold',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'I',\$name.',Italic',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'BI',\$name.',BoldItalic',\$cw,\$CMap,\$registry,\$desc);
}

function AddUHCFont()
{
\t//Add UHC font with proportional Latin
\t\$family='uhc';
\t\$name='HYSMyeongJoStd-Medium-Acro';
\t\$cw=\$this->UHC_widths;
\t\$CMap='UniKS-UTF16-H';
\t\$registry=array('ordering'=>'Korea1','supplement'=>2);
\t\$desc = array(
\t'Ascent' => 880,
\t'Descent' => -120,
\t'CapHeight' => 720,
\t'Flags' => 6,
\t'FontBBox' => '[-28 -148 1001 880]',
\t'ItalicAngle' => 0,
\t'StemV' => 60,
\t'Style' => '<< /Panose <000000000600000000000000> >>',
\t);
\t\$this->AddCIDFont(\$family,'',\$name,\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'B',\$name.',Bold',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'I',\$name.',Italic',\$cw,\$CMap,\$registry,\$desc);
\t\$this->AddCIDFont(\$family,'BI',\$name.',BoldItalic',\$cw,\$CMap,\$registry,\$desc);
}

/*-- END CJK-FONTS --*/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
function SetAutoFont(\$af = AUTOFONT_ALL) {
\tif (\$this->onlyCoreFonts) { return false; }
\tif (!\$af && \$af !== 0) { \$af = AUTOFONT_ALL; }
\t\$this->autoFontGroups = \$af;
\tif (\$this->autoFontGroups ) {
\t\t\$this->useLang = true;
\t}
}


function SetDefaultFont(\$font) {
\t// Disallow embedded fonts to be used as defaults in PDFA
\tif (\$this->PDFA || \$this->PDFX) {
\t\tif (strtolower(\$font) == 'ctimes') { \$font = 'serif'; }
\t\tif (strtolower(\$font) == 'ccourier') { \$font = 'monospace'; }
\t\tif (strtolower(\$font) == 'chelvetica') { \$font = 'sans-serif'; }
\t}
  \t\$font = \$this->SetFont(\$font);\t// returns substituted font if necessary
\t\$this->default_font = \$font;
\t\$this->original_default_font = \$font;
\tif (!\$this->watermark_font ) { \$this->watermark_font = \$font; }\t// *WATERMARK*
\t\$this->defaultCSS['BODY']['FONT-FAMILY'] = \$font;
\t\$this->cssmgr->CSS['BODY']['FONT-FAMILY'] = \$font;
}

function SetDefaultFontSize(\$fontsize) {
\t\$this->default_font_size = \$fontsize;
\t\$this->original_default_font_size = \$fontsize;
\t\$this->SetFontSize(\$fontsize);
\t\$this->defaultCSS['BODY']['FONT-SIZE'] = \$fontsize . 'pt';
\t\$this->cssmgr->CSS['BODY']['FONT-SIZE'] = \$fontsize . 'pt';
}

function SetDefaultBodyCSS(\$prop, \$val) {
   if (\$prop) {
\t\$this->defaultCSS['BODY'][strtoupper(\$prop)] = \$val;
\t\$this->cssmgr->CSS['BODY'][strtoupper(\$prop)] = \$val;
  }
}


function SetDirectionality(\$dir='ltr') {
/*-- RTL --*/
\tif (strtolower(\$dir) == 'rtl') {
\t  if (\$this->directionality != 'rtl') {
\t\t// Swop L/R Margins so page 1 RTL is an 'even' page
\t\t\$tmp = \$this->DeflMargin;
\t\t\$this->DeflMargin = \$this->DefrMargin;
\t\t\$this->DefrMargin = \$tmp;
\t\t\$this->orig_lMargin = \$this->DeflMargin;
\t\t\$this->orig_rMargin = \$this->DefrMargin;

\t\t\$this->SetMargins(\$this->DeflMargin,\$this->DefrMargin,\$this->tMargin);
\t  }
\t\t\$this->directionality = 'rtl';
\t\t\$this->defaultAlign = 'R';
\t\t\$this->defaultTableAlign = 'R';
\t}
\telse  {
/*-- END RTL --*/
\t\t\$this->directionality = 'ltr';
\t\t\$this->defaultAlign = 'L';
\t\t\$this->defaultTableAlign = 'L';
\t}\t// *RTL*
\t\$this->cssmgr->CSS['BODY']['DIRECTION'] = \$this->directionality;
}



// Added to set line-height-correction
function SetLineHeightCorrection(\$val) {
\tif (\$val > 0) { \$this->default_lineheight_correction = \$val; }
\telse { \$this->default_lineheight_correction = 1.2; }
}

// Set a (fixed) lineheight to an actual value - either to named fontsize(pts) or default
function SetLineHeight(\$FontPt='',\$spacing = '') {
   if (\$this->shrin_k > 1) { \$k = \$this->shrin_k; }
   else { \$k = 1; }
   if (\$spacing > 0) {
\tif (preg_match('/mm/',\$spacing)) {
\t\t\$this->lineheight = (\$spacing + 0.0) / \$k; // convert to number
\t}
\telse  {
\t\tif (\$FontPt) { \$this->lineheight = ((\$FontPt/_MPDFK) *\$spacing); }
\t\telse { \$this->lineheight = ((\$this->FontSizePt/_MPDFK) *\$spacing); }
\t}
   }
   else {
\tif (\$FontPt) { \$this->lineheight = ((\$FontPt/_MPDFK) *\$this->normalLineheight); }
\telse { \$this->lineheight = ((\$this->FontSizePt/_MPDFK) *\$this->normalLineheight); }
   }
}

function _computeLineheight(\$lh, \$fs='') {
\tif (\$this->shrin_k > 1) { \$k = \$this->shrin_k; }
\telse { \$k = 1; }
\tif (!\$fs) { \$fs = \$this->FontSize; }
\tif (preg_match('/mm/',\$lh)) {
\t\treturn ((\$lh + 0.0) / \$k); // convert to number
\t}
\telse if (\$lh > 0) {
\t\treturn (\$fs * \$lh);
\t}
\telse if (isset(\$this->normalLineheight)) { return (\$fs * \$this->normalLineheight); }
\telse return (\$fs * \$this->default_lineheight_correction);
}


function SetBasePath(\$str='') {
  if ( isset(\$_SERVER['HTTP_HOST']) ) { \$host = \$_SERVER['HTTP_HOST']; }
  else if ( isset(\$_SERVER['SERVER_NAME']) ) { \$host = \$_SERVER['SERVER_NAME']; }
  else { \$host = ''; }
  if (!\$str) {
\tif (\$_SERVER['SCRIPT_NAME']) { \$currentPath = dirname(\$_SERVER['SCRIPT_NAME']); }
\telse { \$currentPath = dirname(\$_SERVER['PHP_SELF']); }
\t\$currentPath = str_replace(\"\\\\\",\"/\",\$currentPath);
\tif (\$currentPath == '/') { \$currentPath = ''; }
\tif (\$host) { \$currpath = 'http://' . \$host . \$currentPath .'/'; }
\telse { \$currpath = ''; }
\t\$this->basepath = \$currpath;
\t\$this->basepathIsLocal = true;
\treturn;
  }
  \$str = preg_replace('/\\?.*/','',\$str);
  if (!preg_match('/(http|https|ftp):\\/\\/.*\\//i',\$str)) { \$str .= '/'; }
  \$str .= 'xxx';\t// in case \$str ends in / e.g. http://www.bbc.co.uk/
  \$this->basepath = dirname(\$str) . \"/\";\t// returns e.g. e.g. http://www.google.com/dir1/dir2/dir3/
  \$this->basepath = str_replace(\"\\\\\",\"/\",\$this->basepath); //If on Windows
  \$tr = parse_url(\$this->basepath);
  if (isset(\$tr['host']) && (\$tr['host'] == \$host)) { \$this->basepathIsLocal = true; }
  else { \$this->basepathIsLocal = false; }
}


function GetFullPath(&\$path,\$basepath='') {
\t// When parsing CSS need to pass temporary basepath - so links are relative to current stylesheet
\tif (!\$basepath) { \$basepath = \$this->basepath; }
\t//Fix path value
\t\$path = str_replace(\"\\\\\",\"/\",\$path); //If on Windows
\t// mPDF 5.7.2
\tif (substr(\$path,0,2) == \"//\") {
\t\t\$tr = parse_url(\$basepath);
\t\t\$path = \$tr['scheme'].':'.\$path;
\t}
\t\$regexp = '|^./|';\t// Inadvertently corrects \"./path/etc\" and \"//www.domain.com/etc\"
\t\$path = preg_replace(\$regexp,'',\$path);


\tif(substr(\$path,0,1) == '#') { return; }
\tif (stristr(\$path,\"mailto:\") !== false) { return; }
\tif (strpos(\$path,\"../\") !== false ) { //It is a Relative Link
\t\t\$backtrackamount = substr_count(\$path,\"../\");
\t\t\$maxbacktrack = substr_count(\$basepath,\"/\") - 3;\t// mPDF 5.6.18
\t\t\$filepath = str_replace(\"../\",'',\$path);
\t\t\$path = \$basepath;
\t\t//If it is an invalid relative link, then make it go to directory root
\t\tif (\$backtrackamount > \$maxbacktrack) \$backtrackamount = \$maxbacktrack;
\t\t//Backtrack some directories
\t\tfor( \$i = 0 ; \$i < \$backtrackamount + 1 ; \$i++ ) \$path = substr( \$path, 0 , strrpos(\$path,\"/\") );
\t\t\$path = \$path . \"/\" . \$filepath; //Make it an absolute path
\t}
\telse if( strpos(\$path,\":/\") === false || strpos(\$path,\":/\") > 10) { //It is a Local Link
\t\tif (substr(\$path,0,1) == \"/\") {
\t\t\t\$tr = parse_url(\$basepath);
\t\t\t// mPDF 5.7.2
\t\t\t\$root = '';
\t\t\tif (!empty(\$tr['scheme'])) { \$root .= \$tr['scheme'].'://'; }
\t\t\t\$root .= \$tr['host'];
\t\t\t\$root .= (\$tr['port'] ? (':'.\$tr['port']) : '');\t// mPDF 5.7.3
\t\t\t\$path = \$root . \$path;
\t\t}
\t\telse { \$path = \$basepath . \$path; }
\t}
\t//Do nothing if it is an Absolute Link
}


// Used for external CSS files
function _get_file(\$path) {
\t// If local file try using local path (? quicker, but also allowed even if allow_url_fopen false)
\t\$contents = '';
\t// mPDF 5.7.3
\tif (strpos(\$path,\"//\") === false ) { \$path = preg_replace('/\\.css\\?.*\$/', '.css', \$path); }
\t\$contents = @file_get_contents(\$path);
\tif (\$contents) { return \$contents; }
\tif (\$this->basepathIsLocal) {
\t\t\$tr = parse_url(\$path);
\t\t\$lp=getenv(\"SCRIPT_NAME\");
\t\t\$ap=realpath(\$lp);
\t\t\$ap=str_replace(\"\\\\\",\"/\",\$ap);
\t\t\$docroot=substr(\$ap,0,strpos(\$ap,\$lp));
\t\t// WriteHTML parses all paths to full URLs; may be local file name
\t\tif (\$tr['scheme'] && \$tr['host'] && \$_SERVER[\"DOCUMENT_ROOT\"] ) {
\t\t\t\$localpath = \$_SERVER[\"DOCUMENT_ROOT\"] . \$tr['path'];
\t\t}
\t\t// DOCUMENT_ROOT is not returned on IIS
\t\telse if (\$docroot) {
\t\t\t\$localpath = \$docroot . \$tr['path'];
\t\t}
\t\telse { \$localpath = \$path; }
\t\t\$contents = @file_get_contents(\$localpath);
\t}
\t// if not use full URL
\telse if (!\$contents && !ini_get('allow_url_fopen') && function_exists(\"curl_init\"))  {
\t\t\$ch = curl_init(\$path);
\t\tcurl_setopt(\$ch, CURLOPT_HEADER, 0);
\t\tcurl_setopt ( \$ch , CURLOPT_RETURNTRANSFER , 1 );
\t\t\$contents = curl_exec(\$ch);
\t\tcurl_close(\$ch);
\t}
\treturn \$contents;
}


function docPageNum(\$num = 0, \$extras = false) {
\tif (\$num < 1) { \$num = \$this->page; }
\t\$type = '1';\t// set default decimal
\t\$ppgno = \$num;
\t\$suppress = 0;
\t\$offset = 0;
\t\$lastreset = 0;
\tforeach(\$this->PageNumSubstitutions AS \$psarr) {
\t\tif (\$num >= \$psarr['from']) {
\t\t\tif (\$psarr['reset']) {
\t\t\t\tif (\$psarr['reset']>1) { \$offset = \$psarr['reset']-1; }
\t\t\t\t\$ppgno = \$num - \$psarr['from'] + 1 + \$offset;
\t\t\t\t\$lastreset = \$psarr['from'];
\t\t\t}
\t\t\tif (\$psarr['type']) { \$type = \$psarr['type']; }
\t\t\tif (strtoupper(\$psarr['suppress'])=='ON' || \$psarr['suppress']==1) { \$suppress = 1; }
\t\t\telse if (strtoupper(\$psarr['suppress'])=='OFF') { \$suppress = 0; }
\t\t}
\t}
\tif (\$suppress) { return ''; }

\tforeach(\$this->pgsIns AS \$k=>\$v) {
\t\tif (\$k>\$lastreset && \$k<\$num) {
\t\t\t\$ppgno -= \$v;
\t\t}
\t}
\tif (\$type=='A') { \$ppgno = \$this->dec2alpha(\$ppgno,true); }
\telse if (\$type=='a') { \$ppgno = \$this->dec2alpha(\$ppgno,false);}
\telse if (\$type=='I') { \$ppgno = \$this->dec2roman(\$ppgno,true); }
\telse if (\$type=='i') { \$ppgno = \$this->dec2roman(\$ppgno,false); }
\tif (\$extras) { \$ppgno = \$this->pagenumPrefix . \$ppgno . \$this->pagenumSuffix; }
\treturn \$ppgno;
}


function docPageSettings(\$num = 0) {
\t// Returns current type (numberstyle), suppression state for this page number;
\t// reset is only returned if set for this page number
\tif (\$num < 1) { \$num = \$this->page; }
\t\$type = '1';\t// set default decimal
\t\$ppgno = \$num;
\t\$suppress = 0;
\t\$offset = 0;
\t\$reset = '';
\tforeach(\$this->PageNumSubstitutions AS \$psarr) {
\t\tif (\$num >= \$psarr['from']) {
\t\t\tif (\$psarr['reset']) {
\t\t\t\tif (\$psarr['reset']>1) { \$offset = \$psarr['reset']-1; }
\t\t\t\t\$ppgno = \$num - \$psarr['from'] + 1 + \$offset;
\t\t\t}
\t\t\tif (\$psarr['type']) { \$type = \$psarr['type']; }
\t\t\tif (strtoupper(\$psarr['suppress'])=='ON' || \$psarr['suppress']==1) { \$suppress = 1; }
\t\t\telse if (strtoupper(\$psarr['suppress'])=='OFF') { \$suppress = 0; }
\t\t}
\t\tif (\$num == \$psarr['from']) { \$reset = \$psarr['reset']; }
\t}
\tif (\$suppress) { \$suppress = 'on'; }
\telse { \$suppress = 'off'; }
\treturn array(\$type, \$suppress, \$reset);
}

function docPageNumTotal(\$num = 0, \$extras = false) {
\tif (\$num < 1) { \$num = \$this->page; }
\t\$type = '1';\t// set default decimal
\t\$ppgstart = 1;
\t\$ppgend = count(\$this->pages)+1;
\t\$suppress = 0;
\t\$offset = 0;
\tforeach(\$this->PageNumSubstitutions AS \$psarr) {
\t\tif (\$num >= \$psarr['from']) {
\t\t\tif (\$psarr['reset']) {
\t\t\t\tif (\$psarr['reset']>1) { \$offset = \$psarr['reset']-1; }
\t\t\t\t\$ppgstart = \$psarr['from'] + \$offset;
\t\t\t\t\$ppgend = count(\$this->pages)+1 + \$offset;
\t\t\t}
\t\t\tif (\$psarr['type']) { \$type = \$psarr['type']; }
\t\t\tif (strtoupper(\$psarr['suppress'])=='ON' || \$psarr['suppress']==1) { \$suppress = 1; }
\t\t\telse if (strtoupper(\$psarr['suppress'])=='OFF') { \$suppress = 0; }
\t\t}
\t\tif (\$num < \$psarr['from']) {
\t\t\tif (\$psarr['reset']) {
\t\t\t\t\$ppgend = \$psarr['from'] + \$offset;
\t\t\t\tbreak;
\t\t\t}
\t\t}
\t}
\tif (\$suppress) { return ''; }
\t\$ppgno = \$ppgend-\$ppgstart+\$offset;

\t// mPDF 5.6.47
\tforeach(\$this->pgsIns AS \$k => \$v) {
\t\tif (\$k>\$ppgstart && \$k<\$ppgend) {
\t\t\t\$ppgno -= \$v;
\t\t}
\t}

\tif (\$extras) { \$ppgno = \$this->nbpgPrefix . \$ppgno . \$this->nbpgSuffix; }
\treturn \$ppgno;
}

function RestartDocTemplate() {
\t\$this->docTemplateStart = \$this->page;
}



//Page header
function Header(\$content='') {

\t\$this->cMarginL = 0;
\t\$this->cMarginR = 0;


/*-- HTMLHEADERS-FOOTERS --*/
  if ((\$this->mirrorMargins && (\$this->page%2==0) && \$this->HTMLHeaderE) || (\$this->mirrorMargins && (\$this->page%2==1) && \$this->HTMLHeader) || (!\$this->mirrorMargins && \$this->HTMLHeader)) {
\t\$this->writeHTMLHeaders();
\treturn;
  }
/*-- END HTMLHEADERS-FOOTERS --*/
  \$this->processingHeader=true;
  \$h = \$this->headerDetails;
  if(count(\$h)) {

\tif (\$this->forcePortraitHeaders && \$this->CurOrientation=='L' && \$this->CurOrientation!=\$this->DefOrientation) {
\t\t\$this->_out(sprintf('q 0 -1 1 0 0 %.3F cm ',(\$this->h*_MPDFK)));
\t\t\$yadj = \$this->w - \$this->h;
\t\t\$headerpgwidth = \$this->h - \$this->orig_lMargin - \$this->orig_rMargin;
\t\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\t\$headerlmargin = \$this->orig_rMargin;
\t\t}
\t\telse {
\t\t\t\$headerlmargin = \$this->orig_lMargin;
\t\t}
\t}
\telse {
\t\t\$yadj = 0;
\t\t\$headerpgwidth = \$this->pgwidth;
\t\t\$headerlmargin = \$this->lMargin;
\t}

\t\$this->y = \$this->margin_header - \$yadj ;
\t\$this->SetTColor(\$this->ConvertColor(0));
    \t\$this->SUP = false;
\t\$this->SUB = false;
\t\$this->bullet = false;

\t// only show pagenumber if numbering on
\t\$pgno = \$this->docPageNum(\$this->page, true);

\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\t\$side = 'even';
\t}
\telse {\t// ODD\t// OR NOT MIRRORING MARGINS/FOOTERS = DEFAULT
\t\t\t\$side = 'odd';
\t}
\t\$maxfontheight = 0;
\tforeach(array('L','C','R') AS \$pos) {
\t  if (isset(\$h[\$side][\$pos]['content']) && \$h[\$side][\$pos]['content']) {
\t\tif (isset(\$h[\$side][\$pos]['font-size']) && \$h[\$side][\$pos]['font-size']) { \$hfsz = \$h[\$side][\$pos]['font-size']; }
\t\telse { \$hfsz = \$this->default_font_size; }
\t\t\$maxfontheight = max(\$maxfontheight,\$hfsz);
\t  }
\t}
\t// LEFT-CENTER-RIGHT
\tforeach(array('L','C','R') AS \$pos) {
\t  if (isset(\$h[\$side][\$pos]['content']) && \$h[\$side][\$pos]['content']) {
\t\t\$hd = str_replace('{PAGENO}',\$pgno,\$h[\$side][\$pos]['content']);
\t\t\$hd = str_replace(\$this->aliasNbPgGp,\$this->nbpgPrefix.\$this->aliasNbPgGp.\$this->nbpgSuffix,\$hd);
\t\t\$hd = preg_replace_callback('/\\{DATE\\s+(.*?)\\}/', array(\$this, 'date_callback') ,\$hd);\t// mPDF 5.7
\t\tif (isset(\$h[\$side][\$pos]['font-family']) && \$h[\$side][\$pos]['font-family']) { \$hff = \$h[\$side][\$pos]['font-family']; }
\t\telse { \$hff = \$this->original_default_font; }
\t\tif (isset(\$h[\$side][\$pos]['font-size']) && \$h[\$side][\$pos]['font-size']) { \$hfsz = \$h[\$side][\$pos]['font-size']; }
\t\telse { \$hfsz = \$this->original_default_font_size; }\t// pts
\t\t\$maxfontheight = max(\$maxfontheight,\$hfsz);
\t\t\$hfst = '';
\t\tif (isset(\$h[\$side][\$pos]['font-style']) && \$h[\$side][\$pos]['font-style']) {
\t\t\t\$hfst = \$h[\$side][\$pos]['font-style'];
\t\t}
\t\tif (isset(\$h[\$side][\$pos]['color']) && \$h[\$side][\$pos]['color']) {
\t\t\t\$hfcol = \$h[\$side][\$pos]['color'];
\t\t\t\$cor = \$this->ConvertColor(\$hfcol);
\t\t\tif (\$cor) { \$this->SetTColor(\$cor); }
\t\t}
\t\telse { \$hfcol = ''; }
\t\t\$this->SetFont(\$hff,\$hfst,\$hfsz,true,true);
\t\t\$this->x = \$headerlmargin ;
\t\t\$this->y = \$this->margin_header - \$yadj ;

\t\t\$hd = \$this->purify_utf8_text(\$hd);
\t\tif (\$this->text_input_as_HTML) {
\t\t\t\$hd = \$this->all_entities_to_utf8(\$hd);
\t\t}
\t\t// CONVERT CODEPAGE
\t\tif (\$this->usingCoreFont) { \$hd = mb_convert_encoding(\$hd,\$this->mb_enc,'UTF-8'); }
\t\t// DIRECTIONALITY RTL
\t\t\$this->magic_reverse_dir(\$hd, true, \$this->directionality);\t// *RTL*
\t\t// Font-specific ligature substitution for Indic fonts
\t\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) \$this->ConvertIndic(\$hd);\t// *INDIC*
\t\t\$align = \$pos;
/*-- RTL --*/
\t\tif (\$this->directionality == 'rtl') {
\t\t\tif (\$pos == 'L') { \$align = 'R'; }
\t\t\telse if (\$pos == 'R') { \$align = 'L'; }
\t\t}
/*-- END RTL --*/
\t\tif (\$pos!='L' && (strpos(\$hd,\$this->aliasNbPg)!==false || strpos(\$hd,\$this->aliasNbPgGp)!==false)) {
\t\t\tif (strpos(\$hd,\$this->aliasNbPgGp)!==false) { \$type= 'nbpggp'; } else { \$type= 'nbpg'; }
\t\t\t\$this->_out('{mpdfheader'.\$type.' '.\$pos.' ff='.\$hff.' fs='.\$hfst.' fz='.\$hfsz.'}');
\t\t\t\$this->Cell(\$headerpgwidth ,\$maxfontheight/_MPDFK ,\$hd,0,0,\$align,0,'',0,0,0,'M');
\t\t\t\$this->_out('Q');
\t\t}
\t\telse {
\t\t\t\$this->Cell(\$headerpgwidth ,\$maxfontheight/_MPDFK ,\$hd,0,0,\$align,0,'',0,0,0,'M');
\t\t}
\t\tif (\$hfcol) { \$this->SetTColor(\$this->ConvertColor(0)); }
\t  }
\t}
\t//Return Font to normal
\t\$this->SetFont(\$this->default_font,'',\$this->original_default_font_size);
\t// LINE
\tif (isset(\$h[\$side]['line']) && \$h[\$side]['line']) {
\t\t\$this->SetLineWidth(0.1);
\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\$this->Line(\$headerlmargin , \$this->margin_header + (\$maxfontheight*(1+\$this->header_line_spacing)/_MPDFK) - \$yadj , \$headerlmargin + \$headerpgwidth, \$this->margin_header + (\$maxfontheight*(1+\$this->header_line_spacing)/_MPDFK) - \$yadj  );
\t}
\tif (\$this->forcePortraitHeaders && \$this->CurOrientation=='L' && \$this->CurOrientation!=\$this->DefOrientation) {
\t\t\$this->_out('Q');
\t}
  }
  \$this->SetY(\$this->tMargin);
  if (\$this->ColActive) { \$this->pgwidth = \$this->ColWidth; }\t// *COLUMNS*

  \$this->processingHeader=false;
}



/*-- TABLES --*/
function TableHeaderFooter(\$content='',\$tablestartpage='',\$tablestartcolumn ='',\$horf = 'H',\$level, \$firstSpread=true, \$finalSpread=true) {
  if((\$horf=='H' || \$horf=='F') && !empty(\$content)) {\t// mPDF 5.7.2
\t\$table = &\$this->table[1][1];

\t// mPDF 5.7.2
\tif (\$horf=='F') { // Table Footer
\t\t\$firstrow = count(\$table['cells']) - \$table['footernrows'];
\t\t\$lastrow = count(\$table['cells']) - 1;
\t}
   \telse { \t// Table Header
\t\t\$firstrow = 0;
\t\t\$lastrow = \$table['headernrows'] - 1;
\t}
\tif(empty(\$content[\$firstrow])) {
\t\tif (\$this->debug) { \$this->Error(\"&lt;tfoot&gt; must precede &lt;tbody&gt; in a table\"); }
\t\telse { return; }
\t}

\t// Advance down page by half width of top border
\tif (\$horf=='H') { // Only if header
\t\tif (\$table['borders_separate']) { \$adv = \$table['border_spacing_V']/2 + \$table['border_details']['T']['w'] + \$table['padding']['T'];  }
\t\telse { \$adv = \$table['max_cell_border_width']['T'] /2 ; }
\t\tif (\$adv) {
\t\t   if (\$this->table_rotate) {
\t\t\t\$this->y += (\$adv);
\t\t   }
\t\t   else {
\t\t\t\$this->DivLn(\$adv,\$this->blklvl,true);
\t\t   }
\t\t}
\t}


   \$topy = \$content[\$firstrow][0]['y']-\$this->y;

   for (\$i=\$firstrow ; \$i<=\$lastrow; \$i++) {

    \$y = \$this->y;

/*-- COLUMNS --*/
\t// If outside columns, this is done in PaintDivBB
\tif (\$this->ColActive) {
\t//OUTER FILL BGCOLOR of DIVS
\t if (\$this->blklvl > 0) {
\t  \$firstblockfill = \$this->GetFirstBlockFill();
\t  if (\$firstblockfill && \$this->blklvl >= \$firstblockfill) {
\t\t\$divh = \$content[\$i][0]['h'];
\t\t\$bak_x = \$this->x;
\t\t\$this->DivLn(\$divh,-3,false);
\t\t// Reset current block fill
\t\t\$bcor = \$this->blk[\$this->blklvl]['bgcolorarray'];
\t\t\$this->SetFColor(\$bcor);
\t\t\$this->x = \$bak_x;
\t  }
\t }
\t}
/*-- END COLUMNS --*/

    \$colctr = 0;
    foreach(\$content[\$i] as \$tablehf) {
\t\$colctr++;
\t\$y = \$tablehf['y'] - \$topy;
      \$this->y = \$y;
      //Set some cell values
      \$x = \$tablehf['x'];
\tif ((\$this->mirrorMargins) && (\$tablestartpage == 'ODD') && ((\$this->page)%2==0)) {\t// EVEN
\t\t\$x = \$x +\$this->MarginCorrection;
\t}
\telse if ((\$this->mirrorMargins) && (\$tablestartpage == 'EVEN') && ((\$this->page)%2==1)) {\t// ODD
\t\t\$x = \$x +\$this->MarginCorrection;
\t}
/*-- COLUMNS --*/
\t// Added to correct for Columns
\tif (\$this->ColActive) {
\t   if (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\$x -= (\$this->CurrCol - \$tablestartcolumn) * (\$this->ColWidth+\$this->ColGap);\t// *RTL*
\t   }\t// *RTL*
\t   else {\t// *RTL*
\t\t\$x += (\$this->CurrCol - \$tablestartcolumn) * (\$this->ColWidth+\$this->ColGap);
\t   }\t// *RTL*
\t}
/*-- END COLUMNS --*/

\tif (\$colctr==1) { \$x0 = \$x; }

\t// mPDF ITERATION
\tif (\$this->iterationCounter) {
\t   foreach(\$tablehf['textbuffer'] AS \$k=>\$t) {
\t\tif (!is_array(\$t[0]) && preg_match('/{iteration ([a-zA-Z0-9_]+)}/',\$t[0], \$m)) {\t// mPDF 5.5.06
\t\t\t\$vname = '__'.\$m[1].'_';
\t\t\tif (!isset(\$this->\$vname)) { \$this->\$vname = 1; }
\t\t\telse { \$this->\$vname++; }
\t\t\t\$tablehf['textbuffer'][\$k][0] = preg_replace('/{iteration '.\$m[1].'}/', \$this->\$vname, \$tablehf['textbuffer'][\$k][0]);
\t\t}
\t   }
\t}


      \$w = \$tablehf['w'];
      \$h = \$tablehf['h'];
      \$va = \$tablehf['va'];
      \$R = \$tablehf['R'];
      \$mih = \$tablehf['mih'];
      \$border = \$tablehf['border'];
      \$border_details = \$tablehf['border_details'];
      \$padding = \$tablehf['padding'];
\t\$this->tabletheadjustfinished = true;

      \$textbuffer = \$tablehf['textbuffer'];

      \$align = \$tablehf['a'];
      //Align
      \$this->divalign=\$align;
\t\$this->x = \$x;

\tif (\$this->ColActive) {
\t\tif (\$table['borders_separate']) {
\t\t \$tablefill = isset(\$table['bgcolor'][-1]) ? \$table['bgcolor'][-1] : 0;
\t\t if (\$tablefill) {
  \t\t\t\t\$color = \$this->ConvertColor(\$tablefill);
  \t\t\t\tif (\$color) {
\t\t\t\t\t\$xadj = (\$table['border_spacing_H']/2);
\t\t\t\t\t\$yadj = (\$table['border_spacing_V']/2);
\t\t\t\t\t\$wadj = \$table['border_spacing_H'];
\t\t\t\t\t\$hadj = \$table['border_spacing_V'];
 \t\t\t   \t\tif (\$i == \$firstrow && \$horf=='H') {\t\t// Top
\t\t\t\t\t\t\$yadj += \$table['padding']['T'] + \$table['border_details']['T']['w'] ;
\t\t\t\t\t\t\$hadj += \$table['padding']['T'] + \$table['border_details']['T']['w'] ;
\t\t\t   \t\t}
\t\t\t   \t\tif ((\$i == (\$lastrow) || (isset(\$tablehf['rowspan']) && (\$i+\$tablehf['rowspan']) == (\$lastrow+1))  || (!isset(\$tablehf['rowspan']) && (\$i+1) == (\$lastrow+1))) && \$horf=='F') {\t// Bottom
\t\t\t\t\t\t\$hadj += \$table['padding']['B'] + \$table['border_details']['B']['w'] ;
\t\t\t   \t\t}
\t\t\t   \t\tif (\$colctr == 1) {\t\t// Left
\t\t\t\t\t\t\$xadj += \$table['padding']['L'] + \$table['border_details']['L']['w'] ;
\t\t\t\t\t\t\$wadj += \$table['padding']['L'] + \$table['border_details']['L']['w'] ;
\t\t\t   \t\t}
\t\t\t   \t\tif (\$colctr == count(\$content[\$i]) ) {\t// Right
\t\t\t\t\t\t\$wadj += \$table['padding']['R'] + \$table['border_details']['R']['w'] ;
\t\t\t   \t\t}
\t\t\t\t\t\$this->SetFColor(\$color);
\t\t\t\t\t\$this->Rect(\$x - \$xadj, \$y - \$yadj, \$w + \$wadj, \$h + \$hadj, 'F');
\t\t\t\t}
\t\t }
\t\t}
\t}

\tif (\$table['empty_cells']!='hide' || !empty(\$textbuffer) || !\$table['borders_separate']) { \$paintcell = true; }
\telse { \$paintcell = false; }

\t//Vertical align
\tif (\$R && INTVAL(\$R) > 0 && isset(\$va) && \$va!='B') { \$va='B';}

\tif (!isset(\$va) || empty(\$va) || \$va=='M') \$this->y += (\$h-\$mih)/2;
      elseif (isset(\$va) && \$va=='B') \$this->y += \$h-\$mih;


\t//TABLE ROW OR CELL FILL BGCOLOR
\t\$fill = 0;
\tif (isset(\$tablehf['bgcolor']) && \$tablehf['bgcolor'] && \$tablehf['bgcolor']!='transparent') {
\t\t\$fill = \$tablehf['bgcolor'];
\t\t\$leveladj = 6;
\t}
\telse if (isset(\$content[\$i][0]['trbgcolor']) && \$content[\$i][0]['trbgcolor'] && \$content[\$i][0]['trbgcolor']!='transparent') { // Row color
\t\t\$fill = \$content[\$i][0]['trbgcolor'];
\t\t\$leveladj = 3;
\t}
\tif (\$fill && \$paintcell) {
  \t\t\$color = \$this->ConvertColor(\$fill);
  \t\tif (\$color) {
 \t\t\tif (\$table['borders_separate']) {
\t\t\t   if (\$this->ColActive) {
\t\t\t\t\$this->SetFColor(\$color);
\t\t\t\t\$this->Rect(\$x+ (\$table['border_spacing_H']/2), \$y+ (\$table['border_spacing_V']/2), \$w- \$table['border_spacing_H'], \$h- \$table['border_spacing_V'], 'F');
\t\t\t   }
\t\t\t   else {
\t\t\t\t\$this->tableBackgrounds[\$level*9+\$leveladj][] = array('gradient'=>false, 'x'=>(\$x + (\$table['border_spacing_H']/2)), 'y'=>(\$y + (\$table['border_spacing_V']/2)), 'w'=>(\$w - \$table['border_spacing_H']), 'h'=>(\$h - \$table['border_spacing_V']), 'col'=>\$color);
\t\t\t   }
\t\t\t}
 \t\t\telse {
\t\t\t   if (\$this->ColActive) {
\t\t\t\t\$this->SetFColor(\$color);
\t\t\t\t\$this->Rect(\$x, \$y, \$w, \$h, 'F');
\t\t\t   }
\t\t\t   else {
\t\t\t\t\$this->tableBackgrounds[\$level*9+\$leveladj][] = array('gradient'=>false, 'x'=>\$x, 'y'=>\$y, 'w'=>\$w, 'h'=>\$h, 'col'=>\$color);
\t\t\t   }
\t\t\t}
\t\t}
\t}


/*-- BACKGROUNDS --*/
\tif (isset(\$tablehf['gradient']) && \$tablehf['gradient'] && \$paintcell){
\t\t\$g = \$this->grad->parseBackgroundGradient(\$tablehf['gradient']);
\t\tif (\$g) {
 \t\t  if (\$table['borders_separate']) {
 \t\t\t\$px = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\$py = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\$pw = \$w- \$table['border_spacing_H'];
\t\t\t\$ph = \$h- \$table['border_spacing_V'];
\t\t  }
\t\t  else {
\t\t\t\$px = \$x;
\t\t\t\$py = \$y;
\t\t\t\$pw = \$w;
\t\t\t\$ph = \$h;
\t\t  }
\t\t  if (\$this->ColActive) {
\t\t\t\$this->grad->Gradient(\$px, \$py, \$pw, \$ph, \$g['type'], \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend']);
\t\t  }
\t\t  else {
\t\t\t\$this->tableBackgrounds[\$level*9+7][] = array('gradient'=>true, 'x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t  }
\t\t}
\t}

\tif (isset(\$tablehf['background-image']) && \$paintcell){
\t  if (\$tablehf['background-image']['gradient'] && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$tablehf['background-image']['gradient'] )) {
\t\t\$g = \$this->grad->parseMozGradient( \$tablehf['background-image']['gradient'] );
\t\tif (\$g) {
 \t\t  if (\$table['borders_separate']) {
 \t\t\t\$px = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\$py = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\$pw = \$w- \$table['border_spacing_H'];
\t\t\t\$ph = \$h- \$table['border_spacing_V'];
\t\t  }
\t\t  else {
\t\t\t\$px = \$x;
\t\t\t\$py = \$y;
\t\t\t\$pw = \$w;
\t\t\t\$ph = \$h;
\t\t  }
\t\t  if (\$this->ColActive) {
\t\t\t\$this->grad->Gradient(\$px, \$py, \$pw, \$ph, \$g['type'], \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend']);
\t\t  }
\t\t  else {
\t\t\t\$this->tableBackgrounds[\$level*9+7][] = array('gradient'=>true, 'x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t  }
\t\t}
\t  }
\t  else if (\$tablehf['background-image']['image_id']) {\t// Background pattern
\t\t\$n = count(\$this->patterns)+1;
 \t\tif (\$table['borders_separate']) {
 \t\t\t\$px = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\$py = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\$pw = \$w- \$table['border_spacing_H'];
\t\t\t\$ph = \$h- \$table['border_spacing_V'];
\t\t}
\t\telse {
\t\t\t\$px = \$x;
\t\t\t\$py = \$y;
\t\t\t\$pw = \$w;
\t\t\t\$ph = \$h;
\t\t}
\t\tif (\$this->ColActive) {
\t\t\tlist(\$orig_w, \$orig_h, \$x_repeat, \$y_repeat) = \$this->_resizeBackgroundImage(\$tablehf['background-image']['orig_w'], \$tablehf['background-image']['orig_h'], \$pw, \$ph, \$tablehf['background-image']['resize'], \$tablehf['background-image']['x_repeat'] , \$tablehf['background-image']['y_repeat']);
\t\t\t\$this->patterns[\$n] = array('x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'pgh'=>\$this->h, 'image_id'=>\$tablehf['background-image']['image_id'], 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$tablehf['background-image']['x_pos'] , 'y_pos'=>\$tablehf['background-image']['y_pos'] , 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'itype'=>\$tablehf['background-image']['itype']);
\t\t\tif (\$tablehf['background-image']['opacity']>0 && \$tablehf['background-image']['opacity']<1) { \$opac = \$this->SetAlpha(\$tablehf['background-image']['opacity'],'Normal',true); }
\t\t\telse { \$opac = ''; }
\t\t\t\$this->_out(sprintf('q /Pattern cs /P%d scn %s %.3F %.3F %.3F %.3F re f Q', \$n, \$opac, \$px*_MPDFK, (\$this->h-\$py)*_MPDFK, \$pw*_MPDFK, -\$ph*_MPDFK));
\t\t}
\t\telse {
\t\t\t\$this->tableBackgrounds[\$level*9+8][] = array('x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'image_id'=>\$tablehf['background-image']['image_id'], 'orig_w'=>\$tablehf['background-image']['orig_w'], 'orig_h'=>\$tablehf['background-image']['orig_h'], 'x_pos'=>\$tablehf['background-image']['x_pos'], 'y_pos'=>\$tablehf['background-image']['y_pos'], 'x_repeat'=>\$tablehf['background-image']['x_repeat'], 'y_repeat'=>\$tablehf['background-image']['y_repeat'], 'clippath'=>'', 'resize'=>\$tablehf['background-image']['resize'], 'opacity'=>\$tablehf['background-image']['opacity'], 'itype'=>\$tablehf['background-image']['itype']);
\t\t}
\t  }
\t}
/*-- END BACKGROUNDS --*/

   \t//Cell Border
 \tif (\$table['borders_separate'] && \$paintcell && \$border) {
 \t\t\$this->_tableRect(\$x+ (\$table['border_spacing_H']/2)+(\$border_details['L']['w'] /2), \$y+ (\$table['border_spacing_V']/2)+(\$border_details['T']['w'] /2), \$w-\$table['border_spacing_H']-(\$border_details['L']['w'] /2)-(\$border_details['R']['w'] /2), \$h- \$table['border_spacing_V']-(\$border_details['T']['w'] /2)-(\$border_details['B']['w']/2), \$border, \$border_details, false, \$table['borders_separate']);
\t}
 \telse if (\$paintcell && \$border) {
\t\t\$this->_tableRect(\$x, \$y, \$w, \$h, \$border, \$border_details, true, \$table['borders_separate']);  \t// true causes buffer
\t}

 \t//Print cell content
      //\$this->divheight = \$this->table_lineheight*\$this->lineheight;
      if (!empty(\$textbuffer)) {
\t\tif (\$horf=='F' && preg_match('/{colsum([0-9]*)[_]*}/', \$textbuffer[0][0], \$m)) {
\t\t\t\$rep = sprintf(\"%01.\".intval(\$m[1]).\"f\", \$this->colsums[\$colctr-1]);
\t\t\t\$textbuffer[0][0] = preg_replace('/{colsum[0-9_]*}/', \$rep ,\$textbuffer[0][0]);
\t\t}

\t\tif (\$R) {
\t\t\t\t\t\$cellPtSize = \$textbuffer[0][11] / \$this->shrin_k;
\t\t\t\t\tif (!\$cellPtSize) { \$cellPtSize = \$this->default_font_size; }
\t\t\t\t\t\$cellFontHeight = (\$cellPtSize/_MPDFK);
\t\t\t\t\t\$opx = \$this->x;
\t\t\t\t\t\$opy = \$this->y;
\t\t\t\t\t\$angle = INTVAL(\$R);
\t\t\t\t\t// Only allow 45 - 90 degrees (when bottom-aligned) or -90
\t\t\t\t\tif (\$angle > 90) { \$angle = 90; }
\t\t\t\t\telse if (\$angle > 0 && (isset(\$va) && \$va!='B')) { \$angle = 90; }
\t\t\t\t\telse if (\$angle > 0 && \$angle <45) { \$angle = 45; }
\t\t\t\t\telse if (\$angle < 0) { \$angle = -90; }
\t\t\t\t\t\$offset = ((sin(deg2rad(\$angle))) * 0.37 * \$cellFontHeight);
\t\t\t\t\tif (isset(\$align) && \$align =='R') {
\t\t\t\t\t\t\$this->x += (\$w) + (\$offset) - (\$cellFontHeight/3) - (\$padding['R'] + \$border_details['R']['w']);
\t\t\t\t\t}
\t\t\t\t\telse if (!isset(\$align ) || \$align =='C') {
\t\t\t\t\t\t\$this->x += (\$w/2) + (\$offset);
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$this->x += (\$offset) + (\$cellFontHeight/3)+(\$padding['L'] + \$border_details['L']['w']);
\t\t\t\t\t}
\t\t\t\t\t\$str = '';
\t\t\t\t\tforeach(\$tablehf['textbuffer'] AS \$t) { \$str .= \$t[0].' '; }
\t\t\t\t\t\$str = trim(\$str);

\t\t\t\t\tif (!isset(\$va) || \$va=='M') {
\t\t\t\t\t\t\$this->y -= (\$h-\$mih)/2; //Undo what was added earlier VERTICAL ALIGN
\t\t\t\t\t\tif (\$angle > 0) { \$this->y += ((\$h-\$mih)/2)+(\$padding['T'] + \$border_details['T']['w']) + (\$mih-(\$padding['T'] + \$border_details['T']['w']+\$border_details['B']['w']+\$padding['B'])); }
\t\t\t\t\t\telse if (\$angle < 0) { \$this->y += ((\$h-\$mih)/2)+(\$padding['T'] + \$border_details['T']['w']); }
\t\t\t\t\t}
\t\t\t\t\telse if (isset(\$va) && \$va=='B') {
\t\t\t\t\t\t\$this->y -= \$h-\$mih; //Undo what was added earlier VERTICAL ALIGN
\t\t\t\t\t\tif (\$angle > 0) { \$this->y += \$h-(\$border_details['B']['w']+\$padding['B']); }
\t\t\t\t\t\telse if (\$angle < 0) { \$this->y += \$h-\$mih+(\$padding['T'] + \$border_details['T']['w']); }
\t\t\t\t\t}
\t\t\t\t\telse if (isset(\$va) && \$va=='T') {
\t\t\t\t\t\tif (\$angle > 0) { \$this->y += \$mih-(\$border_details['B']['w']+\$padding['B']); }
\t\t\t\t\t\telse if (\$angle < 0) { \$this->y += (\$padding['T'] + \$border_details['T']['w']); }
\t\t\t\t\t}

\t\t\t\t\t\$this->Rotate(\$angle,\$this->x,\$this->y);
\t\t\t\t\t\$s_fs = \$this->FontSizePt;
\t\t\t\t\t\$s_f = \$this->FontFamily;
\t\t\t\t\t\$s_st = \$this->FontStyle;
\t\t\t\t\tif (!empty(\$textbuffer[0][3])) { //Font Color
\t\t\t\t\t\t\$cor = \$textbuffer[0][3];
\t\t\t\t\t\t\$this->SetTColor(\$cor);
\t\t\t\t\t}
\t\t\t\t\t\$s_str = \$this->strike;
\t\t\t\t\t\$this->strike = \$textbuffer[0][8]; //Strikethrough
\t\t\t\t\t\$this->SetFont(\$textbuffer[0][4],\$textbuffer[0][2],\$cellPtSize,true,true);
\t\t\t\t\t\$this->Text(\$this->x,\$this->y,\$str);
\t\t\t\t\t\$this->Rotate(0);
\t\t\t\t\t\$this->SetFont(\$s_f,\$s_st,\$s_fs,true,true);
\t\t\t\t\t\$this->SetTColor(0);
\t\t\t\t\t\$this->strike = \$s_str;
\t\t\t\t\t\$this->x = \$opx;
\t\t\t\t\t\$this->y = \$opy;
\t\t}
\t\telse {
\t\t\tif (\$table['borders_separate']) {\t// NB twice border width
\t\t\t\t\$xadj = \$border_details['L']['w'] + \$padding['L'] +(\$table['border_spacing_H']/2);
\t\t\t\t\$wadj = \$border_details['L']['w'] + \$border_details['R']['w'] + \$padding['L'] +\$padding['R'] + \$table['border_spacing_H'];
\t\t\t\t\$yadj = \$border_details['T']['w'] + \$padding['T'] + (\$table['border_spacing_H']/2);
\t\t\t}
\t\t\telse {
\t\t\t\t\$xadj = \$border_details['L']['w']/2 + \$padding['L'];
\t\t\t\t\$wadj = (\$border_details['L']['w'] + \$border_details['R']['w'])/2 + \$padding['L'] + \$padding['R'];
\t\t\t\t\$yadj = \$border_details['T']['w']/2 + \$padding['T'];
\t\t\t}

\t\t\t\$this->divwidth=\$w-(\$wadj);
\t\t\t\$this->x += \$xadj;
\t\t\t\$this->y += \$yadj;
\t\t\t\$this->printbuffer(\$textbuffer,'',true);
\t\t}

\t}
      \$textbuffer = array();

/*-- BACKGROUNDS --*/
\t\t\tif (!\$this->ColActive) {
\t  \t\t  if (isset(\$content[\$i][0]['trgradients']) && (\$colctr==1 || \$table['borders_separate'])) {
\t\t\t\t\$g = \$this->grad->parseBackgroundGradient(\$content[\$i][0]['trgradients']);
\t\t\t\tif (\$g) {
\t\t\t\t\t\$gx = \$x0;
\t\t\t\t\t\$gy = \$y;
\t\t\t\t\t\$gh = \$h;
\t\t\t\t\t\$gw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\t\$gw -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['padding']['R'] + \$table['border_details']['R']['w'] + \$table['border_spacing_H']);
\t\t\t\t\t\t\$s = '';
 \t\t\t\t\t\t\$clx = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\t\$cly = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\t\$clw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\t\$clh = \$h- \$table['border_spacing_V'];
\t\t\t\t\t\t// Set clipping path
\t\t\t\t\t\t\$s = ' q 0 w ';\t// Line width=0
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F m ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// start point TL before the arc
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BL
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TL
\t\t\t\t\t\t\$s .= ' W n ';\t// Ends path no-op & Sets the clipping path
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx + (\$table['border_spacing_H']/2), 'y'=>\$gy + (\$table['border_spacing_V']/2), 'w'=>\$gw - \$table['border_spacing_V'], 'h'=>\$gh - \$table['border_spacing_H'], 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>\$s);
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx, 'y'=>\$gy, 'w'=>\$gw, 'h'=>\$gh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t\t}
\t\t\t\t}
\t\t\t    }

\t\t\t   if (isset(\$content[\$i][0]['trbackground-images']) && (\$colctr==1 || \$table['borders_separate'])) {
\t\t\t    if (\$content[\$i][0]['trbackground-images']['gradient'] && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$content[\$i][0]['trbackground-images']['gradient'] )) {
\t\t\t\t\$g = \$this->grad->parseMozGradient( \$content[\$i][0]['trbackground-images']['gradient'] );
\t\t\t\tif (\$g) {
\t\t\t\t\t\$gx = \$x0;
\t\t\t\t\t\$gy = \$y;
\t\t\t\t\t\$gh = \$h;
\t\t\t\t\t\$gw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\t\$gw -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['padding']['R'] + \$table['border_details']['R']['w'] + \$table['border_spacing_H']);
\t\t\t\t\t\t\$s = '';
 \t\t\t\t\t\t\$clx = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\t\$cly = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\t\$clw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\t\$clh = \$h- \$table['border_spacing_V'];
\t\t\t\t\t\t// Set clipping path
\t\t\t\t\t\t\$s = ' q 0 w ';\t// Line width=0
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F m ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// start point TL before the arc
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BL
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TL
\t\t\t\t\t\t\$s .= ' W n ';\t// Ends path no-op & Sets the clipping path
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx + (\$table['border_spacing_H']/2), 'y'=>\$gy + (\$table['border_spacing_V']/2), 'w'=>\$gw - \$table['border_spacing_V'], 'h'=>\$gh - \$table['border_spacing_H'], 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>\$s);
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx, 'y'=>\$gy, 'w'=>\$gw, 'h'=>\$gh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t\t}
\t\t\t\t}
\t\t\t    }
\t\t\t    else {
\t\t\t\t\$image_id = \$content[\$i][0]['trbackground-images']['image_id'];
\t\t\t\t\$orig_w = \$content[\$i][0]['trbackground-images']['orig_w'];
\t\t\t\t\$orig_h = \$content[\$i][0]['trbackground-images']['orig_h'];
\t\t\t\t\$x_pos = \$content[\$i][0]['trbackground-images']['x_pos'];
\t\t\t\t\$y_pos = \$content[\$i][0]['trbackground-images']['y_pos'];
\t\t\t\t\$x_repeat = \$content[\$i][0]['trbackground-images']['x_repeat'];
\t\t\t\t\$y_repeat = \$content[\$i][0]['trbackground-images']['y_repeat'];
\t\t\t\t\$resize = \$content[\$i][0]['trbackground-images']['resize'];
\t\t\t\t\$opacity = \$content[\$i][0]['trbackground-images']['opacity'];
\t\t\t\t\$itype = \$content[\$i][0]['trbackground-images']['itype'];

\t\t\t\t\$clippath = '';
\t\t\t\t\$gx = \$x0;
\t\t\t\t\$gy = \$y;
\t\t\t\t\$gh = \$h;
\t\t\t\t\$gw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\$gw -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['padding']['R'] + \$table['border_details']['R']['w'] + \$table['border_spacing_H']);
\t\t\t\t\t\$s = '';
 \t\t\t\t\t\$clx = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\$cly = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\$clw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\$clh = \$h- \$table['border_spacing_V'];
\t\t\t\t\t// Set clipping path
\t\t\t\t\t\$s = ' q 0 w ';\t// Line width=0
\t\t\t\t\t\$s .= sprintf('%.3F %.3F m ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// start point TL before the arc
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BL
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BR
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TR
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TL
\t\t\t\t\t\$s .= ' W n ';\t// Ends path no-op & Sets the clipping path
\t\t\t\t\t\$this->tableBackgrounds[\$level*9+5][] = array('x'=>\$gx + (\$table['border_spacing_H']/2), 'y'=>\$gy + (\$table['border_spacing_V']/2), 'w'=>\$gw - \$table['border_spacing_V'], 'h'=>\$gh - \$table['border_spacing_H'], 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>\$s, 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$this->tableBackgrounds[\$level*9+5][] = array('x'=>\$gx, 'y'=>\$gy, 'w'=>\$gw, 'h'=>\$gh, 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>'', 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype);
\t\t\t\t}
\t\t\t    }
\t\t\t   }
\t\t\t}
/*-- END BACKGROUNDS --*/

\t// TABLE BORDER - if separate OR collapsed and only table border
\tif ((\$table['borders_separate'] || (\$this->simpleTables && !\$table['simple']['border'])) && \$table['border']) {
\t\t\t\$halfspaceL = \$table['padding']['L'] + (\$table['border_spacing_H']/2);
\t\t\t\$halfspaceR = \$table['padding']['R'] + (\$table['border_spacing_H']/2);
\t\t\t\$halfspaceT = \$table['padding']['T'] + (\$table['border_spacing_V']/2);
\t\t\t\$halfspaceB = \$table['padding']['B'] + (\$table['border_spacing_V']/2);
\t\t\t\$tbx = \$x;
\t\t\t\$tby = \$y;
\t\t\t\$tbw = \$w;
\t\t\t\$tbh = \$h;
\t\t\t\$tab_bord = 0;
\t\t\t\$corner = '';
 \t\t\tif (\$i == \$firstrow && \$horf=='H') {\t\t// Top
\t\t\t\t\$tby -= \$halfspaceT + (\$table['border_details']['T']['w']/2);
\t\t\t\t\$tbh += \$halfspaceT + (\$table['border_details']['T']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_TOP);
\t\t\t\t\$corner .= 'T';
\t\t\t}
\t\t\tif ((\$i == (\$lastrow) || (isset(\$tablehf['rowspan']) && (\$i+\$tablehf['rowspan']) == (\$lastrow+1))) && \$horf=='F') {\t// Bottom
\t\t\t\t\$tbh += \$halfspaceB + (\$table['border_details']['B']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_BOTTOM);
\t\t\t\t\$corner .= 'B';
\t\t\t}
\t\t\tif (\$colctr == 1 && \$firstSpread) {\t// Left
\t\t\t\t\$tbx -= \$halfspaceL + (\$table['border_details']['L']['w']/2);
\t\t\t\t\$tbw += \$halfspaceL + (\$table['border_details']['L']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_LEFT);
\t\t\t\t\$corner .= 'L';
\t\t\t}
\t\t\tif (\$colctr == count(\$content[\$i]) && \$finalSpread) {\t// Right
\t\t\t\t\$tbw += \$halfspaceR + (\$table['border_details']['R']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_RIGHT);
\t\t\t\t\$corner .= 'R';
\t\t\t}
\t\t\t\$this->_tableRect(\$tbx, \$tby, \$tbw, \$tbh, \$tab_bord , \$table['border_details'], false, \$table['borders_separate'], 'table', \$corner, \$table['border_spacing_V'], \$table['border_spacing_H'] );
\t}


     }// end column \$content
     \$this->y = \$y + \$h; //Update y coordinate
   }// end row \$i
   unset(\$table );
   \$this->colsums = array();
  }
}
/*-- END TABLES --*/

/*-- HTMLHEADERS-FOOTERS --*/
function SetHTMLHeader(\$header='',\$OE='',\$write=false) {

\t\$height = 0;
\tif (is_array(\$header) && isset(\$header['html']) && \$header['html']) {
\t\t\$Hhtml = \$header['html'];
\t\tif (\$this->setAutoTopMargin) {
\t\t\tif (isset(\$header['h'])) { \$height = \$header['h']; }
\t\t\telse { \$height = \$this->_gethtmlheight(\$Hhtml); }
\t\t}
\t}
\telse if (!is_array(\$header) && \$header) {
\t\t\$Hhtml = \$header;
\t\tif (\$this->setAutoTopMargin) { \$height = \$this->_gethtmlheight(\$Hhtml); }
\t}
\telse { \$Hhtml = ''; }

\tif (\$OE != 'E') { \$OE = 'O'; }
\tif (\$OE == 'E') {

\t   if (\$Hhtml) {
\t\t\$this->HTMLHeaderE['html'] = \$Hhtml;
\t\t\$this->HTMLHeaderE['h'] = \$height;
\t   }
\t   else { \$this->HTMLHeaderE = ''; }
\t}
\telse {

\t   if (\$Hhtml) {
\t\t\$this->HTMLHeader['html'] = \$Hhtml;
\t\t\$this->HTMLHeader['h'] = \$height;
\t   }
\t   else { \$this->HTMLHeader = ''; }
\t}
\tif (!\$this->mirrorMargins && \$OE == 'E') { return; }
\tif (\$Hhtml=='') { return; }
\tif (\$OE == 'E') {
\t\t\$this->headerDetails['even'] = array();\t// override and clear any other non-HTML header/footer
\t}
\telse {
\t\t\$this->headerDetails['odd'] = array();\t// override and clear any non-HTML other header/footer
\t}

\tif (\$this->setAutoTopMargin=='pad') {
\t\t\$this->tMargin = \$this->margin_header + \$height + \$this->orig_tMargin;
\t\tif (isset(\$this->saveHTMLHeader[\$this->page][\$OE]['mt'])) { \$this->saveHTMLHeader[\$this->page][\$OE]['mt'] = \$this->tMargin; }
\t}
\telse if (\$this->setAutoTopMargin=='stretch') {
\t\t\$this->tMargin = max(\$this->orig_tMargin, \$this->margin_header + \$height + \$this->autoMarginPadding);
\t\tif (isset(\$this->saveHTMLHeader[\$this->page][\$OE]['mt'])) { \$this->saveHTMLHeader[\$this->page][\$OE]['mt'] = \$this->tMargin; }
\t}
\tif (\$write && \$this->state!=0 && ((\$this->mirrorMargins && \$OE == 'E' && (\$this->page)%2==0) || (\$this->mirrorMargins && \$OE != 'E' && (\$this->page)%2==1) || !\$this->mirrorMargins)) { \$this->writeHTMLHeaders(); }
}

function SetHTMLFooter(\$footer='',\$OE='') {

\t\$height = 0;
\tif (is_array(\$footer) && isset(\$footer['html']) && \$footer['html']) {
\t\t\$Fhtml = \$footer['html'];
\t\tif (\$this->setAutoBottomMargin) {
\t\t\tif (isset(\$footer['h'])) { \$height = \$footer['h']; }
\t\t\telse { \$height = \$this->_gethtmlheight(\$Fhtml); }
\t\t}
\t}
\telse if (!is_array(\$footer) && \$footer) {
\t\t\$Fhtml = \$footer;
\t\tif (\$this->setAutoBottomMargin) { \$height = \$this->_gethtmlheight(\$Fhtml); }
\t}
\telse { \$Fhtml = ''; }

\tif (\$OE != 'E') { \$OE = 'O'; }
\tif (\$OE == 'E') {

\t   if (\$Fhtml) {
\t\t\$this->HTMLFooterE['html'] = \$Fhtml;
\t\t\$this->HTMLFooterE['h'] = \$height;
\t   }
\t   else { \$this->HTMLFooterE = ''; }
\t}
\telse {

\t   if (\$Fhtml) {
\t\t\$this->HTMLFooter['html'] = \$Fhtml;
\t\t\$this->HTMLFooter['h'] = \$height;
\t   }
\t   else { \$this->HTMLFooter = ''; }
\t}
\tif (!\$this->mirrorMargins && \$OE == 'E') { return; }
\tif (\$Fhtml=='') { return false; }
\tif (\$OE == 'E') {
\t\t\$this->footerDetails['even'] = array();\t// override and clear any other header/footer
\t}
\telse {
\t\t\$this->footerDetails['odd'] = array();\t// override and clear any other header/footer
\t}

\tif (\$this->setAutoBottomMargin=='pad') {
\t\t\$this->bMargin = \$this->margin_footer + \$height + \$this->orig_bMargin;
\t\t\$this->PageBreakTrigger=\$this->h-\$this->bMargin ;
\t\tif (isset(\$this->saveHTMLHeader[\$this->page][\$OE]['mb'])) { \$this->saveHTMLHeader[\$this->page][\$OE]['mb'] = \$this->bMargin; }
\t}
\telse if (\$this->setAutoBottomMargin=='stretch') {
\t\t\$this->bMargin = max(\$this->orig_bMargin, \$this->margin_footer + \$height + \$this->autoMarginPadding);
\t\t\$this->PageBreakTrigger=\$this->h-\$this->bMargin ;
\t\tif (isset(\$this->saveHTMLHeader[\$this->page][\$OE]['mb'])) { \$this->saveHTMLHeader[\$this->page][\$OE]['mb'] = \$this->bMargin; }
\t}
}


function _getHtmlHeight(\$html) {
\t\t\$save_state = \$this->state;
\t\tif(\$this->state==0) {
\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t}
\t\t\$this->state = 2;
\t\t\$this->Reset();
\t\t\$this->pageoutput[\$this->page] = array();
\t\t\$save_x = \$this->x;
\t\t\$save_y = \$this->y;
\t\t\$this->x = \$this->lMargin;
\t\t\$this->y = \$this->margin_header;
\t\t\$html = str_replace('{PAGENO}',\$this->pagenumPrefix.\$this->docPageNum(\$this->page).\$this->pagenumSuffix,\$html);
\t\t\$html = str_replace(\$this->aliasNbPgGp,\$this->nbpgPrefix.\$this->docPageNumTotal(\$this->page).\$this->nbpgSuffix,\$html );
\t\t\$html = str_replace(\$this->aliasNbPg,\$this->page,\$html );
\t\t\$html = preg_replace_callback('/\\{DATE\\s+(.*?)\\}/', array(\$this, 'date_callback') ,\$html ); // mPDF 5.7
\t\t\$this->HTMLheaderPageLinks = array();
\t\t\$this->HTMLheaderPageAnnots = array();
\t\t\$this->HTMLheaderPageForms = array();
\t\t\$savepb = \$this->pageBackgrounds;
\t\t\$this->writingHTMLheader = true;
\t\t\$this->WriteHTML(\$html , 4);\t// parameter 4 saves output to \$this->headerbuffer
\t\t\$this->writingHTMLheader = false;
\t\t\$h = (\$this->y - \$this->margin_header);
\t\t\$this->Reset();
\t\t// mPDF 5.7.2 - Clear in case Float used in Header/Footer
\t\t\$this->blk[0]['blockContext'] = 0;
\t\t\$this->blk[0]['float_endpos'] = 0;

\t\t\$this->pageoutput[\$this->page] = array();
\t\t\$this->headerbuffer = '';
\t\t\$this->pageBackgrounds = \$savepb;
\t\t\$this->x = \$save_x;
\t\t\$this->y = \$save_y;
\t\t\$this->state = \$save_state;
\t\tif(\$save_state==0) {
\t\t\tunset(\$this->pages[1]);
\t\t\t\$this->page = 0;
\t\t}
\t\treturn \$h;
}


// Called internally from Header
function writeHTMLHeaders() {

\tif (\$this->mirrorMargins && (\$this->page)%2==0) { \$OE = 'E'; }\t// EVEN
\telse { \$OE = 'O'; }
\tif (\$OE == 'E') {
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['html'] = \$this->HTMLHeaderE['html'] ;
\t}
\telse {
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['html'] = \$this->HTMLHeader['html'] ;
\t}
\tif (\$this->forcePortraitHeaders && \$this->CurOrientation=='L' && \$this->CurOrientation!=\$this->DefOrientation) {
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['rotate'] = true;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['ml'] = \$this->tMargin;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['mr'] = \$this->bMargin;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['mh'] = \$this->margin_header;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['mf'] = \$this->margin_footer;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['pw'] = \$this->h;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['ph'] = \$this->w;
\t}
\telse {
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['ml'] = \$this->lMargin;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['mr'] = \$this->rMargin;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['mh'] = \$this->margin_header;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['mf'] = \$this->margin_footer;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['pw'] = \$this->w;
\t\t\$this->saveHTMLHeader[\$this->page][\$OE]['ph'] = \$this->h;
\t}
}

function writeHTMLFooters() {

\tif (\$this->mirrorMargins && (\$this->page)%2==0) { \$OE = 'E'; }\t// EVEN
\telse { \$OE = 'O'; }
\tif (\$OE == 'E') {
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['html'] = \$this->HTMLFooterE['html'] ;
\t}
\telse {
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['html'] = \$this->HTMLFooter['html'] ;
\t}
\tif (\$this->forcePortraitHeaders && \$this->CurOrientation=='L' && \$this->CurOrientation!=\$this->DefOrientation) {
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['rotate'] = true;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['ml'] = \$this->tMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mr'] = \$this->bMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mt'] = \$this->rMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mb'] = \$this->lMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mh'] = \$this->margin_header;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mf'] = \$this->margin_footer;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['pw'] = \$this->h;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['ph'] = \$this->w;
\t}
\telse {
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['ml'] = \$this->lMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mr'] = \$this->rMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mt'] = \$this->tMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mb'] = \$this->bMargin;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mh'] = \$this->margin_header;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['mf'] = \$this->margin_footer;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['pw'] = \$this->w;
\t\t\$this->saveHTMLFooter[\$this->page][\$OE]['ph'] = \$this->h;
\t}
}
/*-- END HTMLHEADERS-FOOTERS --*/

function DefHeaderByName(\$name,\$arr) {
\tif (!\$name) { \$name = '_default'; }
\t\$this->pageheaders[\$name] = \$arr;
}

function DefFooterByName(\$name,\$arr) {
\tif (!\$name) { \$name = '_default'; }
\t\$this->pagefooters[\$name] = \$arr;
}

function SetHeaderByName(\$name,\$side='O',\$write=false) {
\tif (!\$name) { \$name = '_default'; }
\tif (\$side=='E') { \$this->headerDetails['even'] = \$this->pageheaders[\$name]; }
\telse { \$this->headerDetails['odd'] = \$this->pageheaders[\$name]; }
\tif (\$write) { \$this->Header(); }
}

function SetFooterByName(\$name,\$side='O') {
\tif (!\$name) { \$name = '_default'; }
\tif (\$side=='E') { \$this->footerDetails['even'] = \$this->pagefooters[\$name]; }
\telse { \$this->footerDetails['odd'] = \$this->pagefooters[\$name]; }
}

/*-- HTMLHEADERS-FOOTERS --*/
function DefHTMLHeaderByName(\$name,\$html) {
\tif (!\$name) { \$name = '_default'; }

\t\$this->pageHTMLheaders[\$name]['html'] = \$html;
\t\$this->pageHTMLheaders[\$name]['h'] = \$this->_gethtmlheight(\$html);
}

function DefHTMLFooterByName(\$name,\$html) {
\tif (!\$name) { \$name = '_default'; }

\t\$this->pageHTMLfooters[\$name]['html'] = \$html;
\t\$this->pageHTMLfooters[\$name]['h'] = \$this->_gethtmlheight(\$html);
}

function SetHTMLHeaderByName(\$name,\$side='O',\$write=false) {
\tif (!\$name) { \$name = '_default'; }
\t\$this->SetHTMLHeader(\$this->pageHTMLheaders[\$name],\$side,\$write);
}

function SetHTMLFooterByName(\$name,\$side='O') {
\tif (!\$name) { \$name = '_default'; }
\t\$this->SetHTMLFooter(\$this->pageHTMLfooters[\$name],\$side);
}
/*-- END HTMLHEADERS-FOOTERS --*/


function SetHeader(\$Harray=array(),\$side='',\$write=false) {
  if (is_string(\$Harray)) {
    if (strlen(\$Harray)==0) {
\tif (\$side=='O') { \$this->headerDetails['odd'] = array(); }
\telse if (\$side=='E') { \$this->headerDetails['even'] = array(); }
\telse { \$this->headerDetails = array(); }
   }
   else if (strpos(\$Harray,'|') || strpos(\$Harray,'|')===0) {
\t\$hdet = explode('|',\$Harray);
\t\$this->headerDetails = array (
  \t\t'odd' => array (
\t'L' => array ('content' => \$hdet[0], 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'C' => array ('content' => \$hdet[1], 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'R' => array ('content' => \$hdet[2], 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'line' => \$this->defaultheaderline,
  \t\t),
  \t\t'even' => array (
\t'R' => array ('content' => \$hdet[0], 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'C' => array ('content' => \$hdet[1], 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'L' => array ('content' => \$hdet[2], 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'line' => \$this->defaultheaderline,
\t\t)
\t);
    }
    else {
\t\$this->headerDetails = array (
  \t\t'odd' => array (
\t'R' => array ('content' => \$Harray, 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'line' => \$this->defaultheaderline,
  \t\t),
  \t\t'even' => array (
\t'L' => array ('content' => \$Harray, 'font-size' => \$this->defaultheaderfontsize, 'font-style' => \$this->defaultheaderfontstyle),
\t'line' => \$this->defaultheaderline,
\t\t)
\t);
    }
  }
  else if (is_array(\$Harray)) {
\tif (\$side=='O') { \$this->headerDetails['odd'] = \$Harray; }
\telse if (\$side=='E') { \$this->headerDetails['even'] = \$Harray; }
\telse { \$this->headerDetails = \$Harray; }
  }
/*-- HTMLHEADERS-FOOTERS --*/
  // Overwrite any HTML Header previously set
  if (\$side=='E') { \$this->SetHTMLHeader('','E'); }
  else if (\$side=='O') {  \$this->SetHTMLHeader(''); }
  else {
\t\$this->SetHTMLHeader('');
\t\$this->SetHTMLHeader('','E');
  }
/*-- END HTMLHEADERS-FOOTERS --*/

  if (\$write) {
\t\$save_y = \$this->y;
\t\$this->Header();
\t\$this->SetY(\$save_y) ;
  }
}




function SetFooter(\$Farray=array(),\$side='') {
  if (is_string(\$Farray)) {
    if (strlen(\$Farray)==0) {
\tif (\$side=='O') { \$this->footerDetails['odd'] = array(); }
\telse if (\$side=='E') { \$this->footerDetails['even'] = array(); }
\telse { \$this->footerDetails = array(); }
    }
    else if (strpos(\$Farray,'|') || strpos(\$Farray,'|')===0) {
\t\$fdet = explode('|',\$Farray);
\t\$this->footerDetails = array (
\t\t'odd' => array (
\t'L' => array ('content' => \$fdet[0], 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'C' => array ('content' => \$fdet[1], 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'R' => array ('content' => \$fdet[2], 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'line' => \$this->defaultfooterline,
\t\t),
\t\t'even' => array (
\t'R' => array ('content' => \$fdet[0], 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'C' => array ('content' => \$fdet[1], 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'L' => array ('content' => \$fdet[2], 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'line' => \$this->defaultfooterline,
\t\t)
\t);
    }
    else {
\t\$this->footerDetails = array (
\t\t'odd' => array (
\t'R' => array ('content' => \$Farray, 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'line' => \$this->defaultfooterline,
\t\t),
\t\t'even' => array (
\t'L' => array ('content' => \$Farray, 'font-size' => \$this->defaultfooterfontsize, 'font-style' => \$this->defaultfooterfontstyle),
\t'line' => \$this->defaultfooterline,
\t\t)
\t);
    }
  }
  else if (is_array(\$Farray)) {
\tif (\$side=='O') { \$this->footerDetails['odd'] = \$Farray; }
\telse if (\$side=='E') { \$this->footerDetails['even'] = \$Farray; }
\telse { \$this->footerDetails = \$Farray; }
  }
/*-- HTMLHEADERS-FOOTERS --*/
  // Overwrite any HTML Footer previously set
  if (\$side=='E') { \$this->SetHTMLFooter('','E'); }
  else if (\$side=='O') {  \$this->SetHTMLFooter(''); }
  else {
\t\$this->SetHTMLFooter('');
\t\$this->SetHTMLFooter('','E');
  }
/*-- END HTMLHEADERS-FOOTERS --*/
}

/*-- WATERMARK --*/
function setUnvalidatedText(\$txt='', \$alpha=-1) {
\tif (\$alpha>=0) \$this->watermarkTextAlpha = \$alpha;
\t\$this->watermarkText = \$txt;
}
function SetWatermarkText(\$txt='', \$alpha=-1) {
\tif (\$alpha>=0) \$this->watermarkTextAlpha = \$alpha;
\t\$this->watermarkText = \$txt;
}

function SetWatermarkImage(\$src, \$alpha=-1, \$size='D', \$pos='F') {
\tif (\$alpha>=0) \$this->watermarkImageAlpha = \$alpha;
\t\$this->watermarkImage = \$src;
\t\$this->watermark_size = \$size;
\t\$this->watermark_pos = \$pos;
}
/*-- END WATERMARK --*/


//Page footer
function Footer() {
/*-- CSS-PAGE --*/
  // PAGED MEDIA - CROP / CROSS MARKS from @PAGE
  if (\$this->show_marks == 'CROP' || \$this->show_marks == 'CROPCROSS') {
\t// Show TICK MARKS
\t\$this->SetLineWidth(0.1);\t// = 0.1 mm
\t\$this->SetDColor(\$this->ConvertColor(0));
\t\$l = \$this->cropMarkLength;
\t\$m = \$this->cropMarkMargin;\t// Distance of crop mark from margin
\t\$b = \$this->nonPrintMargin;\t// Non-printable border at edge of paper sheet
\t\$ax1 = \$b;
\t\$bx = \$this->page_box['outer_width_LR'] - \$m;
\t\$ax = max(\$ax1, \$bx-\$l);
\t\$cx1 = \$this->w - \$b;
\t\$dx = \$this->w - \$this->page_box['outer_width_LR'] + \$m;
\t\$cx = min(\$cx1, \$dx+\$l);
\t\$ay1 = \$b;
\t\$by = \$this->page_box['outer_width_TB'] - \$m;
\t\$ay = max(\$ay1, \$by-\$l);
\t\$cy1 = \$this->h - \$b;
\t\$dy = \$this->h - \$this->page_box['outer_width_TB'] + \$m;
\t\$cy = min(\$cy1, \$dy+\$l);

\t\$this->Line(\$ax, \$this->page_box['outer_width_TB'], \$bx, \$this->page_box['outer_width_TB']);
\t\$this->Line(\$cx, \$this->page_box['outer_width_TB'], \$dx, \$this->page_box['outer_width_TB']);
\t\$this->Line(\$ax, \$this->h - \$this->page_box['outer_width_TB'], \$bx, \$this->h - \$this->page_box['outer_width_TB']);
\t\$this->Line(\$cx, \$this->h - \$this->page_box['outer_width_TB'], \$dx, \$this->h - \$this->page_box['outer_width_TB']);
\t\$this->Line(\$this->page_box['outer_width_LR'], \$ay, \$this->page_box['outer_width_LR'], \$by);
\t\$this->Line(\$this->page_box['outer_width_LR'], \$cy, \$this->page_box['outer_width_LR'], \$dy);
\t\$this->Line(\$this->w - \$this->page_box['outer_width_LR'], \$ay, \$this->w - \$this->page_box['outer_width_LR'], \$by);
\t\$this->Line(\$this->w - \$this->page_box['outer_width_LR'], \$cy, \$this->w - \$this->page_box['outer_width_LR'], \$dy);

\tif (\$this->printers_info) {
\t\t\$hd = date('Y-m-d H:i').'  Page '.\$this->page.' of {nb}';
\t\t\$this->SetTColor(\$this->ConvertColor(0));
\t\t\$this->SetFont('arial','',7.5,true,true);
\t\t\$this->x = \$this->page_box['outer_width_LR'] + 1.5;
\t\t\$this->y = 1;
\t\t\$this->Cell(\$headerpgwidth ,\$this->FontSize,\$hd,0,0,'L',0,'',0,0,0,'M');
\t\t\$this->SetFont(\$this->default_font,'',\$this->original_default_font_size);
\t}

  }
  if (\$this->show_marks == 'CROSS' || \$this->show_marks == 'CROPCROSS') {
\t\$this->SetLineWidth(0.1);\t// = 0.1 mm
\t\$this->SetDColor(\$this->ConvertColor(0));
\t\$l = 14 /2;\t// longer length of the cross line (half)
\t\$w = 6 /2;\t// shorter width of the cross line (half)
\t\$r = 1.2;\t// radius of circle
\t\$m = \$this->crossMarkMargin;\t// Distance of cross mark from margin
\t\$x1 = \$this->page_box['outer_width_LR'] - \$m;
\t\$x2 = \$this->w - \$this->page_box['outer_width_LR'] + \$m;
\t\$y1 = \$this->page_box['outer_width_TB'] - \$m;
\t\$y2 = \$this->h - \$this->page_box['outer_width_TB'] + \$m;
\t// Left
\t\$this->Circle(\$x1, \$this->h/2, \$r, 'S') ;
\t\$this->Line(\$x1-\$w, \$this->h/2, \$x1+\$w, \$this->h/2);
\t\$this->Line(\$x1, \$this->h/2-\$l, \$x1, \$this->h/2+\$l);
\t// Right
\t\$this->Circle(\$x2, \$this->h/2, \$r, 'S') ;
\t\$this->Line(\$x2-\$w, \$this->h/2, \$x2+\$w, \$this->h/2);
\t\$this->Line(\$x2, \$this->h/2-\$l, \$x2, \$this->h/2+\$l);
\t// Top
\t\$this->Circle(\$this->w/2, \$y1, \$r, 'S') ;
\t\$this->Line(\$this->w/2, \$y1-\$w, \$this->w/2, \$y1+\$w);
\t\$this->Line(\$this->w/2-\$l, \$y1, \$this->w/2+\$l, \$y1);
\t// Bottom
\t\$this->Circle(\$this->w/2, \$y2, \$r, 'S') ;
\t\$this->Line(\$this->w/2, \$y2-\$w, \$this->w/2, \$y2+\$w);
\t\$this->Line(\$this->w/2-\$l, \$y2, \$this->w/2+\$l, \$y2);
  }


\t// If @page set non-HTML headers/footers named, they were not read until later in the HTML code - so now set them
\tif (\$this->page==1) {
\t\tif (\$this->firstPageBoxHeader) {
\t\t\t\$this->headerDetails['odd'] = \$this->pageheaders[\$this->firstPageBoxHeader];
  \t\t\t\$this->Header();
\t\t}
\t\tif (\$this->firstPageBoxFooter) {
\t\t\t\$this->footerDetails['odd'] = \$this->pagefooters[\$this->firstPageBoxFooter];
\t\t}
\t\t\$this->firstPageBoxHeader='';
\t\t\$this->firstPageBoxFooter='';
\t}
/*-- END CSS-PAGE --*/



/*-- HTMLHEADERS-FOOTERS --*/
  if ((\$this->mirrorMargins && (\$this->page%2==0) && \$this->HTMLFooterE) || (\$this->mirrorMargins && (\$this->page%2==1) && \$this->HTMLFooter) || (!\$this->mirrorMargins && \$this->HTMLFooter)) {
\t\$this->writeHTMLFooters();
/*-- WATERMARK --*/
  \tif ((\$this->watermarkText) && (\$this->showWatermarkText)) {
\t\t\$this->watermark( \$this->watermarkText, 45, 120, \$this->watermarkTextAlpha);\t// Watermark text
  \t}
\tif ((\$this->watermarkImage) && (\$this->showWatermarkImage)) {
\t\t\$this->watermarkImg( \$this->watermarkImage, \$this->watermarkImageAlpha);\t// Watermark image
\t}
/*-- END WATERMARK --*/
\treturn;
  }
/*-- END HTMLHEADERS-FOOTERS --*/

  \$this->processingHeader=true;
  \$this->ResetMargins();\t// necessary after columns
  \$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
/*-- WATERMARK --*/
  if ((\$this->watermarkText) && (\$this->showWatermarkText)) {
\t\$this->watermark( \$this->watermarkText, 45, 120, \$this->watermarkTextAlpha);\t// Watermark text
  }
  if ((\$this->watermarkImage) && (\$this->showWatermarkImage)) {
\t\$this->watermarkImg( \$this->watermarkImage, \$this->watermarkImageAlpha);\t// Watermark image
  }
/*-- END WATERMARK --*/
  \$h = \$this->footerDetails;
  if(count(\$h)) {

\tif (\$this->forcePortraitHeaders && \$this->CurOrientation=='L' && \$this->CurOrientation!=\$this->DefOrientation) {
\t\t\$this->_out(sprintf('q 0 -1 1 0 0 %.3F cm ',(\$this->h*_MPDFK)));
\t\t\$headerpgwidth = \$this->h - \$this->orig_lMargin - \$this->orig_rMargin;
\t\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\t\$headerlmargin = \$this->orig_rMargin;
\t\t}
\t\telse {
\t\t\t\$headerlmargin = \$this->orig_lMargin;
\t\t}
\t}
\telse {
\t\t\$yadj = 0;
\t\t\$headerpgwidth = \$this->pgwidth;
\t\t\$headerlmargin = \$this->lMargin;
\t}
\t\$this->SetY(-\$this->margin_footer);

\t\$this->SetTColor(\$this->ConvertColor(0));
    \t\$this->SUP = false;
\t\$this->SUB = false;
\t\$this->bullet = false;

\t// only show pagenumber if numbering on
\t\$pgno = \$this->docPageNum(\$this->page, true);

\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\t\$side = 'even';
\t}
\telse {\t// ODD\t// OR NOT MIRRORING MARGINS/FOOTERS = DEFAULT
\t\t\t\$side = 'odd';
\t}
\t\$maxfontheight = 0;
\tforeach(array('L','C','R') AS \$pos) {
\t  if (isset(\$h[\$side][\$pos]['content']) && \$h[\$side][\$pos]['content']) {
\t\tif (isset(\$h[\$side][\$pos]['font-size']) && \$h[\$side][\$pos]['font-size']) { \$hfsz = \$h[\$side][\$pos]['font-size']; }
\t\telse { \$hfsz = \$this->default_font_size; }
\t\t\$maxfontheight = max(\$maxfontheight,\$hfsz);
\t  }
\t}
\t// LEFT-CENTER-RIGHT
\tforeach(array('L','C','R') AS \$pos) {
\t  if (isset(\$h[\$side][\$pos]['content']) && \$h[\$side][\$pos]['content']) {
\t\t\$hd = str_replace('{PAGENO}',\$pgno,\$h[\$side][\$pos]['content']);
\t\t\$hd = str_replace(\$this->aliasNbPgGp,\$this->nbpgPrefix.\$this->aliasNbPgGp.\$this->nbpgSuffix,\$hd);
\t\t\$hd = preg_replace_callback('/\\{DATE\\s+(.*?)\\}/', array(\$this, 'date_callback') ,\$hd);\t// mPDF 5.7
\t\tif (isset(\$h[\$side][\$pos]['font-family']) && \$h[\$side][\$pos]['font-family']) { \$hff = \$h[\$side][\$pos]['font-family']; }
\t\telse { \$hff = \$this->original_default_font; }
\t\tif (isset(\$h[\$side][\$pos]['font-size']) && \$h[\$side][\$pos]['font-size']) { \$hfsz = \$h[\$side][\$pos]['font-size']; }
\t\telse { \$hfsz = \$this->original_default_font_size; }
\t\t\$maxfontheight = max(\$maxfontheight,\$hfsz);
\t\tif (isset(\$h[\$side][\$pos]['font-style']) && \$h[\$side][\$pos]['font-style']) { \$hfst = \$h[\$side][\$pos]['font-style']; }
\t\telse { \$hfst = ''; }
\t\tif (isset(\$h[\$side][\$pos]['color']) && \$h[\$side][\$pos]['color']) {
\t\t\t\$hfcol = \$h[\$side][\$pos]['color'];
\t\t\t\$cor = \$this->ConvertColor(\$hfcol);
\t\t\tif (\$cor) { \$this->SetTColor(\$cor); }
\t\t}
\t\telse { \$hfcol = ''; }
\t\t\$this->SetFont(\$hff,\$hfst,\$hfsz,true,true);
\t\t\$this->x = \$headerlmargin ;
\t\t\$this->y = \$this->h - \$this->margin_footer - (\$maxfontheight/_MPDFK);
\t\t\$hd = \$this->purify_utf8_text(\$hd);
\t\tif (\$this->text_input_as_HTML) {
\t\t\t\$hd = \$this->all_entities_to_utf8(\$hd);
\t\t}
\t\t// CONVERT CODEPAGE
\t\tif (\$this->usingCoreFont) { \$hd = mb_convert_encoding(\$hd,\$this->mb_enc,'UTF-8'); }
\t\t// DIRECTIONALITY RTL
\t\t\$this->magic_reverse_dir(\$hd, true, \$this->directionality);\t// *RTL*
\t\t// Font-specific ligature substitution for Indic fonts
\t\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) \$this->ConvertIndic(\$hd);\t// *INDIC*
\t\t\$align = \$pos;
\t\tif (\$this->directionality == 'rtl') {
\t\t\tif (\$pos == 'L') { \$align = 'R'; }
\t\t\telse if (\$pos == 'R') { \$align = 'L'; }
\t\t}

\t\tif (\$pos!='L' && (strpos(\$hd,\$this->aliasNbPg)!==false || strpos(\$hd,\$this->aliasNbPgGp)!==false)) {
\t\t\tif (strpos(\$hd,\$this->aliasNbPgGp)!==false) { \$type= 'nbpggp'; } else { \$type= 'nbpg'; }
\t\t\t\$this->_out('{mpdfheader'.\$type.' '.\$pos.' ff='.\$hff.' fs='.\$hfst.' fz='.\$hfsz.'}');
\t\t\t\$this->Cell(\$headerpgwidth ,\$maxfontheight/_MPDFK ,\$hd,0,0,\$align,0,'',0,0,0,'M');
\t\t\t\$this->_out('Q');
\t\t}
\t\telse {
\t\t\t\$this->Cell(\$headerpgwidth ,\$maxfontheight/_MPDFK ,\$hd,0,0,\$align,0,'',0,0,0,'M');
\t\t}
\t\tif (\$hfcol) { \$this->SetTColor(\$this->ConvertColor(0)); }
\t  }
\t}
\t// Return Font to normal
\t\$this->SetFont(\$this->default_font,'',\$this->original_default_font_size);

\t// LINE

\tif (isset(\$h[\$side]['line']) && \$h[\$side]['line']) {
\t\t\$this->SetLineWidth(0.1);
\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\$this->Line(\$headerlmargin , \$this->y-(\$maxfontheight*(\$this->footer_line_spacing)/_MPDFK), \$headerlmargin +\$headerpgwidth, \$this->y-(\$maxfontheight*(\$this->footer_line_spacing)/_MPDFK));
\t}
\tif (\$this->forcePortraitHeaders && \$this->CurOrientation=='L' && \$this->CurOrientation!=\$this->DefOrientation) {
\t\t\$this->_out('Q');
\t}
  }
  \$this->processingHeader=false;

}

///////////////////
// HYPHENATION
///////////////////
// mPDF 5.6.21
// Hard hyphens
function hardHyphenate(\$word, \$maxWidth) {
\t// Don't hyphenate web addresses
\tif (preg_match('/^(http:|www\\.)/',\$word)) { return array(false,'','',''); }

\t// Get dictionary
\t\$poss = array();
\t\$softhyphens = array();
\t\$offset = 0;
\t\$p = true;
\tif (\$this->usingCoreFont) {
\t\t\$wl = strlen(\$word);
\t}
\telse {
\t\t\$wl = mb_strlen(\$word,'UTF-8');
\t}
\twhile(\$offset < \$wl) {
\t\tif (!\$this->usingCoreFont) {
\t\t\t\$p = mb_strpos(\$word, \"-\", \$offset, 'UTF-8');
\t\t}
\t\telse if (\$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats') {
\t\t\t\$p = strpos(\$word, \"-\", \$offset);
\t\t}
\t\tif (\$p !== false) { \$poss[] = \$p; }\t// mPDF 5.7.2
\t\telse { break; }
\t\t\$offset = \$p+1;
\t}
\t\$success = false;
\tforeach(\$poss AS \$i) {
\t\t\tif (\$this->usingCoreFont) {
\t\t\t\t\$a = substr(\$word,0,\$i);
\t\t\t\tif (\$this->GetStringWidth(\$a.'-') > \$maxWidth) { break ; }
\t\t\t\t\$pre = \$a;
\t\t\t\t\$post = substr(\$word,\$i,strlen(\$word));
\t\t\t\t\$prelength = strlen(\$pre);
\t\t\t}
\t\t\telse {
\t\t\t\t\$a = mb_substr(\$word,0,\$i,'UTF-8');
\t\t\t\tif (\$this->GetStringWidth(\$a.'-') > \$maxWidth) { break ; }
\t\t\t\t\$pre = \$a;
\t\t\t\t\$post = mb_substr(\$word,\$i,mb_strlen(\$word,'UTF-8'),'UTF-8');
\t\t\t\t\$prelength = mb_strlen(\$pre, 'UTF-8');
\t\t\t}
\t\t\t\$success = true;
\t}
\treturn array(\$success,\$pre,\$post,\$prelength);
}


/*-- HYPHENATION --*/
///////////////////
///////////////////
// HYPHENATION
///////////////////
// Soft hyphs
function softHyphenate(\$word, \$maxWidth) {
\t// Don't hyphenate web addresses
\tif (preg_match('/^(http:|www\\.)/',\$word)) { return array(false,'','',''); }

\t// Get dictionary
\t\$poss = array();
\t\$softhyphens = array();
\t\$offset = 0;
\t\$p = true;
\tif (\$this->usingCoreFont) {
\t\t\$wl = strlen(\$word);
\t}
\telse {
\t\t\$wl = mb_strlen(\$word,'UTF-8');
\t}
\twhile(\$offset < \$wl) {
\t\t// Soft Hyphens chr(173)
\t\tif (!\$this->usingCoreFont) {
\t\t\t\$p = mb_strpos(\$word, \"\\xc2\\xad\", \$offset, 'UTF-8');
\t\t}
\t\telse if (\$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats') {
\t\t\t\$p = strpos(\$word, chr(173), \$offset);
\t\t}
\t\t// mPDF 5.7.2
\t\t//if (\$p !== false) { \$poss[] = \$p - count(\$poss); }
\t\tif (\$p !== false) { \$poss[] = \$p; }
\t\telse { break; }
\t\t\$offset = \$p+1;
\t}
\t\$success = false;
\tforeach(\$poss AS \$i) {
\t\t\tif (\$this->usingCoreFont) {
\t\t\t\t\$a = substr(\$word,0,\$i);
\t\t\t\tif (\$this->GetStringWidth(\$a.'-') > \$maxWidth) { break ; }
\t\t\t\t\$pre = \$a;
\t\t\t\t\$post = substr(\$word,\$i,strlen(\$word));
\t\t\t\t\$prelength = strlen(\$pre);
\t\t\t}
\t\t\telse {
\t\t\t\t\$a = mb_substr(\$word,0,\$i,'UTF-8');
\t\t\t\tif (\$this->GetStringWidth(\$a.'-') > \$maxWidth) { break ; }
\t\t\t\t\$pre = \$a;
\t\t\t\t\$post = mb_substr(\$word,\$i,mb_strlen(\$word,'UTF-8'),'UTF-8');
\t\t\t\t\$prelength = mb_strlen(\$pre, 'UTF-8');
\t\t\t}
\t\t\t\$success = true;
\t}
\treturn array(\$success,\$pre,\$post,\$prelength);
}

///////////////////
// Word hyphenation
function hyphenateWord(\$word, \$maxWidth) {
\t// Do everything inside this function in utf-8
\t// Don't hyphenate web addresses
\tif (preg_match('/^(http:|www\\.)/',\$word)) { return array(false,'','',''); }


\t// Get dictionary
\tif (!\$this->loadedSHYdictionary) {
\t\tif (file_exists(_MPDF_PATH.'patterns/dictionary.txt')) {
\t\t\t\$this->SHYdictionary = file(_MPDF_PATH.'patterns/dictionary.txt',FILE_SKIP_EMPTY_LINES);
\t\t\tforeach(\$this->SHYdictionary as \$entry) {
\t\t\t\t\$entry = trim(\$entry);
\t\t\t\t\$poss = array();
\t\t\t\t\$offset = 0;
\t\t\t\t\$p = true;
\t\t\t\t\$wl = mb_strlen(\$entry ,'UTF-8');
\t\t\t\twhile(\$offset < \$wl) {
\t\t\t\t\t\$p = mb_strpos(\$entry, '/', \$offset, 'UTF-8');
\t\t\t\t\tif (\$p !== false) { \$poss[] = \$p - count(\$poss); }
\t\t\t\t\telse { break; }
\t\t\t\t\t\$offset = \$p+1;
\t\t\t\t}
\t\t\t\tif (count(\$poss)) { \$this->SHYdictionaryWords[str_replace('/', '', mb_strtolower(\$entry))] = \$poss; }
\t\t\t}
\t\t}
\t\t\$this->loadedSHYdictionary = true;
\t}

\tif (!in_array(\$this->SHYlang,\$this->SHYlanguages)) { return array(false,'','',''); }
\t// If no pattern loaded or not the best one
\tif (count(\$this->SHYpatterns) < 1  || (\$this->loadedSHYpatterns && \$this->loadedSHYpatterns != \$this->SHYlang)) {
\t\tinclude(_MPDF_PATH.\"patterns/\" . \$this->SHYlang . \".php\");
\t\t\$patterns = explode(' ', \$patterns);
\t\t\$new_patterns = array();
\t\tfor(\$i = 0; \$i < count(\$patterns); \$i++) {
\t\t\t\$value = \$patterns[\$i];
\t\t\t\$new_patterns[preg_replace('/[0-9]/', '', \$value)] = \$value;
\t\t}
\t\t\$this->SHYpatterns = \$new_patterns;
\t\t\$this->loadedSHYpatterns = \$this->SHYlang;
\t}

\tif (\$this->usingCoreFont) { \$word = mb_convert_encoding(\$word,'UTF-8',\$this->mb_enc); }

\t\$prepre = '';
\t\$postpost = '';
\t\$startpunctuation = \"\\xc2\\xab\\xc2\\xbf\\xe2\\x80\\x98\\xe2\\x80\\x9b\\xe2\\x80\\x9c\\xe2\\x80\\x9f\";
\t\$endpunctuation = \"\\xe2\\x80\\x9e\\xe2\\x80\\x9d\\xe2\\x80\\x9a\\xe2\\x80\\x99\\xc2\\xbb\";
\t\$pre = '';
\t\$post = '';


\tif (preg_match('/^([\"\\''.\$startpunctuation .'])+(.{'.\$this->SHYcharmin.',})\$/u',\$word,\$m)) {
\t\t\$prepre = \$m[1];
\t\t\$word = \$m[2];
\t}
\tif (preg_match('/^(.{'.\$this->SHYcharmin.',})([\\'\\.,;:!?\"'.\$endpunctuation .']+)\$/u',\$word,\$m)) {
\t\t\$word = \$m[1];
\t\t\$postpost = \$m[2];
\t}
\tif(mb_strlen(\$word,'UTF-8') < \$this->SHYcharmin) {
\t\t\treturn array(false,'','','');
\t}
\t\$success = false;

\tif(isset(\$this->SHYdictionaryWords[mb_strtolower(\$word)])) {
\t   foreach(\$this->SHYdictionaryWords[mb_strtolower(\$word)] AS \$i) {
\t\t\t\$a = \$prepre . mb_substr(\$word,0,\$i,'UTF-8');
\t\t\tif (\$this->usingCoreFont) { \$testa = mb_convert_encoding(\$a,\$this->mb_enc,'UTF-8'); }
\t\t\telse { \$testa = \$a; }
\t\t\tif (\$this->GetStringWidth(\$testa.'-') > \$maxWidth) { break ; }
\t\t\t\$pre = \$a;
\t\t\t\$post = mb_substr(\$word,\$i,mb_strlen(\$word,'UTF-8'),'UTF-8') . \$postpost;
\t\t\t\$success = true;
\t   }
\t}

\tif (!\$success) {
\t   \$text_word = '_' . \$word . '_';
\t   \$word_length = mb_strlen(\$text_word,'UTF-8');

\t   \$single_character = preg_split('//u', \$text_word);

\t   \$text_word = mb_strtolower(\$text_word,'UTF-8');
\t   \$hyphenated_word = array();
\t   \$numb3rs = array('0' => true, '1' => true, '2' => true, '3' => true, '4' => true, '5' => true, '6' => true, '7' => true, '8' => true, '9' => true);
\t   for(\$position = 0; \$position <= (\$word_length - \$this->SHYcharmin); \$position++) {
\t\t\$maxwins = min((\$word_length - \$position), \$this->SHYcharmax);
\t\tfor(\$win = \$this->SHYcharmin; \$win <= \$maxwins; \$win++) {
\t\t\tif(isset(\$this->SHYpatterns[mb_substr(\$text_word, \$position, \$win,'UTF-8')])) {
\t\t\t\t\$pattern = \$this->SHYpatterns[mb_substr(\$text_word, \$position, \$win,'UTF-8')];
\t\t\t\t\$digits = 1;
\t\t\t\t\$pattern_length = mb_strlen(\$pattern,'UTF-8');
\t\t\t\tfor(\$i = 0; \$i < \$pattern_length; \$i++) {
\t\t\t\t\t\$char = \$pattern[\$i];
\t\t\t\t\tif(isset(\$numb3rs[\$char])) {
\t\t\t\t\t\t\$zero = (\$i == 0) ? \$position - 1 : \$position + \$i - \$digits;
\t\t\t\t\t\tif(!isset(\$hyphenated_word[\$zero]) || \$hyphenated_word[\$zero] != \$char) \$hyphenated_word[\$zero] = \$char;
\t\t\t\t\t\t\$digits++;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t}
\t   }

\t   for(\$i = \$this->SHYleftmin; \$i <= (mb_strlen(\$word,'UTF-8') - \$this->SHYrightmin); \$i++) {
\t\tif(isset(\$hyphenated_word[\$i]) && \$hyphenated_word[\$i] % 2 != 0) {
\t\t\t\$a = \$prepre . mb_substr(\$word,0,\$i,'UTF-8');
\t\t\tif (\$this->usingCoreFont) { \$testa = mb_convert_encoding(\$a,\$this->mb_enc,'UTF-8'); }
\t\t\telse { \$testa = \$a; }
\t\t\tif (\$this->GetStringWidth(\$testa.'-') > \$maxWidth + 0.0001) { break ; }
\t\t\t\$pre = \$a;
\t\t\t\$post = mb_substr(\$word,\$i,mb_strlen(\$word,'UTF-8'),'UTF-8') . \$postpost;
\t\t\t\$success = true;
\t\t}
\t   }
\t}
\tif (\$this->usingCoreFont) {
\t\t\$pre = mb_convert_encoding(\$pre,\$this->mb_enc,'UTF-8');
\t\t\$post = mb_convert_encoding(\$post,\$this->mb_enc,'UTF-8');
\t\t\$prelength = strlen(\$pre);
\t}
\telse {
\t\t\$prelength = mb_strlen(\$pre);
\t}
\treturn array(\$success,\$pre,\$post,\$prelength);

}
/*-- END HYPHENATION --*/


/*-- HTML-CSS --*/
///////////////////
/// HTML parser ///
///////////////////
function WriteHTML(\$html,\$sub=0,\$init=true,\$close=true) {
\t\t\t\t// \$sub ADDED - 0 = default; 1=headerCSS only; 2=HTML body (parts) only; 3 - HTML parses only
\t\t\t\t// 4 - writes HTML headers
\t\t\t\t// \$close Leaves buffers etc. in current state, so that it can continue a block etc.
\t\t\t\t// \$init - Clears and sets buffers to Top level block etc.

\tif (empty(\$html)) { \$html = ''; }
\tif (\$this->progressBar) { \$this->UpdateProgressBar(1,0,'Parsing CSS & Headers'); }\t// *PROGRESS-BAR*

\tif (\$init) {
\t\t\$this->headerbuffer='';
\t\t\$this->textbuffer = array();
\t\t\$this->fixedPosBlockSave = array();
\t}
\tif (\$sub == 1) { \$html = '<style> '.\$html.' </style>'; }\t// stylesheet only

\tif (\$this->allow_charset_conversion) {
\t\tif (\$sub < 1) {
\t\t\t\$this->ReadCharset(\$html);
\t\t}
\t\tif (\$this->charset_in && \$sub!=4) {\t// mPDF 5.4.14
\t\t\t\$success = iconv(\$this->charset_in,'UTF-8//TRANSLIT',\$html);
\t\t\tif (\$success) { \$html = \$success; }
\t\t}
\t}
\t\$html = \$this->purify_utf8(\$html,false);
\tif (\$init) {
\t\t\$this->blklvl = 0;
\t\t\$this->lastblocklevelchange = 0;
\t\t\$this->blk = array();
\t\t\$this->initialiseBlock(\$this->blk[0]);
\t\t\$this->blk[0]['width'] =& \$this->pgwidth;
\t\t\$this->blk[0]['inner_width'] =& \$this->pgwidth;
\t\t\$this->blk[0]['blockContext'] = \$this->blockContext;
\t}

\t\$zproperties = array();
\tif (\$sub < 2) {
\t\t\$this->ReadMetaTags(\$html);

\t\t// mPDF 5.6.18
\t\tif (preg_match('/<base[^>]*href=[\"\\']([^\"\\'>]*)[\"\\']/i', \$html, \$m)) {
\t\t\t\$this->SetBasePath(\$m[1]);
\t\t}
\t\t// NB default stylesheet now in mPDF.css - read on initialising class
\t\t\$html = \$this->cssmgr->ReadCSS(\$html);

\t\tif (\$this->useLang && !\$this->usingCoreFont && preg_match('/<html [^>]*lang=[\\'\\\"](.*?)[\\'\\\"]/ism',\$html,\$m)) {
\t\t\t\$html_lang = \$m[1];
\t\t}

\t\tif (preg_match('/<html [^>]*dir=[\\'\\\"]\\s*rtl\\s*[\\'\\\"]/ism',\$html)) {
\t\t\t\$zproperties['DIRECTION'] = 'rtl';
\t\t}

\t\t// allow in-line CSS for body tag to be parsed // Get <body> tag inline CSS
\t\tif (preg_match('/<body([^>]*)>(.*?)<\\/body>/ism',\$html,\$m) || preg_match('/<body([^>]*)>(.*)\$/ism',\$html,\$m)) {
\t\t\t\$html = \$m[2];
\t\t\t// Changed to allow style=\"background: url('bg.jpg')\"
\t\t\tif (preg_match('/style=[\\\"](.*?)[\\\"]/ism',\$m[1],\$mm) || preg_match('/style=[\\'](.*?)[\\']/ism',\$m[1],\$mm)) {
\t\t\t\t\$zproperties = \$this->cssmgr->readInlineCSS(\$mm[1]);
\t\t\t}
\t\t\tif (preg_match('/dir=[\\'\\\"]\\s*rtl\\s*[\\'\\\"]/ism',\$m[1])) {
\t\t\t\t\$zproperties['DIRECTION'] = 'rtl';
\t\t\t}
\t\t\tif (isset(\$html_lang) && \$html_lang) { \$zproperties['LANG'] = \$html_lang; }
\t\t\tif (\$this->useLang && !\$this->onlyCoreFonts && preg_match('/lang=[\\'\\\"](.*?)[\\'\\\"]/ism',\$m[1],\$mm)) {
\t\t\t\t\$zproperties['LANG'] = \$mm[1];
\t\t\t}

\t\t}
\t}
\t\$properties = \$this->cssmgr->MergeCSS('BLOCK','BODY','');
\tif (\$zproperties) { \$properties = \$this->cssmgr->array_merge_recursive_unique(\$properties,\$zproperties); }

\tif (isset(\$properties['DIRECTION']) && \$properties['DIRECTION']) {
\t\t\$this->cssmgr->CSS['BODY']['DIRECTION'] = \$properties['DIRECTION'];
\t}
\tif (!isset(\$this->cssmgr->CSS['BODY']['DIRECTION'])) {
\t\t\$this->cssmgr->CSS['BODY']['DIRECTION'] = \$this->directionality;
\t}
\telse { \$this->SetDirectionality(\$this->cssmgr->CSS['BODY']['DIRECTION']); }

\t\$this->setCSS(\$properties,'','BODY');
\t\$this->blk[0]['InlineProperties'] = \$this->saveInlineProperties();

\tif (\$sub == 1) { return ''; }
\tif (!isset(\$this->cssmgr->CSS['BODY'])) { \$this->cssmgr->CSS['BODY'] = array(); }

/*-- BACKGROUNDS --*/
\tif (isset(\$properties['BACKGROUND-GRADIENT'])) {
\t\t\$this->bodyBackgroundGradient = \$properties['BACKGROUND-GRADIENT'];
\t}

\tif (isset(\$properties['BACKGROUND-IMAGE']) && \$properties['BACKGROUND-IMAGE']) {
\t\t\$ret = \$this->SetBackground(\$properties, \$this->pgwidth);
\t\tif (\$ret) { \$this->bodyBackgroundImage = \$ret; }
\t}
/*-- END BACKGROUNDS --*/

/*-- CSS-PAGE --*/
\t// If page-box is set
\tif (\$this->state==0 && ((isset(\$this->cssmgr->CSS['@PAGE']) && \$this->cssmgr->CSS['@PAGE']) || (isset(\$this->cssmgr->CSS['@PAGE>>PSEUDO>>FIRST']) && \$this->cssmgr->CSS['@PAGE>>PSEUDO>>FIRST'])) ) {\t// mPDF 5.7.3
\t\t\$this->page_box['current'] = '';
\t\t\$this->page_box['using'] = true;
\t\tlist(\$pborientation,\$pbmgl,\$pbmgr,\$pbmgt,\$pbmgb,\$pbmgh,\$pbmgf,\$hname,\$fname,\$bg,\$resetpagenum,\$pagenumstyle,\$suppress,\$marks,\$newformat) = \$this->SetPagedMediaCSS('', false, 'O');
\t\t\$this->DefOrientation = \$this->CurOrientation = \$pborientation;
\t\t\$this->orig_lMargin = \$this->DeflMargin = \$pbmgl;
\t\t\$this->orig_rMargin = \$this->DefrMargin = \$pbmgr;
\t\t\$this->orig_tMargin = \$this->tMargin = \$pbmgt;
\t\t\$this->orig_bMargin = \$this->bMargin = \$pbmgb;
\t\t\$this->orig_hMargin = \$this->margin_header = \$pbmgh;
\t\t\$this->orig_fMargin = \$this->margin_footer = \$pbmgf;
\t\tlist(\$pborientation,\$pbmgl,\$pbmgr,\$pbmgt,\$pbmgb,\$pbmgh,\$pbmgf,\$hname,\$fname,\$bg,\$resetpagenum,\$pagenumstyle,\$suppress,\$marks,\$newformat) = \$this->SetPagedMediaCSS('', true, 'O');\t// true=first page
\t\t\$this->show_marks = \$marks;
\t\tif (\$hname && !preg_match('/^html_(.*)\$/i',\$hname)) \$this->firstPageBoxHeader = \$hname;
\t\tif (\$fname && !preg_match('/^html_(.*)\$/i',\$fname)) \$this->firstPageBoxFooter = \$fname;
\t}
/*-- END CSS-PAGE --*/

\t\$parseonly = false;
\t\$this->bufferoutput = false;
\tif (\$sub == 3) {
\t\t\$parseonly = true;
\t\t// Close any open block tags
\t\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }
\t\t// Output any text left in buffer
\t\tif (count(\$this->textbuffer)) { \$this->printbuffer(\$this->textbuffer); }
\t\t\$this->textbuffer=array();
\t}
\telse if (\$sub == 4) {
\t\t// Close any open block tags
\t\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }
\t\t// Output any text left in buffer
\t\tif (count(\$this->textbuffer)) { \$this->printbuffer(\$this->textbuffer); }
\t\t\$this->bufferoutput = true;
\t\t\$this->textbuffer=array();
\t\t\$this->headerbuffer='';
\t\t\$properties = \$this->cssmgr->MergeCSS('BLOCK','BODY','');
\t\t\$this->setCSS(\$properties,'','BODY');
\t}

\tmb_internal_encoding('UTF-8');

\t\$html = \$this->AdjustHTML(\$html, \$this->tabSpaces); //Try to make HTML look more like XHTML

\tif (\$this->autoFontGroups) { \$html = \$this->AutoFont(\$html); }

/*-- HTMLHEADERS-FOOTERS --*/
\tpreg_match_all('/<htmlpageheader([^>]*)>(.*?)<\\/htmlpageheader>/si',\$html,\$h);
\tfor(\$i=0;\$i<count(\$h[1]);\$i++) {
\t\tif (preg_match('/name=[\\'|\\\"](.*?)[\\'|\\\"]/',\$h[1][\$i],\$n)) {
\t\t\t\$this->pageHTMLheaders[\$n[1]]['html'] = \$h[2][\$i];
\t\t\t\$this->pageHTMLheaders[\$n[1]]['h'] = \$this->_gethtmlheight(\$h[2][\$i]);
\t\t}
\t}
\tpreg_match_all('/<htmlpagefooter([^>]*)>(.*?)<\\/htmlpagefooter>/si',\$html,\$f);
\tfor(\$i=0;\$i<count(\$f[1]);\$i++) {
\t\tif (preg_match('/name=[\\'|\\\"](.*?)[\\'|\\\"]/',\$f[1][\$i],\$n)) {
\t\t\t\$this->pageHTMLfooters[\$n[1]]['html'] = \$f[2][\$i];
\t\t\t\$this->pageHTMLfooters[\$n[1]]['h'] = \$this->_gethtmlheight(\$f[2][\$i]);
\t\t}
\t}
/*-- END HTMLHEADERS-FOOTERS --*/
\t\$html = preg_replace('/<htmlpageheader.*?<\\/htmlpageheader>/si','',\$html);
\t\$html = preg_replace('/<htmlpagefooter.*?<\\/htmlpagefooter>/si','',\$html);

\tif(\$this->state==0 && \$sub!=1 && \$sub!=3 && \$sub!=4) {
\t\t\$this->AddPage(\$this->CurOrientation);
\t}


/*-- HTMLHEADERS-FOOTERS --*/

\tif (isset(\$hname) && preg_match('/^html_(.*)\$/i',\$hname,\$n)) \$this->SetHTMLHeader(\$this->pageHTMLheaders[\$n[1]],'O',true);
\tif (isset(\$fname) && preg_match('/^html_(.*)\$/i',\$fname,\$n)) \$this->SetHTMLFooter(\$this->pageHTMLfooters[\$n[1]],'O');

/*-- END HTMLHEADERS-FOOTERS --*/

\t\$html=str_replace('<?','< ',\$html); //Fix '<?XML' bug from HTML code generated by MS Word

\t\$this->checkSIP = false;
\t\$this->checkSMP = false;
\t\$this->checkCJK = false;
\tif (\$this->onlyCoreFonts) { \$html = \$this->SubstituteChars(\$html); }
\telse {
\t\tif (preg_match(\"/([\".\$this->pregRTLchars.\"])/u\", \$html)) { \$this->biDirectional = true; }\t// *RTL*
\t\tif (preg_match(\"/([\\x{20000}-\\x{2FFFF}])/u\", \$html)) { \$this->checkSIP = true; }
\t\tif (preg_match(\"/([\\x{10000}-\\x{1FFFF}])/u\", \$html)) { \$this->checkSMP = true; }
/*-- CJK-FONTS --*/
\t\tif (preg_match(\"/([\".\$this->pregCJKchars.\"])/u\", \$html)) { \$this->checkCJK = true; }
/*-- END CJK-FONTS --*/
\t}

\t// Don't allow non-breaking spaces that are converted to substituted chars or will break anyway and mess up table width calc.
\t\$html = str_replace('<tta>160</tta>',chr(32),\$html);
\t\$html = str_replace('</tta><tta>','|',\$html);
\t\$html = str_replace('</tts><tts>','|',\$html);
\t\$html = str_replace('</ttz><ttz>','|',\$html);

\t//Add new supported tags in the DisableTags function
\t\$html=strip_tags(\$html,\$this->enabledtags); //remove all unsupported tags, but the ones inside the 'enabledtags' string

\t//Explode the string in order to parse the HTML code
\t\$a=preg_split('/<(.*?)>/ms',\$html,-1,PREG_SPLIT_DELIM_CAPTURE);
\t// ? more accurate regexp that allows e.g. <a name=\"Silly <name>\">
\t// if changing - also change in fn.SubstituteChars()
\t// \$a = preg_split ('/<((?:[^<>]+(?:\"[^\"]*\"|\\'[^\\']*\\')?)+)>/ms', \$html, -1, PREG_SPLIT_DELIM_CAPTURE);

\tif (\$this->mb_enc) {
\t\tmb_internal_encoding(\$this->mb_enc);
\t}
\t\$pbc = 0;
\tif (\$this->progressBar) { \$this->UpdateProgressBar(1,0); }\t// *PROGRESS-BAR*
\t\$this->subPos = -1;
\t\$cnt = count(\$a);
\tfor(\$i=0;\$i<\$cnt; \$i++) {
\t\t\$e = \$a[\$i];
\t\tif(\$i%2==0) {
\t\t//TEXT
\t\t\tif (\$this->blk[\$this->blklvl]['hide']) { continue; }
\t\t\tif (\$this->inlineDisplayOff) { continue; }
\t\t\tif (\$this->inMeter) { continue; }\t// mPDF 5.5.09

\t\t\tif (\$this->inFixedPosBlock) { \$this->fixedPosBlock .= \$e; continue; }\t// *CSS-POSITION*
\t\t\tif (strlen(\$e) == 0) { continue; }

\t\t\t\$e = strcode2utf(\$e);
\t\t\t\$e = \$this->lesser_entity_decode(\$e);

\t\t\tif (\$this->usingCoreFont) {
\t\t\t\t// If core font is selected in document which is not onlyCoreFonts - substitute with non-core font
\t\t\t\tif (\$this->useSubstitutions && !\$this->onlyCoreFonts && \$this->subPos<\$i && !\$this->specialcontent) {
\t\t\t\t\t\$cnt += \$this->SubstituteCharsNonCore(\$a, \$i, \$e);
\t\t\t\t}
\t\t\t\t// CONVERT ENCODING
\t\t\t\t\$e = mb_convert_encoding(\$e,\$this->mb_enc,'UTF-8');
\t\t\t\t// mPDF 5.6.41
\t\t\t\tif (\$this->toupper) { \$e = mb_strtoupper(\$e,\$this->mb_enc); }
\t\t\t\tif (\$this->tolower) { \$e = mb_strtolower(\$e,\$this->mb_enc); }
\t\t\t\tif (\$this->capitalize) { \$e = mb_convert_case(\$e, MB_CASE_TITLE, \"UTF-8\"); }
\t\t\t}
\t\t\telse {
\t\t\t\tif (\$this->checkSIP && \$this->CurrentFont['sipext'] && \$this->subPos<\$i && !\$this->specialcontent) {
\t\t\t\t\t\$cnt += \$this->SubstituteCharsSIP(\$a, \$i, \$e);
\t\t\t\t}

\t\t\t\tif (\$this->useSubstitutions && !\$this->onlyCoreFonts && \$this->CurrentFont['type']!='Type0' && \$this->subPos<\$i && !\$this->specialcontent) {
\t\t\t\t\t// mPDF 5.6.62\tremoves U+200E/U+200F LTR and RTL mark and U+200C/U+200D Zero-width Joiner and Non-joiner
\t\t\t\t\t\$e = preg_replace(\"/[\\xe2\\x80\\x8c\\xe2\\x80\\x8d\\xe2\\x80\\x8e\\xe2\\x80\\x8f]/u\",'',\$e);
\t\t\t\t\t\$cnt += \$this->SubstituteCharsMB(\$a, \$i, \$e);
\t\t\t\t}
 \t\t\t\tif (\$this->biDirectional)  { \t// *RTL*
\t\t\t\t\t// mPDF 5.7+
\t\t\t\t\t\$e = preg_replace_callback(\"/([\".\$this->pregRTLchars.\"]+)/u\", array(\$this, 'arabJoinPregCallback'), \$e );\t// *RTL*
\t\t\t\t}\t// *RTL*
\t\t\t\t// Font-specific ligature substitution for Indic fonts
\t\t\t\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) \$this->ConvertIndic(\$e);\t// *INDIC*

\t\t\t\t// mPDF 5.6.62\tremoves U+200E/U+200F LTR and RTL mark and U+200C/U+200D Zero-width Joiner and Non-joiner
\t\t\t\t\$e = preg_replace(\"/[\\xe2\\x80\\x8c\\xe2\\x80\\x8d\\xe2\\x80\\x8e\\xe2\\x80\\x8f]/u\",'',\$e);

\t\t\t\tif (\$this->toupper) { \$e = mb_strtoupper(\$e,\$this->mb_enc); }
\t\t\t\tif (\$this->tolower) { \$e = mb_strtolower(\$e,\$this->mb_enc); }
\t\t\t\tif (\$this->capitalize) { \$e = mb_convert_case(\$e, MB_CASE_TITLE, \"UTF-8\"); }
\t\t\t}
\t\t\tif ((\$this->tts) || (\$this->ttz) || (\$this->tta)) {
\t\t\t\t\$es = explode('|',\$e);
\t\t\t\t\$e = '';
\t\t\t\tforeach(\$es AS \$val) {
\t\t\t\t\t\$e .= chr(\$val);
\t\t\t\t}
\t\t\t}
\t\t\t//Adjust lineheight

\t\t\t//  FORM ELEMENTS
  \t\t\tif (\$this->specialcontent) {
/*-- FORMS --*/
\t\t\t   //SELECT tag (form element)
\t\t\t   if (\$this->specialcontent == \"type=select\") {
\t\t\t\t\$e = ltrim(\$e);
\t\t\t\t\$stringwidth = \$this->GetStringWidth(\$e);
\t\t\t\tif (!isset(\$this->selectoption['MAXWIDTH']) || \$stringwidth > \$this->selectoption['MAXWIDTH']) { \$this->selectoption['MAXWIDTH'] = \$stringwidth; }
\t\t\t\tif (!isset(\$this->selectoption['SELECTED']) || \$this->selectoption['SELECTED'] == '') { \$this->selectoption['SELECTED'] = \$e; }
\t\t\t\t// mPDD 1.4 Active Forms
\t\t\t\tif (isset(\$this->selectoption['ACTIVE']) && \$this->selectoption['ACTIVE']) {
\t\t\t\t\t\$this->selectoption['ITEMS'][]=array('exportValue'=>\$this->selectoption['currentVAL'], 'content'=>\$e, 'selected'=>\$this->selectoption['currentSEL']);
\t\t\t\t}
\t\t\t   }
\t\t\t   // TEXTAREA
\t\t\t   else {
\t\t\t\t\$objattr = unserialize(\$this->specialcontent);
\t\t\t\t\$objattr['text'] = \$e;
\t\t\t\t\$te = \"\\xbb\\xa4\\xactype=textarea,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t\t\tif (\$this->tdbegin) {
\t\t\t\t\t\$this->_saveCellTextBuffer(\$te, \$this->HREF);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$this->_saveTextBuffer(\$te, \$this->HREF);
\t\t\t\t}
\t\t\t   }
/*-- END FORMS --*/
\t\t      }

\t\t\t// TABLE
\t\t\telse if (\$this->tableLevel) {
/*-- TABLES --*/
\t\t\t\tif (\$this->tdbegin) {
     \t\t\t\t   if ((\$this->ignorefollowingspaces) && !\$this->ispre) { \$e = ltrim(\$e); }
\t\t\t\t   if (\$e || \$e==='0') {
\t\t\t\t      if ((\$this->blockjustfinished || \$this->listjustfinished) && \$this->cell[\$this->row][\$this->col]['s']>0) {
\t\t\t\t\t\t\$this->_saveCellTextBuffer(\"\\n\");
\t\t\t\t\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\t\t\t\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t\t\t\t\t}
\t\t\t\t\t\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\t\t\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t\t\t\t\t}
\t\t\t\t\t\t\$this->cell[\$this->row][\$this->col]['s'] = 0;// reset
\t\t\t\t      }
\t\t\t\t\t\$this->blockjustfinished=false;
\t\t\t\t\t\$this->listjustfinished=false;

\t\t\t\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);

          \t\t\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['R']) || !\$this->cell[\$this->row][\$this->col]['R']) {
\t\t\t\t\t\tif (isset(\$this->cell[\$this->row][\$this->col]['s'])) {
\t\t\t\t\t\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$this->GetStringWidth(\$e, false);
\t\t\t\t\t\t}
\t\t\t\t\t\telse { \$this->cell[\$this->row][\$this->col]['s'] = \$this->GetStringWidth(\$e, false); }
\t\t\t\t\t\tif (!empty(\$this->spanborddet)) {
\t\t\t\t\t\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$this->spanborddet['L']['w'] + \$this->spanborddet['R']['w'];
\t\t\t\t\t\t}
\t\t\t\t\t}

\t\t\t\t\tif (\$this->checkCJK && preg_match(\"/([\".\$this->pregCJKchars.\"])/u\", \$e)) { \$this->tableCJK = true; }\t// *CJK-FONTS*

\t\t\t\t\t// mPDF 5.6.13   Decimal mark alignment
\t\t\t\t\tif (substr(\$this->cell[\$this->row][\$this->col]['a'],0,1) == 'D') {
\t\t\t\t\t\t\$dp = \$this->decimal_align[substr(\$this->cell[\$this->row][\$this->col]['a'],0,2)];
\t\t\t\t\t\t\$s = preg_split('/'.preg_quote(\$dp,'/').'/', \$e, 2); \t// ? needs to be /u if not core
\t\t\t\t\t\t\$s0 = \$this->GetStringWidth(\$s[0], false);
\t\t\t\t\t\tif (\$s[1]) { \$s1 = \$this->GetStringWidth((\$s[1].\$dp), false); }
\t\t\t\t\t\telse \$s1 = 0;
\t\t\t\t\t\tif (!isset(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs0'])) {
\t\t\t\t\t\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs0'] = \$s0;
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs0'] = max(\$s0, \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs0']);
\t\t\t\t\t\t}
\t\t\t\t\t\tif (!isset(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs1'])) {
\t\t\t\t\t\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs1'] = \$s1;
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs1'] = max(\$s1, \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['decimal_align'][\$this->col]['maxs1']);
\t\t\t\t\t\t}
\t\t\t\t\t}

\t\t\t\t\tif (\$this->tableLevel==1 && \$this->useGraphs) {
\t\t\t\t\t\t\$this->graphs[\$this->currentGraphId]['data'][\$this->row][\$this->col] = \$e;
\t\t\t\t\t}
\t\t\t\t\t\$this->nestedtablejustfinished = false;
\t\t\t\t\t\$this->linebreakjustfinished=false;
\t\t\t\t   }
\t\t\t\t}
/*-- END TABLES --*/
\t\t\t}
\t\t\t// ALL ELSE
\t\t\telse {
    \t\t\t\tif (\$this->ignorefollowingspaces and !\$this->ispre) { \$e = ltrim(\$e); }
\t\t\t\tif (\$e || \$e==='0') \$this->_saveTextBuffer(\$e, \$this->HREF);
\t\t\t}
\t\t}


\t\telse { // TAG **

\t\t   if(\$e[0]=='/') {
/*-- PROGRESS-BAR --*/
\t\t\tif (\$this->progressBar) { \t// 10% increments
\t\t\t\tif (intval(\$i*10/\$cnt) != \$pbc) { \$pbc = intval(\$i*10/\$cnt); \$this->UpdateProgressBar(1,\$pbc*10,\$tag); }
\t\t\t}
/*-- END PROGRESS-BAR --*/


\t\t    // Check for tags where HTML specifies optional end tags,
    \t\t    // and/or does not allow nesting e.g. P inside P, or
\t\t    \$endtag = trim(strtoupper(substr(\$e,1)));\t// mPDF 5.4.20
\t\t    if(\$this->blk[\$this->blklvl]['hide']) {
\t\t\tif (in_array(\$endtag, \$this->outerblocktags) || in_array(\$endtag, \$this->innerblocktags)) {
\t\t\t\tunset(\$this->blk[\$this->blklvl]);
\t\t\t\t\$this->blklvl--;
\t\t\t}
\t\t\tcontinue;
\t\t    }

/*-- CSS-POSITION --*/
\t\t    if (\$this->inFixedPosBlock) {
\t\t\tif (in_array(\$endtag, \$this->outerblocktags) || in_array(\$endtag, \$this->innerblocktags)) { \$this->fixedPosBlockDepth--; }
\t\t\tif (\$this->fixedPosBlockDepth == 0) {
\t\t\t\t\$this->fixedPosBlockSave[] = array(\$this->fixedPosBlock, \$this->fixedPosBlockBBox, \$this->page);
\t\t\t\t\$this->fixedPosBlock = '';
\t\t\t\t\$this->inFixedPosBlock = false;
\t\t\t\tcontinue;
\t\t\t}
\t\t\t\$this->fixedPosBlock .= '<'.\$e.'>';
\t\t\tcontinue;
\t\t    }
/*-- END CSS-POSITION --*/
\t\t    if (\$this->allow_html_optional_endtags && !\$parseonly) {
\t\t\tif ((\$endtag == 'DIV' || \$endtag =='FORM' || \$endtag =='CENTER') && \$this->lastoptionaltag == 'P') { \$this->CloseTag(\$this->lastoptionaltag ); }
\t\t\tif (\$this->lastoptionaltag == 'LI' && \$endtag == 'OL') { \$this->CloseTag(\$this->lastoptionaltag ); }
\t\t\tif (\$this->lastoptionaltag == 'LI' && \$endtag == 'UL') { \$this->CloseTag(\$this->lastoptionaltag ); }
\t\t\tif (\$this->lastoptionaltag == 'DD' && \$endtag == 'DL') { \$this->CloseTag(\$this->lastoptionaltag ); }
\t\t\tif (\$this->lastoptionaltag == 'DT' && \$endtag == 'DL') { \$this->CloseTag(\$this->lastoptionaltag ); }
\t\t\tif (\$this->lastoptionaltag == 'OPTION' && \$endtag == 'SELECT') { \$this->CloseTag(\$this->lastoptionaltag ); }
/*-- TABLES --*/
\t\t\tif (\$endtag == 'TABLE') {
\t\t\t\tif (\$this->lastoptionaltag == 'THEAD' || \$this->lastoptionaltag == 'TBODY' || \$this->lastoptionaltag == 'TFOOT') {
\t\t\t\t\t\$this->CloseTag(\$this->lastoptionaltag);
\t\t\t\t}
\t\t\t\tif (\$this->lastoptionaltag == 'TR') { \$this->CloseTag('TR'); }
\t\t\t\tif (\$this->lastoptionaltag == 'TD' || \$this->lastoptionaltag == 'TH') { \$this->CloseTag(\$this->lastoptionaltag ); \$this->CloseTag('TR'); }
\t\t\t}
\t\t\tif (\$endtag == 'THEAD' || \$endtag == 'TBODY' || \$endtag == 'TFOOT') {
\t\t\t\tif (\$this->lastoptionaltag == 'TR') { \$this->CloseTag('TR'); }
\t\t\t\tif (\$this->lastoptionaltag == 'TD' || \$this->lastoptionaltag == 'TH') { \$this->CloseTag(\$this->lastoptionaltag ); \$this->CloseTag('TR'); }
\t\t\t}
\t\t\tif (\$endtag == 'TR') {
\t\t\t\tif (\$this->lastoptionaltag == 'TD' || \$this->lastoptionaltag == 'TH') { \$this->CloseTag(\$this->lastoptionaltag ); }
\t\t\t}
/*-- END TABLES --*/
\t\t    }
\t\t    \$this->CloseTag(\$endtag);
\t\t   }

\t\t   else {\t// OPENING TAG
\t\t\tif(\$this->blk[\$this->blklvl]['hide']) {
\t\t\t\tif (strpos(\$e,' ')) { \$te = strtoupper(substr(\$e,0,strpos(\$e,' '))); }
\t\t\t\telse { \$te = strtoupper(\$e); }
\t\t\t\tif (in_array(\$te, \$this->outerblocktags) || in_array(\$te, \$this->innerblocktags)) {
\t\t\t\t\t\$this->blklvl++;
 \t\t\t\t\t\$this->blk[\$this->blklvl]['hide']=true;
\t\t\t\t}
\t\t\t\tcontinue;
\t\t\t}

/*-- CSS-POSITION --*/
\t\t\tif (\$this->inFixedPosBlock) {
\t\t\t\tif (strpos(\$e,' ')) { \$te = strtoupper(substr(\$e,0,strpos(\$e,' '))); }
\t\t\t\telse { \$te = strtoupper(\$e); }
\t\t\t\t\$this->fixedPosBlock .= '<'.\$e.'>';
\t\t\t\tif (in_array(\$te, \$this->outerblocktags) || in_array(\$te, \$this->innerblocktags)) { \$this->fixedPosBlockDepth++; }
\t\t\t\tcontinue;
\t\t\t}
/*-- END CSS-POSITION --*/
\t\t\t\$regexp = '|=\\'(.*?)\\'|s'; // eliminate single quotes, if any
      \t\t\$e = preg_replace(\$regexp,\"=\\\"\\\$1\\\"\",\$e);
\t\t\t// changes anykey=anyvalue to anykey=\"anyvalue\" (only do this inside [some] tags)
\t\t\tif (substr(\$e,0,10)!='pageheader' && substr(\$e,0,10)!='pagefooter' && substr(\$e,0,12)!='tocpagebreak') {\t// mPDF 5.6.69
\t\t\t\t\$regexp = '| (\\\\w+?)=([^\\\\s>\"]+)|si';
\t      \t\t\$e = preg_replace(\$regexp,\" \\\$1=\\\"\\\$2\\\"\",\$e);
\t\t\t}

      \t\t\$e = preg_replace('/ (\\\\S+?)\\s*=\\s*\"/i', \" \\\\1=\\\"\", \$e);

      \t\t//Fix path values, if needed
\t\t\t\$orig_srcpath = '';
\t\t\tif ((stristr(\$e,\"href=\") !== false) or (stristr(\$e,\"src=\") !== false) ) {
\t\t\t\t\$regexp = '/ (href|src)\\s*=\\s*\"(.*?)\"/i';
\t\t\t\tpreg_match(\$regexp,\$e,\$auxiliararray);
\t\t\t\tif (isset(\$auxiliararray[2])) { \$path = \$auxiliararray[2]; }
\t\t\t\telse { \$path = ''; }
\t\t\t\tif (trim(\$path) != '' && !(stristr(\$e,\"src=\") !== false && substr(\$path,0,4)=='var:')) {
\t\t\t\t\t\$orig_srcpath = \$path;
\t\t\t\t\t\$this->GetFullPath(\$path);
\t\t\t\t\t\$regexp = '/ (href|src)=\"(.*?)\"/i';
\t\t\t\t\t\$e = preg_replace(\$regexp,' \\\\1=\"'.\$path.'\"',\$e);
\t\t\t\t}
\t\t\t}//END of Fix path values


\t\t\t//Extract attributes
\t\t\t\$contents=array();
\t\t\t\$contents1=array();\t// mPDF 5.5.17
\t\t\t\$contents2=array();
\t\t\t// Changed to allow style=\"background: url('bg.jpg')\"
\t\t\t// mPDF 5.5.17  Changed to improve performance; maximum length of \\S (attribute) = 16
\t\t\t// mPDF 5.6.30  Increase allowed attribute name to 32 - cutting off \"toc-even-header-name\" etc.
\t\t\tpreg_match_all('/\\\\S{1,32}=[\"][^\"]*[\"]/',\$e,\$contents1);
\t\t\tpreg_match_all('/\\\\S{1,32}=[\\'][^\\']*[\\']/i',\$e,\$contents2);

\t\t\t\$contents = array_merge(\$contents1, \$contents2);
\t\t\tpreg_match('/\\\\S+/',\$e,\$a2);
\t\t\t\$tag=strtoupper(\$a2[0]);
\t\t\t\$attr=array();
\t\t\tif (\$orig_srcpath) { \$attr['ORIG_SRC'] = \$orig_srcpath; }
\t\t\tif (!empty(\$contents)) {
\t\t\t\tforeach(\$contents[0] as \$v) {
\t\t\t\t\t// Changed to allow style=\"background: url('bg.jpg')\"
 \t\t\t\t\tif(preg_match('/^([^=]*)=[\"]?([^\"]*)[\"]?\$/',\$v,\$a3) || preg_match('/^([^=]*)=[\\']?([^\\']*)[\\']?\$/',\$v,\$a3)) {
 \t\t\t\t\t\tif (strtoupper(\$a3[1])=='ID' || strtoupper(\$a3[1])=='CLASS') {\t// 4.2.013 Omits STYLE
   \t\t\t\t\t\t\t\$attr[strtoupper(\$a3[1])]=trim(strtoupper(\$a3[2]));
\t\t\t\t\t\t}
\t\t\t\t\t\t// includes header-style-right etc. used for <pageheader>
 \t\t\t\t\t\telse if (preg_match('/^(HEADER|FOOTER)-STYLE/i',\$a3[1])) {
   \t\t\t\t\t\t\t\$attr[strtoupper(\$a3[1])]=trim(strtoupper(\$a3[2]));
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
    \t\t\t\t\t\t\t\$attr[strtoupper(\$a3[1])]=trim(\$a3[2]);
\t\t\t\t\t\t}
     \t\t\t\t\t}
  \t\t\t\t}
\t\t\t}
\t\t\t\$this->OpenTag(\$tag,\$attr);
/*-- CSS-POSITION --*/
\t\t\tif (\$this->inFixedPosBlock) {
\t\t\t\t\$this->fixedPosBlockBBox = array(\$tag,\$attr, \$this->x, \$this->y);
\t\t\t\t\$this->fixedPosBlock = '';
\t\t\t\t\$this->fixedPosBlockDepth = 1;
\t\t\t}
/*-- END CSS-POSITION --*/
\t\t      // mPDF 5.5.09
\t\t      if (preg_match('/\\/\$/',\$e)) { \$this->closeTag(\$tag); }

\t\t   }

\t\t} // end TAG
\t} //end of\tforeach(\$a as \$i=>\$e)

\tif (\$close) {

\t\t// Close any open block tags
\t\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }

\t\t// Output any text left in buffer
\t\tif (count(\$this->textbuffer) && !\$parseonly) { \$this->printbuffer(\$this->textbuffer); }
\t\tif (!\$parseonly) \$this->textbuffer=array();

/*-- CSS-FLOAT --*/
\t\t// If ended with a float, need to move to end page
\t\t\$currpos = \$this->page*1000 + \$this->y;
\t\tif (isset(\$this->blk[\$this->blklvl]['float_endpos']) && \$this->blk[\$this->blklvl]['float_endpos'] > \$currpos) {
\t\t\t\$old_page = \$this->page;
\t\t\t\$new_page = intval(\$this->blk[\$this->blklvl]['float_endpos'] /1000);
\t\t\tif (\$old_page != \$new_page) {
\t\t\t\t\$s = \$this->PrintPageBackgrounds();
\t\t\t\t// Writes after the marker so not overwritten later by page background etc.
\t\t\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\t\t\t\$this->pageBackgrounds = array();
\t\t\t\t\$this->page = \$new_page;
\t\t\t\t\$this->ResetMargins();
\t\t\t\t\$this->Reset();
\t\t\t\t\$this->pageoutput[\$this->page] = array();
\t\t\t}
\t\t\t\$this->y = ((\$this->blk[\$this->blklvl]['float_endpos'] *1000) % 1000000)/1000;\t// mod changes operands to integers before processing
\t\t}
/*-- END CSS-FLOAT --*/

/*-- CSS-IMAGE-FLOAT --*/
\t\t\$this->printfloatbuffer();
/*-- END CSS-IMAGE-FLOAT --*/

\t\t//Create Internal Links, if needed
\t\tif (!empty(\$this->internallink) ) {
\t\t\tforeach(\$this->internallink as \$k=>\$v) {
\t\t\t\tif (strpos(\$k,\"#\") !== false ) { continue; } //ignore
\t\t\t\t\$ypos = \$v['Y'];
\t\t\t\t\$pagenum = \$v['PAGE'];
\t\t\t\t\$sharp = \"#\";
\t\t\t\twhile (array_key_exists(\$sharp.\$k,\$this->internallink)) {
\t\t\t\t\t\$internallink = \$this->internallink[\$sharp.\$k];
\t\t\t\t\t\$this->SetLink(\$internallink,\$ypos,\$pagenum);
\t\t\t\t\t\$sharp .= \"#\";
\t\t\t\t}
\t\t\t}
\t\t}

\t\t\$this->linemaxfontsize = '';
\t\t\$this->lineheight_correction = \$this->default_lineheight_correction;

\t\t\$this->bufferoutput = false;

/*-- CSS-POSITION --*/
\t\tif (count(\$this->fixedPosBlockSave) && \$sub != 4) {
\t\t  foreach(\$this->fixedPosBlockSave AS \$fpbs) {
\t\t\t\$old_page = \$this->page;
\t\t\t\$this->page = \$fpbs[2];
\t\t\t\$this->WriteFixedPosHTML(\$fpbs[0], 0, 0, 100, 100,'auto', \$fpbs[1]);  // 0,0,10,10 are overwritten by bbox
\t\t\t\$this->page = \$old_page;
\t\t  }
\t\t}
/*-- END CSS-POSITION --*/

\t}
}

/*-- CSS-POSITION --*/

function WriteFixedPosHTML(\$html='',\$x, \$y, \$w, \$h, \$overflow='visible', \$bounding=array()) {
\t// \$overflow can be 'hidden', 'visible' or 'auto' - 'auto' causes autofit to size
\t// Annotations disabled - enabled in mPDF 5.0
\t// Links do work
\t// Will always go on current page (or start Page 1 if required)
\t// Probably INCOMPATIBLE WITH keep with table, columns etc.
\t// Called externally or interally via <div style=\"position: [fixed|absolute]\">
\t// When used internally, \$x \$y \$w \$h and \$overflow are all overridden by \$bounding

\t\$overflow = strtolower(\$overflow);
\tif(\$this->state==0) {
\t\t\$this->AddPage(\$this->CurOrientation);
\t}
\t\$save_y = \$this->y;
\t\$save_x = \$this->x;
\t\$this->fullImageHeight = \$this->h;
\t\$save_cols = false;
/*-- COLUMNS --*/
\tif (\$this->ColActive) {
\t\t\$save_cols = true;
\t\t\$save_nbcol = \$this->NbCol;\t// other values of gap and vAlign will not change by setting Columns off
\t\t\$this->SetColumns(0);
\t}
/*-- END COLUMNS --*/
\t\$save_annots = \$this->title2annots;\t// *ANNOTATIONS*
\t\$this->writingHTMLheader = true;\t// a FIX to stop pagebreaks etc.
\t\$this->writingHTMLfooter = true;
\t\$this->InFooter = true;\t// suppresses autopagebreaks
\t\$save_bgs = \$this->pageBackgrounds;
\t\$checkinnerhtml = preg_replace('/\\s/','',\$html);

\tif (\$w > \$this->w) { \$x = 0; \$w = \$this->w; }
\tif (\$h > \$this->h) { \$y = 0; \$h = \$this->h; }
\tif (\$x > \$this->w) { \$x = \$this->w - \$w; }
\tif (\$y > \$this->h) { \$y = \$this->h - \$h; }

\tif (!empty(\$bounding)) {
\t\t// \$cont_ containing block = full physical page (position: absolute) or page inside margins (position: fixed)
\t\t// \$bbox_ Bounding box is the <div> which is positioned absolutely/fixed
\t\t// top/left/right/bottom/width/height/background*/border*/padding*/margin* are taken from bounding
\t\t// font*[family/size/style/weight]/line-height/text*[align/decoration/transform/indent]/color are transferred to \$inner
\t\t// as an enclosing <div> (after having checked ID/CLASS)
\t\t// \$x, \$y, \$w, \$h are inside of \$bbox_ = containing box for \$inner_
\t\t// \$inner_ InnerHTML is the contents of that block to be output
\t\t\$tag = \$bounding[0];
\t\t\$attr = \$bounding[1];
\t\t\$orig_x0 = \$bounding[2];
\t\t\$orig_y0 = \$bounding[3];

\t\t// As in WriteHTML() initialising
\t\t\$this->blklvl = 0;
\t\t\$this->lastblocklevelchange = 0;
\t\t\$this->blk = array();
\t\t\$this->initialiseBlock(\$this->blk[0]);

\t\t\$this->blk[0]['width'] =& \$this->pgwidth;
\t\t\$this->blk[0]['inner_width'] =& \$this->pgwidth;

\t\t\$this->blk[0]['blockContext'] = \$this->blockContext;

\t\t\$properties = \$this->cssmgr->MergeCSS('BLOCK','BODY','');
\t\t\$this->setCSS(\$properties,'','BODY');
\t\t\$this->blklvl = 1;
\t\t\$this->initialiseBlock(\$this->blk[1]);
\t\t\$this->blk[1]['tag'] = \$tag;
\t\t\$this->blk[1]['attr'] = \$attr;
\t\t\$this->Reset();
\t\t\$p = \$this->cssmgr->MergeCSS('BLOCK',\$tag,\$attr);
\t\tif (isset(\$p['ROTATE']) && (\$p['ROTATE']==90 || \$p['ROTATE']==-90)) { \$rotate = \$p['ROTATE']; }
\t\telse { \$rotate = 0; }
\t\tif (isset(\$p['OVERFLOW'])) { \$overflow = strtolower(\$p['OVERFLOW']); }
\t\tif (strtolower(\$p['POSITION']) == 'fixed') {
\t\t\t\$cont_w = \$this->pgwidth;\t// \$this->blk[0]['inner_width'];
\t\t\t\$cont_h = \$this->h - \$this->tMargin - \$this->bMargin;
\t\t\t\$cont_x = \$this->lMargin;
\t\t\t\$cont_y = \$this->tMargin;
\t\t}
\t\telse {
\t\t\t\$cont_w = \$this->w;\t// ABSOLUTE;
\t\t\t\$cont_h = \$this->h;
\t\t\t\$cont_x = 0;
\t\t\t\$cont_y = 0;
\t\t}

\t\t// Pass on in-line properties to the innerhtml
\t\t\$css = '';
\t\tif (isset(\$p['TEXT-ALIGN'])) { \$css .= 'text-align: '.strtolower(\$p['TEXT-ALIGN']).'; '; }
\t\tif (isset(\$p['TEXT-TRANSFORM'])) { \$css .= 'text-transform: '.strtolower(\$p['TEXT-TRANSFORM']).'; '; }
\t\tif (isset(\$p['TEXT-INDENT'])) { \$css .= 'text-indent: '.strtolower(\$p['TEXT-INDENT']).'; '; }
\t\tif (isset(\$p['TEXT-DECORATION'])) { \$css .= 'text-decoration: '.strtolower(\$p['TEXT-DECORATION']).'; '; }
\t\tif (isset(\$p['FONT-FAMILY'])) { \$css .= 'font-family: '.strtolower(\$p['FONT-FAMILY']).'; '; }
\t\tif (isset(\$p['FONT-STYLE'])) { \$css .= 'font-style: '.strtolower(\$p['FONT-STYLE']).'; '; }
\t\tif (isset(\$p['FONT-WEIGHT'])) { \$css .= 'font-weight: '.strtolower(\$p['FONT-WEIGHT']).'; '; }
\t\tif (isset(\$p['FONT-SIZE'])) { \$css .= 'font-size: '.strtolower(\$p['FONT-SIZE']).'; '; }
\t\tif (isset(\$p['LINE-HEIGHT'])) { \$css .= 'line-height: '.strtolower(\$p['LINE-HEIGHT']).'; '; }
\t\tif (isset(\$p['TEXT-SHADOW'])) { \$css .= 'text-shadow: '.strtolower(\$p['TEXT-SHADOW']).'; '; }
\t\tif (isset(\$p['LETTER-SPACING'])) { \$css .= 'letter-spacing: '.strtolower(\$p['LETTER-SPACING']).'; '; }
\t\tif (isset(\$p['FONT-VARIANT'])) { \$css .= 'font-variant: '.strtolower(\$p['FONT-VARIANT']).'; '; }
\t\tif (isset(\$p['COLOR'])) { \$css .= 'color: '.strtolower(\$p['COLOR']).'; '; }
\t\tif (isset(\$p['Z-INDEX'])) { \$css .= 'z-index: '.\$p['Z-INDEX'].'; '; }\t// mPDF 5.6.01
\t\tif (\$css) {
\t\t\t\$html = '<div style=\"'.\$css.'\">'.\$html.'</div>';
\t\t}
\t\t// Copy over (only) the properties to set for border and background
\t\t\$pb = array();
\t\t\$pb['MARGIN-TOP'] = \$p['MARGIN-TOP'];
\t\t\$pb['MARGIN-RIGHT'] = \$p['MARGIN-RIGHT'];
\t\t\$pb['MARGIN-BOTTOM'] = \$p['MARGIN-BOTTOM'];
\t\t\$pb['MARGIN-LEFT'] = \$p['MARGIN-LEFT'];
\t\t\$pb['PADDING-TOP'] = \$p['PADDING-TOP'];
\t\t\$pb['PADDING-RIGHT'] = \$p['PADDING-RIGHT'];
\t\t\$pb['PADDING-BOTTOM'] = \$p['PADDING-BOTTOM'];
\t\t\$pb['PADDING-LEFT'] = \$p['PADDING-LEFT'];
\t\t\$pb['BORDER-TOP'] = \$p['BORDER-TOP'];
\t\t\$pb['BORDER-RIGHT'] = \$p['BORDER-RIGHT'];
\t\t\$pb['BORDER-BOTTOM'] = \$p['BORDER-BOTTOM'];
\t\t\$pb['BORDER-LEFT'] = \$p['BORDER-LEFT'];
\t\t\$pb['BORDER-TOP-LEFT-RADIUS-H'] = \$p['BORDER-TOP-LEFT-RADIUS-H'];
\t\t\$pb['BORDER-TOP-LEFT-RADIUS-V'] = \$p['BORDER-TOP-LEFT-RADIUS-V'];
\t\t\$pb['BORDER-TOP-RIGHT-RADIUS-H'] = \$p['BORDER-TOP-RIGHT-RADIUS-H'];
\t\t\$pb['BORDER-TOP-RIGHT-RADIUS-V'] = \$p['BORDER-TOP-RIGHT-RADIUS-V'];
\t\t\$pb['BORDER-BOTTOM-LEFT-RADIUS-H'] = \$p['BORDER-BOTTOM-LEFT-RADIUS-H'];
\t\t\$pb['BORDER-BOTTOM-LEFT-RADIUS-V'] = \$p['BORDER-BOTTOM-LEFT-RADIUS-V'];
\t\t\$pb['BORDER-BOTTOM-RIGHT-RADIUS-H'] = \$p['BORDER-BOTTOM-RIGHT-RADIUS-H'];
\t\t\$pb['BORDER-BOTTOM-RIGHT-RADIUS-V'] = \$p['BORDER-BOTTOM-RIGHT-RADIUS-V'];
\t\tif (isset(\$p['BACKGROUND-COLOR'])) { \$pb['BACKGROUND-COLOR'] = \$p['BACKGROUND-COLOR']; }
\t\tif (isset(\$p['BOX-SHADOW'])) { \$pb['BOX-SHADOW'] = \$p['BOX-SHADOW']; }
/*-- BACKGROUNDS --*/
\t\tif (isset(\$p['BACKGROUND-IMAGE'])) { \$pb['BACKGROUND-IMAGE'] = \$p['BACKGROUND-IMAGE']; }
\t\tif (isset(\$p['BACKGROUND-IMAGE-RESIZE'])) { \$pb['BACKGROUND-IMAGE-RESIZE'] = \$p['BACKGROUND-IMAGE-RESIZE']; }
\t\tif (isset(\$p['BACKGROUND-IMAGE-OPACITY'])) { \$pb['BACKGROUND-IMAGE-OPACITY'] = \$p['BACKGROUND-IMAGE-OPACITY']; }
\t\tif (isset(\$p['BACKGROUND-REPEAT'])) { \$pb['BACKGROUND-REPEAT'] = \$p['BACKGROUND-REPEAT']; }
\t\tif (isset(\$p['BACKGROUND-POSITION'])) { \$pb['BACKGROUND-POSITION'] = \$p['BACKGROUND-POSITION']; }
\t\tif (isset(\$p['BACKGROUND-GRADIENT'])) { \$pb['BACKGROUND-GRADIENT'] = \$p['BACKGROUND-GRADIENT']; }
\t\tif (isset(\$p['BACKGROUND-SIZE'])) { \$pb['BACKGROUND-SIZE'] = \$p['BACKGROUND-SIZE']; }\t// mPDF 5.6.12
\t\tif (isset(\$p['BACKGROUND-ORIGIN'])) { \$pb['BACKGROUND-ORIGIN'] = \$p['BACKGROUND-ORIGIN']; }\t// mPDF 5.6.12
\t\tif (isset(\$p['BACKGROUND-CLIP'])) { \$pb['BACKGROUND-CLIP'] = \$p['BACKGROUND-CLIP']; }\t// mPDF 5.6.12

/*-- END BACKGROUNDS --*/

\t\t\$this->setCSS(\$pb,'BLOCK',\$tag);

\t\t//================================================================
\t\t\$bbox_br = \$this->blk[1]['border_right']['w'];
\t\t\$bbox_bl = \$this->blk[1]['border_left']['w'];
\t\t\$bbox_bt = \$this->blk[1]['border_top']['w'];
\t\t\$bbox_bb = \$this->blk[1]['border_bottom']['w'];
\t\t\$bbox_pr = \$this->blk[1]['padding_right'];
\t\t\$bbox_pl = \$this->blk[1]['padding_left'];
\t\t\$bbox_pt = \$this->blk[1]['padding_top'];
\t\t\$bbox_pb = \$this->blk[1]['padding_bottom'];
\t\t\$bbox_mr = \$this->blk[1]['margin_right'];
\t\tif (strtolower(\$p['MARGIN-RIGHT'])=='auto') { \$bbox_mr = 'auto'; }
\t\t\$bbox_ml = \$this->blk[1]['margin_left'];
\t\tif (strtolower(\$p['MARGIN-LEFT'])=='auto') { \$bbox_ml = 'auto'; }
\t\t\$bbox_mt = \$this->blk[1]['margin_top'];
\t\tif (strtolower(\$p['MARGIN-TOP'])=='auto') { \$bbox_mt = 'auto'; }
\t\t\$bbox_mb = \$this->blk[1]['margin_bottom'];
 \t\tif (strtolower(\$p['MARGIN-BOTTOM'])=='auto') { \$bbox_mb = 'auto'; }
\t\tif (isset(\$p['LEFT']) && strtolower(\$p['LEFT'])!='auto') { \$bbox_left = \$this->ConvertSize(\$p['LEFT'], \$cont_w, \$this->FontSize,false); }
\t\telse { \$bbox_left = 'auto'; }
 \t\tif (isset(\$p['TOP']) && strtolower(\$p['TOP'])!='auto') { \$bbox_top = \$this->ConvertSize(\$p['TOP'], \$cont_h, \$this->FontSize,false); }
\t\telse { \$bbox_top = 'auto'; }
 \t\tif (isset(\$p['RIGHT']) && strtolower(\$p['RIGHT'])!='auto') { \$bbox_right = \$this->ConvertSize(\$p['RIGHT'], \$cont_w, \$this->FontSize,false); }
\t\telse { \$bbox_right = 'auto'; }
 \t\tif (isset(\$p['BOTTOM']) && strtolower(\$p['BOTTOM'])!='auto') { \$bbox_bottom = \$this->ConvertSize(\$p['BOTTOM'], \$cont_h, \$this->FontSize,false); }
\t\telse { \$bbox_bottom = 'auto'; }
 \t\tif (isset(\$p['WIDTH']) && strtolower(\$p['WIDTH'])!='auto') { \$inner_w = \$this->ConvertSize(\$p['WIDTH'], \$cont_w, \$this->FontSize,false); }
\t\telse { \$inner_w = 'auto'; }
 \t\tif (isset(\$p['HEIGHT']) && strtolower(\$p['HEIGHT'])!='auto') { \$inner_h = \$this->ConvertSize(\$p['HEIGHT'], \$cont_h, \$this->FontSize,false); }
\t\telse { \$inner_h = 'auto'; }

\t\t// If bottom or right pos are set and not left / top - save this to adjust rotated block later
\t\tif (\$rotate) {
\t\t\tif (\$bbox_left === 'auto' && \$bbox_right !== 'auto') { \$rot_rpos = \$bbox_right; }
\t\t\telse { \$rot_rpos = false; }
\t\t\tif (\$bbox_top === 'auto' && \$bbox_bottom !== 'auto') { \$rot_bpos = \$bbox_bottom; }
\t\t\telse { \$rot_bpos = false; }
\t\t}

\t\t//================================================================
\t\tif (\$checkinnerhtml=='' && \$inner_h==='auto') { \$inner_h = 0.0001; }
\t\tif (\$checkinnerhtml=='' && \$inner_w==='auto') { \$inner_w = 2*\$this->GetCharWidth('W',false); }
\t\t//================================================================
\t\t// Algorithm from CSS2.1  See http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-height
\t\t// mPD 5.3.14
\t\t// Special case (not CSS) if all not specified, centre vertically on page
\t\tif (\$bbox_top==='auto' && \$inner_h==='auto' && \$bbox_bottom==='auto' && \$bbox_mt==='auto' && \$bbox_mb==='auto') {
\t\t\t\$bbox_top_orig = \$bbox_top;
\t\t\tif (\$bbox_mt==='auto') { \$bbox_mt = 0; }
\t\t\tif (\$bbox_mb==='auto') { \$bbox_mb = 0; }
\t\t\t\$bbox_top = \$orig_y0 - \$bbox_mt - \$cont_y;
\t\t\t// solve for \$bbox_bottom when content_h known - \$inner_h=='auto' && \$bbox_bottom=='auto'
\t\t}
\t\t// mPD 5.3.14
\t\telse if (\$bbox_top==='auto' && \$inner_h==='auto' && \$bbox_bottom==='auto') {
\t\t\t\$bbox_top_orig = \$bbox_top = \$orig_y0 - \$cont_y;
\t\t\tif (\$bbox_mt==='auto') { \$bbox_mt = 0; }
\t\t\tif (\$bbox_mb==='auto') { \$bbox_mb = 0; }
\t\t\t// solve for \$bbox_bottom when content_h known - \$inner_h=='auto' && \$bbox_bottom=='auto'
\t\t}
\t\telse if (\$bbox_top!=='auto' && \$inner_h!=='auto' && \$bbox_bottom!=='auto') {
\t\t\tif (\$bbox_mt==='auto' && \$bbox_mb==='auto') {
\t\t\t\t\$x = \$cont_h - \$bbox_top - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_bottom;
\t\t\t\t\$bbox_mt = \$bbox_mb = (\$x/2);
\t\t\t}
\t\t\telse if (\$bbox_mt==='auto') {
\t\t\t\t\$bbox_mt = \$cont_h - \$bbox_top - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mb - \$bbox_bottom;
\t\t\t}
\t\t\telse if (\$bbox_mb==='auto') {
\t\t\t\t\$bbox_mb = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_bottom;
\t\t\t}
\t\t\telse {
\t\t\t\t\$bbox_bottom = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mt;
\t\t\t}
\t\t}
\t\telse {
\t\t  if (\$bbox_mt==='auto') { \$bbox_mt = 0; }
\t\t  if (\$bbox_mb==='auto') { \$bbox_mb = 0; }
\t\t  if (\$bbox_top==='auto' && \$inner_h==='auto' && \$bbox_bottom!=='auto') {
\t\t\t// solve for \$bbox_top when content_h known - \$inner_h=='auto' && \$bbox_top =='auto'
\t\t  }
\t\t  else if (\$bbox_top==='auto' && \$bbox_bottom==='auto' && \$inner_h!=='auto') {
\t\t\t\$bbox_top = \$orig_y0 - \$bbox_mt - \$cont_y;
\t\t\t\$bbox_bottom = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mt;
\t\t  }
\t\t  else if (\$inner_h==='auto' && \$bbox_bottom==='auto' && \$bbox_top!=='auto') {
\t\t\t// solve for \$bbox_bottom when content_h known - \$inner_h=='auto' && \$bbox_bottom=='auto'
\t\t  }
\t\t  else if (\$bbox_top==='auto' && \$inner_h!=='auto' && \$bbox_bottom!=='auto') {
\t\t\t\$bbox_top = \$cont_h - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mt - \$bbox_bottom;
\t\t  }
\t\t  else if (\$inner_h==='auto' && \$bbox_top!=='auto' && \$bbox_bottom!=='auto') {
\t\t\t\$inner_h = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$bbox_pb - \$bbox_bb - \$bbox_mt - \$bbox_bottom;
\t\t  }
\t\t  else if (\$bbox_bottom==='auto' && \$bbox_top!=='auto' && \$inner_h!=='auto') {
\t\t\t\$bbox_bottom = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mt;
\t\t  }
\t\t}

\t\t// THEN DO SAME FOR WIDTH
\t\t// http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width
\t\tif (\$bbox_left==='auto' && \$inner_w==='auto' && \$bbox_right==='auto') {
\t\t\tif (\$bbox_ml==='auto') { \$bbox_ml = 0; }
\t\t\tif (\$bbox_mr==='auto') { \$bbox_mr = 0; }
\t\t\t// IF containing element RTL, should set \$bbox_right
\t\t\t\$bbox_left = \$orig_x0 - \$bbox_ml - \$cont_x;
\t\t\t// solve for \$bbox_right when content_w known - \$inner_w=='auto' && \$bbox_right=='auto'
\t\t}
\t\telse if (\$bbox_left!=='auto' && \$inner_w!=='auto' && \$bbox_right!=='auto') {
\t\t\tif (\$bbox_ml==='auto' && \$bbox_mr==='auto') {
\t\t\t\t\$x = \$cont_w - \$bbox_left - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_right;
\t\t\t\t\$bbox_ml = \$bbox_mr = (\$x/2);
\t\t\t}
\t\t\telse if (\$bbox_ml==='auto') {
\t\t\t\t\$bbox_ml = \$cont_w - \$bbox_left - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_mr - \$bbox_right;
\t\t\t}
\t\t\telse if (\$bbox_mr==='auto') {
\t\t\t\t\$bbox_mr = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_right;
\t\t\t}
\t\t\telse {
\t\t\t\t\$bbox_right = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_ml;
\t\t\t}
\t\t}
\t\telse {
\t\t  if (\$bbox_ml==='auto') { \$bbox_ml = 0; }
\t\t  if (\$bbox_mr==='auto') { \$bbox_mr = 0; }
\t\t  if (\$bbox_left==='auto' && \$inner_w==='auto' && \$bbox_right!=='auto') {
\t\t\t// solve for \$bbox_left when content_w known - \$inner_w=='auto' && \$bbox_left =='auto'
\t\t  }
\t\t  else if (\$bbox_left==='auto' && \$bbox_right==='auto' && \$inner_w!=='auto') {
\t\t\t// IF containing element RTL, should set \$bbox_right
\t\t\t\$bbox_left = \$orig_x0 - \$bbox_ml - \$cont_x;
\t\t\t\$bbox_right = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_ml;
\t\t  }
\t\t  else if (\$inner_w==='auto' && \$bbox_right==='auto' && \$bbox_left!=='auto') {
\t\t\t// solve for \$bbox_right when content_w known - \$inner_w=='auto' && \$bbox_right=='auto'
\t\t  }
\t\t  else if (\$bbox_left==='auto' && \$inner_w!=='auto' && \$bbox_right!=='auto') {
\t\t\t\$bbox_left = \$cont_w - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_ml - \$bbox_right;
\t\t  }
\t\t  else if (\$inner_w==='auto' && \$bbox_left!=='auto' && \$bbox_right!=='auto') {
\t\t\t\$inner_w = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$bbox_pr - \$bbox_br - \$bbox_ml - \$bbox_right;
\t\t  }
\t\t  else if (\$bbox_right==='auto' && \$bbox_left!=='auto' && \$inner_w!=='auto') {
\t\t\t\$bbox_right = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_ml;
\t\t  }
\t\t}

\t\t//================================================================
\t\t//================================================================
/*-- BACKGROUNDS --*/
\t\tif (isset(\$pb['BACKGROUND-IMAGE']) && \$pb['BACKGROUND-IMAGE']) {
\t\t\t\$ret = \$this->SetBackground(\$pb, \$this->blk[1]['inner_width']);
\t\t\tif (\$ret) { \$this->blk[1]['background-image'] = \$ret; }
\t\t}
/*-- END BACKGROUNDS --*/

\t\t//================================================================
\t\t\$y = \$cont_y + \$bbox_top + \$bbox_mt + \$bbox_bt + \$bbox_pt;
\t\t\$h = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$bbox_pb - \$bbox_bb - \$bbox_mb - \$bbox_bottom;
\t\t\$x = \$cont_x + \$bbox_left + \$bbox_ml + \$bbox_bl + \$bbox_pl;
\t\t\$w = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$bbox_pr - \$bbox_br - \$bbox_mr - \$bbox_right;
\t\t// Set (temporary) values for x y w h to do first paint, if values are auto
\t\tif (\$inner_h==='auto' && \$bbox_top==='auto') {
\t\t\t\$y = \$cont_y + \$bbox_mt + \$bbox_bt + \$bbox_pt;
\t\t\t\$h = \$cont_h - (\$bbox_bottom + \$bbox_mt + \$bbox_mb + \$bbox_bt + \$bbox_bb + \$bbox_pt + \$bbox_pb);
\t\t}
\t\telse if (\$inner_h==='auto' && \$bbox_bottom==='auto') {
\t\t\t\$y = \$cont_y + \$bbox_top + \$bbox_mt + \$bbox_bt + \$bbox_pt;
\t\t\t\$h = \$cont_h - (\$bbox_top + \$bbox_mt + \$bbox_mb + \$bbox_bt + \$bbox_bb + \$bbox_pt + \$bbox_pb);
\t\t}
\t\tif (\$inner_w==='auto' && \$bbox_left==='auto') {
\t\t\t\$x = \$cont_x + \$bbox_ml + \$bbox_bl + \$bbox_pl;
\t\t\t\$w = \$cont_w - (\$bbox_right + \$bbox_ml + \$bbox_mr + \$bbox_bl + \$bbox_br + \$bbox_pl + \$bbox_pr);
\t\t}
\t\telse if (\$inner_w==='auto' && \$bbox_right==='auto') {
\t\t\t\$x = \$cont_x + \$bbox_left + \$bbox_ml + \$bbox_bl + \$bbox_pl;
\t\t\t\$w = \$cont_w - (\$bbox_left + \$bbox_ml + \$bbox_mr + \$bbox_bl + \$bbox_br + \$bbox_pl + \$bbox_pr);
\t\t}
\t\t\$bbox_y = \$cont_y + \$bbox_top + \$bbox_mt;
\t\t\$bbox_x = \$cont_x + \$bbox_left + \$bbox_ml;
\t\t\$saved_block1 = \$this->blk[1];
\t\tunset(\$p);
\t\tunset(\$pb);
\t\t//================================================================
\t\tif (\$inner_w==='auto') { // do a first write
\t\t\t\$this->lMargin=\$x;
\t\t\t\$this->rMargin=\$this->w - \$w - \$x;
\t\t\t// SET POSITION & FONT VALUES
\t\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\t\$this->pageoutput[\$this->page]=array();
\t\t\t\$this->x = \$x;
\t\t\t\$this->y = \$y;
\t\t\t\$this->HTMLheaderPageLinks = array();
\t\t\t\$this->HTMLheaderPageAnnots = array();
\t\t\t\$this->HTMLheaderPageForms = array();
\t\t\t\$this->pageBackgrounds = array();
\t\t\t\$this->maxPosR = 0;
\t\t\t\$this->maxPosL = \$this->w;\t// For RTL
\t\t\t\$this->WriteHTML(\$html , 4);
\t\t\t\$inner_w = \$this->maxPosR - \$this->lMargin;
\t\t\tif (\$bbox_right==='auto') {
\t\t\t\t\$bbox_right = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_ml;
\t\t\t}
\t\t\telse if (\$bbox_left==='auto') {
\t\t\t\t\$bbox_left = \$cont_w - \$bbox_ml - \$bbox_bl - \$bbox_pl - \$inner_w - \$bbox_pr - \$bbox_br - \$bbox_ml - \$bbox_right;
\t\t\t\t\$bbox_x = \$cont_x + \$bbox_left + \$bbox_ml ;
\t\t\t\t\$inner_x = \$bbox_x + \$bbox_bl + \$bbox_pl;
\t\t\t\t\$x = \$inner_x;
\t\t\t}
\t\t\t\$w = \$inner_w;
\t\t\t\$bbox_y = \$cont_y + \$bbox_top + \$bbox_mt;
\t\t\t\$bbox_x = \$cont_x + \$bbox_left + \$bbox_ml;
\t\t}

\t\tif (\$inner_h==='auto') { // do a first write
\t\t\t\$this->lMargin=\$x;
\t\t\t\$this->rMargin=\$this->w - \$w - \$x;
\t\t\t// SET POSITION & FONT VALUES
\t\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\t\$this->pageoutput[\$this->page]=array();
\t\t\t\$this->x = \$x;
\t\t\t\$this->y = \$y;
\t\t\t\$this->HTMLheaderPageLinks = array();
\t\t\t\$this->HTMLheaderPageAnnots = array();
\t\t\t\$this->HTMLheaderPageForms = array();
\t\t\t\$this->pageBackgrounds = array();
\t\t\t\$this->WriteHTML(\$html , 4);
\t\t\t\$inner_h = \$this->y - \$y;
\t\t\tif (\$overflow!='hidden' && \$overflow!='visible') {\t// constrained
\t\t\t\tif ((\$this->y + \$bbox_pb + \$bbox_bb) > (\$cont_y + \$cont_h)) {
\t\t\t\t\t\$adj = (\$this->y + \$bbox_pb + \$bbox_bb) - (\$cont_y + \$cont_h);
\t\t\t\t\t\$inner_h -= \$adj;
\t\t\t\t}
\t\t\t}
\t\t\tif (\$bbox_bottom==='auto' && \$bbox_top_orig==='auto') {
\t\t\t\t\$bbox_bottom = \$bbox_top = (\$cont_h - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mb)/2;
\t\t\t\tif (\$overflow!='hidden' && \$overflow!='visible') {\t// constrained
\t\t\t\t\tif (\$bbox_top < 0) {
\t\t\t\t\t\t\$bbox_top = 0;
\t\t\t\t\t\t\$inner_h = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$bbox_pb - \$bbox_bb - \$bbox_mb - \$bbox_bottom;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\t\$bbox_y = \$cont_y + \$bbox_top + \$bbox_mt;
\t\t\t\t\$inner_y = \$bbox_y + \$bbox_bt + \$bbox_pt;
\t\t\t\t\$y = \$inner_y;

\t\t\t}
\t\t\telse if (\$bbox_bottom==='auto') {
\t\t\t\t\$bbox_bottom = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mb;
\t\t\t}
\t\t\telse if (\$bbox_top==='auto') {
\t\t\t\t\$bbox_top = \$cont_h - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$inner_h - \$bbox_pb - \$bbox_bb - \$bbox_mb - \$bbox_bottom;
\t\t\t\tif (\$overflow!='hidden' && \$overflow!='visible') {\t// constrained
\t\t\t\t\tif (\$bbox_top < 0) {
\t\t\t\t\t\t\$bbox_top = 0;
\t\t\t\t\t\t\$inner_h = \$cont_h - \$bbox_top - \$bbox_mt - \$bbox_bt - \$bbox_pt - \$bbox_pb - \$bbox_bb - \$bbox_mb - \$bbox_bottom;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\t\$bbox_y = \$cont_y + \$bbox_top + \$bbox_mt;
\t\t\t\t\$inner_y = \$bbox_y + \$bbox_bt + \$bbox_pt;
\t\t\t\t\$y = \$inner_y;
\t\t\t}
\t\t\t\$h = \$inner_h;
\t\t\t\$bbox_y = \$cont_y + \$bbox_top + \$bbox_mt;
\t\t\t\$bbox_x = \$cont_x + \$bbox_left + \$bbox_ml;
\t\t}
\t\t\$inner_w = \$w;
\t\t\$inner_h = \$h;

\t}
\t\$this->lMargin=\$x;
\t\$this->rMargin=\$this->w - \$w - \$x;
\t// SET POSITION & FONT VALUES
\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\$this->pageoutput[\$this->page]=array();
\t\$this->x = \$x;
\t\$this->y = \$y;
\t\$this->HTMLheaderPageLinks = array();
\t\$this->HTMLheaderPageAnnots = array();
\t\$this->HTMLheaderPageForms = array();
\t\$this->pageBackgrounds = array();
\t\$this->WriteHTML(\$html , 4);\t// parameter 4 saves output to \$this->headerbuffer
\t\$actual_h = \$this->y - \$y;
\t\$use_w = \$w;
\t\$use_h = \$h;
\t\$ratio = \$actual_h / \$use_w;

\tif (\$overflow!='hidden' && \$overflow!='visible') {
\t\t\$target = \$h/\$w;
\t\tif ((\$ratio / \$target ) > 1) {
\t\t\t\$nl = CEIL(\$actual_h / \$this->lineheight);
\t\t\t\$l = \$use_w * \$nl;
\t\t\t\$est_w = sqrt((\$l * \$this->lineheight) / \$target) * 0.8;
\t\t\t\$use_w += (\$est_w - \$use_w) - (\$w/100);
\t\t}
\t\t\$bpcstart = (\$ratio / \$target);
\t\t\$bpcctr = 1;
\t\twhile((\$ratio / \$target ) > 1) {

\t\t\tif (\$this->progressBar) { \$this->UpdateProgressBar(4,intval(100/(\$ratio/\$target)),('Auto-sizing fixed-position block: '.\$bpcctr++)); }\t// *PROGRESS-BAR*

\t\t\t\$this->x = \$x;
\t\t\t\$this->y = \$y;

\t\t\tif ((\$ratio / \$target) > 1.5 || (\$ratio / \$target) < 0.6) {
\t\t\t\t\$use_w += (\$w/\$this->incrementFPR1);
\t\t\t}
\t\t\telse if ((\$ratio / \$target) > 1.2 || (\$ratio / \$target) < 0.85) {
\t\t\t\t\$use_w += (\$w/\$this->incrementFPR2);
\t\t\t}
\t\t\telse if ((\$ratio / \$target) > 1.1 || (\$ratio / \$target) < 0.91) {
\t\t\t\t\$use_w += (\$w/\$this->incrementFPR3);
\t\t\t}
\t\t\telse {
\t\t\t\t\$use_w += (\$w/\$this->incrementFPR4);
\t\t\t}

\t\t\t\$use_h = \$use_w * \$target ;
\t\t\t\$this->rMargin=\$this->w - \$use_w - \$x;
\t\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\t\$this->HTMLheaderPageLinks = array();
\t\t\t\$this->HTMLheaderPageAnnots = array();
\t\t\t\$this->HTMLheaderPageForms = array();
\t\t\t\$this->pageBackgrounds = array();
\t\t\t\$this->WriteHTML(\$html , 4);\t// parameter 4 saves output to \$this->headerbuffer
\t\t\t\$actual_h = \$this->y - \$y;
\t\t\t\$ratio = \$actual_h / \$use_w;
\t\t}
\t\tif (\$this->progressBar) { \$this->UpdateProgressBar(4,'100',' '); }\t// *PROGRESS-BAR*
\t}
\t\$shrink_f = \$w/\$use_w;

\t//================================================================

\t\$this->pages[\$this->page] .= '___BEFORE_BORDERS___';
\t\$block_s = \$this->PrintPageBackgrounds();\t// Save to print later inside clipping path
\t\$this->pageBackgrounds = array();

\t//================================================================

\tif (\$rotate) {
\t\t\$prerotw = \$bbox_bl + \$bbox_pl + \$inner_w + \$bbox_pr + \$bbox_br;
\t\t\$preroth = \$bbox_bt + \$bbox_pt + \$inner_h + \$bbox_pb + \$bbox_bb;
\t\t\$rot_start = \" q\\n\";
\t\tif (\$rotate == 90) {
\t\t\tif (\$rot_rpos !== false) { \$adjw = \$prerotw; }\t// width before rotation
\t\t\telse { \$adjw = \$preroth; }\t// height before rotation
\t\t\tif (\$rot_bpos !== false) { \$adjh = -\$prerotw + \$preroth; }
\t\t\telse { \$adjh = 0; }
\t\t}
\t\telse {
\t\t\tif (\$rot_rpos !== false) { \$adjw = \$prerotw - \$preroth; }
\t\t\telse { \$adjw = 0; }
\t\t\tif (\$rot_bpos !== false) { \$adjh = \$preroth; }\t// height before rotation
\t\t\telse { \$adjh = \$prerotw; }\t// width before rotation
\t\t}
\t\t\$rot_start .= \$this->transformTranslate(\$adjw, \$adjh, true).\"\\n\";
\t\t\$rot_start .= \$this->transformRotate(\$rotate, \$bbox_x, \$bbox_y, true).\"\\n\";
\t\t\$rot_end = \" Q\\n\";
\t}
\telse {
\t\t\$rot_start = '';
\t\t\$rot_end = '';
\t}

\t//================================================================
\tif (!empty(\$bounding)) {
\t\t// WHEN HEIGHT // BOTTOM EDGE IS KNOWN and \$this->y is set to the bottom
\t\t// Re-instate saved \$this->blk[1]
\t\t\$this->blk[1] = \$saved_block1;

\t\t// These are only needed when painting border/background
\t\t\$this->blk[1]['width'] = \$bbox_w = \$cont_w - \$bbox_left - \$bbox_ml - \$bbox_mr - \$bbox_right;
\t\t\$this->blk[1]['x0'] = \$bbox_x;
\t\t\$this->blk[1]['y0'] = \$bbox_y;
\t\t\$this->blk[1]['startpage'] = \$this->page;
\t\t\$this->blk[1]['y1'] = \$bbox_y + \$bbox_bt + \$bbox_pt + \$inner_h + \$bbox_pb + \$bbox_bb ;
\t\t\$this->_out(\$rot_start);\t// mPDF 5.0
\t\t\$this->PaintDivBB('',0,1);\t// Prints borders and sets backgrounds in \$this->pageBackgrounds
\t\t\$this->_out(\$rot_end);
\t}

\t\$s = \$this->PrintPageBackgrounds();
\t\$s = \$rot_start.\$s.\$rot_end;
\t\$this->pages[\$this->page] = preg_replace('/___BEFORE_BORDERS___/', \"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\$this->pageBackgrounds = array();

\t\$this->_out(\$rot_start);

\t// Clipping Output
\tif (\$overflow=='hidden') {
\t\t//Bounding rectangle to clip
\t\t\$clip_y1 = \$this->y;
\t\tif (!empty(\$bounding) && (\$this->y + \$bbox_pb + \$bbox_bb) > (\$bbox_y + \$bbox_bt + \$bbox_pt + \$inner_h + \$bbox_pb + \$bbox_bb )) {
\t\t\t\$clip_y1 = (\$bbox_y + \$bbox_bt + \$bbox_pt + \$inner_h + \$bbox_pb + \$bbox_bb ) - (\$bbox_pb + \$bbox_bb);
\t\t}
\t\t//\$op = 'W* n';\t// Clipping
\t\t\$op = 'W n';\t// Clipping alternative mode
\t\t\$this->_out(\"q\");
\t\t\$ch = \$clip_y1 - \$y;
\t\t\$this->_out(sprintf('%.3F %.3F %.3F %.3F re %s',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$w*_MPDFK,-\$ch*_MPDFK,\$op));
\t\tif (!empty(\$block_s)) {
\t\t\t\$tmp = \"q\\n\".sprintf('%.3F %.3F %.3F %.3F re %s',\$x*_MPDFK,(\$this->h-\$y)*_MPDFK,\$w*_MPDFK,-\$ch*_MPDFK,\$op);
\t\t\t\$tmp .= \"\\n\".\$block_s.\"\\nQ\";
\t\t\t\$block_s = \$tmp ;
\t\t}
\t}


\tif (!empty(\$block_s)) {
\t\tif (\$shrink_f != 1) {\t// i.e. autofit has resized the box
\t\t\t\$tmp = \"q\\n\".\$this->transformScale((\$shrink_f*100),(\$shrink_f*100), \$x, \$y, true);
\t\t\t\$tmp .= \"\\n\".\$block_s.\"\\nQ\";
\t\t\t\$block_s = \$tmp ;
\t\t}
\t\t\$this->_out(\$block_s);
\t}



\tif (\$shrink_f != 1) {\t// i.e. autofit has resized the box
\t\t\$this->StartTransform();
\t\t\$this->transformScale((\$shrink_f*100),(\$shrink_f*100), \$x, \$y);
\t}

\t\$this->_out(\$this->headerbuffer);

\tif (\$shrink_f != 1) {\t// i.e. autofit has resized the box
\t\t\$this->StopTransform();
\t}

\tif (\$overflow=='hidden') {
\t\t//End clipping
\t\t\$this->_out(\"Q\");
\t}

\t\$this->_out(\$rot_end);


\t// Page Links
\tforeach(\$this->HTMLheaderPageLinks AS \$lk) {
\t\tif (\$rotate) {
\t\t\t\$tmp = \$lk[2];\t// Switch h - w
\t\t\t\$lk[2] = \$lk[3];
\t\t\t\$lk[3] = \$tmp;

\t\t\t\$lx1 = ((\$lk[0]/_MPDFK));
\t\t\t\$ly1 = ((\$this->h-(\$lk[1]/_MPDFK)));
\t\t\tif (\$rotate == 90) {
\t\t\t\t\$adjx = -(\$lx1-\$bbox_x) + (\$preroth - (\$ly1-\$bbox_y));
\t\t\t\t\$adjy = -(\$ly1-\$bbox_y) + (\$lx1-\$bbox_x);
\t\t\t\t\$lk[2] = -\$lk[2];
\t\t\t}
\t\t\telse if (\$rotate == -90) {
\t\t\t\t\$adjx = -(\$lx1-\$bbox_x) + (\$ly1-\$bbox_y);
\t\t\t\t\$adjy = -(\$ly1-\$bbox_y) - (\$lx1-\$bbox_x) + \$prerotw;
\t\t\t\t\$lk[3] = -\$lk[3];
\t\t\t}
\t\t\tif (\$rot_rpos !== false) { \$adjx += \$prerotw - \$preroth; }
\t\t\tif (\$rot_bpos !== false) { \$adjy += \$preroth - \$prerotw; }
\t\t\t\$lx1 += \$adjx;
\t\t\t\$ly1 += \$adjy;

\t\t\t\$lk[0] = \$lx1*_MPDFK;
\t\t\t\$lk[1] = (\$this->h-\$ly1)*_MPDFK;
\t\t}
\t\tif (\$shrink_f != 1) { \t// i.e. autofit has resized the box
\t\t\t\$lx1 = ((\$lk[0]/_MPDFK)-\$x);
\t\t\t\$lx2 = \$x + (\$lx1 * \$shrink_f);
\t\t\t\$lk[0] = \$lx2*_MPDFK;
\t\t\t\$ly1 = ((\$this->h-(\$lk[1]/_MPDFK))-\$y);
\t\t\t\$ly2 = \$y + (\$ly1 * \$shrink_f);
\t\t\t\$lk[1] = (\$this->h-\$ly2)*_MPDFK;
\t\t\t\$lk[2] *= \$shrink_f;\t// width
\t\t\t\$lk[3] *= \$shrink_f;\t// height
\t\t}
\t\t\$this->PageLinks[\$this->page][]=\$lk;
\t}

\tforeach(\$this->HTMLheaderPageForms AS \$n=>\$f) {
\t\tif (\$shrink_f != 1) { \t// i.e. autofit has resized the box
\t\t\t\$f['x'] = \$x + ((\$f['x'] -\$x) * \$shrink_f);
\t\t\t\$f['y'] = \$y + ((\$f['y'] -\$y) * \$shrink_f);
\t\t\t\$f['w'] *= \$shrink_f;
\t\t\t\$f['h'] *= \$shrink_f;
\t\t\t\$f['style']['fontsize'] *= \$shrink_f;
\t\t}
\t\t\$this->form->forms[\$f['n']] = \$f;
\t}
\t// Page Annotations
\tforeach(\$this->HTMLheaderPageAnnots AS \$lk) {
\t\tif (\$rotate) {
\t\t\tif (\$rotate == 90) {
\t\t\t\t\$adjx = -(\$lk['x']-\$bbox_x) + (\$preroth - (\$lk['y']-\$bbox_y));
\t\t\t\t\$adjy = -(\$lk['y']-\$bbox_y) + (\$lk['x']-\$bbox_x);
\t\t\t}
\t\t\telse if (\$rotate == -90) {
\t\t\t\t\$adjx = -(\$lk['x']-\$bbox_x) + (\$lk['y']-\$bbox_y);
\t\t\t\t\$adjy = -(\$lk['y']-\$bbox_y) - (\$lk['x']-\$bbox_x) + \$prerotw;
\t\t\t}
\t\t\tif (\$rot_rpos !== false) { \$adjx += \$prerotw - \$preroth; }
\t\t\tif (\$rot_bpos !== false) { \$adjy += \$preroth - \$prerotw; }
\t\t\t\$lk['x'] += \$adjx;
\t\t\t\$lk['y'] += \$adjy;
\t\t}
\t\tif (\$shrink_f != 1) { \t// i.e. autofit has resized the box
\t\t\t\$lk['x'] = \$x + ((\$lk['x']-\$x) * \$shrink_f);
\t\t\t\$lk['y'] = \$y + ((\$lk['y']-\$y) * \$shrink_f);
\t\t}
\t\t\$this->PageAnnots[\$this->page][]=\$lk;
\t}

\t// Restore
\t\$this->headerbuffer = '';
\t\$this->HTMLheaderPageLinks = array();
\t\$this->HTMLheaderPageAnnots = array();
\t\$this->HTMLheaderPageForms = array();
\t\$this->pageBackgrounds = \$save_bgs;
\t\$this->writingHTMLheader = false;

\t\$this->writingHTMLfooter = false;
\t\$this->fullImageHeight = false;
\t\$this->ResetMargins();
\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\$this->SetXY(\$save_x,\$save_y) ;
\t\$this->title2annots = \$save_annots;\t// *ANNOTATIONS*
\t\$this->InFooter = false;\t// turns back on autopagebreaks
\t\$this->pageoutput[\$this->page]=array();
\t\$this->pageoutput[\$this->page]['Font']='';
/*-- COLUMNS --*/
\tif (\$save_cols) {
\t\t\$this->SetColumns(\$save_nbcol,\$this->colvAlign,\$this->ColGap);
\t}
/*-- END COLUMNS --*/
}
/*-- END CSS-POSITION --*/



function initialiseBlock(&\$blk) {
\t\$blk['margin_top'] = 0;
\t\$blk['margin_left'] = 0;
\t\$blk['margin_bottom'] = 0;
\t\$blk['margin_right'] = 0;
\t\$blk['padding_top'] = 0;
\t\$blk['padding_left'] = 0;
\t\$blk['padding_bottom'] = 0;
\t\$blk['padding_right'] = 0;
\t\$blk['border_top']['w'] = 0;
\t\$blk['border_left']['w'] = 0;
\t\$blk['border_bottom']['w'] = 0;
\t\$blk['border_right']['w'] = 0;
\t\$blk['hide'] = false;
\t\$blk['outer_left_margin'] = 0;
\t\$blk['outer_right_margin'] = 0;
\t\$blk['cascadeCSS'] = array();
\t\$blk['block-align'] = false;
\t\$blk['bgcolor'] = false;
\t\$blk['page_break_after_avoid'] = false;
\t\$blk['keep_block_together'] = false;
\t\$blk['float'] = false;
\t\$blk['line_height'] = '';
\t\$blk['margin_collapse'] = false;
}


function border_details(\$bd) {
\t\$prop = preg_split('/\\s+/',trim(\$bd));

\tif (isset(\$this->blk[\$this->blklvl]['inner_width'])) { \$refw = \$this->blk[\$this->blklvl]['inner_width']; }
\telse if (isset(\$this->blk[\$this->blklvl-1]['inner_width'])) { \$refw = \$this->blk[\$this->blklvl-1]['inner_width']; }
\telse { \$refw = \$this->w; }
\tif ( count(\$prop) == 1 ) {
\t\t\$bsize = \$this->ConvertSize(\$prop[0],\$refw,\$this->FontSize,false);
\t\tif (\$bsize > 0) {
\t\t\treturn array('s' => 1, 'w' => \$bsize, 'c' => \$this->ConvertColor(0), 'style'=>'solid');
\t\t}
\t\telse { return array('w' => 0, 's' => 0); }
\t}

\telse if (count(\$prop) == 2 ) {
\t\t// 1px solid
\t\tif (in_array(\$prop[1],\$this->borderstyles) || \$prop[1] == 'none' || \$prop[1] == 'hidden' ) { \$prop[2] = ''; }
\t\t// solid #000000
\t\telse if (in_array(\$prop[0],\$this->borderstyles) || \$prop[0] == 'none' || \$prop[0] == 'hidden' ) { \$prop[0] = ''; \$prop[1] = \$prop[0]; \$prop[2] = \$prop[1]; }
\t\t// 1px #000000
\t\telse { \$prop[1] = ''; \$prop[2] = \$prop[1]; }
\t}
\telse if ( count(\$prop) == 3 ) {
\t\t// Change #000000 1px solid to 1px solid #000000 (proper)
\t\tif (substr(\$prop[0],0,1) == '#') { \$tmp = \$prop[0]; \$prop[0] = \$prop[1]; \$prop[1] = \$prop[2]; \$prop[2] = \$tmp; }
\t\t// Change solid #000000 1px to 1px solid #000000 (proper)
\t\telse if (substr(\$prop[0],1,1) == '#') { \$tmp = \$prop[1]; \$prop[0] = \$prop[2]; \$prop[1] = \$prop[0]; \$prop[2] = \$tmp; }
\t\t// Change solid 1px #000000 to 1px solid #000000 (proper)
\t\telse if (in_array(\$prop[0],\$this->borderstyles) || \$prop[0] == 'none' || \$prop[0] == 'hidden' ) {
\t\t\t\$tmp = \$prop[0]; \$prop[0] = \$prop[1]; \$prop[1] = \$tmp;
\t\t}
\t}
\telse { return array(); }
\t// Size
\t\$bsize = \$this->ConvertSize(\$prop[0],\$refw,\$this->FontSize,false);
\t//color
\t\$coul = \$this->ConvertColor(\$prop[2]);\t// returns array
\t// Style
\t\$prop[1] = strtolower(\$prop[1]);
\tif (in_array(\$prop[1],\$this->borderstyles) && \$bsize > 0) { \$on = 1; }
\telse if (\$prop[1] == 'hidden') { \$on = 1; \$bsize = 0; \$coul = ''; }
\telse if (\$prop[1] == 'none') { \$on = 0; \$bsize = 0; \$coul = ''; }
\telse { \$on = 0; \$bsize = 0; \$coul = ''; \$prop[1] = ''; }
\treturn array('s' => \$on, 'w' => \$bsize, 'c' => \$coul, 'style'=> \$prop[1] );
}



/*-- END HTML-CSS --*/


// Return either a number (factor) - based on current set fontsize (if % or em) - or exact lineheight (with 'mm' after it)
function fixLineheight(\$v) {
\t\$lh = false;
\tif (preg_match('/^[0-9\\.,]*\$/',\$v) && \$v >= 0) { return (\$v + 0); }
\telse if (strtoupper(\$v) == 'NORMAL') {
\t\treturn \$this->normalLineheight;
\t}
\telse {
\t\t\$tlh = \$this->ConvertSize(\$v,\$this->FontSize,\$this->FontSize,true);
\t\tif (\$tlh) { return (\$tlh.'mm'); }
\t}
\treturn \$this->normalLineheight;
}


/*-- BORDER-RADIUS --*/
function _borderPadding(\$a, \$b, &\$px, &\$py) {
\t// \$px and py are padding long axis (x) and short axis (y)
\t\$added = 0;\t// extra padding

\t\$x = \$a-\$px;
\t\$y = \$b-\$py;
\t// Check if Falls within ellipse of border radius
\tif ( ( ((\$x+\$added)*(\$x+\$added))/(\$a*\$a) + ((\$y+\$added)*(\$y+\$added))/(\$b*\$b) ) <=1 ) { return false; }

\t\$t = atan2(\$y,\$x);

\t\$newx = \$b / sqrt(((\$b*\$b)/(\$a*\$a)) + ( tan(\$t) * tan(\$t) )  );
\t\$newy = \$a / sqrt(((\$a*\$a)/(\$b*\$b)) + ( (1/tan(\$t)) * (1/tan(\$t)) )  );
\t\$px = max(\$px, \$a - \$newx + \$added);
\t\$py = max(\$py, \$b - \$newy + \$added);
}
/*-- END BORDER-RADIUS --*/



/*-- HTML-CSS --*/


/*-- CSS-PAGE --*/
function SetPagedMediaCSS(\$name='', \$first, \$oddEven) {
\tif (\$oddEven == 'E') {
\t\tif (\$this->directionality=='rtl') { \$side = 'R'; }
\t\telse { \$side = 'L'; }
\t}
\telse  {
\t\tif (\$this->directionality=='rtl') { \$side = 'L'; }
\t\telse { \$side = 'R'; }
\t}
\t\$name = strtoupper(\$name);
\t\$p = array();
\t\$p['SIZE'] = 'AUTO';

\t// Uses mPDF original margins as default
\t\$p['MARGIN-RIGHT'] = strval(\$this->orig_rMargin).'mm';
\t\$p['MARGIN-LEFT'] = strval(\$this->orig_lMargin).'mm';
\t\$p['MARGIN-TOP'] = strval(\$this->orig_tMargin).'mm';
\t\$p['MARGIN-BOTTOM'] = strval(\$this->orig_bMargin).'mm';
\t\$p['MARGIN-HEADER'] = strval(\$this->orig_hMargin).'mm';
\t\$p['MARGIN-FOOTER'] = strval(\$this->orig_fMargin).'mm';

\t// Basic page + selector
\tif (isset(\$this->cssmgr->CSS['@PAGE'])) { \$zp = \$this->cssmgr->CSS['@PAGE']; }
\telse { \$zp = array(); }
\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp); }

\tif (isset(\$p['EVEN-HEADER-NAME']) && \$oddEven=='E') {
\t\t\$p['HEADER'] = \$p['EVEN-HEADER-NAME']; unset(\$p['EVEN-HEADER-NAME']);
\t}
\tif (isset(\$p['ODD-HEADER-NAME']) && \$oddEven!='E') {
\t\t\$p['HEADER'] = \$p['ODD-HEADER-NAME']; unset(\$p['ODD-HEADER-NAME']);
\t}
\tif (isset(\$p['EVEN-FOOTER-NAME']) && \$oddEven=='E') {
\t\t\$p['FOOTER'] = \$p['EVEN-FOOTER-NAME']; unset(\$p['EVEN-FOOTER-NAME']);
\t}
\tif (isset(\$p['ODD-FOOTER-NAME']) && \$oddEven!='E') {
\t\t\$p['FOOTER'] = \$p['ODD-FOOTER-NAME']; unset(\$p['ODD-FOOTER-NAME']);
\t}

\t// If right/Odd page
\tif (isset(\$this->cssmgr->CSS['@PAGE>>PSEUDO>>RIGHT']) && \$side=='R') {
\t\t\$zp = \$this->cssmgr->CSS['@PAGE>>PSEUDO>>RIGHT'];
\t}
\telse { \$zp = array(); }
\tif (isset(\$zp['SIZE'])) { unset(\$zp['SIZE']); }
\tif (isset(\$zp['SHEET-SIZE'])) { unset(\$zp['SHEET-SIZE']); }
\t// Disallow margin-left or -right on :LEFT or :RIGHT
\tif (isset(\$zp['MARGIN-LEFT'])) { unset(\$zp['MARGIN-LEFT']); }
\tif (isset(\$zp['MARGIN-RIGHT'])) { unset(\$zp['MARGIN-RIGHT']); }
\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp); }

\t// If left/Even page
\tif (isset(\$this->cssmgr->CSS['@PAGE>>PSEUDO>>LEFT']) && \$side=='L') {
\t\t\$zp = \$this->cssmgr->CSS['@PAGE>>PSEUDO>>LEFT'];
\t}
\telse { \$zp = array(); }
\tif (isset(\$zp['SIZE'])) { unset(\$zp['SIZE']); }
\tif (isset(\$zp['SHEET-SIZE'])) { unset(\$zp['SHEET-SIZE']); }
\t// Disallow margin-left or -right on :LEFT or :RIGHT
\tif (isset(\$zp['MARGIN-LEFT'])) { unset(\$zp['MARGIN-LEFT']); }
\tif (isset(\$zp['MARGIN-RIGHT'])) { unset(\$zp['MARGIN-RIGHT']); }
\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp);  }

\t// If first page
\tif (isset(\$this->cssmgr->CSS['@PAGE>>PSEUDO>>FIRST']) && \$first) { \$zp = \$this->cssmgr->CSS['@PAGE>>PSEUDO>>FIRST']; }
\telse { \$zp = array(); }
\tif (isset(\$zp['SIZE'])) { unset(\$zp['SIZE']); }
\tif (isset(\$zp['SHEET-SIZE'])) { unset(\$zp['SHEET-SIZE']); }
\t// Disallow margin-left or -right on :FIRST\t// mPDF 5.7.3
\tif (isset(\$zp['MARGIN-LEFT'])) { unset(\$zp['MARGIN-LEFT']); }
\tif (isset(\$zp['MARGIN-RIGHT'])) { unset(\$zp['MARGIN-RIGHT']); }
\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp); }

\t// If named page
\tif (\$name) {
\t\tif (isset(\$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name])) { \$zp = \$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name]; }
\t\telse { \$zp = array(); }
\t\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp); }

\t\tif (isset(\$p['EVEN-HEADER-NAME']) && \$oddEven=='E') {
\t\t\t\$p['HEADER'] = \$p['EVEN-HEADER-NAME']; unset(\$p['EVEN-HEADER-NAME']);
\t\t}
\t\tif (isset(\$p['ODD-HEADER-NAME']) && \$oddEven!='E') {
\t\t\t\$p['HEADER'] = \$p['ODD-HEADER-NAME']; unset(\$p['ODD-HEADER-NAME']);
\t\t}
\t\tif (isset(\$p['EVEN-FOOTER-NAME']) && \$oddEven=='E') {
\t\t\t\$p['FOOTER'] = \$p['EVEN-FOOTER-NAME']; unset(\$p['EVEN-FOOTER-NAME']);
\t\t}
\t\tif (isset(\$p['ODD-FOOTER-NAME']) && \$oddEven!='E') {
\t\t\t\$p['FOOTER'] = \$p['ODD-FOOTER-NAME']; unset(\$p['ODD-FOOTER-NAME']);
\t\t}

\t\t// If named right/Odd page
\t\tif (isset(\$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name.'>>PSEUDO>>RIGHT']) && \$side=='R') { \$zp = \$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name.'>>PSEUDO>>RIGHT']; }
\t\telse { \$zp = array(); }
\t\tif (isset(\$zp['SIZE'])) { unset(\$zp['SIZE']); }
\t\tif (isset(\$zp['SHEET-SIZE'])) { unset(\$zp['SHEET-SIZE']); }
\t\t// Disallow margin-left or -right on :LEFT or :RIGHT
\t\tif (isset(\$zp['MARGIN-LEFT'])) { unset(\$zp['MARGIN-LEFT']); }
\t\tif (isset(\$zp['MARGIN-RIGHT'])) { unset(\$zp['MARGIN-RIGHT']); }
\t\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp); }

\t\t// If named left/Even page
\t\tif (isset(\$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name.'>>PSEUDO>>LEFT']) && \$side=='L') { \$zp = \$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name.'>>PSEUDO>>LEFT']; }
\t\telse { \$zp = array(); }
\t\tif (isset(\$zp['SIZE'])) { unset(\$zp['SIZE']); }
\t\tif (isset(\$zp['SHEET-SIZE'])) { unset(\$zp['SHEET-SIZE']); }
\t\t// Disallow margin-left or -right on :LEFT or :RIGHT
\t\tif (isset(\$zp['MARGIN-LEFT'])) { unset(\$zp['MARGIN-LEFT']); }
\t\tif (isset(\$zp['MARGIN-RIGHT'])) { unset(\$zp['MARGIN-RIGHT']); }
\t\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp); }

\t\t// If named first page
\t\tif (isset(\$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name.'>>PSEUDO>>FIRST']) && \$first) { \$zp = \$this->cssmgr->CSS['@PAGE>>NAMED>>'.\$name.'>>PSEUDO>>FIRST']; }
\t\telse { \$zp = array(); }
\t\tif (isset(\$zp['SIZE'])) { unset(\$zp['SIZE']); }
\t\tif (isset(\$zp['SHEET-SIZE'])) { unset(\$zp['SHEET-SIZE']); }
\t\t// Disallow margin-left or -right on :FIRST\t// mPDF 5.7.3
\t\tif (isset(\$zp['MARGIN-LEFT'])) { unset(\$zp['MARGIN-LEFT']); }
\t\tif (isset(\$zp['MARGIN-RIGHT'])) { unset(\$zp['MARGIN-RIGHT']); }
\t\tif (is_array(\$zp) && !empty(\$zp)) { \$p = array_merge(\$p,\$zp); }
\t}

\t\$orientation = \$mgl = \$mgr = \$mgt = \$mgb = \$mgh = \$mgf = '';
\t\$header = \$footer = '';
\t\$resetpagenum = \$pagenumstyle = \$suppress = '';
\t\$marks = '';
\t\$bg = array();

\t\$newformat = '';


\tif (isset(\$p['SHEET-SIZE']) && is_array(\$p['SHEET-SIZE'])) {
\t\t\$newformat = \$p['SHEET-SIZE'];
\t\tif (\$newformat[0] > \$newformat[1]) { // landscape
\t\t\t\$newformat = array_reverse(\$newformat);
\t\t\t\$p['ORIENTATION'] = 'L';
\t\t}
\t\telse { \$p['ORIENTATION'] = 'P'; }
\t\t\$this->_setPageSize(\$newformat, \$p['ORIENTATION']);
\t}

\tif (isset(\$p['SIZE']) && is_array(\$p['SIZE']) && !\$newformat) {
\t\tif (\$p['SIZE']['W'] > \$p['SIZE']['H']) { \$p['ORIENTATION'] = 'L'; }
\t\telse { \$p['ORIENTATION'] = 'P'; }
\t}

\tif (is_array(\$p['SIZE'])) {
\t\tif (\$p['SIZE']['W'] > \$this->fw) { \$p['SIZE']['W'] = \$this->fw; }\t// mPD 4.2 use fw not fPt
\t\tif (\$p['SIZE']['H'] > \$this->fh) { \$p['SIZE']['H'] = \$this->fh; }
\t\tif ((\$p['ORIENTATION']==\$this->DefOrientation && !\$newformat) || (\$newformat && \$p['ORIENTATION']=='P')) {
\t\t\t\$outer_width_LR = (\$this->fw - \$p['SIZE']['W'])/2;
\t\t\t\$outer_width_TB = (\$this->fh - \$p['SIZE']['H'])/2;
\t\t}
\t\telse {
\t\t\t\$outer_width_LR = (\$this->fh - \$p['SIZE']['W'])/2;
\t\t\t\$outer_width_TB = (\$this->fw - \$p['SIZE']['H'])/2;
\t\t}
\t\t\$pgw = \$p['SIZE']['W'];
\t\t\$pgh = \$p['SIZE']['H'];
\t}
\telse {\t// AUTO LANDSCAPE PORTRAIT
\t\t\$outer_width_LR = 0;
\t\t\$outer_width_TB = 0;
\t\tif (!\$newformat) {
\t\t\tif (strtoupper(\$p['SIZE']) == 'AUTO') { \$p['ORIENTATION']=\$this->DefOrientation; }
\t\t\telse if (strtoupper(\$p['SIZE']) == 'LANDSCAPE') { \$p['ORIENTATION']='L'; }
\t\t\telse { \$p['ORIENTATION']='P'; }
\t\t}
\t\tif ((\$p['ORIENTATION']==\$this->DefOrientation && !\$newformat) || (\$newformat && \$p['ORIENTATION']=='P')) {
\t\t\t\$pgw = \$this->fw;
\t\t\t\$pgh = \$this->fh;
\t\t}
\t\telse {
\t\t\t\$pgw = \$this->fh;
\t\t\t\$pgh = \$this->fw;
\t\t}
\t}

\tif (isset(\$p['HEADER']) && \$p['HEADER']) { \$header = \$p['HEADER']; }
\tif (isset(\$p['FOOTER']) && \$p['FOOTER']) { \$footer = \$p['FOOTER']; }
\tif (isset(\$p['RESETPAGENUM']) && \$p['RESETPAGENUM']) { \$resetpagenum = \$p['RESETPAGENUM']; }
\tif (isset(\$p['PAGENUMSTYLE']) && \$p['PAGENUMSTYLE']) { \$pagenumstyle = \$p['PAGENUMSTYLE']; }
\tif (isset(\$p['SUPPRESS']) && \$p['SUPPRESS']) { \$suppress = \$p['SUPPRESS']; }

  \tif (preg_match('/cross/i', \$p['MARKS']) && preg_match('/crop/i', \$p['MARKS'])) { \$marks = 'CROPCROSS'; }
  \telse if (strtoupper(\$p['MARKS']) == 'CROP') { \$marks = 'CROP'; }
  \telse if (strtoupper(\$p['MARKS']) == 'CROSS') { \$marks = 'CROSS'; }


\tif (isset(\$p['BACKGROUND-COLOR']) && \$p['BACKGROUND-COLOR']) { \$bg['BACKGROUND-COLOR'] = \$p['BACKGROUND-COLOR']; }
/*-- BACKGROUNDS --*/
\tif (isset(\$p['BACKGROUND-GRADIENT']) && \$p['BACKGROUND-GRADIENT']) { \$bg['BACKGROUND-GRADIENT'] = \$p['BACKGROUND-GRADIENT']; }
\tif (isset(\$p['BACKGROUND-IMAGE']) && \$p['BACKGROUND-IMAGE']) { \$bg['BACKGROUND-IMAGE'] = \$p['BACKGROUND-IMAGE']; }
\tif (isset(\$p['BACKGROUND-REPEAT']) && \$p['BACKGROUND-REPEAT']) { \$bg['BACKGROUND-REPEAT'] = \$p['BACKGROUND-REPEAT']; }
\tif (isset(\$p['BACKGROUND-POSITION']) && \$p['BACKGROUND-POSITION']) { \$bg['BACKGROUND-POSITION'] = \$p['BACKGROUND-POSITION']; }
\tif (isset(\$p['BACKGROUND-IMAGE-RESIZE']) && \$p['BACKGROUND-IMAGE-RESIZE']) { \$bg['BACKGROUND-IMAGE-RESIZE'] = \$p['BACKGROUND-IMAGE-RESIZE']; }
\tif (isset(\$p['BACKGROUND-IMAGE-OPACITY'])) { \$bg['BACKGROUND-IMAGE-OPACITY'] = \$p['BACKGROUND-IMAGE-OPACITY']; }
/*-- END BACKGROUNDS --*/

\tif (isset(\$p['MARGIN-LEFT'])) { \$mgl = \$this->ConvertSize(\$p['MARGIN-LEFT'],\$pgw) + \$outer_width_LR; }
\tif (isset(\$p['MARGIN-RIGHT'])) { \$mgr = \$this->ConvertSize(\$p['MARGIN-RIGHT'],\$pgw) + \$outer_width_LR; }
\tif (isset(\$p['MARGIN-BOTTOM'])) { \$mgb = \$this->ConvertSize(\$p['MARGIN-BOTTOM'],\$pgh) + \$outer_width_TB; }
\tif (isset(\$p['MARGIN-TOP'])) { \$mgt = \$this->ConvertSize(\$p['MARGIN-TOP'],\$pgh) + \$outer_width_TB; }
\tif (isset(\$p['MARGIN-HEADER'])) { \$mgh = \$this->ConvertSize(\$p['MARGIN-HEADER'],\$pgh) + \$outer_width_TB; }
\tif (isset(\$p['MARGIN-FOOTER'])) { \$mgf = \$this->ConvertSize(\$p['MARGIN-FOOTER'],\$pgh) + \$outer_width_TB; }

\tif (isset(\$p['ORIENTATION']) && \$p['ORIENTATION']) { \$orientation = \$p['ORIENTATION']; }
\t\$this->page_box['outer_width_LR'] = \$outer_width_LR;\t// Used in MARKS:crop etc.
\t\$this->page_box['outer_width_TB'] = \$outer_width_TB;

\treturn array(\$orientation,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$header,\$footer,\$bg,\$resetpagenum,\$pagenumstyle,\$suppress,\$marks,\$newformat);
}
/*-- END CSS-PAGE --*/



/*-- CSS-FLOAT --*/
// Added mPDF 3.0 Float DIV - CLEAR
function ClearFloats(\$clear, \$blklvl=0) {
\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$blklvl,true);
\t\$end = \$currpos = (\$this->page*1000 + \$this->y);
\tif (\$clear == 'BOTH' && (\$l_exists || \$r_exists)) {
\t\t\$this->pageoutput[\$this->page] = array();
\t\t\$end = max(\$l_max, \$r_max, \$currpos);
\t}
\telse if (\$clear == 'RIGHT' && \$r_exists) {
\t\t\$this->pageoutput[\$this->page] = array();
\t\t\$end = max(\$r_max, \$currpos);
\t}
\telse if (\$clear == 'LEFT' && \$l_exists ) {
\t\t\$this->pageoutput[\$this->page] = array();
\t\t\$end = max(\$l_max, \$currpos);
\t}
\telse { return; }
\t\$old_page = \$this->page;
\t\$new_page = intval(\$end/1000);
\tif (\$old_page != \$new_page) {
\t\t\$s = \$this->PrintPageBackgrounds();
\t\t// Writes after the marker so not overwritten later by page background etc.
\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\t\$this->pageBackgrounds = array();
\t\t\$this->page = \$new_page;
\t}
\t\$this->ResetMargins();
\t\$this->pageoutput[\$this->page] = array();
\t\$this->y = ((\$end*1000) % 1000000)/1000;\t// mod changes operands to integers before processing
}


// Added mPDF 3.0 Float DIV
function GetFloatDivInfo(\$blklvl=0,\$clear=false) {
\t// If blklvl specified, only returns floats at that level - for ClearFloats
\t\$l_exists = false;
\t\$r_exists = false;
\t\$l_max = 0;
\t\$r_max = 0;
\t\$l_width = 0;
\t\$r_width = 0;
\tif (count(\$this->floatDivs)) {
\t  \$currpos = (\$this->page*1000 + \$this->y);
\t  foreach(\$this->floatDivs AS \$f) {
\t    if ((\$clear && \$f['blockContext'] == \$this->blk[\$blklvl]['blockContext']) || (!\$clear && \$currpos >= \$f['startpos'] && \$currpos < (\$f['endpos']-0.001) && \$f['blklvl'] > \$blklvl && \$f['blockContext'] == \$this->blk[\$blklvl]['blockContext'])) {
\t\tif (\$f['side']=='L') {
\t\t\t\$l_exists= true;
\t\t\t\$l_max = max(\$l_max, \$f['endpos']);
\t\t\t\$l_width = max(\$l_width , \$f['w']);
\t\t}
\t\tif (\$f['side']=='R') {
\t\t\t\$r_exists= true;
\t\t\t\$r_max = max(\$r_max, \$f['endpos']);
\t\t\t\$r_width = max(\$r_width , \$f['w']);
\t\t}
\t    }
\t  }
\t}
\treturn array(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width);
}
/*-- END CSS-FLOAT --*/




function OpenTag(\$tag,\$attr)
{

  // What this gets: < \$tag \$attr['WIDTH']=\"90px\" > does not get content here </closeTag here>
  // Correct tags where HTML specifies optional end tags,
  // and/or does not allow nesting e.g. P inside P, or
  if (\$this->allow_html_optional_endtags) {
    if ((\$tag == 'P' || \$tag == 'DIV' || \$tag == 'H1' || \$tag == 'H2' || \$tag == 'H3' || \$tag == 'H4' || \$tag == 'H5' || \$tag == 'H6' || \$tag == 'UL' || \$tag == 'OL' || \$tag == 'TABLE' || \$tag=='PRE' || \$tag=='FORM' || \$tag=='ADDRESS' || \$tag=='BLOCKQUOTE' || \$tag=='CENTER' || \$tag=='DL' || \$tag == 'HR' || \$tag=='ARTICLE' || \$tag=='ASIDE' || \$tag=='FIELDSET' || \$tag=='HGROUP' || \$tag=='MAIN' || \$tag=='NAV' || \$tag=='SECTION' ) && \$this->lastoptionaltag == 'P') { \$this->CloseTag(\$this->lastoptionaltag ); }\t// mPDF 5.7.3
    if (\$tag == 'DD' && \$this->lastoptionaltag == 'DD') { \$this->CloseTag(\$this->lastoptionaltag ); }
    if (\$tag == 'DD' && \$this->lastoptionaltag == 'DT') { \$this->CloseTag(\$this->lastoptionaltag ); }
    if (\$tag == 'DT' && \$this->lastoptionaltag == 'DD') { \$this->CloseTag(\$this->lastoptionaltag ); }
    if (\$tag == 'DT' && \$this->lastoptionaltag == 'DT') { \$this->CloseTag(\$this->lastoptionaltag ); }
    if (\$tag == 'LI' && \$this->lastoptionaltag == 'LI') { \$this->CloseTag(\$this->lastoptionaltag ); }
    if ((\$tag == 'TD' || \$tag == 'TH') && \$this->lastoptionaltag == 'TD') { \$this->CloseTag(\$this->lastoptionaltag ); }\t// *TABLES*
    if ((\$tag == 'TD' || \$tag == 'TH') && \$this->lastoptionaltag == 'TH') { \$this->CloseTag(\$this->lastoptionaltag ); }\t// *TABLES*
    if (\$tag == 'TR' && \$this->lastoptionaltag == 'TR') { \$this->CloseTag(\$this->lastoptionaltag ); }\t// *TABLES*
    if (\$tag == 'TR' && \$this->lastoptionaltag == 'TD') { \$this->CloseTag(\$this->lastoptionaltag );  \$this->CloseTag('TR'); \$this->CloseTag('THEAD'); }\t// *TABLES*
    if (\$tag == 'TR' && \$this->lastoptionaltag == 'TH') { \$this->CloseTag(\$this->lastoptionaltag );  \$this->CloseTag('TR'); \$this->CloseTag('THEAD'); }\t// *TABLES*
    if (\$tag == 'OPTION' && \$this->lastoptionaltag == 'OPTION') { \$this->CloseTag(\$this->lastoptionaltag ); }
  }

  \$align = array('left'=>'L','center'=>'C','right'=>'R','top'=>'T','text-top'=>'TT','middle'=>'M','baseline'=>'BS','bottom'=>'B','text-bottom'=>'TB','justify'=>'J');

  \$this->ignorefollowingspaces=false;

  //Opening tag
  switch(\$tag){

     case 'DOTTAB':
\t\$objattr = array();
\t\$objattr['type'] = 'dottab';
\t\$dots=str_repeat('.', 3).\"  \";\t// minimum number of dots
\t\$objattr['width'] = \$this->GetStringWidth(\$dots);
\t\$objattr['margin_top'] = 0;
\t\$objattr['margin_bottom'] = 0;
\t\$objattr['margin_left'] = 0;
\t\$objattr['margin_right'] = 0;
\t\$objattr['height'] = 0;
\t\$objattr['colorarray'] = \$this->colorarray;
\t\$objattr['border_top']['w'] = 0;
\t\$objattr['border_bottom']['w'] = 0;
\t\$objattr['border_left']['w'] = 0;
\t\$objattr['border_right']['w'] = 0;

\t// mPDF 5.6.19
\t\$properties = \$this->cssmgr->MergeCSS('INLINE',\$tag,\$attr);\t// mPDF 5.6.33
\tif (isset(\$properties['OUTDENT'])) {\t// mPDF 5.6.33
\t\t\$objattr['outdent'] = \$this->ConvertSize(\$properties['OUTDENT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\telse if (isset(\$attr['OUTDENT'])) {
\t\t\$objattr['outdent'] = \$this->ConvertSize(\$attr['OUTDENT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\telse { \$objattr['outdent'] = 0; }

\t\$objattr['fontfamily'] = \$this->FontFamily;
\t\$objattr['fontsize'] = \$this->FontSizePt;

\t\$e = \"\\xbb\\xa4\\xactype=dottab,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
/*-- TABLES --*/
\t// Output it to buffers
\tif (\$this->tableLevel) {
\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\t\$this->cell[\$this->row][\$this->col]['s'] = 0 ;// reset
\t\t\$this->_saveCellTextBuffer(\$e);
\t}
\telse {
/*-- END TABLES --*/
\t\t\$this->_saveTextBuffer(\$e);
\t}\t// *TABLES*
\tbreak;

     case 'PAGEHEADER':
     case 'PAGEFOOTER':
\t\$this->ignorefollowingspaces = true;
\tif (\$attr['NAME']) { \$pname = \$attr['NAME']; }
\telse { \$pname = '_default'; }

\t\tif (\$tag=='PAGEHEADER') { \$p = &\$this->pageheaders[\$pname]; }
\t\telse { \$p = &\$this->pagefooters[\$pname]; }

\t\t\$p['L']=array();
\t\t\$p['C']=array();
\t\t\$p['R']=array();
\t\t\$p['L']['font-style'] = '';
\t\t\$p['C']['font-style'] = '';
\t\t\$p['R']['font-style'] = '';

\t\tif (isset(\$attr['CONTENT-LEFT'])) {
\t\t\t\$p['L']['content'] = \$attr['CONTENT-LEFT'];
\t\t}
\t\tif (isset(\$attr['CONTENT-CENTER'])) {
\t\t\t\$p['C']['content'] = \$attr['CONTENT-CENTER'];
\t\t}
\t\tif (isset(\$attr['CONTENT-RIGHT'])) {
\t\t\t\$p['R']['content'] = \$attr['CONTENT-RIGHT'];
\t\t}

\t\tif (isset(\$attr['HEADER-STYLE']) || isset(\$attr['FOOTER-STYLE'])) {\t// font-family,size,weight,style,color
\t\t\tif (\$tag=='PAGEHEADER') { \$properties = \$this->cssmgr->readInlineCSS(\$attr['HEADER-STYLE']); }
\t\t\telse { \$properties = \$this->cssmgr->readInlineCSS(\$attr['FOOTER-STYLE']); }
\t\t\tif (isset(\$properties['FONT-FAMILY'])) {
\t\t\t\t\$p['L']['font-family'] = \$properties['FONT-FAMILY'];
\t\t\t\t\$p['C']['font-family'] = \$properties['FONT-FAMILY'];
\t\t\t\t\$p['R']['font-family'] = \$properties['FONT-FAMILY'];
\t\t\t}
\t\t\tif (isset(\$properties['FONT-SIZE'])) {
\t\t\t\t\$p['L']['font-size'] = \$this->ConvertSize(\$properties['FONT-SIZE']) * _MPDFK;
\t\t\t\t\$p['C']['font-size'] = \$this->ConvertSize(\$properties['FONT-SIZE']) * _MPDFK;
\t\t\t\t\$p['R']['font-size'] = \$this->ConvertSize(\$properties['FONT-SIZE']) * _MPDFK;
\t\t\t}
\t\t\tif (isset(\$properties['FONT-WEIGHT']) && \$properties['FONT-WEIGHT']=='bold') {
\t\t\t\t\$p['L']['font-style'] = 'B';
\t\t\t\t\$p['C']['font-style'] = 'B';
\t\t\t\t\$p['R']['font-style'] = 'B';
\t\t\t}
\t\t\tif (isset(\$properties['FONT-STYLE']) && \$properties['FONT-STYLE']=='italic') {
\t\t\t\t\$p['L']['font-style'] .= 'I';
\t\t\t\t\$p['C']['font-style'] .= 'I';
\t\t\t\t\$p['R']['font-style'] .= 'I';
\t\t\t}
\t\t\tif (isset(\$properties['COLOR'])) {
\t\t\t\t\$p['L']['color'] = \$properties['COLOR'];
\t\t\t\t\$p['C']['color'] = \$properties['COLOR'];
\t\t\t\t\$p['R']['color'] = \$properties['COLOR'];
\t\t\t}
\t\t}
\t\tif (isset(\$attr['HEADER-STYLE-LEFT']) || isset(\$attr['FOOTER-STYLE-LEFT'])) {
\t\t\tif (\$tag=='PAGEHEADER') { \$properties = \$this->cssmgr->readInlineCSS(\$attr['HEADER-STYLE-LEFT']); }
\t\t\telse { \$properties = \$this->cssmgr->readInlineCSS(\$attr['FOOTER-STYLE-LEFT']); }
\t\t\tif (isset(\$properties['FONT-FAMILY'])) { \$p['L']['font-family'] = \$properties['FONT-FAMILY']; }
\t\t\tif (isset(\$properties['FONT-SIZE'])) { \$p['L']['font-size'] = \$this->ConvertSize(\$properties['FONT-SIZE']) * _MPDFK; }
\t\t\tif (isset(\$properties['FONT-WEIGHT']) && \$properties['FONT-WEIGHT']=='bold') { \$p['L']['font-style'] ='B'; }
\t\t\tif (isset(\$properties['FONT-STYLE']) && \$properties['FONT-STYLE']=='italic') { \$p['L']['font-style'] .='I'; }
\t\t\tif (isset(\$properties['COLOR'])) { \$p['L']['color'] = \$properties['COLOR']; }
\t\t}
\t\tif (isset(\$attr['HEADER-STYLE-CENTER']) || isset(\$attr['FOOTER-STYLE-CENTER'])) {
\t\t\tif (\$tag=='PAGEHEADER') { \$properties = \$this->cssmgr->readInlineCSS(\$attr['HEADER-STYLE-CENTER']); }
\t\t\telse { \$properties = \$this->cssmgr->readInlineCSS(\$attr['FOOTER-STYLE-CENTER']); }
\t\t\tif (isset(\$properties['FONT-FAMILY'])) { \$p['C']['font-family'] = \$properties['FONT-FAMILY']; }
\t\t\tif (isset(\$properties['FONT-SIZE'])) { \$p['C']['font-size'] = \$this->ConvertSize(\$properties['FONT-SIZE']) * _MPDFK; }
\t\t\tif (isset(\$properties['FONT-WEIGHT']) && \$properties['FONT-WEIGHT']=='bold') { \$p['C']['font-style'] = 'B'; }
\t\t\tif (isset(\$properties['FONT-STYLE']) && \$properties['FONT-STYLE']=='italic') { \$p['C']['font-style'] .= 'I'; }
\t\t\tif (isset(\$properties['COLOR'])) { \$p['C']['color'] = \$properties['COLOR']; }
\t\t}
\t\tif (isset(\$attr['HEADER-STYLE-RIGHT']) || isset(\$attr['FOOTER-STYLE-RIGHT'])) {
\t\t\tif (\$tag=='PAGEHEADER') { \$properties = \$this->cssmgr->readInlineCSS(\$attr['HEADER-STYLE-RIGHT']); }
\t\t\telse { \$properties = \$this->cssmgr->readInlineCSS(\$attr['FOOTER-STYLE-RIGHT']); }
\t\t\tif (isset(\$properties['FONT-FAMILY'])) { \$p['R']['font-family'] = \$properties['FONT-FAMILY']; }
\t\t\tif (isset(\$properties['FONT-SIZE'])) { \$p['R']['font-size'] = \$this->ConvertSize(\$properties['FONT-SIZE']) * _MPDFK; }
\t\t\tif (isset(\$properties['FONT-WEIGHT']) && \$properties['FONT-WEIGHT']=='bold') { \$p['R']['font-style'] = 'B'; }
\t\t\tif (isset(\$properties['FONT-STYLE']) && \$properties['FONT-STYLE']=='italic') { \$p['R']['font-style'] .= 'I'; }
\t\t\tif (isset(\$properties['COLOR'])) { \$p['R']['color'] = \$properties['COLOR']; }
\t\t}
\t\tif (isset(\$attr['LINE']) && \$attr['LINE']) {\t// 0|1|on|off
\t\t\tif (\$attr['LINE']=='1' || strtoupper(\$attr['LINE'])=='ON') { \$lineset=1; }
\t\t\telse { \$lineset=0; }
\t\t\t\$p['line'] = \$lineset;
\t\t}
\tbreak;


/*-- HTMLHEADERS-FOOTERS --*/
     case 'SETHTMLPAGEHEADER':
     case 'SETHTMLPAGEFOOTER':
\t\$this->ignorefollowingspaces = true;
\tif (isset(\$attr['NAME']) && \$attr['NAME']) { \$pname = \$attr['NAME']; }
\telse { \$pname = '_default'; }
\tif (isset(\$attr['PAGE']) && \$attr['PAGE']) { \t// O|odd|even|E|ALL|[blank]
\t\tif (strtoupper(\$attr['PAGE'])=='O' || strtoupper(\$attr['PAGE'])=='ODD') { \$side='odd'; }
\t\telse if (strtoupper(\$attr['PAGE'])=='E' || strtoupper(\$attr['PAGE'])=='EVEN') { \$side='even'; }
\t\telse if (strtoupper(\$attr['PAGE'])=='ALL') { \$side='both'; }
\t\telse { \$side='odd'; }
\t}
\telse { \$side='odd'; }
\tif (isset(\$attr['VALUE']) && \$attr['VALUE']) { \t// -1|1|on|off
\t\tif (\$attr['VALUE']=='1' || strtoupper(\$attr['VALUE'])=='ON') { \$set=1; }
\t\telse if (\$attr['VALUE']=='-1' || strtoupper(\$attr['VALUE'])=='OFF') { \$set=0; }
\t\telse { \$set=1; }
\t}
\telse { \$set=1; }
\tif (isset(\$attr['SHOW-THIS-PAGE']) && \$attr['SHOW-THIS-PAGE'] && \$tag=='SETHTMLPAGEHEADER') { \$write = 1; }
\telse { \$write = 0; }
\tif (\$side=='odd' || \$side=='both') {
\t\tif (\$set && \$tag=='SETHTMLPAGEHEADER') { \$this->SetHTMLHeader(\$this->pageHTMLheaders[\$pname],'O',\$write); }
\t\telse if (\$set && \$tag=='SETHTMLPAGEFOOTER') { \$this->SetHTMLFooter(\$this->pageHTMLfooters[\$pname],'O'); }
\t\telse if (\$tag=='SETHTMLPAGEHEADER') { \$this->SetHTMLHeader('','O'); }
\t\telse { \$this->SetHTMLFooter('','O'); }
\t}
\tif (\$side=='even' || \$side=='both') {
\t\tif (\$set && \$tag=='SETHTMLPAGEHEADER') { \$this->SetHTMLHeader(\$this->pageHTMLheaders[\$pname],'E',\$write); }
\t\telse if (\$set && \$tag=='SETHTMLPAGEFOOTER') { \$this->SetHTMLFooter(\$this->pageHTMLfooters[\$pname],'E'); }
\t\telse if (\$tag=='SETHTMLPAGEHEADER') { \$this->SetHTMLHeader('','E'); }
\t\telse { \$this->SetHTMLFooter('','E'); }
\t}
\tbreak;
/*-- END HTMLHEADERS-FOOTERS --*/

     case 'SETPAGEHEADER':
     case 'SETPAGEFOOTER':
\t\$this->ignorefollowingspaces = true;
\tif (isset(\$attr['NAME']) && \$attr['NAME']) { \$pname = \$attr['NAME']; }
\telse { \$pname = '_default'; }
\tif (isset(\$attr['PAGE']) && \$attr['PAGE']) { \t// O|odd|even|E|ALL|[blank]
\t\tif (strtoupper(\$attr['PAGE'])=='O' || strtoupper(\$attr['PAGE'])=='ODD') { \$side='odd'; }
\t\telse if (strtoupper(\$attr['PAGE'])=='E' || strtoupper(\$attr['PAGE'])=='EVEN') { \$side='even'; }
\t\telse if (strtoupper(\$attr['PAGE'])=='ALL') { \$side='both'; }
\t\telse { \$side='odd'; }
\t}
\telse { \$side='odd'; }
\tif (isset(\$attr['VALUE']) && \$attr['VALUE']) { \t// -1|1|on|off
\t\tif (\$attr['VALUE']=='1' || strtoupper(\$attr['VALUE'])=='ON') { \$set=1; }
\t\telse if (\$attr['VALUE']=='-1' || strtoupper(\$attr['VALUE'])=='OFF') { \$set=0; }
\t\telse { \$set=1; }
\t}
\telse { \$set=1; }
\tif (\$side=='odd' || \$side=='both') {
\t\tif (\$set && \$tag=='SETPAGEHEADER') { \$this->headerDetails['odd'] = \$this->pageheaders[\$pname]; }
\t\telse if (\$set && \$tag=='SETPAGEFOOTER') { \$this->footerDetails['odd'] = \$this->pagefooters[\$pname]; }
\t\telse if (\$tag=='SETPAGEHEADER') { \$this->headerDetails['odd'] = array(); }
\t\telse { \$this->footerDetails['odd'] = array(); }
\t\tif (!\$this->mirrorMargins || (\$this->page)%2!=0) {\t// ODD
\t\t\tif (\$tag=='SETPAGEHEADER') { \$this->_setAutoHeaderHeight(\$this->headerDetails['odd'],\$this->HTMLHeader); }
\t\t\tif (\$tag=='SETPAGEFOOTER') { \$this->_setAutoFooterHeight(\$this->footerDetails['odd'],\$this->HTMLFooter); }
\t\t}
\t}
\tif (\$side=='even' || \$side=='both') {
\t\tif (\$set && \$tag=='SETPAGEHEADER') { \$this->headerDetails['even'] = \$this->pageheaders[\$pname]; }
\t\telse if (\$set && \$tag=='SETPAGEFOOTER') { \$this->footerDetails['even'] = \$this->pagefooters[\$pname]; }
\t\telse if (\$tag=='SETPAGEHEADER') { \$this->headerDetails['even'] = array(); }
\t\telse { \$this->footerDetails['even'] = array(); }
\t\tif (\$this->mirrorMargins && (\$this->page)%2==0) {\t// EVEN
\t\t\tif (\$tag=='SETPAGEHEADER') { \$this->_setAutoHeaderHeight(\$this->headerDetails['even'],\$this->HTMLHeaderE); }
\t\t\tif (\$tag=='SETPAGEFOOTER') { \$this->_setAutoFooterHeight(\$this->footerDetails['even'],\$this->HTMLFooterE); }
\t\t}
\t}
\tif (isset(\$attr['SHOW-THIS-PAGE']) && \$attr['SHOW-THIS-PAGE'] && \$tag=='SETPAGEHEADER') {
\t\t\$this->Header();
\t}
\tbreak;


/*-- TOC --*/
     case 'TOC': //added custom-tag - set Marker for insertion later of ToC
\tif (!class_exists('tocontents', false)) { include(_MPDF_PATH.'classes/tocontents.php'); }
\tif (empty(\$this->tocontents)) { \$this->tocontents = new tocontents(\$this); }
\t\$this->tocontents->openTagTOC(\$attr);
\tbreak;



     case 'TOCPAGEBREAK': // custom-tag - set Marker for insertion later of ToC AND adds PAGEBREAK
\tif (!class_exists('tocontents', false)) { include(_MPDF_PATH.'classes/tocontents.php'); }
\tif (empty(\$this->tocontents)) { \$this->tocontents = new tocontents(\$this); }
\tlist(\$isbreak,\$toc_id) = \$this->tocontents->openTagTOCPAGEBREAK(\$attr);
\tif (\$isbreak) break;
\t// No break - continues as PAGEBREAK...
/*-- END TOC --*/


    case 'PAGE_BREAK': //custom-tag
    case 'PAGEBREAK': //custom-tag
    case 'NEWPAGE': //custom-tag
    case 'FORMFEED': //custom-tag

\t\$save_blklvl = \$this->blklvl;
\t\$save_blk = \$this->blk;
\t\$save_silp = \$this->saveInlineProperties();
\t\$save_ilp = \$this->InlineProperties;

\t// Close any open block tags
\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }
\tif(!empty(\$this->textbuffer))  {\t//Output previously buffered content
   \t  \t\$this->printbuffer(\$this->textbuffer);
        \t\$this->textbuffer=array();
      }
\t\$this->ignorefollowingspaces = true;
\t\$save_cols = false;
/*-- COLUMNS --*/
\tif (\$this->ColActive) {
\t\t\$save_cols = true;
\t\t\$save_nbcol = \$this->NbCol;\t// other values of gap and vAlign will not change by setting Columns off
\t\t\$this->SetColumns(0);
\t}
/*-- END COLUMNS --*/


\tif (isset(\$attr['SHEET-SIZE']) && \$tag != 'FORMFEED' && !\$this->restoreBlockPageBreaks) {
\t\t// Convert to same types as accepted in initial mPDF() A4, A4-L, or array(w,h)
\t\t\$prop = preg_split('/\\s+/',trim(\$attr['SHEET-SIZE']));
\t\tif (count(\$prop) == 2 ) {
\t\t\t\$newformat = array(\$this->ConvertSize(\$prop[0]), \$this->ConvertSize(\$prop[1]));
\t\t}
\t\telse { \$newformat = \$attr['SHEET-SIZE']; }
\t}
\telse { \$newformat = ''; }

\t\$mgr = \$mgl = \$mgt = \$mgb = \$mgh = \$mgf = '';
\tif (isset(\$attr['MARGIN-RIGHT'])) { \$mgr = \$this->ConvertSize(\$attr['MARGIN-RIGHT'],\$this->w,\$this->FontSize,false); }
\tif (isset(\$attr['MARGIN-LEFT'])) { \$mgl = \$this->ConvertSize(\$attr['MARGIN-LEFT'],\$this->w,\$this->FontSize,false); }
\tif (isset(\$attr['MARGIN-TOP'])) { \$mgt = \$this->ConvertSize(\$attr['MARGIN-TOP'],\$this->w,\$this->FontSize,false); }
\tif (isset(\$attr['MARGIN-BOTTOM'])) { \$mgb = \$this->ConvertSize(\$attr['MARGIN-BOTTOM'],\$this->w,\$this->FontSize,false); }
\tif (isset(\$attr['MARGIN-HEADER'])) { \$mgh = \$this->ConvertSize(\$attr['MARGIN-HEADER'],\$this->w,\$this->FontSize,false); }
\tif (isset(\$attr['MARGIN-FOOTER'])) { \$mgf = \$this->ConvertSize(\$attr['MARGIN-FOOTER'],\$this->w,\$this->FontSize,false); }
\t\$ohname = \$ehname = \$ofname = \$efname = '';
\tif (isset(\$attr['ODD-HEADER-NAME'])) { \$ohname = \$attr['ODD-HEADER-NAME']; }
\tif (isset(\$attr['EVEN-HEADER-NAME'])) { \$ehname = \$attr['EVEN-HEADER-NAME']; }
\tif (isset(\$attr['ODD-FOOTER-NAME'])) { \$ofname = \$attr['ODD-FOOTER-NAME']; }
\tif (isset(\$attr['EVEN-FOOTER-NAME'])) { \$efname = \$attr['EVEN-FOOTER-NAME']; }
\t\$ohvalue = \$ehvalue = \$ofvalue = \$efvalue = 0;
\tif (isset(\$attr['ODD-HEADER-VALUE']) && (\$attr['ODD-HEADER-VALUE']=='1' || strtoupper(\$attr['ODD-HEADER-VALUE'])=='ON')) { \$ohvalue = 1; }
\telse if (isset(\$attr['ODD-HEADER-VALUE']) && (\$attr['ODD-HEADER-VALUE']=='-1' || strtoupper(\$attr['ODD-HEADER-VALUE'])=='OFF')) { \$ohvalue = -1; }
\tif (isset(\$attr['EVEN-HEADER-VALUE']) && (\$attr['EVEN-HEADER-VALUE']=='1' || strtoupper(\$attr['EVEN-HEADER-VALUE'])=='ON')) { \$ehvalue = 1; }
\telse if (isset(\$attr['EVEN-HEADER-VALUE']) && (\$attr['EVEN-HEADER-VALUE']=='-1' || strtoupper(\$attr['EVEN-HEADER-VALUE'])=='OFF')) { \$ehvalue = -1; }
\tif (isset(\$attr['ODD-FOOTER-VALUE']) && (\$attr['ODD-FOOTER-VALUE']=='1' || strtoupper(\$attr['ODD-FOOTER-VALUE'])=='ON')) { \$ofvalue = 1; }
\telse if (isset(\$attr['ODD-FOOTER-VALUE']) && (\$attr['ODD-FOOTER-VALUE']=='-1' || strtoupper(\$attr['ODD-FOOTER-VALUE'])=='OFF')) { \$ofvalue = -1; }
\tif (isset(\$attr['EVEN-FOOTER-VALUE']) && (\$attr['EVEN-FOOTER-VALUE']=='1' || strtoupper(\$attr['EVEN-FOOTER-VALUE'])=='ON')) { \$efvalue = 1; }
\telse if (isset(\$attr['EVEN-FOOTER-VALUE']) && (\$attr['EVEN-FOOTER-VALUE']=='-1' || strtoupper(\$attr['EVEN-FOOTER-VALUE'])=='OFF')) { \$efvalue = -1; }

\tif (isset(\$attr['ORIENTATION']) && (strtoupper(\$attr['ORIENTATION'])=='L' || strtoupper(\$attr['ORIENTATION'])=='LANDSCAPE')) { \$orient = 'L'; }
\telse if (isset(\$attr['ORIENTATION']) && (strtoupper(\$attr['ORIENTATION'])=='P' || strtoupper(\$attr['ORIENTATION'])=='PORTRAIT')) { \$orient = 'P'; }
\telse { \$orient = \$this->CurOrientation; }

\tif (isset(\$attr['PAGE-SELECTOR']) && \$attr['PAGE-SELECTOR']) { \$pagesel = \$attr['PAGE-SELECTOR']; }
\telse { \$pagesel = ''; }

\t\$resetpagenum = '';
\t\$pagenumstyle = '';
\t\$suppress = '';
\tif (isset(\$attr['RESETPAGENUM'])) { \$resetpagenum = \$attr['RESETPAGENUM']; }
\tif (isset(\$attr['PAGENUMSTYLE'])) { \$pagenumstyle = \$attr['PAGENUMSTYLE']; }
\tif (isset(\$attr['SUPPRESS'])) { \$suppress = \$attr['SUPPRESS']; }

\tif (\$tag == 'TOCPAGEBREAK') { \$type = 'NEXT-ODD'; }
\telse if(isset(\$attr['TYPE'])) { \$type = strtoupper(\$attr['TYPE']); }
\telse { \$type = ''; }

\tif (\$type == 'E' || \$type == 'EVEN') { \$this->AddPage(\$orient,'E', \$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$ohname,\$ehname,\$ofname,\$efname,\$ohvalue,\$ehvalue,\$ofvalue,\$efvalue,\$pagesel,\$newformat); }
\telse if (\$type == 'O' || \$type == 'ODD') { \$this->AddPage(\$orient,'O', \$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$ohname,\$ehname,\$ofname,\$efname,\$ohvalue,\$ehvalue,\$ofvalue,\$efvalue,\$pagesel,\$newformat); }
\telse if (\$type == 'NEXT-ODD') { \$this->AddPage(\$orient,'NEXT-ODD', \$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$ohname,\$ehname,\$ofname,\$efname,\$ohvalue,\$ehvalue,\$ofvalue,\$efvalue,\$pagesel,\$newformat); }
\telse if (\$type == 'NEXT-EVEN') { \$this->AddPage(\$orient,'NEXT-EVEN', \$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$ohname,\$ehname,\$ofname,\$efname,\$ohvalue,\$ehvalue,\$ofvalue,\$efvalue,\$pagesel,\$newformat); }
\telse { \$this->AddPage(\$orient,'', \$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$ohname,\$ehname,\$ofname,\$efname,\$ohvalue,\$ehvalue,\$ofvalue,\$efvalue,\$pagesel,\$newformat); }

/*-- TOC --*/
\tif (\$tag == 'TOCPAGEBREAK') {
\t\tif (\$toc_id) { \$this->tocontents->m_TOC[\$toc_id]['TOCmark'] = \$this->page; }
\t\telse { \$this->tocontents->TOCmark = \$this->page; }
\t}
/*-- END TOC --*/

/*-- COLUMNS --*/
\tif (\$save_cols) {
\t\t// Restore columns
\t\t\$this->SetColumns(\$save_nbcol,\$this->colvAlign,\$this->ColGap);
\t}
/*-- END COLUMNS --*/
\tif ((\$tag == 'FORMFEED' || \$this->restoreBlockPagebreaks) && !\$this->tableLevel && !\$this->listlvl) {
\t\t\$this->blk = \$save_blk;
\t\t// Re-open block tags
\t\t\$t = \$this->blk[0]['tag'];
\t\t\$a = \$this->blk[0]['attr'];
\t\t\$this->blklvl = 0;
\t\tfor (\$b=0; \$b<=\$save_blklvl;\$b++) {
\t\t\t\$tc = \$t;
\t\t\t\$ac = \$a;
\t\t\t\$t = \$this->blk[\$b+1]['tag'];
\t\t\t\$a = \$this->blk[\$b+1]['attr'];
\t\t\tunset(\$this->blk[\$b+1]);
\t\t\t\$this->OpenTag(\$tc,\$ac);
\t\t}
\t\t\$this->InlineProperties = \$save_ilp;
\t\t\$this->restoreInlineProperties(\$save_silp);
\t}

\tbreak;


/*-- TOC --*/
     case 'TOCENTRY':
\tif (isset(\$attr['CONTENT']) && \$attr['CONTENT']) {
\t\t\$objattr = array();
\t\t\$objattr['CONTENT'] = htmlspecialchars_decode(\$attr['CONTENT'],ENT_QUOTES);
\t\t\$objattr['type'] = 'toc';
\t\tif (isset(\$attr['LEVEL']) && \$attr['LEVEL']) { \$objattr['toclevel'] = \$attr['LEVEL']; } else { \$objattr['toclevel'] = 0; }
\t\tif (isset(\$attr['NAME']) && \$attr['NAME']) { \$objattr['toc_id'] = \$attr['NAME']; } else { \$objattr['toc_id'] = 0; }
\t\t\$e = \"\\xbb\\xa4\\xactype=toc,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\tif(\$this->tableLevel) { \$this->cell[\$this->row][\$this->col]['textbuffer'][] = array(\$e); }\t// *TABLES*
\t\telse  {\t// *TABLES*
\t\t\t\$this->textbuffer[] = array(\$e);
\t\t}\t// *TABLES*
\t}
\tbreak;
/*-- END TOC --*/

/*-- INDEX --*/
     case 'INDEXENTRY':
\tif (isset(\$attr['CONTENT']) && \$attr['CONTENT']) {
\t\tif (isset(\$attr['XREF']) && \$attr['XREF']) {
\t\t\t\$this->IndexEntry(htmlspecialchars_decode(\$attr['CONTENT'],ENT_QUOTES),\$attr['XREF']);
\t\t\tbreak;
\t\t}
\t\t\$objattr = array();
\t\t\$objattr['CONTENT'] = htmlspecialchars_decode(\$attr['CONTENT'],ENT_QUOTES);
\t\t\$objattr['type'] = 'indexentry';
\t\t\$e = \"\\xbb\\xa4\\xactype=indexentry,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\tif(\$this->tableLevel) { \$this->cell[\$this->row][\$this->col]['textbuffer'][] = array(\$e); } \t// *TABLES*
\t\telse  {\t// *TABLES*
\t\t\t\$this->textbuffer[] = array(\$e);
\t\t}\t// *TABLES*
\t}
\tbreak;


     case 'INDEXINSERT':
\tif (isset(\$attr['FONT-SIZE'])) { \$reffontsize = \$attr['FONT-SIZE']; } else { \$reffontsize = ''; }
\tif (isset(\$attr['LINE-SPACING']) && \$attr['LINE-SPACING']) { \$linespacing = \$attr['LINE-SPACING']; } else { \$linespacing = ''; }
\tif (isset(\$attr['DIV-FONT-SIZE']) && \$attr['DIV-FONT-SIZE']) { \$divlettfontsize = \$attr['DIV-FONT-SIZE']; } else { \$divlettfontsize = ''; }
\tif (isset(\$attr['FONT']) && \$attr['FONT']) { \$reffont = \$attr['FONT']; } else { \$reffont = ''; }
\tif (isset(\$attr['DIV-FONT']) && \$attr['DIV-FONT']) { \$divlettfont = \$attr['DIV-FONT']; } else { \$divlettfont = ''; }
\tif (isset(\$attr['COLS']) && \$attr['COLS']) { \$cols = \$attr['COLS']; } else { \$cols = 1; }
\tif (isset(\$attr['OFFSET']) && \$attr['OFFSET']) { \$offset = \$attr['OFFSET']; } else { \$offset = 3; }
\tif (isset(\$attr['GAP']) && \$attr['GAP']) { \$gap = \$attr['GAP']; } else { \$gap = 5; }

\tif (isset(\$attr['USEDIVLETTERS']) && (strtoupper(\$attr['USEDIVLETTERS'])=='OFF' || \$attr['USEDIVLETTERS']==-1 || \$attr['USEDIVLETTERS']==='0')) { \$usedivletters = 0; }
\telse { \$usedivletters = 1; }

\tif (isset(\$attr['LINKS']) && (strtoupper(\$attr['LINKS'])=='ON' || \$attr['LINKS']==1)) { \$links = true; }
\telse { \$links = false; }
\t\$this->CreateIndex(\$cols, \$reffontsize, \$linespacing, \$offset, \$usedivletters, \$divlettfontsize, \$gap, \$reffont,\$divlettfont, \$links);
\tbreak;
/*-- END INDEX --*/

/*-- WATERMARK --*/

     case 'WATERMARKTEXT':
\tif (isset(\$attr['CONTENT']) && \$attr['CONTENT']) { \$txt = htmlspecialchars_decode(\$attr['CONTENT'],ENT_QUOTES); } else { \$txt = ''; }
\tif (isset(\$attr['ALPHA']) && \$attr['ALPHA']>0) { \$alpha = \$attr['ALPHA']; } else { \$alpha = -1; }
\t\$this->SetWatermarkText(\$txt, \$alpha);
\tbreak;


     case 'WATERMARKIMAGE':
\tif (isset(\$attr['SRC'])) { \$src = \$attr['SRC']; } else { \$src = ''; }
\tif (isset(\$attr['ALPHA']) && \$attr['ALPHA']>0) { \$alpha = \$attr['ALPHA']; } else { \$alpha = -1; }
\tif (isset(\$attr['SIZE']) && \$attr['SIZE']) {
\t\t\$size = \$attr['SIZE'];
\t\tif (strpos(\$size,',')) { \$size = explode(',',\$size); }
\t}
\telse { \$size = 'D'; }
\tif (isset(\$attr['POSITION']) && \$attr['POSITION']) {  \t// mPDF 5.7.2
\t\t\$pos = \$attr['POSITION'];
\t\tif (strpos(\$pos,',')) { \$pos = explode(',',\$pos); }
\t}
\telse { \$pos = 'P'; }
\t\$this->SetWatermarkImage(\$src, \$alpha, \$size, \$pos);
\tbreak;
/*-- END WATERMARK --*/

/*-- BOOKMARKS --*/
     case 'BOOKMARK':
\tif (isset(\$attr['CONTENT'])) {
\t\t\$objattr = array();
\t\t\$objattr['CONTENT'] = htmlspecialchars_decode(\$attr['CONTENT'],ENT_QUOTES);
\t\t\$objattr['type'] = 'bookmark';
\t\tif (isset(\$attr['LEVEL']) && \$attr['LEVEL']) { \$objattr['bklevel'] = \$attr['LEVEL']; } else { \$objattr['bklevel'] = 0; }
\t\t\$e = \"\\xbb\\xa4\\xactype=bookmark,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\tif(\$this->tableLevel) { \$this->cell[\$this->row][\$this->col]['textbuffer'][] = array(\$e); }\t// *TABLES*
\t\telse  {\t// *TABLES*
\t\t\t\$this->textbuffer[] = array(\$e);
\t\t}\t// *TABLES*
\t}
\tbreak;
/*-- END BOOKMARKS --*/

/*-- ANNOTATIONS --*/
     case 'ANNOTATION':

\t//if (isset(\$attr['CONTENT']) && !\$this->writingHTMLheader && !\$this->writingHTMLfooter) {\t// Stops annotations in FixedPos
\tif (isset(\$attr['CONTENT'])) {
\t\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;
\t\t\$objattr['CONTENT'] = htmlspecialchars_decode(\$attr['CONTENT'],ENT_QUOTES);
\t\t\$objattr['type'] = 'annot';
\t\t\$objattr['POPUP'] = '';
\t}
\telse { break; }
\tif (isset(\$attr['POS-X'])) { \$objattr['POS-X'] = \$attr['POS-X']; } else { \$objattr['POS-X'] = 0; }
\tif (isset(\$attr['POS-Y'])) { \$objattr['POS-Y'] = \$attr['POS-Y']; } else { \$objattr['POS-Y'] = 0; }
\tif (isset(\$attr['ICON'])) { \$objattr['ICON'] = \$attr['ICON']; } else { \$objattr['ICON'] = 'Note'; }
\tif (isset(\$attr['AUTHOR'])) { \$objattr['AUTHOR'] = \$attr['AUTHOR']; }
\telse if (isset(\$attr['TITLE'])) { \$objattr['AUTHOR'] = \$attr['TITLE']; } else  { \$objattr['AUTHOR'] = ''; }
\tif (isset(\$attr['FILE'])) { \$objattr['FILE'] = \$attr['FILE']; } else  { \$objattr['FILE'] = ''; }
\tif (isset(\$attr['SUBJECT'])) { \$objattr['SUBJECT'] = \$attr['SUBJECT']; } else  { \$objattr['SUBJECT'] = ''; }
\tif (isset(\$attr['OPACITY']) && \$attr['OPACITY']>0 && \$attr['OPACITY']<=1) { \$objattr['OPACITY'] = \$attr['OPACITY']; }
\telse if (\$this->annotMargin) { \$objattr['OPACITY'] = 1; }
\telse { \$objattr['OPACITY'] = \$this->annotOpacity; }
\tif (isset(\$attr['COLOR'])) {
\t\t\$cor = \$this->ConvertColor(\$attr['COLOR']);
\t\tif (\$cor) {  \$objattr['COLOR'] = \$cor; }
\t\telse  { \$objattr['COLOR'] = \$this->ConvertColor('yellow'); }
\t}
\telse  { \$objattr['COLOR'] = \$this->ConvertColor('yellow'); }

\tif (isset(\$attr['POPUP']) && !empty(\$attr['POPUP'])) {
\t\t\$pop = preg_split('/\\s+/',trim(\$attr['POPUP']));
\t\tif (count(\$pop)>1) { \$objattr['POPUP'] = \$pop; }
\t\telse { \$objattr['POPUP'] = true; }
\t}
\t\$e = \"\\xbb\\xa4\\xactype=annot,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\tif(\$this->tableLevel) { \$this->cell[\$this->row][\$this->col]['textbuffer'][] = array(\$e); }\t// *TABLES*
\telse  {\t// *TABLES*
\t\t\$this->textbuffer[] = array(\$e);
\t}\t// *TABLES*
\tbreak;
/*-- END ANNOTATIONS --*/


/*-- COLUMNS --*/
    case 'COLUMNS': //added custom-tag
\tif (isset(\$attr['COLUMN-COUNT']) && (\$attr['COLUMN-COUNT'] || \$attr['COLUMN-COUNT']==='0')) {
\t\t// Close any open block tags
\t\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }
\t\tif(!empty(\$this->textbuffer))  {\t//Output previously buffered content
    \t\t  \t\$this->printbuffer(\$this->textbuffer);
      \t  \t\$this->textbuffer=array();
      \t}

\t\tif (isset(\$attr['VALIGN']) && \$attr['VALIGN']) {
\t\t\tif (\$attr['VALIGN'] == 'J') { \$valign = 'J'; }
\t\t\telse { \$valign = \$align[\$attr['VALIGN']]; }
\t\t}
 \t\telse { \$valign = ''; }
\t\tif (isset(\$attr['COLUMN-GAP']) && \$attr['COLUMN-GAP']) { \$this->SetColumns(\$attr['COLUMN-COUNT'],\$valign,\$attr['COLUMN-GAP']); }
\t\telse { \$this->SetColumns(\$attr['COLUMN-COUNT'],\$valign); }
\t}
\t\$this->ignorefollowingspaces = true;
\tbreak;

    case 'COLUMN_BREAK': //custom-tag
    case 'COLUMNBREAK': //custom-tag
    case 'NEWCOLUMN': //custom-tag
\t\$this->ignorefollowingspaces = true;
\t\$this->NewColumn();
\t\$this->ColumnAdjust = false;\t// disables all column height adjustment for the page.
\tbreak;

/*-- END COLUMNS --*/


    case 'BDO':
\t// \$this->biDirectional = true;
\tbreak;


    case 'TTZ':
\t\$this->ttz = true;
\t\$this->InlineProperties[\$tag] = \$this->saveInlineProperties();
\t\$this->setCSS(array('FONT-FAMILY'=>'czapfdingbats','FONT-WEIGHT'=>'normal','FONT-STYLE'=>'normal'),'INLINE');
\tbreak;

    case 'TTS':
\t\$this->tts = true;
\t\$this->InlineProperties[\$tag] = \$this->saveInlineProperties();
\t\$this->setCSS(array('FONT-FAMILY'=>'csymbol','FONT-WEIGHT'=>'normal','FONT-STYLE'=>'normal'),'INLINE');
\tbreak;

    case 'TTA':
\t\$this->tta = true;
\t\$this->InlineProperties[\$tag] = \$this->saveInlineProperties();

\tif (in_array(\$this->FontFamily,\$this->mono_fonts)) {
\t\t\$this->setCSS(array('FONT-FAMILY'=>'ccourier'),'INLINE');
\t}
\telse if (in_array(\$this->FontFamily,\$this->serif_fonts)) {
\t\t\$this->setCSS(array('FONT-FAMILY'=>'ctimes'),'INLINE');
\t}
\telse {
\t\t\$this->setCSS(array('FONT-FAMILY'=>'chelvetica'),'INLINE');
\t}
\tbreak;



    // INLINE PHRASES OR STYLES
    case 'SUB':
    case 'SUP':
    case 'ACRONYM':
    case 'BIG':
    case 'SMALL':
    case 'INS':
    case 'S':
    case 'STRIKE':
    case 'DEL':
    case 'STRONG':
    case 'CITE':
    case 'Q':
    case 'EM':
    case 'B':
    case 'I':
    case 'U':
    case 'SAMP':
    case 'CODE':
    case 'KBD':
    case 'TT':
    case 'VAR':
    case 'FONT':
    case 'MARK':\t// mPDF 5.5.09
    case 'TIME':

    case 'SPAN':
/*-- ANNOTATIONS --*/
\tif (\$this->title2annots && isset(\$attr['TITLE'])) {
\t\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;

\t\t\$objattr['CONTENT'] = \$attr['TITLE'];
\t\t\$objattr['type'] = 'annot';
\t\t\$objattr['POS-X'] = 0;
\t\t\$objattr['POS-Y'] = 0;
\t\t\$objattr['ICON'] = 'Comment';
\t\t\$objattr['AUTHOR'] = '';
\t\t\$objattr['SUBJECT'] = '';
\t\t\$objattr['OPACITY'] = \$this->annotOpacity;
\t\t\$objattr['COLOR'] = \$this->ConvertColor('yellow');
\t\t\$annot = \"\\xbb\\xa4\\xactype=annot,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t}
/*-- END ANNOTATIONS --*/

\t// mPDF 5.7.3 Inline tags
\tif (!isset(\$this->InlineProperties[\$tag])) { \$this->InlineProperties[\$tag] = array(\$this->saveInlineProperties()); }
\telse { \$this->InlineProperties[\$tag][] = \$this->saveInlineProperties(); }
\tif (isset(\$annot)) { \t// *ANNOTATIONS*
\t\tif (!isset(\$this->InlineAnnots[\$tag])) { \$this->InlineAnnots[\$tag] = array(\$annot); }\t// *ANNOTATIONS*
\t\telse { \$this->InlineAnnots[\$tag][] = \$annot; }\t// *ANNOTATIONS*
\t}\t// *ANNOTATIONS*

\t\$properties = \$this->cssmgr->MergeCSS('INLINE',\$tag,\$attr);
\tif (!empty(\$properties)) \$this->setCSS(\$properties,'INLINE');
\tbreak;


    case 'A':
\tif (isset(\$attr['NAME']) and \$attr['NAME'] != '') {
\t\t\$e = '';
/*-- BOOKMARKS --*/
\t\tif (\$this->anchor2Bookmark) {
\t\t\t\$objattr = array();
\t\t\t\$objattr['CONTENT'] = htmlspecialchars_decode(\$attr['NAME'],ENT_QUOTES);
\t\t\t\$objattr['type'] = 'bookmark';
\t\t\tif (isset(\$attr['LEVEL']) && \$attr['LEVEL']) { \$objattr['bklevel'] = \$attr['LEVEL']; } else { \$objattr['bklevel'] = 0; }
\t\t\t\$e = \"\\xbb\\xa4\\xactype=bookmark,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t}
/*-- END BOOKMARKS --*/
\t\tif(\$this->tableLevel) {\t// *TABLES*
\t\t\t\$this->_saveCellTextBuffer(\$e, '', \$attr['NAME']);\t// *TABLES*
\t\t}\t// *TABLES*
\t\telse  {\t// *TABLES*
\t\t\t\$this->_saveTextBuffer(\$e, '', \$attr['NAME']);\t//an internal link (adds a space for recognition)
\t\t}\t// *TABLES*
\t}
\tif (isset(\$attr['HREF'])) {
\t\t\$this->InlineProperties['A'] = \$this->saveInlineProperties();
\t\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\t\tif (!empty(\$properties)) \$this->setCSS(\$properties,'INLINE');
\t\t\$this->HREF=htmlspecialchars_decode(urldecode(\$attr['HREF']));
\t}
\tbreak;

    case 'LEGEND':\t// mPDF 5.4.18
\t\t\$this->InlineProperties['LEGEND'] = \$this->saveInlineProperties();
\t\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\t\tif (!empty(\$properties)) \$this->setCSS(\$properties,'INLINE');
\tbreak;



    case 'PROGRESS':\t// mPDF 5.5.09
    case 'METER':\t// mPDF 5.5.09
\t\$this->inMeter = true;\t// mPDF 5.5.09

\tif (isset(\$attr['MAX']) && \$attr['MAX']) { \$max = \$attr['MAX']; }
\telse { \$max = 1; }
\tif (isset(\$attr['MIN']) && \$attr['MIN'] && \$tag=='METER') { \$min = \$attr['MIN']; }
\telse { \$min = 0; }
\tif (\$max < \$min) { \$max = \$min; }

\tif (isset(\$attr['VALUE']) && (\$attr['VALUE'] || \$attr['VALUE']==='0')) {
\t\t\$value = \$attr['VALUE'];
\t\tif (\$value < \$min) { \$value = \$min; }
\t\telse if (\$value > \$max) { \$value = \$max; }
\t}
\telse { \$value = ''; }

\tif (isset(\$attr['LOW']) && \$attr['LOW']) { \$low = \$attr['LOW']; }
\telse { \$low = \$min; }
\tif (\$low < \$min) { \$low = \$min; }
\telse if (\$low > \$max) { \$low = \$max; }
\tif (isset(\$attr['HIGH']) && \$attr['HIGH']) { \$high = \$attr['HIGH']; }
\telse { \$high = \$max; }
\tif (\$high < \$low) { \$high = \$low; }
\telse if (\$high > \$max) { \$high = \$max; }
\tif (isset(\$attr['OPTIMUM']) && \$attr['OPTIMUM']) { \$optimum = \$attr['OPTIMUM']; }
\telse { \$optimum = \$min + ((\$max-\$min)/2); }
\tif (\$optimum < \$min) { \$optimum = \$min; }
\telse if (\$optimum > \$max) { \$optimum = \$max; }
\tif (isset(\$attr['TYPE']) && \$attr['TYPE']) { \$type = \$attr['TYPE']; }
\telse { \$type = ''; }
\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['padding_top'] = 0;
\t\t\$objattr['padding_bottom'] = 0;
\t\t\$objattr['padding_left'] = 0;
\t\t\$objattr['padding_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;

\t\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\t\tif(isset(\$properties ['DISPLAY']) && strtolower(\$properties ['DISPLAY'])=='none') {
\t\t\treturn;
\t\t}
\t\t\$objattr['visibility'] = 'visible';
\t\tif (isset(\$properties['VISIBILITY'])) {
\t\t\t\$v = strtolower(\$properties['VISIBILITY']);
\t\t\tif ((\$v == 'hidden' || \$v == 'printonly' || \$v == 'screenonly') && \$this->visibility=='visible') {
\t\t\t\t\$objattr['visibility'] = \$v;
\t\t\t}
\t\t}

\t\tif (isset(\$properties['MARGIN-TOP'])) { \$objattr['margin_top']=\$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-BOTTOM'])) { \$objattr['margin_bottom'] = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-LEFT'])) { \$objattr['margin_left'] = \$this->ConvertSize(\$properties['MARGIN-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-RIGHT'])) { \$objattr['margin_right'] = \$this->ConvertSize(\$properties['MARGIN-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['PADDING-TOP'])) { \$objattr['padding_top']=\$this->ConvertSize(\$properties['PADDING-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-BOTTOM'])) { \$objattr['padding_bottom'] = \$this->ConvertSize(\$properties['PADDING-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-LEFT'])) { \$objattr['padding_left'] = \$this->ConvertSize(\$properties['PADDING-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-RIGHT'])) { \$objattr['padding_right'] = \$this->ConvertSize(\$properties['PADDING-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['BORDER-TOP'])) { \$objattr['border_top'] = \$this->border_details(\$properties['BORDER-TOP']); }
\t\tif (isset(\$properties['BORDER-BOTTOM'])) { \$objattr['border_bottom'] = \$this->border_details(\$properties['BORDER-BOTTOM']); }
\t\tif (isset(\$properties['BORDER-LEFT'])) { \$objattr['border_left'] = \$this->border_details(\$properties['BORDER-LEFT']); }
\t\tif (isset(\$properties['BORDER-RIGHT'])) { \$objattr['border_right'] = \$this->border_details(\$properties['BORDER-RIGHT']); }

\t\tif (isset(\$properties['VERTICAL-ALIGN'])) { \$objattr['vertical-align'] = \$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }
\t\t\$w = 0;
\t\t\$h = 0;
\t\tif(isset(\$properties['WIDTH'])) \$w = \$this->ConvertSize(\$properties['WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['WIDTH'])) \$w = \$this->ConvertSize(\$attr['WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);

\t\tif(isset(\$properties['HEIGHT'])) \$h = \$this->ConvertSize(\$properties['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['HEIGHT'])) \$h = \$this->ConvertSize(\$attr['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);

\t\tif (isset(\$properties['OPACITY']) && \$properties['OPACITY'] > 0 && \$properties['OPACITY'] <= 1) { \$objattr['opacity'] = \$properties['OPACITY']; }
\t\tif (\$this->HREF) {
\t\t\tif (strpos(\$this->HREF,\".\") === false && strpos(\$this->HREF,\"@\") !== 0) {
\t\t\t\t\$href = \$this->HREF;
\t\t\t\twhile(array_key_exists(\$href,\$this->internallink)) \$href=\"#\".\$href;
\t    \t\t\t\$this->internallink[\$href] = \$this->AddLink();
\t\t\t\t\$objattr['link'] = \$this->internallink[\$href];
\t\t\t}
\t\t\telse { \$objattr['link'] = \$this->HREF; }
\t\t}
\t\t\$extraheight = \$objattr['padding_top'] + \$objattr['padding_bottom'] + \$objattr['margin_top'] + \$objattr['margin_bottom'] + \$objattr['border_top']['w'] + \$objattr['border_bottom']['w'];
\t\t\$extrawidth = \$objattr['padding_left'] + \$objattr['padding_right'] + \$objattr['margin_left'] + \$objattr['margin_right'] + \$objattr['border_left']['w'] + \$objattr['border_right']['w'];

\t\t// Image file
\t\tif (!class_exists('meter', false)) {
\t\t\tinclude(_MPDF_PATH.'classes/meter.php');
\t\t}
\t\t\$this->meter = new meter();
\t\t\$svg = \$this->meter->makeSVG(strtolower(\$tag), \$type, \$value, \$max, \$min, \$optimum, \$low, \$high);
\t\t//Save to local file
\t\t\$srcpath= _MPDF_TEMP_PATH.'_tempSVG'.uniqid(rand(1,100000),true).'_'.strtolower(\$tag).'.svg';
\t\tfile_put_contents(\$srcpath, \$svg);
\t\t\$orig_srcpath = \$srcpath;
\t\t\$this->GetFullPath(\$srcpath);

\t\t\$info=\$this->_getImage(\$srcpath, true, true, \$orig_srcpath);
\t\tif(!\$info) {
\t\t\t\$info = \$this->_getImage(\$this->noImageFile);
\t\t\tif (\$info) {
\t\t\t\t\$srcpath = \$this->noImageFile;
\t\t\t\t\$w = (\$info['w'] * (25.4/\$this->dpi));
\t\t\t\t\$h = (\$info['h'] * (25.4/\$this->dpi));
\t\t\t}
\t\t}
\t\tif(!\$info) break;

\t\t\$objattr['file'] = \$srcpath;
\t\t//Default width and height calculation if needed
\t\tif(\$w==0 and \$h==0) {
\t\t\t// SVG units are pixels
\t\t\t\$w = \$this->FontSize/(10/_MPDFK) * abs(\$info['w'])/_MPDFK;\t// mPDF 5.5.21
\t\t\t\$h = \$this->FontSize/(10/_MPDFK) * abs(\$info['h'])/_MPDFK;
\t\t}
\t\t// IF WIDTH OR HEIGHT SPECIFIED
\t\tif(\$w==0)  \$w=abs(\$h*\$info['w']/\$info['h']);
\t\tif(\$h==0)\t\$h=abs(\$w*\$info['h']/\$info['w']);

\t\t// Resize to maximum dimensions of page
\t\t\$maxWidth = \$this->blk[\$this->blklvl]['inner_width'];
   \t\t\$maxHeight = \$this->h - (\$this->tMargin + \$this->bMargin + 1) ;
\t\tif (\$this->fullImageHeight) { \$maxHeight = \$this->fullImageHeight; }
\t\tif (\$w + \$extrawidth > \$maxWidth ) {
\t\t\t\$w = \$maxWidth - \$extrawidth;
\t\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t\t}

\t\tif (\$h + \$extraheight > \$maxHeight ) {
\t\t\t\$h = \$maxHeight - \$extraheight;
\t\t\t\$w=abs(\$h*\$info['w']/\$info['h']);
\t\t}
\t\t\$objattr['type'] = 'image';
\t\t\$objattr['itype'] = \$info['type'];

\t\t\$objattr['orig_h'] = \$info['h'];
\t\t\$objattr['orig_w'] = \$info['w'];
\t\t\$objattr['wmf_x'] = \$info['x'];
\t\t\$objattr['wmf_y'] = \$info['y'];
\t\t\$objattr['height'] = \$h + \$extraheight;
\t\t\$objattr['width'] = \$w + \$extrawidth;
\t\t\$objattr['image_height'] = \$h;
\t\t\$objattr['image_width'] = \$w;
\t\t\$e = \"\\xbb\\xa4\\xactype=image,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t\$properties = array();
\t\tif (\$this->tableLevel) {
\t\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);
\t\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$objattr['width'] ;
\t\t}
\t\telse {
\t\t\t\$this->_saveTextBuffer(\$e, \$this->HREF);
\t\t}

\tbreak;


    case 'BR':
\t// Added mPDF 3.0 Float DIV - CLEAR
\tif (isset(\$attr['STYLE'])) {
\t\t\$properties = \$this->cssmgr->readInlineCSS(\$attr['STYLE']);
\t\tif (isset(\$properties['CLEAR'])) { \$this->ClearFloats(strtoupper(\$properties['CLEAR']),\$this->blklvl); }\t// *CSS-FLOAT*
\t}


/*-- TABLES --*/
\tif(\$this->tableLevel) {

\t   if (\$this->blockjustfinished || \$this->listjustfinished) {
\t\t\$this->_saveCellTextBuffer(\"\\n\");
\t   }

\t\t\$this->_saveCellTextBuffer(\"\\n\");
\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\t\$this->cell[\$this->row][\$this->col]['s'] = 0 ;// reset
\t}
\telse  {
/*-- END TABLES --*/
\t\tif (count(\$this->textbuffer)) {
\t\t\t\$this->textbuffer[count(\$this->textbuffer)-1][0] = preg_replace('/ \$/','',\$this->textbuffer[count(\$this->textbuffer)-1][0]);
\t\t}
\t\t\$this->_saveTextBuffer(\"\\n\");
\t}\t// *TABLES*
\t\$this->ignorefollowingspaces = true;
\t\$this->blockjustfinished=false;
\t\$this->listjustfinished=false;

\t\$this->linebreakjustfinished=true;
\tbreak;


\t// *********** BLOCKS  ********************


    case 'PRE':
\t\$this->ispre=true;\t// ADDED - Prevents left trim of textbuffer in printbuffer()

    case 'DIV':
    case 'FORM':
    case 'CENTER':

    case 'BLOCKQUOTE':
    case 'ADDRESS':

    case 'CAPTION':
    case 'P':
    case 'H1':
    case 'H2':
    case 'H3':
    case 'H4':
    case 'H5':
    case 'H6':
    case 'DL':
    case 'DT':
    case 'DD':
    case 'FIELDSET':
    case 'DETAILS':
    case 'SUMMARY':
    case 'ARTICLE':
    case 'ASIDE':
    case 'FIGURE':
    case 'FIGCAPTION':
    case 'FOOTER':
    case 'HEADER':
    case 'HGROUP':
    case 'NAV':
    case 'SECTION':
    case 'MAIN':\t// mPDF 5.7.3
\t\$p = \$this->cssmgr->PreviewBlockCSS(\$tag,\$attr);
\tif(isset(\$p['DISPLAY']) && strtolower(\$p['DISPLAY'])=='none') {
\t\t\$this->blklvl++;
\t\t\$this->blk[\$this->blklvl]['hide'] = true;
\t\treturn;
\t}
\tif(\$tag == 'CAPTION') {
\t\t// position is written in AdjstHTML
\t\tif (isset(\$attr['POSITION']) && strtolower(\$attr['POSITION'])=='bottom') { \$divpos = 'B'; }
\t\telse { \$divpos = 'T'; }
\t\tif (isset(\$attr['ALIGN']) && strtolower(\$attr['ALIGN'])=='bottom') { \$cappos = 'B'; }
\t\telse if (isset(\$p['CAPTION-SIDE']) && strtolower(\$p['CAPTION-SIDE'])=='bottom') { \$cappos = 'B'; }
\t\telse { \$cappos = 'T'; }
\t\tif (isset(\$attr['ALIGN'])) { unset(\$attr['ALIGN']); }
\t\tif (\$cappos != \$divpos) {
\t\t\t\$this->blklvl++;
\t\t\t\$this->blk[\$this->blklvl]['hide'] = true;
\t\t\treturn;
\t\t}
\t}

/*-- FORMS --*/
\tif(\$tag == 'FORM') {
\t\tif (isset(\$attr['METHOD']) && strtolower(\$attr['METHOD'])=='get') { \$this->form->formMethod = 'GET'; }
\t\telse { \$this->form->formMethod = 'POST'; }
\t\tif (isset(\$attr['ACTION'])) { \$this->form->formAction = \$attr['ACTION']; }
\t\telse { \$this->form->formAction = ''; }
\t}
/*-- END FORMS --*/


/*-- CSS-POSITION --*/
\tif ((isset(\$p['POSITION']) && (strtolower(\$p['POSITION'])=='fixed' || strtolower(\$p['POSITION'])=='absolute')) && \$this->blklvl==0) {
\t\tif (\$this->inFixedPosBlock) {
\t\t\t\$this->Error(\"Cannot nest block with position:fixed or position:absolute\");
\t\t}
\t\t\$this->inFixedPosBlock = true;
\t\treturn;
\t}
/*-- END CSS-POSITION --*/
\t// Start Block
\t\$this->ignorefollowingspaces = true;

\tif (\$this->blockjustfinished && !count(\$this->textbuffer) && \$this->y != \$this->tMargin && \$this->collapseBlockMargins) { \$lastbottommargin = \$this->lastblockbottommargin; }
\telse { \$lastbottommargin = 0; }
\t\$this->lastblockbottommargin = 0;
\t\$this->blockjustfinished=false;

/*-- LISTS --*/
\tif (\$this->listlvl>0) { return; }
/*-- END LISTS --*/

\t\$this->InlineProperties = array();
\t\$this->listjustfinished=false;
\t\$this->divbegin=true;

\t\$this->linebreakjustfinished=false;

/*-- TABLES --*/
\tif (\$this->tableLevel) {

\t   // If already something on the line
\t   if (\$this->cell[\$this->row][\$this->col]['s'] > 0  && !\$this->nestedtablejustfinished ) {
\t\t\$this->_saveCellTextBuffer(\"\\n\");
\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\t\$this->cell[\$this->row][\$this->col]['s'] = 0 ;// reset
\t   }
\t   // Cannot set block properties inside table - use Bold to indicate h1-h6
\t   if (\$tag == 'CENTER' && \$this->tdbegin) { \$this->cell[\$this->row][\$this->col]['a'] = \$align['center']; }

\t\t\$this->InlineProperties['BLOCKINTABLE'] = \$this->saveInlineProperties();
\t\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\t\tif (!empty(\$properties)) \$this->setCSS(\$properties,'INLINE');


\t   break;
\t}
/*-- END TABLES --*/

\tif (\$tag == 'P' || \$tag == 'DT' || \$tag == 'DD') { \$this->lastoptionaltag = \$tag; } // Save current HTML specified optional endtag
\telse { \$this->lastoptionaltag = ''; }

\tif (\$this->lastblocklevelchange == 1) { \$blockstate = 1; }\t// Top margins/padding only
\telse if (\$this->lastblocklevelchange < 1) { \$blockstate = 0; }\t// NO margins/padding
\t\$this->printbuffer(\$this->textbuffer,\$blockstate);
\t\$this->textbuffer=array();

\t\$save_blklvl = \$this->blklvl;
\t\$save_blk = \$this->blk;
\t\$save_silp = \$this->saveInlineProperties();
\t\$save_ilp = \$this->InlineProperties;

\t\$this->blklvl++;

\t\$currblk =& \$this->blk[\$this->blklvl];
\t\$this->initialiseBlock(\$currblk);
\t\$prevblk =& \$this->blk[\$this->blklvl-1];

\t\$currblk['tag'] = \$tag;
\t\$currblk['attr'] = \$attr;

\t\$this->Reset();
\t\$properties = \$this->cssmgr->MergeCSS('BLOCK',\$tag,\$attr);
\t\$pagesel = '';
/*-- CSS-PAGE --*/

\tif (isset(\$properties['PAGE'])) { \$pagesel = \$properties['PAGE']; }
/*-- END CSS-PAGE --*/

\t// If page-box has changed AND/OR PAGE-BREAK-BEFORE
\t\$save_cols = false;
\tif ((\$pagesel && \$pagesel != \$this->page_box['current']) || (isset(\$properties['PAGE-BREAK-BEFORE']) && \$properties['PAGE-BREAK-BEFORE'])) {
\t\tif (\$this->blklvl>1) {
\t\t\t// Close any open block tags
\t\t\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }
\t\t\t// Output any text left in buffer
\t\t\tif (count(\$this->textbuffer)) { \$this->printbuffer(\$this->textbuffer); \$this->textbuffer=array(); }
\t\t}
/*-- COLUMNS --*/
\t\tif (\$this->ColActive) {
\t\t\t\$save_cols = true;
\t\t\t\$save_nbcol = \$this->NbCol;\t// other values of gap and vAlign will not change by setting Columns off
\t\t\t\$this->SetColumns(0);
\t\t}
/*-- END COLUMNS --*/

\t\t// Must Add new page if changed page properties
\t\tif (isset(\$properties['PAGE-BREAK-BEFORE'])) {
\t\t\tif (strtoupper(\$properties['PAGE-BREAK-BEFORE']) == 'RIGHT') { \$this->AddPage(\$this->CurOrientation,'NEXT-ODD','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\t\telse if (strtoupper(\$properties['PAGE-BREAK-BEFORE']) == 'LEFT') { \$this->AddPage(\$this->CurOrientation,'NEXT-EVEN','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\t\telse if (strtoupper(\$properties['PAGE-BREAK-BEFORE']) == 'ALWAYS') { \$this->AddPage(\$this->CurOrientation,'','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\t\telse if (\$this->page_box['current'] != \$pagesel) { \$this->AddPage(\$this->CurOrientation,'','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }\t// *CSS-PAGE*
\t\t}
/*-- CSS-PAGE --*/
\t\telse if (\$pagesel != \$this->page_box['current']) { \$this->AddPage(\$this->CurOrientation,'','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
/*-- END CSS-PAGE --*/

\t\t// if using htmlheaders, the headers need to be rewritten when new page
\t\t// done by calling WriteHTML() within resethtmlheaders
\t\t// so block is reset to 0 - now we need to resurrect it
\t\t// As in WriteHTML() initialising
\t\tif (!(\$this->restoreBlockPagebreaks && isset(\$properties['PAGE-BREAK-BEFORE']) && \$properties['PAGE-BREAK-BEFORE'])) {
\t\t\t\$this->blklvl = 0;
\t\t\t\$this->lastblocklevelchange = 0;
\t\t\t\$this->blk = array();
\t\t\t\$this->initialiseBlock(\$this->blk[0]);
\t\t\t\$this->blk[0]['width'] =& \$this->pgwidth;
\t\t\t\$this->blk[0]['inner_width'] =& \$this->pgwidth;
\t\t\t\$this->blk[0]['blockContext'] = \$this->blockContext;
\t\t\t\$properties = \$this->cssmgr->MergeCSS('BLOCK','BODY','');
\t\t\t\$this->setCSS(\$properties,'','BODY');
\t\t\t\$this->blklvl++;
\t\t\t\$currblk =& \$this->blk[\$this->blklvl];
\t\t\t\$prevblk =& \$this->blk[\$this->blklvl-1];

\t\t\t\$this->initialiseBlock(\$currblk);
\t\t\t\$currblk['tag'] = \$tag;
\t\t\t\$currblk['attr'] = \$attr;

\t\t\t\$this->Reset();
\t\t\t\$properties = \$this->cssmgr->MergeCSS('BLOCK',\$tag,\$attr);
\t\t}
/*-- COLUMNS --*/
\t\tif (\$save_cols) {
\t\t\t// Restore columns
\t\t\t\$this->SetColumns(\$save_nbcol,\$this->colvAlign,\$this->ColGap);
\t\t}
/*-- END COLUMNS --*/
\t\tif (\$this->restoreBlockPagebreaks && isset(\$properties['PAGE-BREAK-BEFORE']) && \$properties['PAGE-BREAK-BEFORE']) {
\t\t\t\$this->blk = \$save_blk;
\t\t\t// Re-open block tags
\t\t\t\$t = \$this->blk[0]['tag'];
\t\t\t\$a = \$this->blk[0]['attr'];
\t\t\t\$this->blklvl = 0;
\t\t\tfor (\$b=0; \$b<=\$save_blklvl;\$b++) {
\t\t\t\t\$tc = \$t;
\t\t\t\t\$ac = \$a;
\t\t\t\t\$t = \$this->blk[\$b+1]['tag'];
\t\t\t\t\$a = \$this->blk[\$b+1]['attr'];
\t\t\t\tunset(\$this->blk[\$b+1]);
\t\t\t\t\$this->OpenTag(\$tc,\$ac);
\t\t\t}
\t\t\t\$this->InlineProperties = \$save_ilp;
\t\t\t\$this->restoreInlineProperties(\$save_silp);
\t\t}
\t}

\tif (isset(\$properties['PAGE-BREAK-INSIDE']) && strtoupper(\$properties['PAGE-BREAK-INSIDE']) == 'AVOID' && !\$this->ColActive && !\$this->keep_block_together) {
\t\t\$currblk['keep_block_together'] = 1;
\t\t\$this->kt_y00 = \$this->y;
\t\t\$this->kt_p00 = \$this->page;
\t\t\$this->keep_block_together = 1;
\t\t\$this->divbuffer = array();
\t\t\$this->ktLinks = array();
\t\t\$this->ktAnnots = array();
\t\t\$this->ktForms = array();
\t\t\$this->ktBlock = array();
\t\t\$this->ktReference = array();
\t\t\$this->ktBMoutlines = array();
\t\t\$this->_kttoc = array();
\t}
\tif (\$lastbottommargin && isset(\$properties['MARGIN-TOP']) && \$properties['MARGIN-TOP'] && empty(\$properties['FLOAT'])) { \$currblk['lastbottommargin'] = \$lastbottommargin; }

\t// mPDF 5.6.01  - LAYERS
\tif (isset(\$properties['Z-INDEX']) && \$this->currentlayer==0) {
\t\t\$v = intval(\$properties['Z-INDEX']);
\t\tif (\$v > 0) {
\t\t\t\$currblk['z-index'] = \$v;
\t\t\t\$this->BeginLayer(\$v);
\t\t}
\t}

\t\$this->setCSS(\$properties,'BLOCK',\$tag); //name(id/class/style) found in the CSS array!
\t\$currblk['InlineProperties'] = \$this->saveInlineProperties();

\tif (isset(\$properties['VISIBILITY'])) {
\t\t\$v = strtolower(\$properties['VISIBILITY']);
\t\tif ((\$v == 'hidden' || \$v == 'printonly' || \$v == 'screenonly') && \$this->visibility=='visible' && !\$this->tableLevel) {
\t\t\t\$currblk['visibility'] = \$v;
\t\t\t\$this->SetVisibility(\$v);
\t\t}
\t}

\tif(isset(\$attr['DIR']) && \$attr['DIR']) { \$currblk['direction'] = strtolower(\$attr['DIR']); }
\tif(isset(\$attr['ALIGN']) && \$attr['ALIGN']) { \$currblk['block-align'] = \$align[strtolower(\$attr['ALIGN'])]; }

\tif (isset(\$properties['HEIGHT'])) {
\t\t\$currblk['css_set_height'] = \$this->ConvertSize(\$properties['HEIGHT'],(\$this->h - \$this->tMargin - \$this->bMargin),\$this->FontSize,false);
\t\tif ((\$currblk['css_set_height'] + \$this->y) > \$this->PageBreakTrigger && \$this->y > \$this->tMargin+5 && \$currblk['css_set_height'] < (\$this->h - (\$this->tMargin + \$this->bMargin))) { \$this->AddPage(\$this->CurOrientation); }
\t}
\telse { \$currblk['css_set_height'] = false; }


\t// Added mPDF 3.0 Float DIV
\tif (isset(\$prevblk['blockContext'])) { \$currblk['blockContext'] = \$prevblk['blockContext'] ; }\t// *CSS-FLOAT*

\tif (isset(\$properties['CLEAR'])) { \$this->ClearFloats(strtoupper(\$properties['CLEAR']), \$this->blklvl-1); }\t// *CSS-FLOAT*

\t\$container_w = \$prevblk['inner_width'];
\t\$bdr = \$currblk['border_right']['w'];
\t\$bdl = \$currblk['border_left']['w'];
\t\$pdr = \$currblk['padding_right'];
\t\$pdl = \$currblk['padding_left'];

\tif (isset(\$currblk['css_set_width'])) { \$setwidth = \$currblk['css_set_width']; }
\telse { \$setwidth = 0; }

/*-- CSS-FLOAT --*/
\tif (isset(\$properties['FLOAT']) && strtoupper(\$properties['FLOAT']) == 'RIGHT' && !\$this->ColActive) {
\t\t// Cancel Keep-Block-together
\t\t\$currblk['keep_block_together'] = false;
\t\t\$this->kt_y00 = '';
\t\t\$this->keep_block_together = 0;

\t\t\$this->blockContext++;
\t\t\$currblk['blockContext'] = \$this->blockContext;

\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl-1);

\t\t// DIV is too narrow for text to fit!
\t\t\$maxw = \$container_w - \$l_width - \$r_width;
\t\tif ((\$setwidth + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr) > \$maxw || (\$maxw - (\$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr)) < (2*\$this->GetCharWidth('W',false))) {
\t\t\t// Too narrow to fit - try to move down past L or R float
\t\t\tif (\$l_max < \$r_max && (\$setwidth + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr) <= (\$container_w - \$r_width) && ((\$container_w - \$r_width) - (\$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr)) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('LEFT', \$this->blklvl-1);
\t\t\t}
\t\t\telse if (\$r_max < \$l_max && (\$setwidth + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr)  <= (\$container_w - \$l_width) && ((\$container_w - \$l_width) - (\$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr)) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('RIGHT', \$this->blklvl-1);
\t\t\t}
\t\t\telse { \$this->ClearFloats('BOTH', \$this->blklvl-1); }
\t\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl-1);
\t\t}

\t\tif (\$r_exists) { \$currblk['margin_right'] += \$r_width; }

\t\t\$currblk['float'] = 'R';
\t\t\$currblk['float_start_y'] = \$this->y;
\t\tif (\$currblk['css_set_width']) {
\t\t\t\$currblk['margin_left'] = \$container_w - (\$setwidth + \$bdl + \$pdl + \$bdr + \$pdr + \$currblk['margin_right']);
\t\t\t\$currblk['float_width'] = (\$setwidth + \$bdl + \$pdl + \$bdr + \$pdr + \$currblk['margin_right']);
\t\t}
\t\telse {
\t\t\t// *** If no width set - would need to buffer and keep track of max width, then Right-align if not full width
\t\t\t// and do borders and backgrounds - For now - just set to maximum width left

\t\t\tif (\$l_exists) { \$currblk['margin_left'] += \$l_width; }
\t\t\t\$currblk['css_set_width'] = \$container_w - (\$currblk['margin_left'] + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr);

\t\t\t\$currblk['float_width'] = (\$currblk['css_set_width'] + \$bdl + \$pdl + \$bdr + \$pdr + \$currblk['margin_right']);
\t\t}
\t}
\telse if (isset(\$properties['FLOAT']) && strtoupper(\$properties['FLOAT']) == 'LEFT' && !\$this->ColActive) {
\t\t// Cancel Keep-Block-together
\t\t\$currblk['keep_block_together'] = false;
\t\t\$this->kt_y00 = '';
\t\t\$this->keep_block_together = 0;

\t\t\$this->blockContext++;
\t\t\$currblk['blockContext'] = \$this->blockContext;

\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl-1);

\t\t// DIV is too narrow for text to fit!
\t\t\$maxw = \$container_w - \$l_width - \$r_width;
\t\tif ((\$setwidth + \$currblk['margin_left'] + \$bdl + \$pdl + \$bdr + \$pdr) > \$maxw || (\$maxw - (\$currblk['margin_left'] + \$bdl + \$pdl + \$bdr + \$pdr)) < (2*\$this->GetCharWidth('W',false))) {
\t\t\t// Too narrow to fit - try to move down past L or R float
\t\t\tif (\$l_max < \$r_max && (\$setwidth + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr) <= (\$container_w - \$r_width) && ((\$container_w - \$r_width) - (\$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr)) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('LEFT', \$this->blklvl-1);
\t\t\t}
\t\t\telse if (\$r_max < \$l_max && (\$setwidth + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr) <= (\$container_w - \$l_width) && ((\$container_w - \$l_width) - (\$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr)) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('RIGHT', \$this->blklvl-1);
\t\t\t}
\t\t\telse { \$this->ClearFloats('BOTH', \$this->blklvl-1); }
\t\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl-1);
\t\t}

\t\tif (\$l_exists) { \$currblk['margin_left'] += \$l_width; }

\t\t\$currblk['float'] = 'L';
\t\t\$currblk['float_start_y'] = \$this->y;
\t\tif (\$setwidth) {
\t\t\t\$currblk['margin_right'] = \$container_w - (\$setwidth + \$bdl + \$pdl + \$bdr + \$pdr + \$currblk['margin_left']);
\t\t\t\$currblk['float_width'] = (\$setwidth + \$bdl + \$pdl + \$bdr + \$pdr + \$currblk['margin_left']);
\t\t}
\t\telse {
\t\t\t// *** If no width set - would need to buffer and keep track of max width, then Right-align if not full width
\t\t\t// and do borders and backgrounds - For now - just set to maximum width left

\t\t\tif (\$r_exists) { \$currblk['margin_right'] += \$r_width; }
\t\t\t\$currblk['css_set_width'] = \$container_w - (\$currblk['margin_left'] + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr);

\t\t\t\$currblk['float_width'] = (\$currblk['css_set_width'] + \$bdl + \$pdl + \$bdr + \$pdr + \$currblk['margin_left']);
\t\t}
\t}

\telse {
\t\t// Don't allow overlap - if floats present - adjust padding to avoid overlap with Floats
\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl-1);
\t\t\$maxw = \$container_w - \$l_width - \$r_width;
\t\tif ((\$setwidth + \$currblk['margin_left'] + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr) > \$maxw || (\$maxw - (\$currblk['margin_right'] + \$currblk['margin_left'] + \$bdl + \$pdl + \$bdr + \$pdr)) < (2*\$this->GetCharWidth('W',false))) {
\t\t\t// Too narrow to fit - try to move down past L or R float
\t\t\tif (\$l_max < \$r_max && (\$setwidth + \$currblk['margin_left'] + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr) <= (\$container_w - \$r_width) && ((\$container_w - \$r_width) - (\$currblk['margin_right'] + \$currblk['margin_left'] + \$bdl + \$pdl + \$bdr + \$pdr)) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('LEFT', \$this->blklvl-1);
\t\t\t}
\t\t\telse if (\$r_max < \$l_max && (\$setwidth + \$currblk['margin_left'] + \$currblk['margin_right'] + \$bdl + \$pdl + \$bdr + \$pdr) <= (\$container_w - \$l_width) && ((\$container_w - \$l_width) - (\$currblk['margin_right'] + \$currblk['margin_left'] + \$bdl + \$pdl + \$bdr + \$pdr)) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('RIGHT', \$this->blklvl-1);
\t\t\t}
\t\t\telse { \$this->ClearFloats('BOTH', \$this->blklvl-1); }
\t\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl-1);
\t\t}
\t\tif (\$r_exists) { \$currblk['padding_right'] = max((\$r_width-\$currblk['margin_right']-\$bdr), \$pdr); }
\t\tif (\$l_exists) { \$currblk['padding_left'] = max((\$l_width-\$currblk['margin_left']-\$bdl), \$pdl); }
\t}
/*-- END CSS-FLOAT --*/


/*-- BORDER-RADIUS --*/
\t// Automatically increase padding if required for border-radius
\tif (\$this->autoPadding && !\$this->ColActive && !\$this->keep_block_together) {
\t  if (\$currblk['border_radius_TL_H']>\$currblk['padding_left'] && \$currblk['border_radius_TL_V']>\$currblk['padding_top']) {
\t\tif (\$currblk['border_radius_TL_H']>\$currblk['border_radius_TL_V']) {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_TL_H'],\$currblk['border_radius_TL_V'], \$currblk['padding_left'], \$currblk['padding_top']);
\t\t}
\t\telse {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_TL_V'],\$currblk['border_radius_TL_H'], \$currblk['padding_top'], \$currblk['padding_left']);
\t\t}
\t  }
\t  if (\$currblk['border_radius_TR_H']>\$currblk['padding_right'] && \$currblk['border_radius_TR_V']>\$currblk['padding_top']) {
\t\tif (\$currblk['border_radius_TR_H']>\$currblk['border_radius_TR_V']) {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_TR_H'],\$currblk['border_radius_TR_V'], \$currblk['padding_right'], \$currblk['padding_top']);
\t\t}
\t\telse {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_TR_V'],\$currblk['border_radius_TR_H'], \$currblk['padding_top'], \$currblk['padding_right']);
\t\t}
\t  }
\t  if (\$currblk['border_radius_BL_H']>\$currblk['padding_left'] && \$currblk['border_radius_BL_V']>\$currblk['padding_bottom']) {
\t\tif (\$currblk['border_radius_BL_H']>\$currblk['border_radius_BL_V']) {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_BL_H'],\$currblk['border_radius_BL_V'], \$currblk['padding_left'], \$currblk['padding_bottom']);
\t\t}
\t\telse {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_BL_V'],\$currblk['border_radius_BL_H'], \$currblk['padding_bottom'], \$currblk['padding_left']);
\t\t}
\t  }
\t  if (\$currblk['border_radius_BR_H']>\$currblk['padding_right'] && \$currblk['border_radius_BR_V']>\$currblk['padding_bottom']) {
\t\tif (\$currblk['border_radius_BR_H']>\$currblk['border_radius_BR_V']) {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_BR_H'],\$currblk['border_radius_BR_V'], \$currblk['padding_right'], \$currblk['padding_bottom']);
\t\t}
\t\telse {
\t\t\t\$this->_borderPadding(\$currblk['border_radius_BR_V'],\$currblk['border_radius_BR_H'], \$currblk['padding_bottom'], \$currblk['padding_right']);
\t\t}
\t  }
\t}
/*-- END BORDER-RADIUS --*/


\t// Hanging indent - if negative indent: ensure padding is >= indent
\tif(!isset(\$currblk['text_indent'])) { \$currblk['text_indent'] = null; }
\tif(!isset(\$currblk['inner_width'])) { \$currblk['inner_width'] = null; }
\t\$cbti = \$this->ConvertSize(\$currblk['text_indent'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\tif (\$cbti < 0) {
\t  \$hangind = -(\$cbti);
\t  if (\$currblk['direction'] == 'rtl') {\t// *RTL*
\t\t\$currblk['padding_right'] = max(\$currblk['padding_right'],\$hangind);\t// *RTL*
\t  }\t// *RTL*
\t  else {\t// *RTL*
\t\t\$currblk['padding_left'] = max(\$currblk['padding_left'],\$hangind);
\t  }\t// *RTL*
\t}

\tif (isset(\$currblk['css_set_width'])) {
\t  if (isset(\$properties['MARGIN-LEFT']) && isset(\$properties['MARGIN-RIGHT']) && strtolower(\$properties['MARGIN-LEFT'])=='auto' && strtolower(\$properties['MARGIN-RIGHT'])=='auto') {
\t\t  // Try to reduce margins to accomodate - if still too wide, set margin-right/left=0 (reduces width)
\t\t  \$anyextra = \$prevblk['inner_width'] - (\$currblk['css_set_width'] + \$currblk['border_left']['w'] + \$currblk['padding_left'] + \$currblk['border_right']['w'] + \$currblk['padding_right']);
\t\t  if (\$anyextra>0) {
\t\t\t\$currblk['margin_left'] = \$currblk['margin_right'] = \$anyextra /2;
\t\t  }
\t\t  else {
\t\t\t\$currblk['margin_left'] = \$currblk['margin_right'] = 0;
\t\t  }
\t  }
\t  else if (isset(\$properties['MARGIN-LEFT']) && strtolower(\$properties['MARGIN-LEFT'])=='auto') {
\t\t  // Try to reduce margin-left to accomodate - if still too wide, set margin-left=0 (reduces width)
\t\t  \$currblk['margin_left'] = \$prevblk['inner_width'] - (\$currblk['css_set_width'] + \$currblk['border_left']['w'] + \$currblk['padding_left'] + \$currblk['border_right']['w'] + \$currblk['padding_right'] + \$currblk['margin_right']);
\t\t  if (\$currblk['margin_left'] < 0) {
\t\t\t\$currblk['margin_left'] = 0;
\t\t  }
\t  }
\t  else if (isset(\$properties['MARGIN-RIGHT']) && strtolower(\$properties['MARGIN-RIGHT'])=='auto') {
\t\t  // Try to reduce margin-right to accomodate - if still too wide, set margin-right=0 (reduces width)
\t\t  \$currblk['margin_right'] = \$prevblk['inner_width'] - (\$currblk['css_set_width'] + \$currblk['border_left']['w'] + \$currblk['padding_left'] + \$currblk['border_right']['w'] + \$currblk['padding_right'] + \$currblk['margin_left']);
\t\t  if (\$currblk['margin_right'] < 0) {
\t\t\t\$currblk['margin_right'] = 0;
\t\t  }
\t  }
\t  else {
\t    if (\$currblk['direction'] == 'rtl') {\t// *RTL*
\t\t// Try to reduce margin-left to accomodate - if still too wide, set margin-left=0 (reduces width)
\t\t\$currblk['margin_left'] = \$prevblk['inner_width'] - (\$currblk['css_set_width'] + \$currblk['border_left']['w'] + \$currblk['padding_left'] + \$currblk['border_right']['w'] + \$currblk['padding_right'] + \$currblk['margin_right']);\t// *RTL*
\t\tif (\$currblk['margin_left'] < 0) {\t// *RTL*
\t\t\t\$currblk['margin_left'] = 0;\t// *RTL*
\t\t}\t// *RTL*
\t    }\t// *RTL*
\t    else {\t// *RTL*
\t\t  // Try to reduce margin-right to accomodate - if still too wide, set margin-right=0 (reduces width)
\t\t  \$currblk['margin_right'] = \$prevblk['inner_width'] - (\$currblk['css_set_width'] + \$currblk['border_left']['w'] + \$currblk['padding_left'] + \$currblk['border_right']['w'] + \$currblk['padding_right'] + \$currblk['margin_left']);
\t\t  if (\$currblk['margin_right'] < 0) {
\t\t\t\$currblk['margin_right'] = 0;
\t\t  }
\t    }\t// *RTL*
\t  }
\t}

\t\$currblk['outer_left_margin'] = \$prevblk['outer_left_margin'] + \$currblk['margin_left'] + \$prevblk['border_left']['w'] + \$prevblk['padding_left'];
\t\$currblk['outer_right_margin'] = \$prevblk['outer_right_margin']  + \$currblk['margin_right'] + \$prevblk['border_right']['w'] + \$prevblk['padding_right'];

\t\$currblk['width'] = \$this->pgwidth - (\$currblk['outer_right_margin'] + \$currblk['outer_left_margin']);
\t\$currblk['inner_width'] = \$currblk['width'] - (\$currblk['border_left']['w'] + \$currblk['padding_left'] + \$currblk['border_right']['w'] + \$currblk['padding_right']);

\t// Check DIV is not now too narrow to fit text
\t\$mw = 2*\$this->GetCharWidth('W',false);
\tif (\$currblk['inner_width'] < \$mw) {
\t\t\$currblk['padding_left'] = 0;
\t\t\$currblk['padding_right'] = 0;
\t\t\$currblk['border_left']['w'] = 0.2;
\t\t\$currblk['border_right']['w'] = 0.2;
\t\t\$currblk['margin_left'] = 0;
\t\t\$currblk['margin_right'] = 0;
\t\t\$currblk['outer_left_margin'] = \$prevblk['outer_left_margin'] + \$currblk['margin_left'] + \$prevblk['border_left']['w'] + \$prevblk['padding_left'];
\t\t\$currblk['outer_right_margin'] = \$prevblk['outer_right_margin']  + \$currblk['margin_right'] + \$prevblk['border_right']['w'] + \$prevblk['padding_right'];
\t\t\$currblk['width'] = \$this->pgwidth - (\$currblk['outer_right_margin'] + \$currblk['outer_left_margin']);
\t\t\$currblk['inner_width'] = \$this->pgwidth - (\$currblk['outer_right_margin'] + \$currblk['outer_left_margin'] + \$currblk['border_left']['w'] + \$currblk['padding_left'] + \$currblk['border_right']['w'] + \$currblk['padding_right']);
//\t\tif (\$currblk['inner_width'] < \$mw) { \$this->Error(\"DIV is too narrow for text to fit!\"); }
\t}

\t\$this->x = \$this->lMargin + \$currblk['outer_left_margin'];

/*-- BACKGROUNDS --*/
\tif (isset(\$properties['BACKGROUND-IMAGE']) && \$properties['BACKGROUND-IMAGE'] && !\$this->kwt && !\$this->ColActive && !\$this->keep_block_together) {
\t\t\$ret = \$this->SetBackground(\$properties, \$currblk['inner_width']);
\t\tif (\$ret) { \$currblk['background-image'] = \$ret; }
\t}
/*-- END BACKGROUNDS --*/

/*-- TABLES --*/
\tif (\$this->use_kwt && isset(\$attr['KEEP-WITH-TABLE']) && !\$this->ColActive && !\$this->keep_block_together) {
\t\t\$this->kwt = true;
\t\t\$this->kwt_y0 = \$this->y;
\t\t\$this->kwt_x0 = \$this->x;
\t\t\$this->kwt_height = 0;
\t\t\$this->kwt_buffer = array();
\t\t\$this->kwt_Links = array();
\t\t\$this->kwt_Annots = array();
\t\t\$this->kwt_moved = false;
\t\t\$this->kwt_saved = false;
\t\t\$this->kwt_Reference = array();
\t\t\$this->kwt_BMoutlines = array();
\t\t\$this->kwt_toc = array();
\t}
\telse {
/*-- END TABLES --*/
\t\t\$this->kwt = false;
\t}\t// *TABLES*

\t//Save x,y coords in case we need to print borders...
\t\$currblk['y0'] = \$this->y;
\t\$currblk['x0'] = \$this->x;
\t\$currblk['startpage'] = \$this->page;
\t\$this->oldy = \$this->y;

\t\$this->lastblocklevelchange = 1 ;

\tbreak;

    case 'HR':
\t// Added mPDF 3.0 Float DIV - CLEAR
\tif (isset(\$attr['STYLE'])) {
\t\t\$properties = \$this->cssmgr->readInlineCSS(\$attr['STYLE']);
\t\tif (isset(\$properties['CLEAR'])) { \$this->ClearFloats(strtoupper(\$properties['CLEAR']),\$this->blklvl); }\t// *CSS-FLOAT*
\t}

\t\$this->ignorefollowingspaces = true;

\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;
\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\tif (isset(\$properties['MARGIN-TOP'])) { \$objattr['margin_top'] = \$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\tif (isset(\$properties['MARGIN-BOTTOM'])) { \$objattr['margin_bottom'] = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\tif (isset(\$properties['WIDTH'])) { \$objattr['width'] = \$this->ConvertSize(\$properties['WIDTH'],\$this->blk[\$this->blklvl]['inner_width']); }
\telse if(isset(\$attr['WIDTH']) && \$attr['WIDTH'] != '') \$objattr['width'] = \$this->ConvertSize(\$attr['WIDTH'],\$this->blk[\$this->blklvl]['inner_width']);
\tif (isset(\$properties['TEXT-ALIGN'])) { \$objattr['align'] = \$align[strtolower(\$properties['TEXT-ALIGN'])]; }
\telse if(isset(\$attr['ALIGN']) && \$attr['ALIGN'] != '') \$objattr['align'] = \$align[strtolower(\$attr['ALIGN'])];

\tif (isset(\$properties['MARGIN-LEFT']) && strtolower(\$properties['MARGIN-LEFT'])=='auto') {
\t\t\$objattr['align'] = 'R';
\t}
\tif (isset(\$properties['MARGIN-RIGHT']) && strtolower(\$properties['MARGIN-RIGHT'])=='auto') {
\t\t\$objattr['align'] = 'L';
\t\tif (isset(\$properties['MARGIN-RIGHT']) && strtolower(\$properties['MARGIN-RIGHT'])=='auto' && isset(\$properties['MARGIN-LEFT']) && strtolower(\$properties['MARGIN-LEFT'])=='auto') {
\t\t\t\$objattr['align'] = 'C';
\t\t}
\t}
\tif (isset(\$properties['COLOR'])) { \$objattr['color'] = \$this->ConvertColor(\$properties['COLOR']); }
\telse if(isset(\$attr['COLOR']) && \$attr['COLOR'] != '') \$objattr['color'] = \$this->ConvertColor(\$attr['COLOR']);
\tif (isset(\$properties['HEIGHT'])) { \$objattr['linewidth'] = \$this->ConvertSize(\$properties['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }


/*-- TABLES --*/
\tif (\$this->tableLevel) {
\t\t\$objattr['W-PERCENT'] = 100;
\t\tif (isset(\$properties['WIDTH']) && stristr(\$properties['WIDTH'],'%')) {
\t\t\t\$properties['WIDTH'] += 0;  //make \"90%\" become simply \"90\"
\t\t\t\$objattr['W-PERCENT'] = \$properties['WIDTH'];
\t\t}
\t\tif (isset(\$attr['WIDTH']) && stristr(\$attr['WIDTH'],'%')) {
\t\t\t\$attr['WIDTH'] += 0;  //make \"90%\" become simply \"90\"
\t\t\t\$objattr['W-PERCENT'] = \$attr['WIDTH'];
\t\t}
\t}
/*-- END TABLES --*/

\t\$objattr['type'] = 'hr';
\t\$objattr['height'] = \$objattr['linewidth'] + \$objattr['margin_top'] + \$objattr['margin_bottom'];
\t\$e = \"\\xbb\\xa4\\xactype=image,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";

\t// Clear properties - tidy up
\t\$properties = array();

/*-- TABLES --*/
\t// Output it to buffers
\tif (\$this->tableLevel) {
\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\t\$this->cell[\$this->row][\$this->col]['s'] = 0 ;// reset
\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);
\t}
\telse {
/*-- END TABLES --*/
\t\t\$this->_saveTextBuffer(\$e, \$this->HREF);
\t}\t// *TABLES*

\tbreak;


/*-- BARCODES --*/

    case 'BARCODE':
\tif(isset(\$attr['CODE']) && \$attr['CODE']) {
\t\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['padding_top'] = 0;
\t\t\$objattr['padding_bottom'] = 0;
\t\t\$objattr['padding_left'] = 0;
\t\t\$objattr['padding_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;
     \t\t\$objattr['code'] = \$attr['CODE'];

\t\tif(isset(\$attr['TYPE'])) {
\t\t\t\$objattr['btype'] = trim(strtoupper(\$attr['TYPE']));
\t\t}
\t\telse { \$objattr['btype'] = 'EAN13'; }\t// default
\t\tif (preg_match('/^(EAN13|ISBN|ISSN|EAN8|UPCA|UPCE)P([25])\$/',\$objattr['btype'],\$m)) {
\t\t\t\$objattr['btype'] = \$m[1];
\t\t\t\$objattr['bsupp'] = \$m[2];
\t\t\tif (preg_match('/^(\\S+)\\s+(.*)\$/',\$objattr['code'],\$mm)) {
\t\t\t\t\$objattr['code'] = \$mm[1];
\t\t\t\t\$objattr['bsupp_code'] = \$mm[2];
\t\t\t}
\t\t}
\t\telse { \$objattr['bsupp'] = 0; }

\t\tif(isset(\$attr['TEXT']) && \$attr['TEXT']==1) { \$objattr['showtext'] = 1; }
\t\telse { \$objattr['showtext'] = 0; }
\t\tif(isset(\$attr['SIZE']) && \$attr['SIZE']>0) { \$objattr['bsize'] = \$attr['SIZE']; }
\t\telse { \$objattr['bsize'] = 1; }
\t\tif(isset(\$attr['HEIGHT']) && \$attr['HEIGHT']>0) { \$objattr['bheight'] = \$attr['HEIGHT']; }
\t\telse { \$objattr['bheight'] = 1; }
\t\tif(isset(\$attr['PR']) && \$attr['PR']>0) { \$objattr['pr_ratio'] = \$attr['PR']; }
\t\telse { \$objattr['pr_ratio'] = ''; }
\t\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\t\tif(isset(\$properties ['DISPLAY']) && strtolower(\$properties ['DISPLAY'])=='none') {
\t\t\treturn;
\t\t}
\t\tif (isset(\$properties['MARGIN-TOP'])) { \$objattr['margin_top']=\$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-BOTTOM'])) { \$objattr['margin_bottom'] = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-LEFT'])) { \$objattr['margin_left'] = \$this->ConvertSize(\$properties['MARGIN-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-RIGHT'])) { \$objattr['margin_right'] = \$this->ConvertSize(\$properties['MARGIN-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['PADDING-TOP'])) { \$objattr['padding_top']=\$this->ConvertSize(\$properties['PADDING-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-BOTTOM'])) { \$objattr['padding_bottom'] = \$this->ConvertSize(\$properties['PADDING-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-LEFT'])) { \$objattr['padding_left'] = \$this->ConvertSize(\$properties['PADDING-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-RIGHT'])) { \$objattr['padding_right'] = \$this->ConvertSize(\$properties['PADDING-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['BORDER-TOP'])) { \$objattr['border_top'] = \$this->border_details(\$properties['BORDER-TOP']); }
\t\tif (isset(\$properties['BORDER-BOTTOM'])) { \$objattr['border_bottom'] = \$this->border_details(\$properties['BORDER-BOTTOM']); }
\t\tif (isset(\$properties['BORDER-LEFT'])) { \$objattr['border_left'] = \$this->border_details(\$properties['BORDER-LEFT']); }
\t\tif (isset(\$properties['BORDER-RIGHT'])) { \$objattr['border_right'] = \$this->border_details(\$properties['BORDER-RIGHT']); }

\t\tif (isset(\$properties['VERTICAL-ALIGN'])) { \$objattr['vertical-align'] = \$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }
\t\tif (isset(\$properties['COLOR']) && \$properties['COLOR'] != '') { \$objattr['color'] = \$this->ConvertColor(\$properties['COLOR']); }
\t\telse { \$objattr['color'] = false; }
\t\tif (isset(\$properties['BACKGROUND-COLOR']) && \$properties['BACKGROUND-COLOR'] != '') { \$objattr['bgcolor'] = \$this->ConvertColor(\$properties['BACKGROUND-COLOR']); }
\t\telse { \$objattr['bgcolor'] = false; }

\t\tif (!class_exists('PDFBarcode', false)) {
\t\t\tinclude(_MPDF_PATH.'classes/barcode.php');
\t\t}
\t\t\$this->barcode = new PDFBarcode();

\t\tif (\$objattr['btype'] == 'EAN13' || \$objattr['btype'] == 'ISBN' || \$objattr['btype'] == 'ISSN' || \$objattr['btype'] == 'UPCA' || \$objattr['btype'] == 'UPCE' || \$objattr['btype'] == 'EAN8') {
\t\t\t\$code = preg_replace('/\\-/','',\$objattr['code']);
\t\t\tif (\$objattr['btype'] == 'ISSN' || \$objattr['btype'] == 'ISBN') {
\t\t\t\t\$arrcode = \$this->barcode->getBarcodeArray(\$code, 'EAN13');
\t\t\t}
\t\t\telse { \$arrcode = \$this->barcode->getBarcodeArray(\$code, \$objattr['btype'] ); }
\t\t\tif (\$arrcode === false) { \$this->Error('Error in barcode string.'); }

\t\t\tif (\$objattr['bsupp'] == 2 || \$objattr['bsupp'] == 5) {\t// EAN-2 or -5 Supplement
\t\t\t\t\$supparrcode = \$this->barcode->getBarcodeArray(\$objattr['bsupp_code'], 'EAN'.\$objattr['bsupp'] );
\t\t\t\t\$w = (\$arrcode[\"maxw\"] + \$arrcode['lightmL'] + \$arrcode['lightmR'] + \$supparrcode[\"maxw\"] + \$supparrcode['sepM']) * \$arrcode['nom-X'] * \$objattr['bsize'];
\t\t\t}
\t\t\telse {
\t\t\t\t\$w = (\$arrcode[\"maxw\"] + \$arrcode['lightmL'] + \$arrcode['lightmR']) * \$arrcode['nom-X'] * \$objattr['bsize'];
\t\t\t}
\t\t\t\$h = \$arrcode['nom-H'] * \$objattr['bsize'] * \$objattr['bheight'];
\t\t\t// Add height for ISBN string + margin from top of bars
\t\t\tif ((\$objattr['showtext'] && \$objattr['btype'] == 'EAN13') || \$objattr['btype'] == 'ISBN' || \$objattr['btype'] == 'ISSN') {
\t\t\t\t\$tisbnm = 1.5 * \$objattr['bsize'];\t// Top margin between TOP TEXT (isbn - if shown) & bars
\t\t\t\t\$isbn_fontsize = 2.1 * \$objattr['bsize'];
\t\t\t\t\$h += \$isbn_fontsize + \$tisbnm  ;
\t\t\t}
\t\t}
\t\t// QR-code
\t\telse if (\$objattr['btype'] == 'QR') {
\t\t\t\$w = \$h = \$objattr['bsize']*25;\t// Factor of 25mm (default)
\t\t\t\$objattr['errorlevel'] = 'L';
\t\t\tif (isset(\$attr['ERROR'])) { \$objattr['errorlevel'] = \$attr['ERROR']; }
\t\t}
\t\telse if (\$objattr['btype'] == 'IMB' || \$objattr['btype'] == 'RM4SCC' || \$objattr['btype'] == 'KIX' || \$objattr['btype'] == 'POSTNET' || \$objattr['btype'] == 'PLANET') {
\t\t\t\$arrcode = \$this->barcode->getBarcodeArray(\$objattr['code'], \$objattr['btype'] );
\t\t\tif (\$arrcode === false) { \$this->Error('Error in barcode string.'); }
\t\t\t\$w = (\$arrcode[\"maxw\"] * \$arrcode['nom-X'] * \$objattr['bsize']) + \$arrcode['quietL'] + \$arrcode['quietR'];
\t\t\t\$h = (\$arrcode['nom-H'] * \$objattr['bsize']) + (2*\$arrcode['quietTB']);
\t\t}
\t\telse if (in_array(\$objattr['btype'], array('C128A','C128B','C128C','EAN128A','EAN128B','EAN128C','C39','C39+','C39E','C39E+','S25','S25+','I25','I25+','I25B','I25B+','C93','MSI','MSI+','CODABAR','CODE11'))) {
\t\t\t\$arrcode = \$this->barcode->getBarcodeArray(\$objattr['code'], \$objattr['btype'], \$objattr['pr_ratio'] );
\t\t\tif (\$arrcode === false) { \$this->Error('Error in barcode string.'); }
\t\t\t\$w = (\$arrcode[\"maxw\"] + \$arrcode['lightmL'] + \$arrcode['lightmR']) * \$arrcode['nom-X'] * \$objattr['bsize'];
\t\t\t\$h = ((2*\$arrcode['lightTB'] * \$arrcode['nom-X']) + \$arrcode['nom-H']) * \$objattr['bsize'] * \$objattr['bheight'];
\t\t}
\t\telse { break; }

\t\t\$extraheight = \$objattr['padding_top'] + \$objattr['padding_bottom'] + \$objattr['margin_top'] + \$objattr['margin_bottom'] + \$objattr['border_top']['w'] + \$objattr['border_bottom']['w'];
\t\t\$extrawidth = \$objattr['padding_left'] + \$objattr['padding_right'] + \$objattr['margin_left'] + \$objattr['margin_right'] + \$objattr['border_left']['w'] + \$objattr['border_right']['w'];

\t\t\$objattr['type'] = 'barcode';
\t\t\$objattr['height'] = \$h + \$extraheight;
\t\t\$objattr['width'] = \$w + \$extrawidth;
\t\t\$objattr['barcode_height'] = \$h;
\t\t\$objattr['barcode_width'] = \$w;
/*-- CSS-IMAGE-FLOAT --*/
\t\tif (!\$this->ColActive && !\$this->tableLevel && !\$this->listlvl && !\$this->kwt && !\$this->keep_block_together) {
\t\t  if (isset(\$properties['FLOAT']) && (strtoupper(\$properties['FLOAT']) == 'RIGHT' || strtoupper(\$properties['FLOAT']) == 'LEFT')) {
\t\t\t\$objattr['float'] = substr(strtoupper(\$properties['FLOAT']),0,1);
\t\t  }
\t\t}
/*-- END CSS-IMAGE-FLOAT --*/

\t\t\$e = \"\\xbb\\xa4\\xactype=barcode,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";

\t\t// Clear properties - tidy up
\t\t\$properties = array();

/*-- TABLES --*/
\t\t// Output it to buffers
\t\tif (\$this->tableLevel) {
\t\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);
\t\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$objattr['width'] ;
\t\t}
\t\telse {
/*-- END TABLES --*/
\t\t\t\$this->_saveTextBuffer(\$e, \$this->HREF);

\t\t}\t// *TABLES*
\t}
\tbreak;
/*-- END BARCODES --*/


\t// *********** FORM ELEMENTS ********************

/*-- FORMS --*/
    case 'SELECT':
\t\$this->lastoptionaltag = ''; // Save current HTML specified optional endtag
\t\$this->InlineProperties[\$tag] = \$this->saveInlineProperties();
\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\tif (isset(\$properties['FONT-FAMILY'])) {
\t\t\$this->SetFont(\$properties['FONT-FAMILY'],\$this->FontStyle,0,false);
\t}
\tif (isset(\$properties['FONT-SIZE'])) {
\t\t\$mmsize = \$this->ConvertSize(\$properties['FONT-SIZE'],\$this->default_font_size/_MPDFK);
  \t\t\$this->SetFontSize(\$mmsize*_MPDFK,false);
\t}
\tif (isset(\$attr['SPELLCHECK']) && strtolower(\$attr['SPELLCHECK'])=='true') {
\t\t\$this->selectoption['SPELLCHECK'] = true;
\t}

\tif (isset(\$properties['COLOR'])) { \$this->selectoption['COLOR'] = \$this->ConvertColor(\$properties['COLOR']); }
\t\$this->specialcontent = \"type=select\";
\tif(isset(\$attr['DISABLED'])) { \$this->selectoption['DISABLED'] = \$attr['DISABLED']; }
\tif(isset(\$attr['READONLY'])) { \$this->selectoption['READONLY'] = \$attr['READONLY']; }
\tif(isset(\$attr['REQUIRED'])) { \$this->selectoption['REQUIRED'] = \$attr['REQUIRED']; }
\tif(isset(\$attr['EDITABLE'])) { \$this->selectoption['EDITABLE'] = \$attr['EDITABLE']; }
\tif(isset(\$attr['TITLE'])) { \$this->selectoption['TITLE'] = \$attr['TITLE']; }
\tif(isset(\$attr['MULTIPLE'])) { \$this->selectoption['MULTIPLE'] = \$attr['MULTIPLE']; }
\tif(isset(\$attr['SIZE']) && \$attr['SIZE']>1) { \$this->selectoption['SIZE'] = \$attr['SIZE']; }
\tif (\$this->useActiveForms) {
\t\tif(isset(\$attr['NAME'])) { \$this->selectoption['NAME'] = \$attr['NAME']; }
\t\tif (isset(\$attr['ONCHANGE'])) { \$this->selectoption['ONCHANGE'] = \$attr['ONCHANGE']; }
\t}

\t\$properties = array();
\tbreak;

    case 'OPTION':
\t\$this->lastoptionaltag = 'OPTION'; // Save current HTML specified optional endtag
\t\$this->selectoption['ACTIVE'] = true;
\t\$this->selectoption['currentSEL'] = false;
\tif (empty(\$this->selectoption)) {
\t\t\$this->selectoption['MAXWIDTH'] = '';
\t\t\$this->selectoption['SELECTED'] = '';
\t}
\tif (isset(\$attr['SELECTED'])) {
\t\t\$this->selectoption['SELECTED'] = '';
\t\t\$this->selectoption['currentSEL'] = true;
\t}
\tif(isset(\$attr['VALUE'])) {
\t\t\$attr['VALUE'] = strcode2utf(\$attr['VALUE']);
\t\t\$attr['VALUE'] = \$this->lesser_entity_decode(\$attr['VALUE']);
\t\tif (\$this->onlyCoreFonts)
\t\t\t\$attr['VALUE'] = mb_convert_encoding(\$attr['VALUE'], \$this->mb_enc,'UTF-8');
\t}
\t\$this->selectoption['currentVAL'] = \$attr['VALUE'];
\tbreak;

    case 'TEXTAREA':
\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;
\tif(isset(\$attr['DISABLED'])) { \$objattr['disabled'] = true; }
\tif(isset(\$attr['READONLY'])) { \$objattr['readonly'] = true; }
\tif(isset(\$attr['REQUIRED'])) { \$objattr['required'] = true; }
\tif(isset(\$attr['SPELLCHECK']) && strtolower(\$attr['SPELLCHECK'])=='true') { \$objattr['spellcheck'] = true; }
\tif(isset(\$attr['TITLE'])) { \$objattr['title'] = \$attr['TITLE']; }
\tif (\$this->onlyCoreFonts)
\t\t\$objattr['title'] = mb_convert_encoding(\$objattr['title'], \$this->mb_enc,'UTF-8');
\tif (\$this->useActiveForms) {
\t\tif(isset(\$attr['NAME'])) { \$objattr['fieldname'] = \$attr['NAME']; }
\t\t\$this->form->form_element_spacing['textarea']['outer']['v'] = 0;
\t\t\$this->form->form_element_spacing['textarea']['inner']['v'] = 0;
\t\tif (isset(\$attr['ONCALCULATE'])) { \$objattr['onCalculate'] = \$attr['ONCALCULATE']; }
\t\telse if (isset(\$attr['ONCHANGE'])) { \$objattr['onCalculate'] = \$attr['ONCHANGE']; }
\t\tif (isset(\$attr['ONVALIDATE'])) { \$objattr['onValidate'] = \$attr['ONVALIDATE']; }
\t\tif (isset(\$attr['ONKEYSTROKE'])) { \$objattr['onKeystroke'] = \$attr['ONKEYSTROKE']; }
\t\tif (isset(\$attr['ONFORMAT'])) { \$objattr['onFormat'] = \$attr['ONFORMAT']; }
\t}
\t\$this->InlineProperties[\$tag] = \$this->saveInlineProperties();
\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\tif (isset(\$properties['FONT-FAMILY'])) {
\t\t\$this->SetFont(\$properties['FONT-FAMILY'],'',0,false);
\t}
\tif (isset(\$properties['FONT-SIZE'])) {
\t\t\$mmsize = \$this->ConvertSize(\$properties['FONT-SIZE'],\$this->default_font_size/_MPDFK);
  \t\t\$this->SetFontSize(\$mmsize*_MPDFK,false);
\t}
\tif (isset(\$properties['COLOR'])) { \$objattr['color'] = \$this->ConvertColor(\$properties['COLOR']); }
\t\$objattr['fontfamily'] = \$this->FontFamily;
\t\$objattr['fontsize'] = \$this->FontSizePt;
\tif (\$this->useActiveForms) {
\t\tif(isset(\$properties['TEXT-ALIGN'])) { \$objattr['text_align'] = \$align[strtolower(\$properties['TEXT-ALIGN'])]; }
\t\telse if(isset(\$attr['ALIGN'])) { \$objattr['text_align'] =  \$align[strtolower(\$attr['ALIGN'])]; }
\t\tif (isset(\$properties['OVERFLOW']) && strtolower(\$properties['OVERFLOW'])=='hidden') { \$objattr['donotscroll'] = true; }
\t\tif (isset(\$properties['BORDER-TOP-COLOR'])) { \$objattr['border-col'] = \$this->ConvertColor(\$properties['BORDER-TOP-COLOR']); }
\t\tif (isset(\$properties['BACKGROUND-COLOR'])) { \$objattr['background-col'] = \$this->ConvertColor(\$properties['BACKGROUND-COLOR']); }
\t}
\t\$this->SetLineHeight('',\$this->form->textarea_lineheight);
\t\$formLineHeight = \$this->lineheight;

\t\$w = 0;
\t\$h = 0;
\tif(isset(\$properties['WIDTH'])) \$w = \$this->ConvertSize(\$properties['WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\tif(isset(\$properties['HEIGHT'])) \$h = \$this->ConvertSize(\$properties['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\tif (\$properties['VERTICAL-ALIGN']) { \$objattr['vertical-align'] = \$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }

\t\$colsize = 20; //HTML default value
\t\$rowsize = 2; //HTML default value
\tif (isset(\$attr['COLS'])) \$colsize = intval(\$attr['COLS']);
\tif (isset(\$attr['ROWS'])) \$rowsize = intval(\$attr['ROWS']);

\t\$charsize = \$this->GetCharWidth('w',false);
\tif (\$w) { \$colsize = round((\$w-(\$this->form->form_element_spacing['textarea']['outer']['h']*2)-(\$this->form->form_element_spacing['textarea']['inner']['h']*2))/\$charsize); }
\tif (\$h) { \$rowsize = round((\$h-(\$this->form->form_element_spacing['textarea']['outer']['v']*2)-(\$this->form->form_element_spacing['textarea']['inner']['v']*2))/\$formLineHeight); }

\t\$objattr['type'] = 'textarea';
\t\$objattr['width'] = (\$colsize * \$charsize) + (\$this->form->form_element_spacing['textarea']['outer']['h']*2)+(\$this->form->form_element_spacing['textarea']['inner']['h']*2);
\t\$objattr['height'] = (\$rowsize * \$formLineHeight) + (\$this->form->form_element_spacing['textarea']['outer']['v']*2)+(\$this->form->form_element_spacing['textarea']['inner']['v']*2);
\t\$objattr['rows'] = \$rowsize;
\t\$objattr['cols'] = \$colsize;

\t\$this->specialcontent = serialize(\$objattr);

\tif (\$this->tableLevel) {\t// *TABLES*
\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$objattr['width'] ;\t// *TABLES*
\t}\t// *TABLES*

\t// Clear properties - tidy up
\t\$properties = array();
\tbreak;



\t// *********** FORM - INPUT ********************

    case 'INPUT':
\tif (!isset(\$attr['TYPE'])) \$attr['TYPE'] == 'TEXT';
\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;
\t\$objattr['type'] = 'input';
\tif(isset(\$attr['DISABLED'])) { \$objattr['disabled'] = true; }
\tif(isset(\$attr['READONLY'])) { \$objattr['readonly'] = true; }
\tif(isset(\$attr['REQUIRED'])) { \$objattr['required'] = true; }
\tif(isset(\$attr['SPELLCHECK']) && strtolower(\$attr['SPELLCHECK'])=='true') { \$objattr['spellcheck'] = true; }
\tif(isset(\$attr['TITLE'])) { \$objattr['title'] = \$attr['TITLE']; }
\telse if(isset(\$attr['ALT'])) { \$objattr['title'] = \$attr['ALT']; }
\telse \$objattr['title'] = '';
\t\$objattr['title'] = strcode2utf(\$objattr['title']);
\t\$objattr['title'] = \$this->lesser_entity_decode(\$objattr['title']);
\tif (\$this->onlyCoreFonts)
\t\t\$objattr['title'] = mb_convert_encoding(\$objattr['title'], \$this->mb_enc,'UTF-8');
\tif (\$this->useActiveForms) {
\t\tif(isset(\$attr['NAME'])) { \$objattr['fieldname'] = \$attr['NAME']; }
\t}
\tif(isset(\$attr['VALUE'])) {
\t\t\$attr['VALUE'] = strcode2utf(\$attr['VALUE']);
\t\t\$attr['VALUE'] = \$this->lesser_entity_decode(\$attr['VALUE']);
\t\tif (\$this->onlyCoreFonts)
\t\t\t\$attr['VALUE'] = mb_convert_encoding(\$attr['VALUE'], \$this->mb_enc,'UTF-8');
\t\t\$objattr['value'] = \$attr['VALUE'];
\t}

\t\$this->InlineProperties[\$tag] = \$this->saveInlineProperties();
\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\t\$objattr['vertical-align'] = '';

\tif (isset(\$properties['FONT-FAMILY'])) {
\t\t\$this->SetFont(\$properties['FONT-FAMILY'],\$this->FontStyle,0,false);
\t}
\tif (isset(\$properties['FONT-SIZE'])) {
\t\t\$mmsize = \$this->ConvertSize(\$properties['FONT-SIZE'],(\$this->default_font_size/_MPDFK));
  \t\t\$this->SetFontSize(\$mmsize*_MPDFK,false);
\t}
\tif (isset(\$properties['COLOR'])) { \$objattr['color'] = \$this->ConvertColor(\$properties['COLOR']); }
\t\$objattr['fontfamily'] = \$this->FontFamily;
\t\$objattr['fontsize'] = \$this->FontSizePt;
\tif (\$this->useActiveForms) {
\t\tif(isset(\$attr['ALIGN'])) { \$objattr['text_align'] = \$align[strtolower(\$attr['ALIGN'])]; }
\t\telse if(isset(\$properties['TEXT-ALIGN'])) { \$objattr['text_align'] = \$align[strtolower(\$properties['TEXT-ALIGN'])]; }
\t\tif (isset(\$properties['BORDER-TOP-COLOR'])) { \$objattr['border-col'] = \$this->ConvertColor(\$properties['BORDER-TOP-COLOR']); }
\t\tif (isset(\$properties['BACKGROUND-COLOR'])) { \$objattr['background-col'] = \$this->ConvertColor(\$properties['BACKGROUND-COLOR']); }
\t}

\t\$type = '';
      \$texto='';
\t\$height = \$this->FontSize;
\t\$width = 0;
\t\$spacesize = \$this->GetCharWidth(' ',false);

\t\$w = 0;
\tif(isset(\$properties['WIDTH'])) \$w = \$this->ConvertSize(\$properties['WIDTH'],\$this->blk[\$this->blklvl]['inner_width']);

\tif (\$properties['VERTICAL-ALIGN']) { \$objattr['vertical-align'] = \$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }

\tswitch(strtoupper(\$attr['TYPE'])){
\t   case 'HIDDEN':
      \t\t\$this->ignorefollowingspaces = true; //Eliminate exceeding left-side spaces
\t\t\tif (\$this->useActiveForms) {
\t\t\t\t\$this->form->SetFormText( 0, 0, \$objattr['fieldname'], \$objattr['value'], \$objattr['value'], '', 0, '', true );
\t\t\t}
\t\t\tif (\$this->InlineProperties[\$tag]) { \$this->restoreInlineProperties(\$this->InlineProperties[\$tag]); }
\t\t\tunset(\$this->InlineProperties[\$tag]);
\t\t\tbreak 2;
\t   case 'CHECKBOX': //Draw Checkbox
\t\t\t\$type = 'CHECKBOX';
\t\t\tif (isset(\$attr['CHECKED'])) { \$objattr['checked'] = true; }
\t\t\telse { \$objattr['checked'] = false; }
\t\t\t\$width = \$this->FontSize;
\t\t\t\$height = \$this->FontSize;
\t\t\tbreak;

\t   case 'RADIO': //Draw Radio button
\t\t\t\$type = 'RADIO';
\t\t\tif (isset(\$attr['CHECKED'])) \$objattr['checked'] = true;
\t\t\t\$width = \$this->FontSize;
\t\t\t\$height = \$this->FontSize;
\t\t\tbreak;

/*-- IMAGES-CORE --*/
\t   case 'IMAGE': // Draw an Image button
\tif(isset(\$attr['SRC']))\t{
\t\t\$type = 'IMAGE';
     \t\t\$srcpath = \$attr['SRC'];
\t\t\$orig_srcpath = \$attr['ORIG_SRC'];
\t\t// VSPACE and HSPACE converted to margins in MergeCSS
\t\tif (isset(\$properties['MARGIN-TOP'])) { \$objattr['margin_top']=\$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-BOTTOM'])) { \$objattr['margin_bottom'] = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-LEFT'])) { \$objattr['margin_left'] = \$this->ConvertSize(\$properties['MARGIN-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-RIGHT'])) { \$objattr['margin_right'] = \$this->ConvertSize(\$properties['MARGIN-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }


\t\tif (isset(\$properties['BORDER-TOP'])) { \$objattr['border_top'] = \$this->border_details(\$properties['BORDER-TOP']); }
\t\tif (isset(\$properties['BORDER-BOTTOM'])) { \$objattr['border_bottom'] = \$this->border_details(\$properties['BORDER-BOTTOM']); }
\t\tif (isset(\$properties['BORDER-LEFT'])) { \$objattr['border_left'] = \$this->border_details(\$properties['BORDER-LEFT']); }
\t\tif (isset(\$properties['BORDER-RIGHT'])) { \$objattr['border_right'] = \$this->border_details(\$properties['BORDER-RIGHT']); }

\t\t\$objattr['padding_top'] = 0;
\t\t\$objattr['padding_bottom'] = 0;
\t\t\$objattr['padding_left'] = 0;
\t\t\$objattr['padding_right'] = 0;

\t\tif (isset(\$properties['VERTICAL-ALIGN'])) { \$objattr['vertical-align'] = \$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }

\t\t\$w = 0;
\t\t\$h = 0;
\t\tif(isset(\$properties['WIDTH'])) \$w = \$this->ConvertSize(\$properties['WIDTH'],\$this->blk[\$this->blklvl]['inner_width']);
\t\tif(isset(\$properties['HEIGHT'])) \$h = \$this->ConvertSize(\$properties['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width']);

\t\t\$extraheight = \$objattr['margin_top'] + \$objattr['margin_bottom'] + \$objattr['border_top']['w'] + \$objattr['border_bottom']['w'];
\t\t\$extrawidth = \$objattr['margin_left'] + \$objattr['margin_right'] + \$objattr['border_left']['w'] + \$objattr['border_right']['w'];

\t\t// Image file
\t\t\$info=\$this->_getImage(\$srcpath, true, true, \$orig_srcpath);
\t\tif(!\$info) {
\t\t\t\$info = \$this->_getImage(\$this->noImageFile);
\t\t\tif (\$info) {
\t\t\t\t\$srcpath = \$this->noImageFile;
\t\t\t\t\$w = (\$info['w'] * (25.4/\$this->dpi));
\t\t\t\t\$h = (\$info['h'] * (25.4/\$this->dpi));
\t\t\t}
\t\t}
\t\tif(!\$info) break;
\t\tif (\$info['cs']=='Indexed') { \$objattr['Indexed'] = true; }
\t\t\$objattr['file'] = \$srcpath;
\t\t//Default width and height calculation if needed
\t\tif(\$w==0 and \$h==0) {
/*-- IMAGES-WMF --*/
      \t      if (\$info['type']=='wmf') {
\t\t\t\t// WMF units are twips (1/20pt)
\t\t\t\t// divide by 20 to get points
\t\t\t\t// divide by k to get user units
\t\t\t\t\$w = abs(\$info['w'])/(20*_MPDFK);
\t\t\t\t\$h = abs(\$info['h']) / (20*_MPDFK);
\t\t\t}
\t\t\telse
/*-- END IMAGES-WMF --*/
      \t      if (\$info['type']=='svg') {
\t\t\t\t// SVG units are pixels
\t\t\t\t\$w = abs(\$info['w'])/_MPDFK;
\t\t\t\t\$h = abs(\$info['h'])/_MPDFK;
\t\t\t}
\t\t\telse {
\t\t\t\t//Put image at default image dpi
\t\t\t\t\$w=(\$info['w']/_MPDFK) * (72/\$this->img_dpi);
\t\t\t\t\$h=(\$info['h']/_MPDFK) * (72/\$this->img_dpi);
\t\t\t}
\t\t\tif (isset(\$properties['IMAGE-RESOLUTION'])) {
\t\t\t\tif (preg_match('/from-image/i', \$properties['IMAGE-RESOLUTION']) && isset(\$info['set-dpi']) && \$info['set-dpi']>0) {
\t\t\t\t\t\$w *= \$this->img_dpi / \$info['set-dpi'];
\t\t\t\t\t\$h *= \$this->img_dpi / \$info['set-dpi'];
\t\t\t\t}
\t\t\t\telse if (preg_match('/(\\d+)dpi/i', \$properties['IMAGE-RESOLUTION'], \$m)) {
\t\t\t\t\t\$dpi = \$m[1];
\t\t\t\t\tif (\$dpi > 0) {
\t\t\t\t\t\t\$w *= \$this->img_dpi / \$dpi;
\t\t\t\t\t\t\$h *= \$this->img_dpi / \$dpi;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t}
\t\t// IF WIDTH OR HEIGHT SPECIFIED
\t\tif(\$w==0)\t\$w=\$h*\$info['w']/\$info['h'];
\t\tif(\$h==0)\t\$h=\$w*\$info['h']/\$info['w'];
\t\t// Resize to maximum dimensions of page
\t\t\$maxWidth = \$this->blk[\$this->blklvl]['inner_width'];
   \t\t\$maxHeight = \$this->h - (\$this->tMargin + \$this->bMargin + 10) ;
\t\tif (\$this->fullImageHeight) { \$maxHeight = \$this->fullImageHeight; }
\t\tif (\$w + \$extrawidth > \$maxWidth ) {
\t\t\t\$w = \$maxWidth - \$extrawidth;
\t\t\t\$h=\$w*\$info['h']/\$info['w'];
\t\t}
\t\tif (\$h + \$extraheight > \$maxHeight ) {
\t\t\t\$h = \$maxHeight - \$extraheight;
\t\t\t\$w=\$h*\$info['w']/\$info['h'];
\t\t}
\t\t\$height = \$h + \$extraheight;
\t\t\$width = \$w + \$extrawidth;
\t\t\$objattr['type'] = 'image';
\t\t\$objattr['itype'] = \$info['type'];
\t\t\$objattr['orig_h'] = \$info['h'];
\t\t\$objattr['orig_w'] = \$info['w'];
/*-- IMAGES-WMF --*/
\t\tif (\$info['type']=='wmf') {
\t\t\t\$objattr['wmf_x'] = \$info['x'];
\t\t\t\$objattr['wmf_y'] = \$info['y'];
\t\t}
\t\telse
/*-- END IMAGES-WMF --*/
\t\tif (\$info['type']=='svg') {
\t\t\t\$objattr['wmf_x'] = \$info['x'];
\t\t\t\$objattr['wmf_y'] = \$info['y'];
\t\t}
\t\t\$objattr['height'] = \$h + \$extraheight;
\t\t\$objattr['width'] = \$w + \$extrawidth;

\t\t\$objattr['image_height'] = \$h;
\t\t\$objattr['image_width'] = \$w;
\t\t\$objattr['ID'] = \$info['i'];
\t\t\$texto = 'X';
\t\tif (\$this->useActiveForms) {
\t\t\tif (isset(\$attr['ONCLICK'])) { \$objattr['onClick'] = \$attr['ONCLICK']; }
\t\t\t\$objattr['type'] = 'input';
\t\t\t\$type = 'IMAGE';
\t\t}
\t\tbreak;
\t}
/*-- END IMAGES-CORE --*/

\t   case 'BUTTON': // Draw a button
\t   case 'SUBMIT':
\t   case 'RESET':
\t\t\t\$type = strtoupper(\$attr['TYPE']);
\t\t\tif (\$type=='IMAGE') { \$type = 'BUTTON'; } // src path not found
\t\t\tif(isset(\$attr['NOPRINT'])) { \$objattr['noprint'] = true; }
\t\t\tif (!isset(\$attr['VALUE'])) {
\t\t\t\t\$objattr['value'] = ucfirst(strtolower(\$type));
\t\t\t}

\t\t\t\$texto = \" \" . \$objattr['value'] . \" \";
\t\t\t\$width = \$this->GetStringWidth(\$texto) + (\$this->form->form_element_spacing['button']['outer']['h']*2)+(\$this->form->form_element_spacing['button']['inner']['h']*2);
\t\t\t\$height = \$this->FontSize + (\$this->form->form_element_spacing['button']['outer']['v']*2)+(\$this->form->form_element_spacing['button']['inner']['v']*2);
\t\t\tif (\$this->useActiveForms) {
\t\t\t\tif (isset(\$attr['ONCLICK'])) { \$objattr['onClick'] = \$attr['ONCLICK']; }
\t\t\t}
\t\t\tbreak;

\t   case 'PASSWORD':
\t   case 'TEXT':
\t   default:
                if (\$type == '') { \$type = 'TEXT'; }
\t\t    if(strtoupper(\$attr['TYPE'])=='PASSWORD') { \$type = 'PASSWORD'; }
                if (isset(\$attr['VALUE'])) {
\t\t\tif (\$type == 'PASSWORD') {
                    \$num_stars = mb_strlen(\$attr['VALUE'],\$this->mb_enc );
                    \$texto = str_repeat('*',\$num_stars);
\t\t\t}
\t\t\telse { \$texto = \$attr['VALUE']; }
                }
\t\t    \$xw = (\$this->form->form_element_spacing['input']['outer']['h']*2)+(\$this->form->form_element_spacing['input']['inner']['h']*2);
\t\t    \$xh = (\$this->form->form_element_spacing['input']['outer']['v']*2)+(\$this->form->form_element_spacing['input']['inner']['v']*2);
\t\t    if (\$w) { \$width = \$w + \$xw; }
\t\t    else { \$width = (20 * \$spacesize) + \$xw; }\t// Default width in chars
                if (isset(\$attr['SIZE']) and ctype_digit(\$attr['SIZE']) ) \$width = (\$attr['SIZE'] * \$spacesize) + \$xw;
\t\t    \$height = \$this->FontSize + \$xh;
                if (isset(\$attr['MAXLENGTH']) and ctype_digit(\$attr['MAXLENGTH']) ) \$objattr['maxlength'] = \$attr['MAXLENGTH'];
\t\t    if (\$this->useActiveForms) {
\t\t\tif (isset(\$attr['ONCALCULATE'])) { \$objattr['onCalculate'] = \$attr['ONCALCULATE']; }
\t\t\telse if (isset(\$attr['ONCHANGE'])) { \$objattr['onCalculate'] = \$attr['ONCHANGE']; }
\t\t\tif (isset(\$attr['ONVALIDATE'])) { \$objattr['onValidate'] = \$attr['ONVALIDATE']; }
\t\t\tif (isset(\$attr['ONKEYSTROKE'])) { \$objattr['onKeystroke'] = \$attr['ONKEYSTROKE']; }
\t\t\tif (isset(\$attr['ONFORMAT'])) { \$objattr['onFormat'] = \$attr['ONFORMAT']; }
\t\t    }
                break;
\t}

\t\$objattr['subtype'] = \$type;
\t\$objattr['text'] = \$texto;
\t\$objattr['width'] = \$width;
\t\$objattr['height'] = \$height;
\t\$e = \"\\xbb\\xa4\\xactype=input,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";

\t// Clear properties - tidy up
\t\$properties = array();

/*-- TABLES --*/
\t// Output it to buffers
\tif (\$this->tableLevel) {
\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);
\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$objattr['width'] ;

\t}
\telse {
/*-- END TABLES --*/
\t\t\$this->_saveTextBuffer(\$e, \$this->HREF);
\t}\t// *TABLES*

\tif (\$this->InlineProperties[\$tag]) { \$this->restoreInlineProperties(\$this->InlineProperties[\$tag]); }
\tunset(\$this->InlineProperties[\$tag]);

\tbreak;\t// END of INPUT
/*-- END FORMS --*/


\t// *********** GRAPH  ********************
     case 'JPGRAPH':
\tif (!\$this->useGraphs) { break; }
\tif (\$attr['TABLE']) { \$gid = strtoupper(\$attr['TABLE']); }
\telse { \$gid = '0'; }
\tif (!is_array(\$this->graphs[\$gid]) || count(\$this->graphs[\$gid])==0 ) { break; }
\tinclude_once(_MPDF_PATH.'graph.php');
\t\$this->graphs[\$gid]['attr'] = \$attr;


\tif (isset(\$this->graphs[\$gid]['attr']['WIDTH']) && \$this->graphs[\$gid]['attr']['WIDTH']) {
\t\t\$this->graphs[\$gid]['attr']['cWIDTH']=\$this->ConvertSize(\$this->graphs[\$gid]['attr']['WIDTH'],\$pgwidth);
\t}\t// mm
\tif (isset(\$this->graphs[\$gid]['attr']['HEIGHT']) && \$this->graphs[\$gid]['attr']['HEIGHT']) {
\t\t\$this->graphs[\$gid]['attr']['cHEIGHT']=\$this->ConvertSize(\$this->graphs[\$gid]['attr']['HEIGHT'],\$pgwidth);
\t}

\t\$graph_img = print_graph(\$this->graphs[\$gid],\$this->blk[\$this->blklvl]['inner_width']);
\tif (\$graph_img) {
\t\tif(isset(\$attr['ROTATE'])) {
\t\t   if (\$attr['ROTATE']==90 || \$attr['ROTATE']==-90) {
\t\t\t\$tmpw = \$graph_img['w'];
\t\t\t\$graph_img['w']= \$graph_img['h'];
\t\t\t\$graph_img['h']= \$tmpw;
\t\t   }
\t\t}
\t\t\$attr['SRC'] = \$graph_img['file'];
\t\t\$attr['WIDTH'] = \$graph_img['w'];
\t\t\$attr['HEIGHT'] = \$graph_img['h'];
\t}
\telse { break; }

\t// *********** IMAGE  ********************
/*-- IMAGES-CORE --*/
    case 'IMG':
\tif (\$this->progressBar) { \$this->UpdateProgressBar(1,'','IMG'); }\t// *PROGRESS-BAR*
\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['padding_top'] = 0;
\t\t\$objattr['padding_bottom'] = 0;
\t\t\$objattr['padding_left'] = 0;
\t\t\$objattr['padding_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;
\tif(isset(\$attr['SRC']))\t{
     \t\t\$srcpath = \$attr['SRC'];
\t\t\$orig_srcpath = \$attr['ORIG_SRC'];
\t\t\$properties = \$this->cssmgr->MergeCSS('',\$tag,\$attr);
\t\tif(isset(\$properties ['DISPLAY']) && strtolower(\$properties ['DISPLAY'])=='none') {
\t\t\treturn;
\t\t}
\t\t// mPDF 5.6.01  - LAYERS
\t\tif (isset(\$properties['Z-INDEX']) && \$this->currentlayer==0) {
\t\t\t\$v = intval(\$properties['Z-INDEX']);
\t\t\tif (\$v > 0) {
\t\t\t\t\$objattr['z-index'] = \$v;
\t\t\t}
\t\t}

\t\t\$objattr['visibility'] = 'visible';
\t\tif (isset(\$properties['VISIBILITY'])) {
\t\t\t\$v = strtolower(\$properties['VISIBILITY']);
\t\t\tif ((\$v == 'hidden' || \$v == 'printonly' || \$v == 'screenonly') && \$this->visibility=='visible') {
\t\t\t\t\$objattr['visibility'] = \$v;
\t\t\t}
\t\t}

\t\t// VSPACE and HSPACE converted to margins in MergeCSS
\t\tif (isset(\$properties['MARGIN-TOP'])) { \$objattr['margin_top']=\$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-BOTTOM'])) { \$objattr['margin_bottom'] = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-LEFT'])) { \$objattr['margin_left'] = \$this->ConvertSize(\$properties['MARGIN-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-RIGHT'])) { \$objattr['margin_right'] = \$this->ConvertSize(\$properties['MARGIN-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['PADDING-TOP'])) { \$objattr['padding_top']=\$this->ConvertSize(\$properties['PADDING-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-BOTTOM'])) { \$objattr['padding_bottom'] = \$this->ConvertSize(\$properties['PADDING-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-LEFT'])) { \$objattr['padding_left'] = \$this->ConvertSize(\$properties['PADDING-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-RIGHT'])) { \$objattr['padding_right'] = \$this->ConvertSize(\$properties['PADDING-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['BORDER-TOP'])) { \$objattr['border_top'] = \$this->border_details(\$properties['BORDER-TOP']); }
\t\tif (isset(\$properties['BORDER-BOTTOM'])) { \$objattr['border_bottom'] = \$this->border_details(\$properties['BORDER-BOTTOM']); }
\t\tif (isset(\$properties['BORDER-LEFT'])) { \$objattr['border_left'] = \$this->border_details(\$properties['BORDER-LEFT']); }
\t\tif (isset(\$properties['BORDER-RIGHT'])) { \$objattr['border_right'] = \$this->border_details(\$properties['BORDER-RIGHT']); }

\t\tif (isset(\$properties['VERTICAL-ALIGN'])) { \$objattr['vertical-align'] = \$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }
\t\t\$w = 0;
\t\t\$h = 0;
\t\tif(isset(\$properties['WIDTH'])) \$w = \$this->ConvertSize(\$properties['WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['WIDTH'])) \$w = \$this->ConvertSize(\$attr['WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\tif(isset(\$properties['HEIGHT'])) \$h = \$this->ConvertSize(\$properties['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['HEIGHT'])) \$h = \$this->ConvertSize(\$attr['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t// mPDF 5.5.15\t\t// mPDF 5.6.60
\t\t\$maxw=\$maxh=\$minw=\$minh=false;
\t\tif(isset(\$properties['MAX-WIDTH'])) \$maxw = \$this->ConvertSize(\$properties['MAX-WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['MAX-WIDTH'])) \$maxw = \$this->ConvertSize(\$attr['MAX-WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\tif(isset(\$properties['MAX-HEIGHT'])) \$maxh = \$this->ConvertSize(\$properties['MAX-HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['MAX-HEIGHT'])) \$maxh = \$this->ConvertSize(\$attr['MAX-HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\tif(isset(\$properties['MIN-WIDTH'])) \$minw = \$this->ConvertSize(\$properties['MIN-WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['MIN-WIDTH'])) \$minw = \$this->ConvertSize(\$attr['MIN-WIDTH'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\tif(isset(\$properties['MIN-HEIGHT'])) \$minh = \$this->ConvertSize(\$properties['MIN-HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\telse if(isset(\$attr['MIN-HEIGHT'])) \$minh = \$this->ConvertSize(\$attr['MIN-HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);

\t\tif (isset(\$properties['OPACITY']) && \$properties['OPACITY'] > 0 && \$properties['OPACITY'] <= 1) { \$objattr['opacity'] = \$properties['OPACITY']; }
\t\tif (\$this->HREF) {
\t\t\tif (strpos(\$this->HREF,\".\") === false && strpos(\$this->HREF,\"@\") !== 0) {
\t\t\t\t\$href = \$this->HREF;
\t\t\t\twhile(array_key_exists(\$href,\$this->internallink)) \$href=\"#\".\$href;
\t    \t\t\t\$this->internallink[\$href] = \$this->AddLink();
\t\t\t\t\$objattr['link'] = \$this->internallink[\$href];
\t\t\t}
\t\t\telse { \$objattr['link'] = \$this->HREF; }
\t\t}
\t\t\$extraheight = \$objattr['padding_top'] + \$objattr['padding_bottom'] + \$objattr['margin_top'] + \$objattr['margin_bottom'] + \$objattr['border_top']['w'] + \$objattr['border_bottom']['w'];
\t\t\$extrawidth = \$objattr['padding_left'] + \$objattr['padding_right'] + \$objattr['margin_left'] + \$objattr['margin_right'] + \$objattr['border_left']['w'] + \$objattr['border_right']['w'];

\t\t// mPDF 5.7.3 TRANSFORMS
\t\tif (isset(\$properties['BACKGROUND-COLOR']) && \$properties['BACKGROUND-COLOR'] != '') { \$objattr['bgcolor'] = \$this->ConvertColor(\$properties['BACKGROUND-COLOR']); }

/*-- BACKGROUNDS --*/
\t\tif(isset(\$properties['GRADIENT-MASK']) && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/',\$properties['GRADIENT-MASK'])) {
\t     \t\t\$objattr['GRADIENT-MASK'] = \$properties['GRADIENT-MASK'];
\t\t}
/*-- END BACKGROUNDS --*/

\t\t// Image file
\t\t\$info=\$this->_getImage(\$srcpath, true, true, \$orig_srcpath);
\t\tif(!\$info) {
\t\t\t\$info = \$this->_getImage(\$this->noImageFile);
\t\t\tif (\$info) {
\t\t\t\t\$srcpath = \$this->noImageFile;
\t\t\t\t\$w = (\$info['w'] * (25.4/\$this->dpi));
\t\t\t\t\$h = (\$info['h'] * (25.4/\$this->dpi));
\t\t\t}
\t\t}
\t\tif(!\$info) break;

\t\tif(isset(\$attr['ROTATE'])) { \$image_orientation = \$attr['ROTATE']; }
\t\telse if(isset(\$properties['IMAGE-ORIENTATION'])) { \$image_orientation = \$properties['IMAGE-ORIENTATION']; }
\t\telse { \$image_orientation = 0; }
\t\tif(\$image_orientation) {
\t\t   if (\$image_orientation==90 || \$image_orientation==-90 || \$image_orientation==270) {
\t\t\t\$tmpw = \$info['w'];
\t\t\t\$info['w'] = \$info['h'];
\t\t\t\$info['h'] = \$tmpw;
\t\t   }
\t\t   \$objattr['ROTATE'] = \$image_orientation;
\t\t}

\t\t\$objattr['file'] = \$srcpath;
\t\t//Default width and height calculation if needed
\t\tif(\$w==0 and \$h==0) {
/*-- IMAGES-WMF --*/
      \t      if (\$info['type']=='wmf') {
\t\t\t\t// WMF units are twips (1/20pt)
\t\t\t\t// divide by 20 to get points
\t\t\t\t// divide by k to get user units
\t\t\t\t\$w = abs(\$info['w'])/(20*_MPDFK);
\t\t\t\t\$h = abs(\$info['h']) / (20*_MPDFK);
\t\t\t}
\t\t\telse
/*-- END IMAGES-WMF --*/
      \t      if (\$info['type']=='svg') {
\t\t\t\t// SVG units are pixels
\t\t\t\t\$w = abs(\$info['w'])/_MPDFK;
\t\t\t\t\$h = abs(\$info['h'])/_MPDFK;
\t\t\t}
\t\t\telse {
\t\t\t\t//Put image at default image dpi
\t\t\t\t\$w=(\$info['w']/_MPDFK) * (72/\$this->img_dpi);
\t\t\t\t\$h=(\$info['h']/_MPDFK) * (72/\$this->img_dpi);
\t\t\t}
\t\t\tif (isset(\$properties['IMAGE-RESOLUTION'])) {
\t\t\t\tif (preg_match('/from-image/i', \$properties['IMAGE-RESOLUTION']) && isset(\$info['set-dpi']) && \$info['set-dpi']>0) {
\t\t\t\t\t\$w *= \$this->img_dpi / \$info['set-dpi'];
\t\t\t\t\t\$h *= \$this->img_dpi / \$info['set-dpi'];
\t\t\t\t}
\t\t\t\telse if (preg_match('/(\\d+)dpi/i', \$properties['IMAGE-RESOLUTION'], \$m)) {
\t\t\t\t\t\$dpi = \$m[1];
\t\t\t\t\tif (\$dpi > 0) {
\t\t\t\t\t\t\$w *= \$this->img_dpi / \$dpi;
\t\t\t\t\t\t\$h *= \$this->img_dpi / \$dpi;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t}
\t\t// IF WIDTH OR HEIGHT SPECIFIED
\t\tif(\$w==0) \$w=abs(\$h*\$info['w']/\$info['h']);
\t\tif(\$h==0) \$h=abs(\$w*\$info['h']/\$info['w']);

\t\t// mPDF 5.5.15
\t\tif (\$minw && \$w<\$minw) { \$w = \$minw; \$h=abs(\$w*\$info['h']/\$info['w']); }
\t\tif (\$maxw && \$w>\$maxw) { \$w = \$maxw; \$h=abs(\$w*\$info['h']/\$info['w']); }
\t\tif (\$minh && \$h<\$minh) { \$h = \$minh; \$w=abs(\$h*\$info['w']/\$info['h']); }
\t\tif (\$maxh && \$h>\$maxh) { \$h = \$maxh; \$w=abs(\$h*\$info['w']/\$info['h']); }

\t\t// Resize to maximum dimensions of page
\t\t\$maxWidth = \$this->blk[\$this->blklvl]['inner_width'];
   \t\t\$maxHeight = \$this->h - (\$this->tMargin + \$this->bMargin + 1) ;
\t\tif (\$this->fullImageHeight) { \$maxHeight = \$this->fullImageHeight; }
\t\tif (\$w + \$extrawidth > \$maxWidth ) {
\t\t\t\$w = \$maxWidth - \$extrawidth;
\t\t\t\$h=abs(\$w*\$info['h']/\$info['w']);
\t\t}

\t\tif (\$h + \$extraheight > \$maxHeight ) {
\t\t\t\$h = \$maxHeight - \$extraheight;
\t\t\t\$w=abs(\$h*\$info['w']/\$info['h']);
\t\t}
\t\t\$objattr['type'] = 'image';
\t\t\$objattr['itype'] = \$info['type'];

\t\t\$objattr['orig_h'] = \$info['h'];
\t\t\$objattr['orig_w'] = \$info['w'];
/*-- IMAGES-WMF --*/
\t\tif (\$info['type']=='wmf') {
\t\t\t\$objattr['wmf_x'] = \$info['x'];
\t\t\t\$objattr['wmf_y'] = \$info['y'];
\t\t}
\t\telse
/*-- END IMAGES-WMF --*/
\t\tif (\$info['type']=='svg') {
\t\t\t\$objattr['wmf_x'] = \$info['x'];
\t\t\t\$objattr['wmf_y'] = \$info['y'];
\t\t}
\t\t\$objattr['height'] = \$h + \$extraheight;
\t\t\$objattr['width'] = \$w + \$extrawidth;
\t\t\$objattr['image_height'] = \$h;
\t\t\$objattr['image_width'] = \$w;
/*-- CSS-IMAGE-FLOAT --*/
\t\tif (!\$this->ColActive && !\$this->tableLevel && !\$this->listlvl && !\$this->kwt && !\$this->keep_block_together) {
\t\t  if (isset(\$properties['FLOAT']) && (strtoupper(\$properties['FLOAT']) == 'RIGHT' || strtoupper(\$properties['FLOAT']) == 'LEFT')) {
\t\t\t\$objattr['float'] = substr(strtoupper(\$properties['FLOAT']),0,1);
\t\t  }
\t\t}
/*-- END CSS-IMAGE-FLOAT --*/
\t\t// mPDF 5.7.3 TRANSFORMS
\t\tif (isset(\$properties['TRANSFORM']) && !\$this->ColActive && !\$this->kwt) {
\t\t\t\$objattr['transform'] = \$properties['TRANSFORM'];
\t\t}

\t\t\$e = \"\\xbb\\xa4\\xactype=image,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";

\t\t// Clear properties - tidy up
\t\t\$properties = array();

/*-- TABLES --*/
\t\t// Output it to buffers
\t\tif (\$this->tableLevel) {
\t\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);
\t\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$objattr['width'] ;
\t\t}
\t\telse {
/*-- END TABLES --*/
\t\t\t\$this->_saveTextBuffer(\$e, \$this->HREF);
\t\t}\t// *TABLES*
/*-- ANNOTATIONS --*/
\t\tif (\$this->title2annots && isset(\$attr['TITLE'])) {
\t\t\t\$objattr = array();
\t\t\t\$objattr['margin_top'] = 0;
\t\t\t\$objattr['margin_bottom'] = 0;
\t\t\t\$objattr['margin_left'] = 0;
\t\t\t\$objattr['margin_right'] = 0;
\t\t\t\$objattr['width'] = 0;
\t\t\t\$objattr['height'] = 0;
\t\t\t\$objattr['border_top']['w'] = 0;
\t\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\t\$objattr['border_left']['w'] = 0;
\t\t\t\$objattr['border_right']['w'] = 0;
\t\t\t\$objattr['CONTENT'] = \$attr['TITLE'];
\t\t\t\$objattr['type'] = 'annot';
\t\t\t\$objattr['POS-X'] = 0;
\t\t\t\$objattr['POS-Y'] = 0;
\t\t\t\$objattr['ICON'] = 'Comment';
\t\t\t\$objattr['AUTHOR'] = '';
\t\t\t\$objattr['SUBJECT'] = '';
\t\t\t\$objattr['OPACITY'] = \$this->annotOpacity;
\t\t\t\$objattr['COLOR'] = \$this->ConvertColor('yellow');
\t\t\t\$e = \"\\xbb\\xa4\\xactype=annot,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t\tif(\$this->tableLevel) {\t// *TABLES*
\t\t\t\t\$this->cell[\$this->row][\$this->col]['textbuffer'][] = array(\$e);\t// *TABLES*
\t\t\t}\t// *TABLES*
\t\t\telse  {\t// *TABLES*
\t\t\t\t\$this->textbuffer[] = array(\$e);
\t\t\t}\t// *TABLES*
\t\t}
/*-- END ANNOTATIONS --*/
\t}
\tbreak;
/*-- END IMAGES-CORE --*/


\t// *********** CIRCULAR TEXT = TEXTCIRCLE  ********************
    case 'TEXTCIRCLE':
\t\t\$objattr = array();
\t\t\$objattr['margin_top'] = 0;
\t\t\$objattr['margin_bottom'] = 0;
\t\t\$objattr['margin_left'] = 0;
\t\t\$objattr['margin_right'] = 0;
\t\t\$objattr['padding_top'] = 0;
\t\t\$objattr['padding_bottom'] = 0;
\t\t\$objattr['padding_left'] = 0;
\t\t\$objattr['padding_right'] = 0;
\t\t\$objattr['width'] = 0;
\t\t\$objattr['height'] = 0;
\t\t\$objattr['border_top']['w'] = 0;
\t\t\$objattr['border_bottom']['w'] = 0;
\t\t\$objattr['border_left']['w'] = 0;
\t\t\$objattr['border_right']['w'] = 0;
\t\t\$objattr['top-text'] = '';
\t\t\$objattr['bottom-text'] = '';
\t\t\$objattr['r'] = 20;\t// radius (default value here for safety)
\t\t\$objattr['space-width'] = 120;
\t\t\$objattr['char-width'] = 100;

\t\t\$this->InlineProperties[\$tag] = \$this->saveInlineProperties();
\t\t\$properties = \$this->cssmgr->MergeCSS('INLINE',\$tag,\$attr);

\t\tif(isset(\$properties ['DISPLAY']) && strtolower(\$properties ['DISPLAY'])=='none') {
\t\t\treturn;
\t\t}
\t\tif (isset(\$attr['R'])) { \$objattr['r']=\$this->ConvertSize(\$attr['R'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif(isset(\$attr['TOP-TEXT'])) {
\t\t\t\$objattr['top-text'] = strcode2utf(\$attr['TOP-TEXT']);
\t\t\t\$objattr['top-text'] = \$this->lesser_entity_decode(\$objattr['top-text']);
\t\t\tif (\$this->onlyCoreFonts)
\t\t\t\t\$objattr['top-text'] = mb_convert_encoding(\$objattr['top-text'], \$this->mb_enc,'UTF-8');
\t\t}
\t\tif(isset(\$attr['BOTTOM-TEXT'])) {
\t\t\t\$objattr['bottom-text'] = strcode2utf(\$attr['BOTTOM-TEXT']);
\t\t\t\$objattr['bottom-text'] = \$this->lesser_entity_decode(\$objattr['bottom-text']);
\t\t\tif (\$this->onlyCoreFonts)
\t\t\t\t\$objattr['bottom-text'] = mb_convert_encoding(\$objattr['bottom-text'], \$this->mb_enc,'UTF-8');
\t\t}
\t\tif(isset(\$attr['SPACE-WIDTH']) && \$attr['SPACE-WIDTH']) { \$objattr['space-width'] = \$attr['SPACE-WIDTH']; }
\t\tif(isset(\$attr['CHAR-WIDTH']) && \$attr['CHAR-WIDTH']) { \$objattr['char-width'] = \$attr['CHAR-WIDTH']; }

\t\t// VISIBILITY
\t\t\$objattr['visibility'] = 'visible';
\t\tif (isset(\$properties['VISIBILITY'])) {
\t\t\t\$v = strtolower(\$properties['VISIBILITY']);
\t\t\tif ((\$v == 'hidden' || \$v == 'printonly' || \$v == 'screenonly') && \$this->visibility=='visible') {
\t\t\t\t\$objattr['visibility'] = \$v;
\t\t\t}
\t\t}
\t\t// mPDF 5.5.23
\t\tif (isset(\$properties['FONT-SIZE'])) {
\t\t  if (strtolower(\$properties['FONT-SIZE'])=='auto') {
\t\t\tif (\$objattr['top-text'] && \$objattr['bottom-text']) {
\t\t\t\t\$objattr['fontsize'] = -2;
\t\t\t}
\t\t\telse {
\t\t\t\t\$objattr['fontsize'] = -1;
\t\t\t}
\t\t  }
\t\t  else {
\t\t\t\$mmsize = \$this->ConvertSize(\$properties['FONT-SIZE'],(\$this->default_font_size/_MPDFK));
  \t\t\t\$this->SetFontSize(\$mmsize*_MPDFK,false);
\t\t\t\$objattr['fontsize'] = \$this->FontSizePt;
\t\t  }
\t\t}
\t\t// mPDF 5.5.23
\t\tif(isset(\$attr['DIVIDER'])) {
\t\t\t\$objattr['divider'] = strcode2utf(\$attr['DIVIDER']);
\t\t\t\$objattr['divider'] = \$this->lesser_entity_decode(\$objattr['divider']);
\t\t\tif (\$this->onlyCoreFonts)
\t\t\t\t\$objattr['divider'] = mb_convert_encoding(\$objattr['divider'], \$this->mb_enc,'UTF-8');

\t\t}

\t\tif (isset(\$properties['COLOR'])) { \$objattr['color'] = \$this->ConvertColor(\$properties['COLOR']); }

\t\t\$objattr['fontstyle'] = '';
\t\tif (isset(\$properties['FONT-WEIGHT'])) {
\t\t\tif (strtoupper(\$properties['FONT-WEIGHT']) == 'BOLD')\t{ \$objattr['fontstyle'] .= 'B'; }
\t\t}
\t\tif (isset(\$properties['FONT-STYLE'])) {
\t\t\tif (strtoupper(\$properties['FONT-STYLE']) == 'ITALIC') { \$objattr['fontstyle'] .= 'I'; }
\t\t}

\t\tif (isset(\$properties['FONT-FAMILY'])) {
\t\t\t\$this->SetFont(\$properties['FONT-FAMILY'],\$this->FontStyle,0,false);
\t\t}
\t\t\$objattr['fontfamily'] = \$this->FontFamily;

\t\t// VSPACE and HSPACE converted to margins in MergeCSS
\t\tif (isset(\$properties['MARGIN-TOP'])) { \$objattr['margin_top']=\$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-BOTTOM'])) { \$objattr['margin_bottom'] = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-LEFT'])) { \$objattr['margin_left'] = \$this->ConvertSize(\$properties['MARGIN-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['MARGIN-RIGHT'])) { \$objattr['margin_right'] = \$this->ConvertSize(\$properties['MARGIN-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['PADDING-TOP'])) { \$objattr['padding_top']=\$this->ConvertSize(\$properties['PADDING-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-BOTTOM'])) { \$objattr['padding_bottom'] = \$this->ConvertSize(\$properties['PADDING-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-LEFT'])) { \$objattr['padding_left'] = \$this->ConvertSize(\$properties['PADDING-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t\tif (isset(\$properties['PADDING-RIGHT'])) { \$objattr['padding_right'] = \$this->ConvertSize(\$properties['PADDING-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\t\tif (isset(\$properties['BORDER-TOP'])) { \$objattr['border_top'] = \$this->border_details(\$properties['BORDER-TOP']); }
\t\tif (isset(\$properties['BORDER-BOTTOM'])) { \$objattr['border_bottom'] = \$this->border_details(\$properties['BORDER-BOTTOM']); }
\t\tif (isset(\$properties['BORDER-LEFT'])) { \$objattr['border_left'] = \$this->border_details(\$properties['BORDER-LEFT']); }
\t\tif (isset(\$properties['BORDER-RIGHT'])) { \$objattr['border_right'] = \$this->border_details(\$properties['BORDER-RIGHT']); }

\t\tif (isset(\$properties['OPACITY']) && \$properties['OPACITY'] > 0 && \$properties['OPACITY'] <= 1) { \$objattr['opacity'] = \$properties['OPACITY']; }
\t\tif (isset(\$properties['BACKGROUND-COLOR']) && \$properties['BACKGROUND-COLOR'] != '') { \$objattr['bgcolor'] = \$this->ConvertColor(\$properties['BACKGROUND-COLOR']); }
\t\telse { \$objattr['bgcolor'] = false; }
\t\tif (\$this->HREF) {
\t\t\tif (strpos(\$this->HREF,\".\") === false && strpos(\$this->HREF,\"@\") !== 0) {
\t\t\t\t\$href = \$this->HREF;
\t\t\t\twhile(array_key_exists(\$href,\$this->internallink)) \$href=\"#\".\$href;
\t    \t\t\t\$this->internallink[\$href] = \$this->AddLink();
\t\t\t\t\$objattr['link'] = \$this->internallink[\$href];
\t\t\t}
\t\t\telse { \$objattr['link'] = \$this->HREF; }
\t\t}
\t\t\$extraheight = \$objattr['padding_top'] + \$objattr['padding_bottom'] + \$objattr['margin_top'] + \$objattr['margin_bottom'] + \$objattr['border_top']['w'] + \$objattr['border_bottom']['w'];
\t\t\$extrawidth = \$objattr['padding_left'] + \$objattr['padding_right'] + \$objattr['margin_left'] + \$objattr['margin_right'] + \$objattr['border_left']['w'] + \$objattr['border_right']['w'];


\t\t\$w = \$objattr['r']*2;
\t\t\$h = \$w;
\t\t\$objattr['height'] = \$h + \$extraheight;
\t\t\$objattr['width'] = \$w + \$extrawidth;
\t\t\$objattr['type'] = 'textcircle';

\t\t\$e = \"\\xbb\\xa4\\xactype=image,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";

\t\t// Clear properties - tidy up
\t\t\$properties = array();

/*-- TABLES --*/
\t\t// Output it to buffers
\t\tif (\$this->tableLevel) {
\t\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);
\t\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$objattr['width'] ;
\t\t}
\t\telse {
/*-- END TABLES --*/
\t\t\t\$this->_saveTextBuffer(\$e, \$this->HREF);
\t\t}\t// *TABLES*

\t\tif (\$this->InlineProperties[\$tag]) { \$this->restoreInlineProperties(\$this->InlineProperties[\$tag]); }
\t\tunset(\$this->InlineProperties[\$tag]);

\t\tbreak;


/*-- TABLES --*/

    case 'TABLE': // TABLE-BEGIN
\t\$this->tdbegin = false;
\t\$this->lastoptionaltag = '';
\t// Disable vertical justification in columns
\tif (\$this->ColActive) { \$this->colvAlign = ''; }\t// *COLUMNS*
\tif (\$this->lastblocklevelchange == 1) { \$blockstate = 1; }\t// Top margins/padding only
\telse if (\$this->lastblocklevelchange < 1) { \$blockstate = 0; }\t// NO margins/padding
\t// called from block after new div e.g. <div> ... <table> ...    Outputs block top margin/border and padding
\tif (count(\$this->textbuffer) == 0 && \$this->lastblocklevelchange == 1 && !\$this->tableLevel && !\$this->kwt) {
\t\t\$this->newFlowingBlock( \$this->blk[\$this->blklvl]['width'],\$this->lineheight,'',false,false,1,true, \$this->blk[\$this->blklvl]['direction']);
\t\t\$this->finishFlowingBlock(true);\t// true = END of flowing block
\t}
\telse if (!\$this->tableLevel && count(\$this->textbuffer)) { \$this->printbuffer(\$this->textbuffer,\$blockstate); }

\t\$this->textbuffer=array();
\t\$this->lastblocklevelchange = -1;
\tif (\$this->tableLevel) {\t// i.e. now a nested table coming...
\t\t// Save current level table
\t\t// mPDF 5.4.10
\t\t\$this->cell['PARENTCELL'] = \$this->saveInlineProperties();
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['baseProperties']= \$this->base_table_properties;
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cells'] = \$this->cell;
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['currrow'] = \$this->row;
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['currcol'] = \$this->col;
\t}
\t\$this->tableLevel++;
\t\$this->cssmgr->tbCSSlvl++;

\tif (\$this->tableLevel>1) {\t// inherit table properties from cell in which nested
\t\t\$this->base_table_properties['FONT-KERNING'] = \$this->kerning ;
\t\t\$this->base_table_properties['LETTER-SPACING'] = \$this->lSpacingCSS ;
\t\t\$this->base_table_properties['WORD-SPACING'] = \$this->wSpacingCSS ;
\t}

\tif (isset(\$this->tbctr[\$this->tableLevel])) { \$this->tbctr[\$this->tableLevel]++; }
\telse { \$this->tbctr[\$this->tableLevel] = 1; }

\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['level'] = \$this->tableLevel;
\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['levelid'] = \$this->tbctr[\$this->tableLevel];

\tif (\$this->tableLevel > \$this->innermostTableLevel) { \$this->innermostTableLevel = \$this->tableLevel; }
\tif (\$this->tableLevel > 1) {
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nestedpos'] = array(\$this->row,\$this->col,\$this->tbctr[(\$this->tableLevel-1)]);
\t}
\t//++++++++++++++++++++++++++++

\t\$this->cell = array();
\t\$this->col=-1; //int
\t\$this->row=-1; //int
\t\$table = &\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]];

\t// New table - any level
\tif (\$this->cacheTables) {
\t\t\$this->packTableData = true;\t// required for cacheTables
\t\t\$this->simpleTables = false;  // Cannot co-exist with cacheTables
\t\t\$table['cache'] = _MPDF_TEMP_PATH.'_tempTblCache'.uniqid(rand(1,100000),true).'.dat';
\t\t\$fh = fopen(\$table['cache'] , \"wb\") or \$this->Error(\"When using cacheTables, you must have read/write access to cache files (\".\$table['cache'] .\")\");
\t\tfwrite(\$fh, \"\\x00\");
\t\tfclose(\$fh);
\t\t\$table['ptr'] = 1 ;\t// Must not be 0
\t}

\t\$table['direction'] = \$this->directionality;
\t\$table['bgcolor'] = false;
\t\$table['va'] = false;
\t\$table['txta'] = false;
\t\$table['topntail'] = false;
\t\$table['thead-underline'] = false;
\t\$table['border'] = false;
\t\$table['border_details']['R']['w'] = 0;
\t\$table['border_details']['L']['w'] = 0;
\t\$table['border_details']['T']['w'] = 0;
\t\$table['border_details']['B']['w'] = 0;
\t\$table['border_details']['R']['style'] = '';
\t\$table['border_details']['L']['style'] = '';
\t\$table['border_details']['T']['style'] = '';
\t\$table['border_details']['B']['style'] = '';
\t\$table['max_cell_border_width']['R'] = 0;
\t\$table['max_cell_border_width']['L'] = 0;
\t\$table['max_cell_border_width']['T'] = 0;
\t\$table['max_cell_border_width']['B'] = 0;
\t\$table['padding']['L'] = false;
\t\$table['padding']['R'] = false;
\t\$table['padding']['T'] = false;
\t\$table['padding']['B'] = false;
\t\$table['margin']['L'] = false;
\t\$table['margin']['R'] = false;
\t\$table['margin']['T'] = false;
\t\$table['margin']['B'] = false;
\t\$table['a'] = false;
\t\$table['border_spacing_H'] = false;
\t\$table['border_spacing_V'] = false;
\t\$table['decimal_align'] = false;\t// mPDF 5.6.13
\t\$this->Reset();
\t\$this->InlineProperties = array();
\t\$table['nc'] = \$table['nr'] = 0;
\t\$this->tablethead = 0;
\t\$this->tabletfoot = 0;
\t\$this->tabletheadjustfinished = false;


\tif (\$this->blockjustfinished && !count(\$this->textbuffer) && \$this->y != \$this->tMargin && \$this->collapseBlockMargins && \$this->tableLevel==1) { \$lastbottommargin = \$this->lastblockbottommargin; }
\telse { \$lastbottommargin = 0; }
\t\$this->lastblockbottommargin = 0;
\t\$this->blockjustfinished=false;

\tif (\$this->tableLevel==1) {
\t\t\$this->tableCJK = false;
\t\t\$this->table_lineheight = \$this->normalLineheight;
\t\t\$table['headernrows'] = 0;
\t\t\$table['footernrows'] = 0;
\t\t\$this->base_table_properties = array();
\t}

\t// ADDED CSS FUNCIONS FOR TABLE
\tif (\$this->cssmgr->tbCSSlvl==1) {
\t\t\$properties = \$this->cssmgr->MergeCSS('TOPTABLE',\$tag,\$attr);
\t}
\telse {
\t\t\$properties = \$this->cssmgr->MergeCSS('TABLE',\$tag,\$attr);
\t}
\t\$w = '';
\tif (isset(\$properties['WIDTH'])) { \$w = \$properties['WIDTH']; }
\telse if (isset(\$attr['WIDTH']) && \$attr['WIDTH']) { \$w = \$attr['WIDTH']; }


\tif(isset(\$properties['DIRECTION']) && \$properties['DIRECTION']) { \$table['direction'] = strtolower(\$properties['DIRECTION']); }
\telse if(isset(\$attr['DIR']) && \$attr['DIR']) { \$table['direction'] = strtolower(\$attr['DIR']); }
\telse if (!isset(\$table['direction'])){ \$table['direction'] = \$this->blk[\$this->blklvl]['direction']; }

\tif (isset(\$properties['BACKGROUND-COLOR'])) { \$table['bgcolor'][-1] = \$properties['BACKGROUND-COLOR'];\t}
\telse if (isset(\$properties['BACKGROUND'])) { \$table['bgcolor'][-1] = \$properties['BACKGROUND'];\t}
\telse if (isset(\$attr['BGCOLOR'])) { \$table['bgcolor'][-1]\t= \$attr['BGCOLOR']; }
\tif (isset(\$properties['VERTICAL-ALIGN'])) { \$table['va'] = \$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }
\tif (isset(\$properties['TEXT-ALIGN'])) { \$table['txta'] = \$align[strtolower(\$properties['TEXT-ALIGN'])]; }
\tif (isset(\$attr['ALIGN'])) { \$table['a']\t= \$align[strtolower(\$attr['ALIGN'])]; }
\tif (!\$table['a']) {
\t\tif (\$table['direction'] == 'rtl' ) { \$table['a'] = 'R'; }
\t\telse { \$table['a'] = 'L'; }
\t}

\tif (isset(\$properties['AUTOSIZE']) && \$properties['AUTOSIZE'] && \$this->tableLevel ==1)\t{
\t\t\$this->shrink_this_table_to_fit = \$properties['AUTOSIZE'];
\t\tif (\$this->shrink_this_table_to_fit < 1) { \$this->shrink_this_table_to_fit = 0; }
\t}
\tif (isset(\$properties['ROTATE']) && \$properties['ROTATE'] && \$this->tableLevel ==1)\t{
\t\t\$this->table_rotate = \$properties['ROTATE'];
\t}
\tif (isset(\$properties['TOPNTAIL'])) { \$table['topntail'] = \$properties['TOPNTAIL']; }
\tif (isset(\$properties['THEAD-UNDERLINE'])) { \$table['thead-underline'] = \$properties['THEAD-UNDERLINE']; }

\tif (isset(\$properties['BORDER'])) {
\t\t\$bord = \$this->border_details(\$properties['BORDER']);
\t\tif (\$bord['s']) {
\t\t\t\$table['border'] = _BORDER_ALL;
\t\t\t\$table['border_details']['R'] = \$bord;
\t\t\t\$table['border_details']['L'] = \$bord;
\t\t\t\$table['border_details']['T'] = \$bord;
\t\t\t\$table['border_details']['B'] = \$bord;
\t\t}
\t}
\tif (isset(\$properties['BORDER-RIGHT'])) {
\t  if (\$table['direction'] == 'rtl') { \t// *RTL*
\t\t\$table['border_details']['R'] = \$this->border_details(\$properties['BORDER-LEFT']);\t// *RTL*
\t  }\t// *RTL*
\t  else {\t// *RTL*
\t\t\$table['border_details']['R'] = \$this->border_details(\$properties['BORDER-RIGHT']);
\t  }\t// *RTL*
\t  \$this->setBorder(\$table['border'], _BORDER_RIGHT, \$table['border_details']['R']['s']);
\t}
\tif (isset(\$properties['BORDER-LEFT'])) {
\t  if (\$table['direction'] == 'rtl') { \t// *RTL*
\t\t\$table['border_details']['L'] = \$this->border_details(\$properties['BORDER-RIGHT']);\t// *RTL*
\t  }\t// *RTL*
\t  else {\t// *RTL*
\t\t\$table['border_details']['L'] = \$this->border_details(\$properties['BORDER-LEFT']);
\t  }\t// *RTL*
\t  \$this->setBorder(\$table['border'], _BORDER_LEFT, \$table['border_details']['L']['s']);
\t}
\tif (isset(\$properties['BORDER-BOTTOM'])) {
\t\t\$table['border_details']['B'] = \$this->border_details(\$properties['BORDER-BOTTOM']);
\t\t\$this->setBorder(\$table['border'], _BORDER_BOTTOM, \$table['border_details']['B']['s']);
\t}
\tif (isset(\$properties['BORDER-TOP'])) {
\t\t\$table['border_details']['T'] = \$this->border_details(\$properties['BORDER-TOP']);
\t\t\$this->setBorder(\$table['border'], _BORDER_TOP, \$table['border_details']['T']['s']);
\t}
\tif (\$table['border']){
\t\t  \$this->table_border_css_set = 1;
\t}
\telse {
\t  \$this->table_border_css_set = 0;
\t}

\tif (isset(\$properties['FONT-FAMILY'])) {
\t\t\$this->default_font = \$properties['FONT-FAMILY'];
\t\t\$this->SetFont(\$this->default_font,'',0,false);
\t}
\t\$this->base_table_properties['FONT-FAMILY'] = \$this->FontFamily;\t// mPDF 5.4.10

\tif (isset(\$properties['FONT-SIZE'])) {
\t   // mPDF 5.4.10
\t   if (\$this->tableLevel>1) { \$mmsize = \$this->ConvertSize(\$properties['FONT-SIZE'], \$this->base_table_properties['FONT-SIZE']); }
\t   else { \$mmsize = \$this->ConvertSize(\$properties['FONT-SIZE'],\$this->default_font_size/_MPDFK); }
\t   if (\$mmsize) {
\t\t\$this->default_font_size = \$mmsize*(_MPDFK);
   \t\t\$this->SetFontSize(\$this->default_font_size,false);
\t   }
\t}
\t\$this->base_table_properties['FONT-SIZE'] = \$this->FontSize.'mm';\t// mPDF 5.4.10

\tif (isset(\$properties['FONT-WEIGHT'])) {
\t\tif (strtoupper(\$properties['FONT-WEIGHT']) == 'BOLD')\t{ \$this->base_table_properties['FONT-WEIGHT'] = 'BOLD'; }
\t}
\tif (isset(\$properties['FONT-STYLE'])) {
\t\tif (strtoupper(\$properties['FONT-STYLE']) == 'ITALIC') { \$this->base_table_properties['FONT-STYLE'] = 'ITALIC'; }
\t}
\tif (isset(\$properties['COLOR'])) {
\t\t\$this->base_table_properties['COLOR'] = \$properties['COLOR'];
\t}
\tif (isset(\$properties['FONT-KERNING'])) {
\t\t\$this->base_table_properties['FONT-KERNING'] = \$properties['FONT-KERNING'];
\t}
\tif (isset(\$properties['LETTER-SPACING'])) {
\t\t\$this->base_table_properties['LETTER-SPACING'] = \$properties['LETTER-SPACING'];
\t}
\tif (isset(\$properties['WORD-SPACING'])) {
\t\t\$this->base_table_properties['WORD-SPACING'] = \$properties['WORD-SPACING'];
\t}

\tif (isset(\$properties['PADDING-LEFT'])) {
\t\t\$table['padding']['L'] = \$this->ConvertSize(\$properties['PADDING-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['PADDING-RIGHT'])) {
\t\t\$table['padding']['R'] = \$this->ConvertSize(\$properties['PADDING-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['PADDING-TOP'])) {
\t\t\$table['padding']['T'] = \$this->ConvertSize(\$properties['PADDING-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['PADDING-BOTTOM'])) {
\t\t\$table['padding']['B'] = \$this->ConvertSize(\$properties['PADDING-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}

\tif (isset(\$properties['MARGIN-TOP'])) {
\t\tif (\$lastbottommargin) {
\t\t\t\$tmp = \$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t\tif (\$tmp > \$lastbottommargin) { \$properties['MARGIN-TOP'] -= \$lastbottommargin; }
\t\t\telse { \$properties['MARGIN-TOP'] = 0; }
\t\t}
\t\t\$table['margin']['T'] = \$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}

\tif (isset(\$properties['MARGIN-BOTTOM'])) {
\t\t\$table['margin']['B'] = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['MARGIN-LEFT'])) {
\t\t\$table['margin']['L'] = \$this->ConvertSize(\$properties['MARGIN-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}

\tif (isset(\$properties['MARGIN-RIGHT'])) {
\t\t\$table['margin']['R'] = \$this->ConvertSize(\$properties['MARGIN-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['MARGIN-LEFT']) && isset(\$properties['MARGIN-RIGHT']) && strtolower(\$properties['MARGIN-LEFT'])=='auto' && strtolower(\$properties['MARGIN-RIGHT'])=='auto') {
\t\t\$table['a'] = 'C';
\t}
\telse if (isset(\$properties['MARGIN-LEFT']) && strtolower(\$properties['MARGIN-LEFT'])=='auto') {
\t\t\$table['a'] = 'R';
\t}
\telse if (isset(\$properties['MARGIN-RIGHT']) && strtolower(\$properties['MARGIN-RIGHT'])=='auto') {
\t\t\$table['a'] = 'L';
\t}

\tif (isset(\$properties['LINE-HEIGHT']) && \$this->tableLevel==1) {
\t\t\$this->table_lineheight = \$this->fixLineheight(\$properties['LINE-HEIGHT']);
\t\tif (!\$this->table_lineheight) { \$this->table_lineheight = \$this->normalLineheight; }
\t}

\tif (isset(\$properties['BORDER-COLLAPSE']) && strtoupper(\$properties['BORDER-COLLAPSE'])=='SEPARATE') {
\t\t\$table['borders_separate'] = true;
\t}
\telse {
\t\t\$table['borders_separate'] = false;
\t}

\t// mPDF 5.7.3
\tif (isset(\$properties['BORDER-SPACING-H'])) {
\t\t\$table['border_spacing_H'] = \$this->ConvertSize(\$properties['BORDER-SPACING-H'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['BORDER-SPACING-V'])) {
\t\t\$table['border_spacing_V'] = \$this->ConvertSize(\$properties['BORDER-SPACING-V'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}

\tif (!\$table['borders_separate']) { \$table['border_spacing_H'] = \$table['border_spacing_V'] = 0; }

\tif (isset(\$properties['EMPTY-CELLS'])) {
\t\t\$table['empty_cells'] = strtolower(\$properties['EMPTY-CELLS']); \t// 'hide'  or 'show'
\t}
\telse { \$table['empty_cells'] = ''; }

\tif (isset(\$properties['PAGE-BREAK-INSIDE']) && strtoupper(\$properties['PAGE-BREAK-INSIDE'])=='AVOID' && \$this->tableLevel==1 && !\$this->writingHTMLfooter) {
\t\t\$this->table_keep_together = true;
\t}
\telse if (\$this->tableLevel==1) {
\t\t\$this->table_keep_together = false;
\t}
\tif (isset(\$properties['PAGE-BREAK-AFTER']) && \$this->tableLevel==1) {
\t\t\$table['page_break_after'] = strtoupper(\$properties['PAGE-BREAK-AFTER']);
\t}

/*-- BACKGROUNDS --*/
\tif (isset(\$properties['BACKGROUND-GRADIENT']) && !\$this->kwt && !\$this->ColActive) { \$table['gradient'] = \$properties['BACKGROUND-GRADIENT']; }

\tif (isset(\$properties['BACKGROUND-IMAGE']) && \$properties['BACKGROUND-IMAGE'] && !\$this->kwt && !\$this->ColActive) {
\t\t\$ret = \$this->SetBackground(\$properties, \$currblk['inner_width']);
\t\tif (\$ret) { \$table['background-image'] = \$ret; }
\t}
/*-- END BACKGROUNDS --*/

\tif (isset(\$properties['OVERFLOW']))\t{
\t\t\$table['overflow'] = strtolower(\$properties['OVERFLOW']); \t// 'hidden' 'wrap' or 'visible' or 'auto'
\t\tif ((\$this->ColActive || \$this->tableLevel>1) && \$table['overflow']=='visible') { unset(\$table['overflow']); }
\t}

\t\$properties = array();



\tif (isset(\$attr['CELLPADDING'])) {
\t\t\$table['cell_padding'] = \$attr['CELLPADDING'];
\t}
\telse {
\t\t\$table['cell_padding'] = false;
\t}

\tif (isset(\$attr['BORDER']) && \$attr['BORDER']=='1') {\t// mPDF 5.5.08
\t\t\$this->table_border_attr_set = 1;\t// mPDF 5.5.08
\t\t\$bord = \$this->border_details('#000000 1px solid');
\t\tif (\$bord['s']) {
\t\t\t\$table['border'] = _BORDER_ALL;
\t\t\t\$table['border_details']['R'] = \$bord;
\t\t\t\$table['border_details']['L'] = \$bord;
\t\t\t\$table['border_details']['T'] = \$bord;
\t\t\t\$table['border_details']['B'] = \$bord;
\t\t}
\t}
\telse {
\t\t\$this->table_border_attr_set = 0;
\t}

\tif (\$w) {
\t\t\$maxwidth = \$this->blk[\$this->blklvl]['inner_width'];
\t\tif (\$table['borders_separate']) {
\t\t\t\$tblblw = \$table['margin']['L'] + \$table['margin']['R'] + \$table['border_details']['L']['w']/2 + \$table['border_details']['R']['w']/2;
\t\t}
\t\telse {
\t\t\t\$tblblw = \$table['margin']['L'] + \$table['margin']['R'] + \$table['max_cell_border_width']['L']/2 + \$table['max_cell_border_width']['R']/2;
\t\t}
\t\tif (strpos(\$w,'%') && \$this->tableLevel == 1 && !\$this->ignore_table_percents ) {
\t\t\t// % needs to be of inner box without table margins etc.
\t\t\t\$maxwidth -= \$tblblw ;
\t\t\t\$wmm = \$this->ConvertSize(\$w,\$maxwidth,\$this->FontSize,false);
\t\t\t\$table['w'] = \$wmm + \$tblblw ;
\t\t}
\t\tif (strpos(\$w,'%') && \$this->tableLevel > 1 && !\$this->ignore_table_percents && \$this->keep_table_proportions) {
\t\t\t\$table['wpercent'] = \$w + 0; \t// makes 80% -> 80
\t\t}
\t\tif (!strpos(\$w,'%') && !\$this->ignore_table_widths ) {
\t\t\t\$wmm = \$this->ConvertSize(\$w,\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t\t\$table['w'] = \$wmm + \$tblblw ;
\t\t}
\t\tif (!\$this->keep_table_proportions) {
\t\t\tif (isset(\$table['w']) && \$table['w'] > \$this->blk[\$this->blklvl]['inner_width']) { \$table['w'] = \$this->blk[\$this->blklvl]['inner_width']; }
\t\t}
\t}

\tif (isset(\$attr['AUTOSIZE']) && \$this->tableLevel==1)\t{
\t\t\$this->shrink_this_table_to_fit = \$attr['AUTOSIZE'];
\t\tif (\$this->shrink_this_table_to_fit < 1) { \$this->shrink_this_table_to_fit = 1; }
\t}
\tif (isset(\$attr['ROTATE']) && \$this->tableLevel==1)\t{
\t\t\$this->table_rotate = \$attr['ROTATE'];
\t}

\t//++++++++++++++++++++++++++++
\t// keeping block together on one page
\t// Autosize is now forced therefore keep block together disabled
\tif (\$this->keep_block_together) {
\t\t\$this->keep_block_together = 0;
\t\t\$this->printdivbuffer();
\t\t\$this->blk[\$this->blklvl]['keep_block_together'] = 0;
\t}
\tif (\$this->table_rotate) {
\t\t\$this->tbrot_Links = array();
\t\t\$this->tbrot_Annots = array();
\t\t\$this->tbrotForms = array();
\t\t\$this->tbrot_Reference = array();
\t\t\$this->tbrot_BMoutlines = array();
\t\t\$this->tbrot_toc = array();
\t}

\tif (\$this->kwt) {
\t\tif (\$this->table_rotate) { \$this->table_keep_together = true; }
\t\t\$this->kwt = false;
\t\t\$this->kwt_saved = true;
\t}

\tif (\$this->tableLevel==1 && \$this->useGraphs) {
\t\tif (isset(\$attr['ID']) && \$attr['ID']) { \$this->currentGraphId = strtoupper(\$attr['ID']); }
\t\telse { \$this->currentGraphId = '0'; }
\t\t\$this->graphs[\$this->currentGraphId] = array();
\t}
\t//++++++++++++++++++++++++++++
\t\$this->plainCell_properties = array();
\tunset(\$table);
\tbreak;

    case 'THEAD':
\t\$this->lastoptionaltag = \$tag; // Save current HTML specified optional endtag
\t\$this->cssmgr->tbCSSlvl++;
\t\$this->tablethead = 1;
\t\$this->tabletfoot = 0;
\t\$properties = \$this->cssmgr->MergeCSS('TABLE',\$tag,\$attr);
\tif (isset(\$properties['FONT-WEIGHT'])) {
\t\tif (strtoupper(\$properties['FONT-WEIGHT']) == 'BOLD')\t{ \$this->thead_font_weight = 'B'; }
\t\telse { \$this->thead_font_weight = ''; }
\t}

\tif (isset(\$properties['FONT-STYLE'])) {
\t\tif (strtoupper(\$properties['FONT-STYLE']) == 'ITALIC') { \$this->thead_font_style = 'I'; }
\t\telse { \$this->thead_font_style = ''; }
\t}
\tif (isset(\$properties['FONT-VARIANT'])) {
\t\tif (strtoupper(\$properties['FONT-VARIANT']) == 'SMALL-CAPS') { \$this->thead_font_smCaps = 'S'; }
\t\telse { \$this->thead_font_smCaps = ''; }
\t}

\tif (isset(\$properties['VERTICAL-ALIGN'])) {
\t\t\$this->thead_valign_default = \$properties['VERTICAL-ALIGN'];
\t}
\tif (isset(\$properties['TEXT-ALIGN'])) {
\t\t\$this->thead_textalign_default = \$properties['TEXT-ALIGN'];
\t}
\t\$properties = array();
\tbreak;

    case 'TFOOT':
\t\$this->lastoptionaltag = \$tag; // Save current HTML specified optional endtag
\t\$this->cssmgr->tbCSSlvl++;
\t\$this->tabletfoot = 1;
\t\$this->tablethead = 0;
\t\$properties = \$this->cssmgr->MergeCSS('TABLE',\$tag,\$attr);
\tif (isset(\$properties['FONT-WEIGHT'])) {
\t\tif (strtoupper(\$properties['FONT-WEIGHT']) == 'BOLD')\t{ \$this->tfoot_font_weight = 'B'; }
\t\telse { \$this->tfoot_font_weight = ''; }
\t}

\tif (isset(\$properties['FONT-STYLE'])) {
\t\tif (strtoupper(\$properties['FONT-STYLE']) == 'ITALIC') { \$this->tfoot_font_style = 'I'; }
\t\telse { \$this->tfoot_font_style = ''; }
\t}
\tif (isset(\$properties['FONT-VARIANT'])) {
\t\tif (strtoupper(\$properties['FONT-VARIANT']) == 'SMALL-CAPS') { \$this->tfoot_font_smCaps = 'S'; }
\t\telse { \$this->tfoot_font_smCaps = ''; }
\t}

\tif (isset(\$properties['VERTICAL-ALIGN'])) {
\t\t\$this->tfoot_valign_default = \$properties['VERTICAL-ALIGN'];
\t}
\tif (isset(\$properties['TEXT-ALIGN'])) {
\t\t\$this->tfoot_textalign_default = \$properties['TEXT-ALIGN'];
\t}
\t\$properties = array();
\tbreak;


    case 'TBODY':
\t\$this->tablethead = 0;
\t\$this->tabletfoot = 0;
\t\$this->lastoptionaltag = \$tag; // Save current HTML specified optional endtag
\t\$this->cssmgr->tbCSSlvl++;
\t\$this->cssmgr->MergeCSS('TABLE',\$tag,\$attr);
\tbreak;


    case 'TR':
\t\$this->lastoptionaltag = \$tag; // Save current HTML specified optional endtag
\t\$this->cssmgr->tbCSSlvl++;
\t\$this->row++;
\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nr']++;
\t\$this->col = -1;
\t\$properties = \$this->cssmgr->MergeCSS('TABLE',\$tag,\$attr);

\tif (!\$this->simpleTables && (!isset(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['borders_separate']) || !\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['borders_separate'])) {
\t\tif (isset(\$properties['BORDER-LEFT']) && \$properties['BORDER-LEFT']) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trborder-left'][\$this->row] = \$properties['BORDER-LEFT']; }
\t\tif (isset(\$properties['BORDER-RIGHT']) && \$properties['BORDER-RIGHT']) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trborder-right'][\$this->row] = \$properties['BORDER-RIGHT']; }
\t\tif (isset(\$properties['BORDER-TOP']) && \$properties['BORDER-TOP']) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trborder-top'][\$this->row] = \$properties['BORDER-TOP']; }
\t\tif (isset(\$properties['BORDER-BOTTOM']) && \$properties['BORDER-BOTTOM']) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trborder-bottom'][\$this->row] = \$properties['BORDER-BOTTOM']; }
\t}

\tif (isset(\$properties['BACKGROUND-COLOR'])) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['bgcolor'][\$this->row] = \$properties['BACKGROUND-COLOR']; }
\telse if (isset(\$attr['BGCOLOR'])) \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['bgcolor'][\$this->row] = \$attr['BGCOLOR'];

/*-- BACKGROUNDS --*/
\tif (isset(\$properties['BACKGROUND-GRADIENT']) && !\$this->kwt && !\$this->ColActive) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trgradients'][\$this->row] = \$properties['BACKGROUND-GRADIENT']; }

\tif (isset(\$properties['BACKGROUND-IMAGE']) && \$properties['BACKGROUND-IMAGE'] && !\$this->kwt && !\$this->ColActive) {
\t\t\$ret = \$this->SetBackground(\$properties, \$currblk['inner_width']);
\t\tif (\$ret) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trbackground-images'][\$this->row] = \$ret; }
\t}
/*-- END BACKGROUNDS --*/


\tif (isset(\$properties['TEXT-ROTATE'])) {
\t\t\$this->trow_text_rotate = \$properties['TEXT-ROTATE'];
\t}
\tif (isset(\$attr['TEXT-ROTATE'])) \$this->trow_text_rotate = \$attr['TEXT-ROTATE'];

\tif (\$this->tablethead) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_thead'][\$this->row] = true; }
\tif (\$this->tabletfoot) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_tfoot'][\$this->row] = true; }
\t\$properties = array();
\tbreak;


    case 'TH':
    case 'TD':
\t\$this->ignorefollowingspaces = true;
\t\$this->lastoptionaltag = \$tag; // Save current HTML specified optional endtag
\t\$this->cssmgr->tbCSSlvl++;
\t\$this->InlineProperties = array();
\t\$this->tdbegin = true;
\t\$this->col++;
\twhile (isset(\$this->cell[\$this->row][\$this->col])) { \$this->col++; }

\t//Update number column
\tif (\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nc'] < \$this->col+1) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nc'] = \$this->col+1; }

\t\$table = &\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]];

\t\$c = array('a' => false,
\t'R' => false,
\t'nowrap' => false,
\t'bgcolor' => false,
\t'padding' => array('L' => false,
\t\t'R' => false,
\t\t'T' => false,
\t\t'B' => false
\t\t)
\t);

\tif (\$this->simpleTables && \$this->row==0 && \$this->col==0){
\t\t\$table['simple']['border'] = false;
\t\t\$table['simple']['border_details']['R']['w'] = 0;
\t\t\$table['simple']['border_details']['L']['w'] = 0;
\t\t\$table['simple']['border_details']['T']['w'] = 0;
\t\t\$table['simple']['border_details']['B']['w'] = 0;
\t\t\$table['simple']['border_details']['R']['style'] = '';
\t\t\$table['simple']['border_details']['L']['style'] = '';
\t\t\$table['simple']['border_details']['T']['style'] = '';
\t\t\$table['simple']['border_details']['B']['style'] = '';
\t}
\telse if (!\$this->simpleTables) {
\t\$c['border'] = false;
\t\$c['border_details']['R']['w'] = 0;
\t\$c['border_details']['L']['w'] = 0;
\t\$c['border_details']['T']['w'] = 0;
\t\$c['border_details']['B']['w'] = 0;
\t\$c['border_details']['mbw']['BL'] = 0;
\t\$c['border_details']['mbw']['BR'] = 0;
\t\$c['border_details']['mbw']['RT'] = 0;
\t\$c['border_details']['mbw']['RB'] = 0;
\t\$c['border_details']['mbw']['TL'] = 0;
\t\$c['border_details']['mbw']['TR'] = 0;
\t\$c['border_details']['mbw']['LT'] = 0;
\t\$c['border_details']['mbw']['LB'] = 0;
\t\$c['border_details']['R']['style'] = '';
\t\$c['border_details']['L']['style'] = '';
\t\$c['border_details']['T']['style'] = '';
\t\$c['border_details']['B']['style'] = '';
\t\$c['border_details']['R']['s'] = 0;
\t\$c['border_details']['L']['s'] = 0;
\t\$c['border_details']['T']['s'] = 0;
\t\$c['border_details']['B']['s'] = 0;
\t\$c['border_details']['R']['c'] = \$this->ConvertColor(0);
\t\$c['border_details']['L']['c'] = \$this->ConvertColor(0);
\t\$c['border_details']['T']['c'] = \$this->ConvertColor(0);
\t\$c['border_details']['B']['c'] = \$this->ConvertColor(0);
\t\$c['border_details']['R']['dom'] = 0;
\t\$c['border_details']['L']['dom'] = 0;
\t\$c['border_details']['T']['dom'] = 0;
\t\$c['border_details']['B']['dom'] = 0;
\t}


\tif (\$table['va']) { \$c['va'] = \$table['va']; }
\tif (\$table['txta']) { \$c['a'] = \$table['txta']; }
\tif (\$this->table_border_attr_set) {
\t  if (\$table['border_details']) {
\t    if (!\$this->simpleTables){
\t\t\$c['border_details']['R'] = \$table['border_details']['R'];
\t\t\$c['border_details']['L'] = \$table['border_details']['L'];
\t\t\$c['border_details']['T'] = \$table['border_details']['T'];
\t\t\$c['border_details']['B'] = \$table['border_details']['B'];
\t\t\$c['border'] = \$table['border'];
\t\t\$c['border_details']['L']['dom'] = 1;
\t\t\$c['border_details']['R']['dom'] = 1;
\t\t\$c['border_details']['T']['dom'] = 1;
\t\t\$c['border_details']['B']['dom'] = 1;
\t    }
\t    else if (\$this->simpleTables && \$this->row==0 && \$this->col==0){
\t\t\$table['simple']['border_details']['R'] = \$table['border_details']['R'];
\t\t\$table['simple']['border_details']['L'] = \$table['border_details']['L'];
\t\t\$table['simple']['border_details']['T'] = \$table['border_details']['T'];
\t\t\$table['simple']['border_details']['B'] = \$table['border_details']['B'];
\t\t\$table['simple']['border'] = \$table['border'];
\t    }
\t  }
\t}
\t// INHERITED THEAD CSS Properties
\tif (\$this->tablethead) {
\t\tif (\$this->thead_valign_default) \$c['va'] = \$align[strtolower(\$this->thead_valign_default)];
\t\tif (\$this->thead_textalign_default) \$c['a'] = \$align[strtolower(\$this->thead_textalign_default)];
\t\tif (\$this->thead_font_weight == 'B') { \$this->SetStyle('B',true); }
\t\tif (\$this->thead_font_style == 'I') { \$this->SetStyle('I',true); }
\t\tif (\$this->thead_font_smCaps == 'S') { \$this->SetStyle('S',true); }
\t}

\t// INHERITED TFOOT CSS Properties
\tif (\$this->tabletfoot) {
\t\tif (\$this->tfoot_valign_default) \$c['va'] = \$align[strtolower(\$this->tfoot_valign_default)];
\t\tif (\$this->tfoot_textalign_default) \$c['a'] = \$align[strtolower(\$this->tfoot_textalign_default)];
\t\tif (\$this->tfoot_font_weight == 'B') { \$this->SetStyle('B',true); }
\t\tif (\$this->tfoot_font_style == 'I') { \$this->SetStyle('I',true); }
\t\tif (\$this->tfoot_font_style == 'S') { \$this->SetStyle('S',true); }
\t}


\tif (\$this->trow_text_rotate){
\t\t\$c['R'] = \$this->trow_text_rotate;
\t}

\t\$this->cell_border_dominance_L = 0;
\t\$this->cell_border_dominance_R = 0;
\t\$this->cell_border_dominance_T = 0;
\t\$this->cell_border_dominance_B = 0;

\t\$properties = \$this->cssmgr->MergeCSS('TABLE',\$tag,\$attr);
\t\$properties = \$this->cssmgr->array_merge_recursive_unique(\$this->base_table_properties, \$properties);

\tif (isset(\$properties['FONT-KERNING']) && (strtoupper(\$properties['FONT-KERNING'])=='NORMAL' || strtoupper(\$properties['FONT-KERNING'])=='AUTO')) {
\t\t\$this->kerning = true;
\t}
\telse { \$this->kerning = false; }

\tif (isset(\$properties['LETTER-SPACING']) && (\$properties['LETTER-SPACING'] || \$properties['LETTER-SPACING']==='0') && strtoupper(\$properties['LETTER-SPACING']) != 'NORMAL') {
\t\t\$this->lSpacingCSS = strtoupper(\$properties['LETTER-SPACING']);
\t\t\$this->fixedlSpacing = \$this->ConvertSize(\$this->lSpacingCSS,\$this->FontSize);
\t}
\telse {
\t\t\$this->lSpacingCSS = '';
\t\t\$this->fixedlSpacing = false;
\t}
\tif (isset(\$properties['WORD-SPACING']) && strtoupper(\$properties['WORD-SPACING']) != 'NORMAL') {
\t\t\$this->wSpacingCSS = strtoupper(\$properties['WORD-SPACING']);
\t\t\$this->minwSpacing = \$this->ConvertSize(\$this->wSpacingCSS,\$this->FontSize);
\t}
\telse {
\t\t\$this->minwSpacing = 0;
\t\t\$this->wSpacingCSS = '';
\t}
\t// mPDF 5.6.08
\tif (isset(\$properties['HYPHENS']) && \$properties['HYPHENS']) {
\t\tif (strtoupper(\$properties['HYPHENS']) == 'NONE') { \$this->textparam['hyphens'] = 2; }
\t\telse if (strtoupper(\$properties['HYPHENS']) == 'AUTO') { \$this->textparam['hyphens'] = 1; }
\t\telse if (strtoupper(\$properties['HYPHENS']) == 'MANUAL') { \$this->textparam['hyphens'] = 0; }
\t}

\tif (isset(\$properties['BACKGROUND-COLOR'])) { \$c['bgcolor'] = \$properties['BACKGROUND-COLOR']; }
\telse if (isset(\$properties['BACKGROUND'])) { \$c['bgcolor'] = \$properties['BACKGROUND']; }
\telse if (isset(\$attr['BGCOLOR'])) \$c['bgcolor'] = \$attr['BGCOLOR'];



/*-- BACKGROUNDS --*/
\tif (isset(\$properties['BACKGROUND-GRADIENT'])) { \$c['gradient'] = \$properties['BACKGROUND-GRADIENT']; }
\telse { \$c['gradient'] = false; }

\tif (isset(\$properties['BACKGROUND-IMAGE']) && \$properties['BACKGROUND-IMAGE'] && !\$this->keep_block_together) {
\t\t\$ret = \$this->SetBackground(\$properties, \$this->blk[\$this->blklvl]['inner_width']);
\t\tif (\$ret) { \$c['background-image'] = \$ret; }
\t}
/*-- END BACKGROUNDS --*/
\tif (isset(\$properties['VERTICAL-ALIGN'])) { \$c['va']=\$align[strtolower(\$properties['VERTICAL-ALIGN'])]; }
\telse if (isset(\$attr['VALIGN'])) \$c['va'] = \$align[strtolower(\$attr['VALIGN'])];


\t// mPDF 5.6.13
\tif (isset(\$properties['TEXT-ALIGN']) && \$properties['TEXT-ALIGN']) {
\t\tif (substr(\$properties['TEXT-ALIGN'],0,1)=='D') { \$c['a'] = \$properties['TEXT-ALIGN']; }
\t\telse { \$c['a'] = \$align[strtolower(\$properties['TEXT-ALIGN'])]; }
\t}
\t// mPDF 5.6.13
\tif (isset(\$attr['ALIGN']) && \$attr['ALIGN']) {
\t\tif (strtolower(\$attr['ALIGN']) == 'char') {
\t\t\tif (isset(\$attr['CHAR']) && \$attr['CHAR']) {
\t\t\t\t\$char = html_entity_decode(\$attr['CHAR']);
\t\t\t\t\$char = strcode2utf(\$char);
\t\t\t\t\$d = array_search(\$char,\$this->decimal_align);
\t\t\t\tif (\$d !== false) { \$c['a'] = \$d.'R'; }
\t\t\t}
\t\t\telse { \$c['a'] = 'DPR'; }
\t\t}
\t\telse { \$c['a'] = \$align[strtolower(\$attr['ALIGN'])]; }
\t}

\tif (!\$c['a']) {
\t\tif (isset(\$table['direction']) && \$table['direction'] == 'rtl' ) { \$c['a'] = 'R'; }
\t\telse { \$c['a'] = 'L'; }
\t}


\tif (isset(\$properties['TEXT-ROTATE']) && (\$properties['TEXT-ROTATE'] || \$properties['TEXT-ROTATE']===\"0\")){
\t\t\$c['R'] = \$properties['TEXT-ROTATE'];
\t}
\tif (isset(\$properties['BORDER'])) {
\t\t\$bord = \$this->border_details(\$properties['BORDER']);
\t\tif (\$bord['s']) {
\t\t   if (!\$this->simpleTables){
\t\t\t\$c['border'] = _BORDER_ALL;
\t\t\t\$c['border_details']['R'] = \$bord;
\t\t\t\$c['border_details']['L'] = \$bord;
\t\t\t\$c['border_details']['T'] = \$bord;
\t\t\t\$c['border_details']['B'] = \$bord;
\t\t\t\$c['border_details']['L']['dom'] = \$this->cell_border_dominance_L;
\t\t\t\$c['border_details']['R']['dom'] = \$this->cell_border_dominance_R;
\t\t\t\$c['border_details']['T']['dom'] = \$this->cell_border_dominance_T;
\t\t\t\$c['border_details']['B']['dom'] = \$this->cell_border_dominance_B;
\t\t   }
\t\t   else if (\$this->simpleTables && \$this->row==0 && \$this->col==0){
\t\t\t\$table['simple']['border'] = _BORDER_ALL;
\t\t\t\$table['simple']['border_details']['R'] = \$bord;
\t\t\t\$table['simple']['border_details']['L'] = \$bord;
\t\t\t\$table['simple']['border_details']['T'] = \$bord;
\t\t\t\$table['simple']['border_details']['B'] = \$bord;
\t\t   }
\t\t}
\t}
\tif (!\$this->simpleTables){
\t   if (isset(\$properties['BORDER-RIGHT']) && \$properties['BORDER-RIGHT']) {
\t\t\$c['border_details']['R'] = \$this->border_details(\$properties['BORDER-RIGHT']);
\t\t\$this->setBorder(\$c['border'], _BORDER_RIGHT, \$c['border_details']['R']['s']);
\t\t\$c['border_details']['R']['dom'] = \$this->cell_border_dominance_R;
\t   }
\t   if (isset(\$properties['BORDER-LEFT']) && \$properties['BORDER-LEFT']) {
\t\t\$c['border_details']['L'] = \$this->border_details(\$properties['BORDER-LEFT']);
\t\t\$this->setBorder(\$c['border'], _BORDER_LEFT, \$c['border_details']['L']['s']);
\t\t\$c['border_details']['L']['dom'] = \$this->cell_border_dominance_L;
\t   }
\t   if (isset(\$properties['BORDER-BOTTOM']) && \$properties['BORDER-BOTTOM']) {
\t\t\$c['border_details']['B'] = \$this->border_details(\$properties['BORDER-BOTTOM']);
\t\t\$this->setBorder(\$c['border'], _BORDER_BOTTOM, \$c['border_details']['B']['s']);
\t\t\$c['border_details']['B']['dom'] = \$this->cell_border_dominance_B;
\t   }
\t   if (isset(\$properties['BORDER-TOP']) && \$properties['BORDER-TOP']) {
\t\t\$c['border_details']['T'] = \$this->border_details(\$properties['BORDER-TOP']);
\t\t\$this->setBorder(\$c['border'], _BORDER_TOP, \$c['border_details']['T']['s']);
\t\t\$c['border_details']['T']['dom'] = \$this->cell_border_dominance_T;
\t   }
\t}
\telse if (\$this->simpleTables && \$this->row==0 && \$this->col==0){
\t   if (isset(\$properties['BORDER-LEFT']) && \$properties['BORDER-LEFT']) {
\t\t\$bord = \$this->border_details(\$properties['BORDER-LEFT']);
\t\t\tif (\$bord['s']) { \$table['simple']['border'] = _BORDER_ALL; }
\t\t\telse { \$table['simple']['border'] = 0; }
\t\t\t\$table['simple']['border_details']['R'] = \$bord;
\t\t\t\$table['simple']['border_details']['L'] = \$bord;
\t\t\t\$table['simple']['border_details']['T'] = \$bord;
\t\t\t\$table['simple']['border_details']['B'] = \$bord;
\t   }
\t}

\tif (\$this->simpleTables && \$this->row==0 && \$this->col==0 && !\$table['borders_separate'] && \$table['simple']['border'] ){
\t\t\$table['border_details'] = \$table['simple']['border_details'];
\t\t\$table['border'] = \$table['simple']['border'];
\t}

\t// Border set on TR (if collapsed only)
\tif (!\$table['borders_separate'] && !\$this->simpleTables && isset(\$table['trborder-left'][\$this->row])) {
\t\tif (\$this->col==0) {
\t\t\t\$left = \$this->border_details(\$table['trborder-left'][\$this->row]);
\t\t\t\$c['border_details']['L'] = \$left;
\t\t\t\$this->setBorder(\$c['border'], _BORDER_LEFT, \$c['border_details']['L']['s']);
\t\t}
\t\t\$c['border_details']['B'] = \$this->border_details(\$table['trborder-bottom'][\$this->row]);
\t\t\$this->setBorder(\$c['border'], _BORDER_BOTTOM, \$c['border_details']['B']['s']);
\t\t\$c['border_details']['T'] = \$this->border_details(\$table['trborder-top'][\$this->row]);
\t\t\$this->setBorder(\$c['border'], _BORDER_TOP, \$c['border_details']['T']['s']);
\t}

\tif (\$this->packTableData && !\$this->simpleTables) {
\t\t\$c['borderbin'] = \$this->_packCellBorder(\$c);
\t\tunset(\$c['border']);
\t\tunset(\$c['border_details']);
\t}

\tif (isset(\$properties['PADDING-LEFT'])) {
\t\t\$c['padding']['L'] = \$this->ConvertSize(\$properties['PADDING-LEFT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['PADDING-RIGHT'])) {
\t\t\$c['padding']['R'] = \$this->ConvertSize(\$properties['PADDING-RIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['PADDING-BOTTOM'])) {
\t\t\$c['padding']['B'] = \$this->ConvertSize(\$properties['PADDING-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}
\tif (isset(\$properties['PADDING-TOP'])) {
\t\t\$c['padding']['T'] = \$this->ConvertSize(\$properties['PADDING-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t}

\t\$w = '';
\tif (isset(\$properties['WIDTH'])) { \$w = \$properties['WIDTH']; }
\telse if (isset(\$attr['WIDTH'])) { \$w = \$attr['WIDTH']; }
\tif (\$w) {
\t\tif (strpos(\$w,'%') && !\$this->ignore_table_percents ) { \$c['wpercent'] = \$w + 0; }\t// makes 80% -> 80
\t\telse if (!strpos(\$w,'%') && !\$this->ignore_table_widths ) { \$c['w'] = \$this->ConvertSize(\$w,\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\t}

\tif (isset(\$properties['HEIGHT']) && !strpos(\$properties['HEIGHT'],'%')) { \$c['h'] = \$this->ConvertSize(\$properties['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }
\telse if (isset(\$attr['HEIGHT']) && !strpos(\$attr['HEIGHT'],'%')) \$c['h'] = \$this->ConvertSize(\$attr['HEIGHT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);


\tif (isset(\$properties['COLOR'])) {
\t  \$cor = \$this->ConvertColor(\$properties['COLOR']);
\t  if (\$cor) {
\t\t\$this->colorarray = \$cor;
\t\t\$this->SetTColor(\$cor);
\t  }
\t}
\tif (isset(\$properties['FONT-FAMILY'])) {
\t\t\$this->SetFont(\$properties['FONT-FAMILY'],'',0,false);
\t}
\tif (isset(\$properties['FONT-SIZE'])) {
\t   \$mmsize = \$this->ConvertSize(\$properties['FONT-SIZE'],\$this->default_font_size/_MPDFK);
\t   if (\$mmsize) {
  \t\t\$this->SetFontSize(\$mmsize*(_MPDFK),false);
\t   }
\t}
\t\$c['dfs'] = \$this->FontSize;\t// Default Font size
\tif (isset(\$properties['FONT-WEIGHT'])) {
\t\tif (strtoupper(\$properties['FONT-WEIGHT']) == 'BOLD')\t{ \$this->SetStyle('B',true); }
\t}
\tif (isset(\$properties['FONT-STYLE'])) {
\t\tif (strtoupper(\$properties['FONT-STYLE']) == 'ITALIC') { \$this->SetStyle('I',true); }
\t}
\tif (isset(\$properties['FONT-VARIANT'])) {
\t\tif (strtoupper(\$properties['FONT-VARIANT']) == 'SMALL-CAPS') { \$this->SetStyle('S',true); }
\t}
\tif (isset(\$properties['TEXT-DECORATION'])) {
\t\tif (strtoupper(\$properties['TEXT-DECORATION']) == 'LINE-THROUGH') { \$this->strike = true; }
\t\telse if (strtoupper(\$properties['TEXT-DECORATION']) == 'UNDERLINE') { \$this->SetStyle('U',true); }
\t}
\tif (isset(\$properties['TEXT-SHADOW'])) {
\t\t\$ts = \$this->cssmgr->setCSStextshadow(\$properties['TEXT-SHADOW']);
\t\tif (\$ts) { \$this->textshadow = \$ts; }
\t}
\tif (isset(\$properties['TEXT-TRANSFORM'])) {
\t\tif (strtoupper(\$properties['TEXT-TRANSFORM']) == 'CAPITALIZE') { \$this->capitalize = true; }
\t\telse if (strtoupper(\$properties['TEXT-TRANSFORM']) == 'UPPERCASE') { \$this->toupper = true; }
\t\telse if (strtoupper(\$properties['TEXT-TRANSFORM']) == 'LOWERCASE') { \$this->tolower = true; }
\t}
\tif (isset(\$properties['WHITE-SPACE'])) {
\t\tif (strtoupper(\$properties['WHITE-SPACE']) == 'NOWRAP') { \$c['nowrap']= 1; }
\t}
\t\$properties = array();

\tif (isset(\$attr['TEXT-ROTATE'])) {
\t\t\$c['R'] = \$attr['TEXT-ROTATE'];
\t}
\tif (isset(\$attr['NOWRAP']) && \$attr['NOWRAP']) \$c['nowrap']= 1;

\t\$this->cell[\$this->row][\$this->col] = \$c;
\tunset(\$c);
\t\$this->cell[\$this->row][\$this->col]['s'] = 0 ;

\t\$cs = \$rs = 1;
\tif (isset(\$attr['COLSPAN']) && \$attr['COLSPAN']>1)\t\$cs = \$this->cell[\$this->row][\$this->col]['colspan']\t= \$attr['COLSPAN'];
\tif (\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nc'] < \$this->col+\$cs) {
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nc'] = \$this->col+\$cs;
\t}\t// following code moved outside if...
\tfor(\$l=\$this->col; \$l < \$this->col+\$cs ;\$l++) {
\t\tif (\$l-\$this->col) \$this->cell[\$this->row][\$l] = 0;
\t}

\tif (isset(\$attr['ROWSPAN']) && \$attr['ROWSPAN']>1)\t\$rs = \$this->cell[\$this->row][\$this->col]['rowspan']\t= \$attr['ROWSPAN'];
\tfor (\$k=\$this->row ; \$k < \$this->row+\$rs ;\$k++) {
\t\tfor(\$l=\$this->col; \$l < \$this->col+\$cs ;\$l++) {
\t\t\tif (\$k-\$this->row || \$l-\$this->col)\t\$this->cell[\$k][\$l] = 0;
\t\t}
\t}
\tunset(\$table);
\tbreak;
/*-- END TABLES --*/


/*-- LISTS --*/
    // *********** LISTS ********************
    case 'OL':
    case 'UL':
\t\$this->listjustfinished = false;

\tif (\$this->blockjustfinished && !count(\$this->textbuffer) && \$this->y != \$this->tMargin && \$this->collapseBlockMargins) { \$lastbottommargin = \$this->lastblockbottommargin; }
\telse { \$lastbottommargin = 0; }
\t\$this->lastblockbottommargin = 0;
\t\$this->blockjustfinished=false;

\t\$this->linebreakjustfinished=false;
\t\$this->lastoptionaltag = ''; // Save current HTML specified optional endtag
\t\$this->cssmgr->listCSSlvl++;
\tif((!\$this->tableLevel) && (\$this->listlvl == 0)) {
\t\t\$blockstate = 0;
\t\t//if (\$this->lastblocklevelchange == 1) { \$blockstate = -1; }\t// Top margins/padding only
\t\t//else if (\$this->lastblocklevelchange < 1) { \$blockstate = 0; }\t// NO margins/padding
\t\t// called from block after new div e.g. <div> ... <ol> ...    Outputs block top margin/border and padding
\t\tif (count(\$this->textbuffer) == 0 && \$this->lastblocklevelchange == 1 && !\$this->tableLevel && !\$this->kwt) {
\t\t\t\$this->newFlowingBlock( \$this->blk[\$this->blklvl]['width'],\$this->lineheight,'',false,false,1,true, \$this->blk[\$this->blklvl]['direction']);
\t\t\t\$this->finishFlowingBlock(true);\t// true = END of flowing block
\t\t}
\t\telse if (count(\$this->textbuffer)) { \$this->printbuffer(\$this->textbuffer,\$blockstate); }
\t\t\$this->textbuffer=array();
\t\t\$this->lastblocklevelchange = -1;
\t}
\t// ol and ul types are mixed here
\tif (\$this->listlvl == 0) {
\t\t\$this->list_indent = array();
\t\t\$this->list_align = array();
\t\t\$this->list_lineheight = array();
\t\t\$this->InlineProperties['LIST'] = array();
\t\t\$this->InlineProperties['LISTITEM'] = array();
\t}

/*-- TABLES --*/
\t// A simple list for inside a table
\tif(\$this->tableLevel) {
\t\t\$this->list_indent[\$this->listlvl] = 0;\t// mm default indent for each level
\t\tif (\$tag == 'OL') \$this->listtype = '1';
\t\telse if (\$tag == 'UL') \$this->listtype = 'disc';
      \tif (\$this->listlvl > 0) {
\t\t\t\$this->listlist[\$this->listlvl]['MAXNUM'] = \$this->listnum; //save previous lvl's maxnum
\t\t}
\t\t\$this->listlvl++;
\t\t// mPDF 5.6.15
\t\tif (isset(\$attr['START'])) { \$this->listnum = intval(\$attr['START']); }
\t\telse { \$this->listnum = 0; }
\t\t\$this->listlist[\$this->listlvl] = array('TYPE'=>\$this->listtype,'MAXNUM'=>\$this->listnum);
\t\tbreak;
\t}
/*-- END TABLES --*/


\tif ((\$this->PDFA || \$this->PDFX) && \$tag == 'UL') {
\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"List bullets cannot use core font Zapfdingbats in PDFA1-b or PDFX/1-a. (Substitute characters from current font used if available, otherwise substitutes hyphen '-')\"; }
\t}

\tif (\$this->cssmgr->listCSSlvl==1) {
\t\t\$properties = \$this->cssmgr->MergeCSS('TOPLIST',\$tag,\$attr);
\t}
\telse {
\t\t\$properties = \$this->cssmgr->MergeCSS('LIST',\$tag,\$attr);
\t}
\tif (!empty(\$properties)) \$this->setCSS(\$properties,'LIST');
\t// List-type

\t\$this->listtype = '';
\tif (isset(\$properties['LIST-STYLE-TYPE'])) {
\t\t\$this->listtype = \$this->_getListStyle(\$properties['LIST-STYLE-TYPE']);
\t}
\telse if (isset(\$properties['LIST-STYLE'])) {
\t\t\$this->listtype = \$this->_getListStyle(\$properties['LIST-STYLE']);
\t}
\telse if (isset(\$attr['TYPE']) && \$attr['TYPE']) { \$this->listtype = \$attr['TYPE']; }
\tif (!\$this->listtype) {
\t\tif (\$tag == 'OL') \$this->listtype = '1';
\t\tif (\$tag == 'UL') {
\t\t\tif (\$this->listlvl % 3 == 0) \$this->listtype = 'disc';
\t\t\telseif (\$this->listlvl % 3 == 1) \$this->listtype = 'circle';
\t\t\telse \$this->listtype = 'square';
\t\t}
\t}
      if (\$this->listlvl == 0) {
\t  \$this->inherit_lineheight = 0;
\t  \$this->listlvl++; // first depth level
\t  // mPDF 5.6.15
\t  if (isset(\$attr['START'])) { \$this->listnum = intval(\$attr['START']); }
\t  else { \$this->listnum = 0; }
\t  \$this->listDir = (isset(\$this->blk[\$this->blklvl]['direction']) ? \$this->blk[\$this->blklvl]['direction'] : null);
\t  \$occur = \$this->listoccur[\$this->listlvl] = 1;
\t  \$this->listlist[\$this->listlvl][1] = array('TYPE'=>\$this->listtype,'MAXNUM'=>\$this->listnum);
      }
      else {
\tif (!empty(\$this->textbuffer))
        {
\t\t\$this->listitem[] = array(\$this->listlvl,\$this->listnum,\$this->textbuffer,\$this->listoccur[\$this->listlvl],\$this->listitemtype);
\t\t\$this->listnum++;
        }
\t  // Save current lineheight to inherit
\t  \$this->textbuffer = array();
  \t  \$occur = \$this->listoccur[\$this->listlvl];
\t  \$this->listlist[\$this->listlvl][\$occur]['MAXNUM'] = \$this->listnum; //save previous lvl's maxnum
\t  \$this->listlvl++;
\t  // mPDF 5.6.15
\t  if (isset(\$attr['START'])) { \$this->listnum = intval(\$attr['START']); }
\t  else { \$this->listnum = 0; }


\t  if (!isset(\$this->listoccur[\$this->listlvl]) || \$this->listoccur[\$this->listlvl] == 0) \$this->listoccur[\$this->listlvl] = 1;
\t  else \$this->listoccur[\$this->listlvl]++;
  \t  \$occur = \$this->listoccur[\$this->listlvl];
\t  \$this->listlist[\$this->listlvl][\$occur] = array('TYPE'=>\$this->listtype,'MAXNUM'=>\$this->listnum);
      }


\t// TOP LEVEL ONLY
\tif (\$this->listlvl == 1) {
\t   if (isset(\$properties['MARGIN-TOP'])) {
\t\tif (\$lastbottommargin) {
\t\t\t\$tmp = \$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t\t\tif (\$tmp > \$lastbottommargin) { \$properties['MARGIN-TOP'] -= \$lastbottommargin; }
\t\t\telse { \$properties['MARGIN-TOP'] = 0; }
\t\t}
\t\t\$this->DivLn(\$this->ConvertSize(\$properties['MARGIN-TOP'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false),\$this->blklvl,true,1); \t// collapsible
\t   }
\t   if (isset(\$properties['MARGIN-BOTTOM'])) {
\t\t\$this->list_margin_bottom = \$this->ConvertSize(\$properties['MARGIN-BOTTOM'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false);
\t   }

\t   if (isset(\$this->blk[\$this->blklvl]['line_height'])) {
\t\t\$this->list_lineheight[\$this->listlvl][\$occur] = \$this->blk[\$this->blklvl]['line_height'];
\t   }

\t   if (isset(\$properties['DIRECTION']) && \$properties['DIRECTION']) { \$this->listDir = strtolower(\$properties['DIRECTION']); }
\t   else if (isset(\$attr['DIR']) && \$attr['DIR']) { \$this->listDir = strtolower(\$attr['DIR']); }

\t}
\t\$this->list_indent[\$this->listlvl][\$occur] = 5;\t// mm default indent for each level
\tif (isset(\$properties['TEXT-INDENT'])) { \$this->list_indent[\$this->listlvl][\$occur] = \$this->ConvertSize(\$properties['TEXT-INDENT'],\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize,false); }

\tif (isset(\$properties['TEXT-ALIGN'])) {
\t\t\$this->list_align[\$this->listlvl][\$occur] = \$align[strtolower(\$properties['TEXT-ALIGN'])];
\t}


\tif (isset(\$properties['LINE-HEIGHT'])) {
\t\t\$this->list_lineheight[\$this->listlvl][\$occur] = \$this->fixLineheight(\$properties['LINE-HEIGHT']);
\t}
\telse if (\$this->listlvl>1 && isset(\$this->list_lineheight[(\$this->listlvl - 1)][1])) {
\t\t\$this->list_lineheight[\$this->listlvl][\$occur] = end(\$this->list_lineheight[(\$this->listlvl - 1)]);
\t}
\tif (!isset(\$this->list_lineheight[\$this->listlvl][\$occur]) || !\$this->list_lineheight[\$this->listlvl][\$occur]) {
\t\t\$this->list_lineheight[\$this->listlvl][\$occur] = \$this->normalLineheight;
\t}

\t\$this->InlineProperties['LIST'][\$this->listlvl][\$occur] = \$this->saveInlineProperties();
\t\$properties = array();
     break;



    case 'LI':
\t// Start Block
\t\$this->lastoptionaltag = \$tag; // Save current HTML specified optional endtag
      \$this->ignorefollowingspaces = true; //Eliminate exceeding left-side spaces
/*-- TABLES --*/
\t// A simple list for inside a table
\tif(\$this->tableLevel) {
\t   \$this->blockjustfinished=false;

\t   // If already something in the Cell
\t   if ((isset(\$this->cell[\$this->row][\$this->col]['maxs']) && \$this->cell[\$this->row][\$this->col]['maxs'] > 0 ) || \$this->cell[\$this->row][\$this->col]['s'] > 0 ) {
\t\t\t\$this->_saveCellTextBuffer(\"\\n\");
\t\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t\t}
\t\t\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t\t}
\t\t\t\$this->cell[\$this->row][\$this->col]['s'] = 0 ;
\t\t}
\t\tif (\$this->listlvl == 0) { //in case of malformed HTML code. Example:(...)</p><li>Content</li><p>Paragraph1</p>(...)
\t\t\t\$this->listlvl++; // first depth level
\t\t\t\$this->listnum = 0; // reset
\t\t\t\$this->listlist[\$this->listlvl] = array('TYPE'=>'disc','MAXNUM'=>\$this->listnum);
\t\t}

\t\t\$this->listnum++;
\t\tswitch(\$this->listlist[\$this->listlvl]['TYPE']) {
\t\tcase 'A':
\t\t\t\$blt = \$this->dec2alpha(\$this->listnum,true).\$this->list_number_suffix;
\t\t\tbreak;
\t\tcase 'a':
\t\t\t\$blt = \$this->dec2alpha(\$this->listnum,false).\$this->list_number_suffix;
\t\t\tbreak;
\t\tcase 'I':
\t\t\t\$blt = \$this->dec2roman(\$this->listnum,true).\$this->list_number_suffix;
\t\t\tbreak;
\t\tcase 'i':
\t\t\t\$blt = \$this->dec2roman(\$this->listnum,false).\$this->list_number_suffix;
\t\t\tbreak;
\t\tcase '1':
\t\t\t\$blt = \$this->listnum.\$this->list_number_suffix;
            \tbreak;
\t\tdefault:
\t\t\tif (\$this->listlvl % 3 == 1 && \$this->_charDefined(\$this->CurrentFont['cw'],8226)) { \$blt = \"\\xe2\\x80\\xa2\"; } \t// &#8226;
\t\t\telse if (\$this->listlvl % 3 == 2 && \$this->_charDefined(\$this->CurrentFont['cw'],9900)) { \$blt = \"\\xe2\\x9a\\xac\"; } // &#9900;
\t\t\telse if (\$this->listlvl % 3 == 0 && \$this->_charDefined(\$this->CurrentFont['cw'],9642)) { \$blt = \"\\xe2\\x96\\xaa\"; } // &#9642;
\t\t\telse { \$blt = '-'; }
\t\t\tbreak;
\t\t}

\t\t// change to &nbsp; spaces
\t\tif (\$this->usingCoreFont) {
\t\t\t\$ls = str_repeat(chr(160).chr(160),(\$this->listlvl-1)*2) . \$blt . ' ';
\t\t}
\t\telse {
\t\t\t\$ls = str_repeat(\"\\xc2\\xa0\\xc2\\xa0\",(\$this->listlvl-1)*2) . \$blt . ' ';
\t\t}

\t\t\$this->_saveCellTextBuffer(\$ls, \$this->HREF);
\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$this->GetStringWidth(\$ls);
\t\tbreak;
\t}
/*-- END TABLES --*/
\t//Observation: </LI> is ignored
\tif (\$this->listlvl == 0) { //in case of malformed HTML code. Example:(...)</p><li>Content</li><p>Paragraph1</p>(...)
\t//First of all, skip a line
\t\t\$this->listlvl++; // first depth level
\t\t\$this->listnum = 0; // reset
\t\t\$this->listoccur[\$this->listlvl] = 1;
\t\t\$this->listlist[\$this->listlvl][1] = array('TYPE'=>'disc','MAXNUM'=>\$this->listnum);
\t}
\tif (\$this->listnum == 0) {
\t\t\$this->listnum++;
\t\t\$this->textbuffer = array();
\t}
\telse {
\t\tif (!empty(\$this->textbuffer)) {
\t\t  if (!\$this->listjustfinished) {
\t\t\t\$this->listitem[] = array(\$this->listlvl,\$this->listnum,\$this->textbuffer,\$this->listoccur[\$this->listlvl],\$this->listitemtype);
\t\t\t\$this->listnum++;
\t\t  }
\t\t  else {
\t\t\t\$this->listitem[] = array(\$this->listlvl,\$this->listnum,\$this->textbuffer,\$this->listoccur[\$this->listlvl],\$this->listitemtype, true);
\t\t  }
\t\t}
\t\t\$this->textbuffer = array();
      }
\t\$this->listjustfinished = false;

\t\$this->cssmgr->listCSSlvl++;
\t\$properties = \$this->cssmgr->MergeCSS('LIST',\$tag,\$attr);
\tif (!empty(\$properties)) \$this->setCSS(\$properties,'LIST');
\t\$this->InlineProperties['LISTITEM'][\$this->listlvl][\$this->listoccur[\$this->listlvl]][\$this->listnum] = \$this->saveInlineProperties();

\t// List-type
\tif (isset(\$properties['LIST-STYLE-TYPE'])) {
\t\t\$this->listitemtype = \$this->_getListStyle(\$properties['LIST-STYLE-TYPE']);
\t}
\telse if (isset(\$properties['LIST-STYLE'])) {
\t\t\$this->listitemtype = \$this->_getListStyle(\$properties['LIST-STYLE']);
\t}
\telse if (isset(\$attr['TYPE']) && \$attr['TYPE']) { \$this->listitemtype = \$attr['TYPE']; }
\telse \$this->listitemtype = '';
      break;
/*-- END LISTS --*/

  }//end of switch
}

/*-- LISTS --*/

function _getListStyle(\$ls) {
 \tif (stristr(\$ls,'decimal')) { return '1'; }
\telse if (preg_match('/(disc|circle|square|arabic-indic|bengali|devanagari|gujarati|gurmukhi|kannada|malayalam|oriya|persian|tamil|telugu|thai|urdu|cambodian|khmer|lao)/i',\$ls,\$m)) {
\t\treturn strtolower(trim(\$m[1]));
\t}
\telse if (stristr(\$ls,'lower-roman')) { return 'i'; }
\telse if (stristr(\$ls,'upper-roman')) { return 'I'; }
\telse if (stristr(\$ls,'lower-latin')|| stristr(\$ls,'lower-alpha')) { return 'a'; }
\telse if (stristr(\$ls,'upper-latin') || stristr(\$ls,'upper-alpha')) { return 'A'; }
\telse if (stristr(\$ls,'none')) { return 'none'; }
\telse if (preg_match('/U\\+([a-fA-F0-9]+)/i',\$ls)) { return \$ls; }
\telse { return ''; }
}
/*-- END LISTS --*/



function CloseTag(\$tag)
{
\t\$this->ignorefollowingspaces = false; //Eliminate exceeding left-side spaces
    //Closing tag
    if(\$tag=='OPTION') { \$this->selectoption['ACTIVE'] = false; \t\$this->lastoptionaltag = ''; }

    if(\$tag=='TTS' or \$tag=='TTA' or \$tag=='TTZ') {
\tif (\$this->InlineProperties[\$tag]) { \$this->restoreInlineProperties(\$this->InlineProperties[\$tag]); }
\tunset(\$this->InlineProperties[\$tag]);
\t\$ltag = strtolower(\$tag);
\t\$this->\$ltag = false;
    }


    if(\$tag=='FONT' || \$tag=='SPAN' || \$tag=='CODE' || \$tag=='KBD' || \$tag=='SAMP' || \$tag=='TT' || \$tag=='VAR'
\t|| \$tag=='INS' || \$tag=='STRONG' || \$tag=='CITE' || \$tag=='SUB' || \$tag=='SUP' || \$tag=='S' || \$tag=='STRIKE' || \$tag=='DEL'
\t|| \$tag=='Q' || \$tag=='EM' || \$tag=='B' || \$tag=='I' || \$tag=='U' | \$tag=='SMALL' || \$tag=='BIG' || \$tag=='ACRONYM'
\t|| \$tag=='MARK'  || \$tag=='TIME'  || \$tag=='PROGRESS'  || \$tag=='METER'
\t) {\t// mPDF 5.5.09

\t// mPDF 5.7.3 Inline tags
\tif (\$tag=='PROGRESS'  || \$tag=='METER') {
\t\tif (isset(\$this->InlineProperties[\$tag]) && \$this->InlineProperties[\$tag]) { \$this->restoreInlineProperties(\$this->InlineProperties[\$tag]); }
\t\tunset(\$this->InlineProperties[\$tag]);
\t\tif (isset(\$this->InlineAnnots[\$tag]) && \$this->InlineAnnots[\$tag]) { \$annot = \$this->InlineAnnots[\$tag]; }\t// *ANNOTATIONS*
\t\tunset(\$this->InlineAnnots[\$tag]);\t// *ANNOTATIONS*
\t}
\telse {
\t\tif (isset(\$this->InlineProperties[\$tag]) && count(\$this->InlineProperties[\$tag])) {
\t\t\t\$this->restoreInlineProperties(array_pop(\$this->InlineProperties[\$tag]));
\t\t}
\t\tif (isset(\$this->InlineAnnots[\$tag]) && count(\$this->InlineAnnots[\$tag])) { \t// *ANNOTATIONS*
\t\t\t\$annot = array_pop(\$this->InlineAnnots[\$tag]); \t// *ANNOTATIONS*
\t\t}\t// *ANNOTATIONS*
\t}

/*-- ANNOTATIONS --*/
\tif (isset(\$annot)) {
\t\tif(\$this->tableLevel) {\t// *TABLES*
\t\t\t\$this->cell[\$this->row][\$this->col]['textbuffer'][] = array(\$annot);\t// *TABLES*
\t\t}\t// *TABLES*
\t\telse  {\t// *TABLES*
\t\t\t\$this->textbuffer[] = array(\$annot);
\t\t}\t// *TABLES*
\t}
/*-- END ANNOTATIONS --*/
    }

    if(\$tag=='METER' || \$tag=='PROGRESS') {
\t\$this->inMeter = false;\t// mPDF 5.5.09
    }


    if(\$tag=='A') {
\t\$this->HREF='';
\tif (isset(\$this->InlineProperties['A'])) { \$this->restoreInlineProperties(\$this->InlineProperties['A']); }
\tunset(\$this->InlineProperties['A']);
    }

    if(\$tag=='LEGEND') {\t// mPDF 5.4.18
\tif (count(\$this->textbuffer) && !\$this->tableLevel) {
\t\t\$leg = \$this->textbuffer[(count(\$this->textbuffer)-1)];
\t\tunset(\$this->textbuffer[(count(\$this->textbuffer)-1)]);
\t\t\$this->textbuffer = array_values(\$this->textbuffer);
\t\t\$this->blk[\$this->blklvl]['border_legend'] = \$leg;
\t\t\$this->blk[\$this->blklvl]['margin_top'] += (\$leg[11]/2)/_MPDFK;
\t\t\$this->blk[\$this->blklvl]['padding_top'] += (\$leg[11]/2)/_MPDFK;
\t}
\tif (isset(\$this->InlineProperties['LEGEND'])) { \$this->restoreInlineProperties(\$this->InlineProperties['LEGEND']); }
\tunset(\$this->InlineProperties['LEGEND']);
\t\$this->ignorefollowingspaces = true; //Eliminate exceeding left-side spaces
    }



/*-- FORMS --*/
\t// *********** FORM ELEMENTS ********************

    if(\$tag=='TEXTAREA') {
\t\$this->specialcontent = '';
\tif (\$this->InlineProperties[\$tag]) { \$this->restoreInlineProperties(\$this->InlineProperties[\$tag]); }
\tunset(\$this->InlineProperties[\$tag]);
    }


    if(\$tag=='SELECT') {
\t\$this->lastoptionaltag = '';
\t\$texto = '';
\tif (isset(\$this->selectoption['SELECTED'])) { \$texto = \$this->selectoption['SELECTED']; }

\tif (\$this->useActiveForms) { \$w = \$this->selectoption['MAXWIDTH']; }
\telse { \$w = \$this->GetStringWidth(\$texto); }
\tif (\$w == 0) { \$w = 5; }
\t\$objattr['type'] = 'select';
\t\$objattr['text'] = \$texto;
\tif (isset(\$this->selectoption['NAME'])) { \$objattr['fieldname'] = \$this->selectoption['NAME']; }
\tif (isset(\$this->selectoption['READONLY'])) { \$objattr['readonly'] = true; }
\tif (isset(\$this->selectoption['REQUIRED'])) { \$objattr['required'] = true; }
\tif (isset(\$this->selectoption['SPELLCHECK'])) { \$objattr['spellcheck'] = true; }
\tif (isset(\$this->selectoption['EDITABLE'])) { \$objattr['editable'] = true; }
\tif (isset(\$this->selectoption['ONCHANGE'])) { \$objattr['onChange'] = \$this->selectoption['ONCHANGE']; }
\tif (isset(\$this->selectoption['ITEMS'])) { \$objattr['items'] = \$this->selectoption['ITEMS']; }
\tif (isset(\$this->selectoption['MULTIPLE'])) { \$objattr['multiple'] = \$this->selectoption['MULTIPLE']; }
\tif (isset(\$this->selectoption['DISABLED'])) { \$objattr['disabled'] = \$this->selectoption['DISABLED']; }
\tif (isset(\$this->selectoption['TITLE'])) { \$objattr['title'] = \$this->selectoption['TITLE']; }
\tif (isset(\$this->selectoption['COLOR'])) { \$objattr['color'] = \$this->selectoption['COLOR']; }
\tif (isset(\$this->selectoption['SIZE'])) { \$objattr['size'] = \$this->selectoption['SIZE']; }
\tif (isset(\$objattr['size']) && \$objattr['size']>1) { \$rows=\$objattr['size']; } else { \$rows = 1; }

\t\$objattr['fontfamily'] = \$this->FontFamily;
\t\$objattr['fontsize'] = \$this->FontSizePt;

\t\$objattr['width'] = \$w + (\$this->form->form_element_spacing['select']['outer']['h']*2)+(\$this->form->form_element_spacing['select']['inner']['h']*2) + (\$this->FontSize*1.4);
\t\$objattr['height'] = (\$this->FontSize*\$rows) + (\$this->form->form_element_spacing['select']['outer']['v']*2)+(\$this->form->form_element_spacing['select']['inner']['v']*2);
\t\$e = \"\\xbb\\xa4\\xactype=select,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";

\t// Clear properties - tidy up
\t\$properties = array();

\t// Output it to buffers
\tif (\$this->tableLevel) {\t// *TABLES*
\t\t\$this->_saveCellTextBuffer(\$e, \$this->HREF);
\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$objattr['width'] ;\t// *TABLES*
\t}\t// *TABLES*
\telse {\t// *TABLES*
\t\t\$this->_saveTextBuffer(\$e, \$this->HREF);
\t}\t// *TABLES*

\t\$this->selectoption = array();
\t\$this->specialcontent = '';

\tif (\$this->InlineProperties[\$tag]) { \$this->restoreInlineProperties(\$this->InlineProperties[\$tag]); }
\tunset(\$this->InlineProperties[\$tag]);

    }
/*-- END FORMS --*/


\t// *********** BLOCKS ********************
    if(\$tag=='P' || \$tag=='DIV' || \$tag=='H1' || \$tag=='H2' || \$tag=='H3' || \$tag=='H4' || \$tag=='H5' || \$tag=='H6' || \$tag=='PRE'
\t || \$tag=='FORM' || \$tag=='ADDRESS' || \$tag=='BLOCKQUOTE' || \$tag=='CENTER' || \$tag=='DT'  || \$tag=='DD'  || \$tag=='DL'
\t|| \$tag=='CAPTION' || \$tag=='FIELDSET'
\t|| \$tag=='ARTICLE' || \$tag=='ASIDE' || \$tag=='FIGURE' || \$tag=='FIGCAPTION' || \$tag=='FOOTER' || \$tag=='HEADER' || \$tag=='HGROUP'
\t|| \$tag=='MAIN' || \$tag=='NAV' || \$tag=='SECTION'  || \$tag=='DETAILS' || \$tag=='SUMMARY'
\t) { \t// mPDF 5.7.3

\t\$this->ignorefollowingspaces = true; //Eliminate exceeding left-side spaces
\t\$this->blockjustfinished=true;

\t\$this->lastblockbottommargin = \$this->blk[\$this->blklvl]['margin_bottom'];
/*-- LISTS --*/
\tif (\$this->listlvl>0) { return; }
/*-- END LISTS --*/

\t// mPDF 5.6.34
\tif (preg_match('/^H\\d/',\$tag) && !\$this->tableLevel && !\$this->writingToC) {\t// mPDF 5.6.38
\t\tif (isset(\$this->h2toc[\$tag]) || isset(\$this->h2bookmarks[\$tag])) {
\t\t\t\$content = '';
\t\t\tif (count(\$this->textbuffer)==1) { \$content = \$this->textbuffer[0][0]; }
\t\t\telse {
\t\t\t\tfor (\$i=0;\$i<count(\$this->textbuffer);\$i++) {
      \t\t\t\tif (substr(\$this->textbuffer[\$i][0],0,3) != \"\\xbb\\xa4\\xac\") { //inline object
\t\t\t\t\t\t\$content .= \$this->textbuffer[\$i][0];
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
/*-- TOC --*/
\t\t\tif (isset(\$this->h2toc[\$tag])) {
\t\t\t\t\$objattr = array();
\t\t\t\t\$objattr['type'] = 'toc';
\t\t\t\t\$objattr['toclevel'] = \$this->h2toc[\$tag];
\t\t\t\t\$objattr['CONTENT'] = htmlspecialchars(\$content);\t// mPDF 5.6.37
\t\t\t\t\$e = \"\\xbb\\xa4\\xactype=toc,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t\t\tarray_unshift(\$this->textbuffer,array(\$e));
\t\t\t}
/*-- END TOC --*/
/*-- BOOKMARKS --*/
\t\t\tif (isset(\$this->h2bookmarks[\$tag])) {
\t\t\t\t\$objattr = array();
\t\t\t\t\$objattr['type'] = 'bookmark';
\t\t\t\t\$objattr['bklevel'] = \$this->h2bookmarks[\$tag];
\t\t\t\t\$objattr['CONTENT'] = \$content;
\t\t\t\t\$e = \"\\xbb\\xa4\\xactype=toc,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t\t\tarray_unshift(\$this->textbuffer,array(\$e));
\t\t\t}
/*-- END BOOKMARKS --*/
\t\t}
\t}

/*-- TABLES --*/
\tif(\$this->tableLevel) {
\t\tif (\$this->linebreakjustfinished) { \$this->blockjustfinished=false; }
\t\tif (isset(\$this->InlineProperties['BLOCKINTABLE'])) {
\t\t\tif (\$this->InlineProperties['BLOCKINTABLE']) { \$this->restoreInlineProperties(\$this->InlineProperties['BLOCKINTABLE']); }
\t\t\tunset(\$this->InlineProperties['BLOCKINTABLE']);
\t\t}
\t\tif(\$tag=='PRE') { \$this->ispre=false; }
\t\treturn;
\t}
/*-- END TABLES --*/
\t\$this->lastoptionaltag = '';
\t\$this->divbegin=false;

\t\$this->linebreakjustfinished=false;

\t\$this->x = \$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'];

/*-- CSS-FLOAT --*/
\t// If float contained in a float, need to extend bottom to allow for it
\t\$currpos = \$this->page*1000 + \$this->y;
\tif (isset(\$this->blk[\$this->blklvl]['float_endpos']) && \$this->blk[\$this->blklvl]['float_endpos'] > \$currpos) {
\t\t\$old_page = \$this->page;
\t\t\$new_page = intval(\$this->blk[\$this->blklvl]['float_endpos'] /1000);
\t\tif (\$old_page != \$new_page) {
\t\t\t\$s = \$this->PrintPageBackgrounds();
\t\t\t// Writes after the marker so not overwritten later by page background etc.
\t\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\t\t\$this->pageBackgrounds = array();
\t\t\t\$this->page = \$new_page;
\t\t\t\$this->ResetMargins();
\t\t\t\$this->Reset();
\t\t\t\$this->pageoutput[\$this->page] = array();
\t\t}
\t\t\$this->y = ((\$this->blk[\$this->blklvl]['float_endpos'] *1000) % 1000000)/1000;\t// mod changes operands to integers before processing
\t}
/*-- END CSS-FLOAT --*/


\t//Print content
\tif (\$this->lastblocklevelchange == 1) { \$blockstate = 3; }\t// Top & bottom margins/padding
\telse if (\$this->lastblocklevelchange == -1) { \$blockstate = 2; }\t// Bottom margins/padding only
\telse { \$blockstate = 0; }
\t// called from after e.g. </table> </div> </div> ...    Outputs block margin/border and padding
\tif (count(\$this->textbuffer) && \$this->textbuffer[count(\$this->textbuffer)-1]) {
\t  if (substr(\$this->textbuffer[count(\$this->textbuffer)-1][0],0,3) != \"\\xbb\\xa4\\xac\") {\t// not special content
\t   if (\$this->usingCoreFont) {
\t\t\$this->textbuffer[count(\$this->textbuffer)-1][0] = preg_replace('/[ ]+\$/', '', \$this->textbuffer[count(\$this->textbuffer)-1][0]);
\t   }
\t   else {
\t\t\$this->textbuffer[count(\$this->textbuffer)-1][0] = preg_replace('/[ ]+\$/u', '', \$this->textbuffer[count(\$this->textbuffer)-1][0]);\t   }
\t  }
\t}

\tif (count(\$this->textbuffer) == 0 && \$this->lastblocklevelchange != 0) {
\t\t//\$this->newFlowingBlock( \$this->blk[\$this->blklvl]['width'],\$this->lineheight,'',false,false,2,true, \$this->blk[\$this->blklvl]['direction']);
\t\t\$this->newFlowingBlock( \$this->blk[\$this->blklvl]['width'],\$this->lineheight,'',false,false,\$blockstate,true, \$this->blk[\$this->blklvl]['direction']);
\t\t\$this->finishFlowingBlock(true);\t// true = END of flowing block
\t\t\$this->PaintDivBB('',\$blockstate);
\t}
\telse {
\t\t\$this->printbuffer(\$this->textbuffer,\$blockstate);
\t}


\t\$this->textbuffer=array();

\tif (\$this->blk[\$this->blklvl]['keep_block_together']) {
\t\t\$this->printdivbuffer();
\t}

\tif (\$this->kwt) {
\t\t\$this->kwt_height = \$this->y - \$this->kwt_y0;
\t}

/*-- CSS-IMAGE-FLOAT --*/
\t\$this->printfloatbuffer();
/*-- END CSS-IMAGE-FLOAT --*/

\tif(\$tag=='PRE') { \$this->ispre=false; }

/*-- CSS-FLOAT --*/
\tif (\$this->blk[\$this->blklvl]['float'] == 'R') {
\t\t// If width not set, here would need to adjust and output buffer
\t\t\$s = \$this->PrintPageBackgrounds();
\t\t// Writes after the marker so not overwritten later by page background etc.
\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\t\$this->pageBackgrounds = array();
\t\t\$this->Reset();
\t\t\$this->pageoutput[\$this->page] = array();

\t\tfor(\$i=(\$this->blklvl-1); \$i >= 0; \$i--) {
\t\t\tif (isset(\$this->blk[\$i]['float_endpos'])) { \$this->blk[\$i]['float_endpos'] = max(\$this->blk[\$i]['float_endpos'], (\$this->page*1000 + \$this->y)); }
\t\t\telse { \$this->blk[\$i]['float_endpos'] = \$this->page*1000 + \$this->y; }
\t\t}

\t\t\$this->floatDivs[] = array(
\t\t\t'side'=>'R',
\t\t\t'startpage'=>\$this->blk[\$this->blklvl]['startpage'] ,
\t\t\t'y0'=>\$this->blk[\$this->blklvl]['float_start_y'] ,
\t\t\t'startpos'=> (\$this->blk[\$this->blklvl]['startpage']*1000 + \$this->blk[\$this->blklvl]['float_start_y']),
\t\t\t'endpage'=>\$this->page ,
\t\t\t'y1'=>\$this->y ,
\t\t\t'endpos'=> (\$this->page*1000 + \$this->y),
\t\t\t'w'=> \$this->blk[\$this->blklvl]['float_width'],
\t\t\t'blklvl'=>\$this->blklvl,
\t\t\t'blockContext' => \$this->blk[\$this->blklvl-1]['blockContext']
\t\t);

\t\t\$this->y = \$this->blk[\$this->blklvl]['float_start_y'] ;
\t\t\$this->page = \$this->blk[\$this->blklvl]['startpage'] ;
\t\t\$this->ResetMargins();
\t\t\$this->pageoutput[\$this->page] = array();
\t}
\tif (\$this->blk[\$this->blklvl]['float'] == 'L') {
\t\t// If width not set, here would need to adjust and output buffer
\t\t\$s = \$this->PrintPageBackgrounds();
\t\t// Writes after the marker so not overwritten later by page background etc.
\t\t\$this->pages[\$this->page] = preg_replace('/(___BACKGROUND___PATTERNS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\t\$this->pageBackgrounds = array();
\t\t\$this->Reset();
\t\t\$this->pageoutput[\$this->page] = array();

\t\tfor(\$i=(\$this->blklvl-1); \$i >= 0; \$i--) {
\t\t\tif (isset(\$this->blk[\$i]['float_endpos'])) { \$this->blk[\$i]['float_endpos'] = max(\$this->blk[\$i]['float_endpos'], (\$this->page*1000 + \$this->y)); }
\t\t\telse { \$this->blk[\$i]['float_endpos'] = \$this->page*1000 + \$this->y; }
\t\t}

\t\t\$this->floatDivs[] = array(
\t\t\t'side'=>'L',
\t\t\t'startpage'=>\$this->blk[\$this->blklvl]['startpage'] ,
\t\t\t'y0'=>\$this->blk[\$this->blklvl]['float_start_y'] ,
\t\t\t'startpos'=> (\$this->blk[\$this->blklvl]['startpage']*1000 + \$this->blk[\$this->blklvl]['float_start_y']),
\t\t\t'endpage'=>\$this->page ,
\t\t\t'y1'=>\$this->y ,
\t\t\t'endpos'=> (\$this->page*1000 + \$this->y),
\t\t\t'w'=> \$this->blk[\$this->blklvl]['float_width'],
\t\t\t'blklvl'=>\$this->blklvl,
\t\t\t'blockContext' => \$this->blk[\$this->blklvl-1]['blockContext']
\t\t);

\t\t\$this->y = \$this->blk[\$this->blklvl]['float_start_y'] ;
\t\t\$this->page = \$this->blk[\$this->blklvl]['startpage'] ;
\t\t\$this->ResetMargins();
\t\t\$this->pageoutput[\$this->page] = array();
\t}
/*-- END CSS-FLOAT --*/

\tif (isset(\$this->blk[\$this->blklvl]['visibility']) && \$this->blk[\$this->blklvl]['visibility']!='visible') {
\t\t\$this->SetVisibility('visible');
\t}

\tif (isset(\$this->blk[\$this->blklvl]['page_break_after'])) { \$page_break_after = \$this->blk[\$this->blklvl]['page_break_after']; }
\telse { \$page_break_after = ''; }

\t//Reset values
\t\$this->Reset();

\t// mPDF 5.6.01  - LAYERS
\tif (isset(\$this->blk[\$this->blklvl]['z-index']) && \$this->blk[\$this->blklvl]['z-index'] > 0) {
\t\t\$this->EndLayer();
\t}

\tif (\$this->blklvl > 0) {\t// ==0 SHOULDN'T HAPPEN - NOT XHTML
\t   if (\$this->blk[\$this->blklvl]['tag'] == \$tag) {
\t\tunset(\$this->blk[\$this->blklvl]);
\t\t\$this->blklvl--;
\t   }
\t   //else { echo \$tag; exit; }\t// debug - forces error if incorrectly nested html tags
\t}

\t\$this->lastblocklevelchange = -1 ;
\t// Reset Inline-type properties
\tif (isset(\$this->blk[\$this->blklvl]['InlineProperties'])) { \$this->restoreInlineProperties(\$this->blk[\$this->blklvl]['InlineProperties']); }

\t\$this->x = \$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'];

\tif (\$page_break_after) {
\t\t\$save_blklvl = \$this->blklvl;
\t\t\$save_blk = \$this->blk;
\t\t\$save_silp = \$this->saveInlineProperties();
\t\t\$save_ilp = \$this->InlineProperties;
\t\tif (\$this->blklvl>1) {
\t\t\t// Close any open block tags
\t\t\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }
\t\t\t// Output any text left in buffer
\t\t\tif (count(\$this->textbuffer)) { \$this->printbuffer(\$this->textbuffer); \$this->textbuffer=array(); }
\t\t}
/*-- COLUMNS --*/
\t\t\$save_cols = false;
\t\tif (\$this->ColActive) {
\t\t\t\$save_cols = true;
\t\t\t\$save_nbcol = \$this->NbCol;\t// other values of gap and vAlign will not change by setting Columns off
\t\t\t\$this->SetColumns(0);
\t\t}
/*-- END COLUMNS --*/
\t\tif (\$page_break_after == 'RIGHT') { \$this->AddPage(\$this->CurOrientation,'NEXT-ODD','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\telse if (\$page_break_after == 'LEFT') { \$this->AddPage(\$this->CurOrientation,'NEXT-EVEN','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\telse { \$this->AddPage(\$this->CurOrientation,'','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\t// mPDF 5.7.3
\t\tif (!\$this->restoreBlockPagebreaks) {
\t\t\t\$this->blklvl = 0;
\t\t\t\$this->lastblocklevelchange = 0;
\t\t\t\$this->Reset();
\t\t\t\$this->restoreInlineProperties(\$this->blk[0]['InlineProperties']);
\t\t}
/*-- COLUMNS --*/
\t\tif (\$save_cols) {
\t\t\t// Restore columns
\t\t\t\$this->SetColumns(\$save_nbcol,\$this->colvAlign,\$this->ColGap);
\t\t}
/*-- END COLUMNS --*/
\t\tif (\$this->restoreBlockPagebreaks && !\$this->tableLevel && !\$this->listlvl) {
\t\t\t\$this->blk = \$save_blk;
\t\t\t// Re-open block tags
\t\t\t\$t = \$this->blk[0]['tag'];
\t\t\t\$a = \$this->blk[0]['attr'];
\t\t\t\$this->blklvl = 0;
\t\t\tfor (\$b=0; \$b<=\$save_blklvl;\$b++) {
\t\t\t\t\$tc = \$t;
\t\t\t\t\$ac = \$a;
\t\t\t\t\$t = \$this->blk[\$b+1]['tag'];
\t\t\t\t\$a = \$this->blk[\$b+1]['attr'];
\t\t\t\tunset(\$this->blk[\$b+1]);
\t\t\t\t\$this->OpenTag(\$tc,\$ac);
\t\t\t}
\t\t\t\$this->InlineProperties = \$save_ilp;
\t\t\t\$this->restoreInlineProperties(\$save_silp);
\t\t}
\t}

    }


/*-- TABLES --*/

    if(\$tag=='TH') \$this->SetStyle('B',false);

    if((\$tag=='TH' or \$tag=='TD') && \$this->tableLevel) {
\t\$this->lastoptionaltag = 'TR';
\tunset(\$this->cssmgr->tablecascadeCSS[\$this->cssmgr->tbCSSlvl]);
\t\$this->cssmgr->tbCSSlvl--;
\tif (!\$this->tdbegin) { return; }
\t\$this->tdbegin = false;
\t// Added for correct calculation of cell column width - otherwise misses the last line if not end </p> etc.
\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\tif (!is_array(\$this->cell[\$this->row][\$this->col])) { \$this->Error(\"You may have an error in your HTML code e.g. &lt;/td&gt;&lt;/td&gt;\"); }
\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t}
\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t}

\t// Remove last <br> if at end of cell
\tif (isset(\$this->cell[\$this->row][\$this->col]['textbuffer'])) { \$ntb = count(\$this->cell[\$this->row][\$this->col]['textbuffer']); }
\telse { \$ntb = 0; }
\tif (\$ntb>1 && \$this->cell[\$this->row][\$this->col]['textbuffer'][\$ntb-1][0] == \"\\n\") {
\t\tunset(\$this->cell[\$this->row][\$this->col]['textbuffer'][\$ntb-1]);
\t}

\tif (\$this->cacheTables) {
\t\t\$clen = \$this->_cacheCell(\$this->cell[\$this->row][\$this->col], \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cache']);
\t\t\$this->cell[\$this->row][\$this->col] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['ptr'];
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['ptr'] += \$clen;
\t}

\tif (\$this->tablethead) {
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_thead'][\$this->row] = true;
\t\tif (\$this->tableLevel==1) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['headernrows'] = max(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['headernrows'] , (\$this->row+1)); }
\t}
\tif (\$this->tabletfoot) {
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_tfoot'][\$this->row] = true;
\t\tif (\$this->tableLevel==1) { \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['footernrows'] = max(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['footernrows'] , (\$this->row+1 - \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['headernrows'] )); }
\t}
\t\$this->Reset();
    }

    if(\$tag=='TR' && \$this->tableLevel) {
\t// If Border set on TR - Update right border
\tif (isset(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trborder-left'][\$this->row])) {
\t\tif (\$this->cacheTables) {
\t\t\t\$c = \$this->_uncacheCell(\$this->cell[\$this->row][\$this->col], \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cache'], null);
\t\t}
\t\telse { \$c =& \$this->cell[\$this->row][\$this->col]; }
\t\tif (\$c) {
\t\t\tif (\$this->packTableData) {
\t\t\t\t\$cell = \$this->_unpackCellBorder(\$c['borderbin'] );
\t\t\t}
\t\t\telse { \$cell = \$c; }
\t\t\t\$cell['border_details']['R'] = \$this->border_details(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trborder-right'][\$this->row]);
\t\t\t\$this->setBorder(\$cell['border'], _BORDER_RIGHT, \$cell['border_details']['R']['s']);
\t\t\tif (\$this->packTableData) {
\t\t\t\t\$c['borderbin'] = \$this->_packCellBorder(\$cell);
\t\t\t\tunset(\$c['border']);
\t\t\t\tunset(\$c['border_details']);
\t\t\t}
\t\t\telse { \$c = \$cell; }
\t\t}
\t\tif (\$this->cacheTables) {
\t\t\t\$fh = fopen(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cache'], \"r+b\");
\t\t\t\$this->_cacheUpdateBorder(\$c, \$fh, \$this->cell[\$this->row][\$this->col]);
\t\t\tfclose(\$fh);
\t\t}
\t}
\t\$this->lastoptionaltag = '';
\tunset(\$this->cssmgr->tablecascadeCSS[\$this->cssmgr->tbCSSlvl]);
\t\$this->cssmgr->tbCSSlvl--;
\t\$this->trow_text_rotate = '';
\t\$this->tabletheadjustfinished = false;
   }

    if(\$tag=='TBODY') {
\t\$this->lastoptionaltag = '';
\tunset(\$this->cssmgr->tablecascadeCSS[\$this->cssmgr->tbCSSlvl]);
\t\$this->cssmgr->tbCSSlvl--;
    }

    if(\$tag=='THEAD') {
\t\$this->lastoptionaltag = '';
\tunset(\$this->cssmgr->tablecascadeCSS[\$this->cssmgr->tbCSSlvl]);
\t\$this->cssmgr->tbCSSlvl--;
\t\$this->tablethead = 0;
\t\$this->tabletheadjustfinished = true;
\t\$this->ResetStyles();
\t\$this->thead_font_weight = '';
\t\$this->thead_font_style = '';
\t\$this->thead_font_smCaps = '';

\t\$this->thead_valign_default = '';
\t\$this->thead_textalign_default = '';
    }

    if(\$tag=='TFOOT') {
\t\$this->lastoptionaltag = '';
\tunset(\$this->cssmgr->tablecascadeCSS[\$this->cssmgr->tbCSSlvl]);
\t\$this->cssmgr->tbCSSlvl--;
\t\$this->tabletfoot = 0;
\t\$this->ResetStyles();
\t\$this->tfoot_font_weight = '';
\t\$this->tfoot_font_style = '';
\t\$this->tfoot_font_smCaps = '';

\t\$this->tfoot_valign_default = '';
\t\$this->tfoot_textalign_default = '';
    }

    if(\$tag=='TABLE') { // TABLE-END (
\tif (\$this->progressBar) { \$this->UpdateProgressBar(1,'','TABLE'); }\t// *PROGRESS-BAR*
\tif (\$this->progressBar) { \$this->UpdateProgressBar(7,0,''); }\t// *PROGRESS-BAR*
\t\$this->lastoptionaltag = '';
\tunset(\$this->cssmgr->tablecascadeCSS[\$this->cssmgr->tbCSSlvl]);
\t\$this->cssmgr->tbCSSlvl--;
\t\$this->ignorefollowingspaces = true; //Eliminate exceeding left-side spaces

\t// mPDF 5.7.3
\t// In case a colspan (on a row after first row) exceeded number of columns in table
\tfor (\$k=0; \$k < \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nr']; \$k++) {
\t\tfor(\$l=0; \$l < \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nc']; \$l++) {
\t\t\tif (!isset(\$this->cell[\$k][\$l])) {
\t\t\t\tfor (\$n=\$l-1; \$n>=0; \$n--) {
\t\t\t\t\tif (isset(\$this->cell[\$k][\$n]) && \$this->cell[\$k][\$n]!=0) { break; }
\t\t\t\t}
\t\t\t\t\$this->cell[\$k][\$l] = array(
\t\t\t\t\t'a' => 'C',
\t\t\t\t\t'va' => 'M',
\t\t\t\t\t'R' => false,
\t\t\t\t\t'nowrap' => false,
\t\t\t\t\t'bgcolor' => false,
\t\t\t\t\t'padding' => array('L' => false, 'R' => false, 'T' => false, 'B' => false),
\t\t\t\t\t'gradient' => false,
\t\t\t\t\t's' => 0,
\t\t\t\t\t'maxs' => 0,
\t\t\t\t\t'textbuffer' => array(),
\t\t\t\t\t'dfs' => \$this->FontSize,
\t\t\t\t);

\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t\t\$this->cell[\$k][\$l]['border'] = 0;
\t\t\t\t\t\$this->cell[\$k][\$l]['border_details']['R'] = array('s' => 0, 'w' => 0, 'c' => false, 'style' => 'none', 'dom' => 0);
\t\t\t\t\t\$this->cell[\$k][\$l]['border_details']['L'] = array('s' => 0, 'w' => 0, 'c' => false, 'style' => 'none', 'dom' => 0);
\t\t\t\t\t\$this->cell[\$k][\$l]['border_details']['T'] = array('s' => 0, 'w' => 0, 'c' => false, 'style' => 'none', 'dom' => 0);
\t\t\t\t\t\$this->cell[\$k][\$l]['border_details']['B'] = array('s' => 0, 'w' => 0, 'c' => false, 'style' => 'none', 'dom' => 0);
\t\t\t\t\t\$this->cell[\$k][\$l]['border_details']['mbw'] = array('BL' =>0,'BR' =>0,'RT' =>0,'RB' =>0,'TL' =>0,'TR' =>0,'LT' =>0,'LB' =>0);
\t\t\t\t\tif (\$this->packTableData) {
\t\t\t\t\t\t\$this->cell[\$k][\$l]['borderbin'] = \$this->_packCellBorder(\$this->cell[\$k][\$l]);
\t\t\t\t\t\tunset(\$this->cell[\$k][\$l]['border']);
\t\t\t\t\t\tunset(\$this->cell[\$k][\$l]['border_details']);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t}
\t}

\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cells'] = \$this->cell;
\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['wc'] = array_pad(array(),\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nc'],array('miw'=>0,'maw'=>0));
\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['hr'] = array_pad(array(),\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nr'],0);

\t// Move table footer <tfoot> row to end of table
\tif (isset(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_tfoot']) && count(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_tfoot'])) {
\t\t\$tfrows = array();
\t\tforeach(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_tfoot'] AS \$r=>\$val) {
\t\t\tif (\$val) { \$tfrows[] = \$r; }
\t\t}
\t\t\$temp = array();
\t\t\$temptf = array();
\t\tforeach(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cells'] AS \$k=>\$row) {
\t\t\tif (in_array(\$k,\$tfrows)) {
\t\t\t\t\$temptf[] = \$row;
\t\t\t}
\t\t\telse {
\t\t\t\t\$temp[] = \$row;
\t\t\t}
\t\t}
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_tfoot'] = array();
\t\tfor(\$i=count(\$temp) ; \$i<(count(\$temp)+count(\$temptf)); \$i++) {
\t\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['is_tfoot'][\$i] = true;
\t\t}
\t\t// Update nestedpos row references
\t\tif (count(\$this->table[(\$this->tableLevel+1)])) {
\t\t  foreach(\$this->table[(\$this->tableLevel+1)] AS \$nid=>\$nested) {
\t\t\t\$this->table[(\$this->tableLevel+1)][\$nid]['nestedpos'][0] -= count(\$temptf);
\t\t  }
\t\t}
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cells'] = array_merge(\$temp, \$temptf);

\t\t// Update other arays set on row number
\t\t// [trbackground-images] [trgradients]
\t\t\$temptrbgi = array();
\t\t\$temptrbgg = array();
\t\t\$temptrbgc = array();
\t\t\$temptrbgc[-1] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['bgcolor'][-1];
\t\tfor(\$k=0; \$k<\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nr']; \$k++) {
\t\t\tif (!in_array(\$k,\$tfrows)) {
\t\t\t\t\$temptrbgi[] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trbackground-images'][\$k];
\t\t\t\t\$temptrbgg[] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trgradients'][\$k];
\t\t\t\t\$temptrbgc[] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['bgcolor'][\$k];
\t\t\t}
\t\t}
\t\tfor(\$k=0; \$k<\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['nr']; \$k++) {
\t\t\tif (in_array(\$k,\$tfrows)) {
\t\t\t\t\$temptrbgi[] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trbackground-images'][\$k];
\t\t\t\t\$temptrbgg[] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trgradients'][\$k];
\t\t\t\t\$temptrbgc[] = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['bgcolor'][\$k];
\t\t\t}
\t\t}
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trbackground-images'] = \$temptrbgi;
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['trgradients'] = \$temptrbgg;
\t\t\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['bgcolor'] = \$temptrbgc ;
\t\t// Should Update all other arays set on row number, but cell properties have been set so not needed
\t\t// [bgcolor] [trborder-left] [trborder-right] [trborder-top] [trborder-bottom]
\t}

\tif (\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['direction']=='rtl') {
\t\t\$this->_reverseTableDir(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]);
\t}

\t// Fix Borders *********************************************
\t\$this->_fixTableBorders(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]);

\tif (\$this->progressBar) { \$this->UpdateProgressBar(7,10,' '); }\t// *PROGRESS-BAR*

\tif (\$this->ColActive) { \$this->table_rotate = 0; }\t// *COLUMNS*
\tif (\$this->table_rotate <> 0) {
\t\t\$this->tablebuffer = '';
\t\t// Max width for rotated table
\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 1);
\t\t\$this->tbrot_maxh = \$this->blk[\$this->blklvl]['inner_width'] ;\t\t// Max width for rotated table
\t\t\$this->tbrot_align = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['a'] ;
\t}
\t\$this->shrin_k = 1;

\tif (\$this->shrink_tables_to_fit < 1) { \$this->shrink_tables_to_fit = 1; }
\tif (!\$this->shrink_this_table_to_fit) { \$this->shrink_this_table_to_fit = \$this->shrink_tables_to_fit; }

\tif (\$this->tableLevel>1) {
\t\t// deal with nested table

\t\t\$this->_tableColumnWidth(\$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]],true);

\t\t\$tmiw = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['miw'];
\t\t\$tmaw = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['maw'];
\t\t\$tl = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['tl'];

\t\t// Go down to lower table level
\t\t\$this->tableLevel--;

\t\t// Reset lower level table
\t\t\$this->base_table_properties = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['baseProperties'];
\t\t// mPDF 5.7.3
\t\t\$this->default_font = \$this->base_table_properties['FONT-FAMILY'];
\t\t\$this->SetFont(\$this->default_font,'',0,false);
\t\t\$this->default_font_size = \$this->ConvertSize(\$this->base_table_properties['FONT-SIZE'])*(_MPDFK);
   \t\t\$this->SetFontSize(\$this->default_font_size,false);

\t\t\$this->cell = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['cells'];
\t\t// mPDF 5.4.10
\t\tif (isset(\$this->cell['PARENTCELL'])) {
\t\t\tif (\$this->cell['PARENTCELL']) { \$this->restoreInlineProperties(\$this->cell['PARENTCELL']); }
\t\t\tunset(\$this->cell['PARENTCELL']);
\t\t}
\t\t\$this->row = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['currrow'];
\t\t\$this->col = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['currcol'];
\t\t\$objattr = array();
\t\t\$objattr['type'] = 'nestedtable';
\t\t\$objattr['nestedcontent'] = \$this->tbctr[(\$this->tableLevel+1)];
\t\t\$objattr['table'] = \$this->tbctr[\$this->tableLevel];
\t\t\$objattr['row'] = \$this->row;
\t\t\$objattr['col'] = \$this->col;
\t\t\$objattr['level'] = \$this->tableLevel;
\t\t\$e = \"\\xbb\\xa4\\xactype=nestedtable,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t\$this->_saveCellTextBuffer(\$e);
\t\t\$this->cell[\$this->row][\$this->col]['s'] += \$tl ;
\t\tif (!isset(\$this->cell[\$this->row][\$this->col]['maxs'])) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\telseif(\$this->cell[\$this->row][\$this->col]['maxs'] < \$this->cell[\$this->row][\$this->col]['s']) {
\t\t\t\$this->cell[\$this->row][\$this->col]['maxs'] = \$this->cell[\$this->row][\$this->col]['s'];
\t\t}
\t\t\$this->cell[\$this->row][\$this->col]['s'] = 0;// reset
\t\tif ((isset(\$this->cell[\$this->row][\$this->col]['nestedmaw']) && \$this->cell[\$this->row][\$this->col]['nestedmaw'] < \$tmaw) || !isset(\$this->cell[\$this->row][\$this->col]['nestedmaw'])) { \$this->cell[\$this->row][\$this->col]['nestedmaw'] = \$tmaw ; }
\t\tif ((isset(\$this->cell[\$this->row][\$this->col]['nestedmiw']) && \$this->cell[\$this->row][\$this->col]['nestedmiw'] < \$tmiw) || !isset(\$this->cell[\$this->row][\$this->col]['nestedmiw'])) { \$this->cell[\$this->row][\$this->col]['nestedmiw'] = \$tmiw ; }
\t\t\$this->tdbegin = true;
\t\t\$this->nestedtablejustfinished = true;
\t\t\$this->ignorefollowingspaces = true;
\t\treturn;
\t}
\t\$this->cMarginL = 0;
\t\$this->cMarginR = 0;
\t\$this->cMarginT = 0;
\t\$this->cMarginB = 0;
\t\$this->cellPaddingL = 0;
\t\$this->cellPaddingR = 0;
\t\$this->cellPaddingT = 0;
\t\$this->cellPaddingB = 0;

\tif (isset(\$this->table[1][1]['overflow']) && \$this->table[1][1]['overflow']=='visible') {
\t\tif (\$this->kwt || \$this->table_rotate || \$this->table_keep_together || \$this->ColActive) {
\t\t\t\$this->kwt = false;
\t\t\t\$this->table_rotate = 0;
\t\t\t\$this->table_keep_together = false;
\t\t\t//die(\"mPDF Warning: You cannot use CSS overflow:visible together with any of these functions: 'Keep-with-table', rotated tables, page-break-inside:avoid, or columns\");
\t\t}
\t\t\$this->_tableColumnWidth(\$this->table[1][1],true);
\t\t\$this->_tableWidth(\$this->table[1][1]);
\t}
\telse {
\t  if (!\$this->kwt_saved) { \$this->kwt_height = 0; }

\t  list(\$check,\$tablemiw) = \$this->_tableColumnWidth(\$this->table[1][1],true);
\t  \$save_table = \$this->table;
\t  if (\$this->cacheTables) { \$this->_backupCacheFiles(); }
\t  \$reset_to_minimum_width = false;
\t  \$added_page = false;

\t  if (\$check > 1) {
\t\tif (\$check > \$this->shrink_this_table_to_fit && \$this->table_rotate) {
\t\t\tif (\$this->y != \$this->tMargin) {
\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t\$this->kwt_moved = true;
\t\t\t}
\t\t\t\$added_page = true;
\t\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 5) - \$this->kwt_height;
\t\t\t//\$check = \$tablemiw/\$this->tbrot_maxw; \t// undo any shrink
\t\t\t\$check = 1; \t// undo any shrink
\t\t}
\t\t\$reset_to_minimum_width = true;
\t  }

\t  if (\$reset_to_minimum_width) {

\t\t\$this->shrin_k = \$check;

 \t\t\$this->default_font_size /= \$this->shrin_k;
\t\t\$this->SetFontSize(\$this->default_font_size, false );

\t\t\$this->shrinkTable(\$this->table[1][1],\$this->shrin_k);

\t\t\$this->_tableColumnWidth(\$this->table[1][1],false);\t// repeat

\t\t// Starting at \$this->innermostTableLevel
\t\t// Shrink table values - and redo columnWidth
\t\tfor(\$lvl=2;\$lvl<=\$this->innermostTableLevel;\$lvl++) {
\t\t\tfor (\$nid=1; \$nid<=\$this->tbctr[\$lvl]; \$nid++) {
\t\t\t\t\$this->shrinkTable(\$this->table[\$lvl][\$nid],\$this->shrin_k);
\t\t\t\t\$this->_tableColumnWidth(\$this->table[\$lvl][\$nid],false);
\t\t\t}
\t\t}
\t  }

\t  // Set table cell widths for top level table
\t  // Use \$shrin_k to resize but don't change again
\t  \$this->SetLineHeight('',\$this->table_lineheight);

\t  // Top level table
\t  \$this->_tableWidth(\$this->table[1][1]);

\t}


\t// Now work through any nested tables setting child table[w'] = parent cell['w']
\t// Now do nested tables _tableWidth
\tfor(\$lvl=2;\$lvl<=\$this->innermostTableLevel;\$lvl++) {
\t\tfor (\$nid=1; \$nid<=\$this->tbctr[\$lvl]; \$nid++) {
\t\t\t// HERE set child table width = cell width

\t\t\tlist(\$parentrow, \$parentcol, \$parentnid) = \$this->table[\$lvl][\$nid]['nestedpos'];

\t\t\tif (\$this->cacheTables) {
\t\t\t\t\$c = \$this->_uncacheCell(\$this->table[(\$lvl-1)][\$parentnid]['cells'][\$parentrow][\$parentcol], \$this->table[(\$lvl-1)][\$parentnid]['cache'], null);
\t\t\t}
\t\t\telse
\t\t\t\t\$c =& \$this->table[(\$lvl-1)][\$parentnid]['cells'][\$parentrow][\$parentcol];

\t\t\tif (isset(\$c['colspan']) && \$c['colspan']> 1) {
\t\t\t   \$parentwidth = 0;
\t\t\t   for(\$cs=0;\$cs<\$c['colspan'] ; \$cs++) {
\t\t\t\t\$parentwidth += \$this->table[(\$lvl-1)][\$parentnid]['wc'][\$parentcol+\$cs];
\t\t\t   }
\t\t\t}
\t\t\telse { \$parentwidth = \$this->table[(\$lvl-1)][\$parentnid]['wc'][\$parentcol]; }


\t\t\t//\$parentwidth -= ALLOW FOR PADDING ETC.in parent cell
\t\t\tif (!\$this->simpleTables){
\t\t\t if (\$this->packTableData) {
\t\t\t \tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$c['borderbin']);
\t\t\t }
\t\t\t else {
\t\t\t\t\$br = \$c['border_details']['R']['w'];
\t\t\t\t\$bl = \$c['border_details']['L']['w'];
\t\t\t }
\t\t\t if (\$this->table[\$lvl-1][\$parentnid]['borders_separate']) {
\t\t\t  \$parentwidth -= \$br + \$bl
\t\t\t\t+ \$c['padding']['L']
\t\t\t\t+ \$c['padding']['R']
\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['border_spacing_H'];
\t\t\t }
\t\t\t else {
\t\t\t  \$parentwidth -= \$br/2 + \$bl/2
\t\t\t\t+ \$c['padding']['L']
\t\t\t\t+ \$c['padding']['R'];
\t\t\t }
\t\t\t}
\t\t\telse if (\$this->simpleTables){
\t\t\t if (\$this->table[\$lvl-1][\$parentnid]['borders_separate']) {
\t\t\t  \$parentwidth -= \$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['L']['w']
\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['R']['w']
\t\t\t\t+ \$c['padding']['L']
\t\t\t\t+ \$c['padding']['R']
\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['border_spacing_H'];
\t\t\t }
\t\t\t else {
\t\t\t  \$parentwidth -= \$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['L']['w']/2
\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['R']['w']/2
\t\t\t\t+ \$c['padding']['L']
\t\t\t\t+ \$c['padding']['R'];
\t\t\t }
\t\t\t}
\t\t\tif (isset(\$this->table[\$lvl][\$nid]['wpercent']) && \$this->table[\$lvl][\$nid]['wpercent'] && \$lvl>1) {
\t\t\t\t\$this->table[\$lvl][\$nid]['w'] = \$parentwidth;
\t\t\t}
\t\t\telse if (\$parentwidth > \$this->table[\$lvl][\$nid]['maw']) {
\t\t\t\t\$this->table[\$lvl][\$nid]['w'] = \$this->table[\$lvl][\$nid]['maw'];
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->table[\$lvl][\$nid]['w'] = \$parentwidth;
\t\t\t}
\t\t\tunset(\$c);
\t\t\t\$this->_tableWidth(\$this->table[\$lvl][\$nid]);
\t\t}
\t}

\t// Starting at \$this->innermostTableLevel
\t// Cascade back up nested tables: setting heights back up the tree
\tfor(\$lvl=\$this->innermostTableLevel;\$lvl>0;\$lvl--) {
\t\tfor (\$nid=1; \$nid<=\$this->tbctr[\$lvl]; \$nid++) {
\t\t\tlist(\$tableheight,\$maxrowheight,\$fullpage,\$remainingpage, \$maxfirstrowheight) = \$this->_tableHeight(\$this->table[\$lvl][\$nid]);\t\t\t}
\t}
\tif (\$this->progressBar) { \$this->UpdateProgressBar(7,20,' '); }\t// *PROGRESS-BAR*
\tif (\$this->table[1][1]['overflow']=='visible') {
\t\tif (\$maxrowheight > \$fullpage) { die(\"mPDF Warning: A Table row is greater than available height. You cannot use CSS overflow:visible\"); }
\t\tif (\$maxfirstrowheight > \$remainingpage) { \$this->AddPage(\$this->CurOrientation); }
\t\t\$r = 0; \$c = 0; \$p = 0; \$y = 0;
\t\twhile (!\$finished) {
\t\t\tlist(\$finished,\$r,\$c,\$p,\$y,\$y0) = \$this->_tableWrite(\$this->table[1][1],true,\$r,\$c,\$p,\$y);
\t\t\tif (!\$finished) {
\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t// If printed something on first spread, set same y
\t\t\t\tif (\$r==0 && \$y0 > -1) { \$this->y = \$y0; }
\t\t\t}
\t\t}
\t}
\telse {
\t  \$recalculate = 1;
\t  \$forcerecalc = false;
\t  // RESIZING ALGORITHM
\t  if (\$maxrowheight > \$fullpage) {
\t\t\$recalculate = \$this->tbsqrt(\$maxrowheight / \$fullpage, 1);
\t\t\$forcerecalc = true;
\t  }
\t  else if (\$this->table_rotate) {\t// NB \$remainingpage == \$fullpage == the width of the page
\t\tif (\$tableheight > \$remainingpage) {
\t\t\t// If can fit on remainder of page whilst respecting autsize value..
\t\t\tif ((\$this->shrin_k * \$this->tbsqrt(\$tableheight / \$remainingpage, 1)) <= \$this->shrink_this_table_to_fit) {
\t\t\t\t\$recalculate = \$this->tbsqrt(\$tableheight / \$remainingpage, 1);
\t\t\t}
\t\t\telse if (!\$added_page) {
\t\t\t\tif (\$this->y != \$this->tMargin) {
\t\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t\t\$this->kwt_moved = true;
\t\t\t\t}
\t\t\t\t\$added_page = true;
\t\t\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 5) - \$this->kwt_height;
\t\t\t\t// 0.001 to force it to recalculate
\t\t\t\t\$recalculate = (1 / \$this->shrin_k) + 0.001; \t// undo any shrink
\t\t\t}
\t\t}
\t\telse { \$recalculate = 1; }
\t  }
\t  else if (\$this->table_keep_together || (\$this->table[1][1]['nr']==1 && !\$this->writingHTMLfooter)) {
\t\tif (\$tableheight > \$fullpage) {
\t\t\tif ((\$this->shrin_k * \$this->tbsqrt(\$tableheight / \$fullpage, 1)) <= \$this->shrink_this_table_to_fit) {
\t\t\t\t\$recalculate = \$this->tbsqrt(\$tableheight / \$fullpage, 1);
\t\t\t}
\t\t\telse if (\$this->tableMinSizePriority) {
\t\t\t\t\$this->table_keep_together = false;
\t\t\t\t\$recalculate = 1.001;
\t\t\t}
\t\t\telse {
\t\t\t\tif (\$this->y != \$this->tMargin) {\t// mPDF 5.1
\t\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t\t\$this->kwt_moved = true;
\t\t\t\t}
\t\t\t\t\$added_page = true;
\t\t\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 5) - \$this->kwt_height;
\t\t\t\t\$recalculate = \$this->tbsqrt(\$tableheight / \$fullpage, 1);
\t\t\t}
\t\t}
\t\telse if (\$tableheight > \$remainingpage) {
\t\t\t// If can fit on remainder of page whilst respecting autsize value..
\t\t\tif ((\$this->shrin_k * \$this->tbsqrt(\$tableheight / \$remainingpage, 1)) <= \$this->shrink_this_table_to_fit) {
\t\t\t\t\$recalculate = \$this->tbsqrt(\$tableheight / \$remainingpage, 1);
\t\t\t}
\t\t\telse {
\t\t\t\tif (\$this->y != \$this->tMargin) {
\t\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t\t\$this->kwt_moved = true;
\t\t\t\t}
\t\t\t\t\$added_page = true;
\t\t\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 5) - \$this->kwt_height;
\t\t\t\t\$recalculate = 1.001;
\t\t\t}
\t\t}
\t\telse { \$recalculate = 1; }
\t  }
\t  else { \$recalculate = 1; }

\t  if (\$recalculate > \$this->shrink_this_table_to_fit && !\$forcerecalc) { \$recalculate = \$this->shrink_this_table_to_fit; }

\t  \$iteration = 1;

\t  // RECALCULATE
\t  while(\$recalculate <> 1) {
\t\t\$this->shrin_k1 = \$recalculate ;
\t\t\$this->shrin_k *= \$recalculate ;
 \t\t\$this->default_font_size /= (\$this->shrin_k1) ;
\t\t\$this->SetFontSize(\$this->default_font_size, false );
\t\t\$this->SetLineHeight('',\$this->table_lineheight);
\t\t\$this->table = \$save_table;
\t\tif (\$this->cacheTables) { \$this->_restoreCacheFiles(); }
\t\tif (\$this->shrin_k <> 1) { \$this->shrinkTable(\$this->table[1][1],\$this->shrin_k); }
\t\t\$this->_tableColumnWidth(\$this->table[1][1],false);\t// repeat

\t\t// Starting at \$this->innermostTableLevel
\t\t// Shrink table values - and redo columnWidth
\t\tfor(\$lvl=2;\$lvl<=\$this->innermostTableLevel;\$lvl++) {
\t\t\tfor (\$nid=1; \$nid<=\$this->tbctr[\$lvl]; \$nid++) {
\t\t\t\tif (\$this->shrin_k <> 1) { \$this->shrinkTable(\$this->table[\$lvl][\$nid],\$this->shrin_k); }
\t\t\t\t\$this->_tableColumnWidth(\$this->table[\$lvl][\$nid],false);
\t\t\t}
\t\t}
\t\t// Set table cell widths for top level table

\t\t// Top level table
\t\t\$this->_tableWidth(\$this->table[1][1]);

\t\t// Now work through any nested tables setting child table[w'] = parent cell['w']
\t\t// Now do nested tables _tableWidth
\t\tfor(\$lvl=2;\$lvl<=\$this->innermostTableLevel;\$lvl++) {
\t\t\tfor (\$nid=1; \$nid<=\$this->tbctr[\$lvl]; \$nid++) {
\t\t\t\t// HERE set child table width = cell width

\t\t\t\tlist(\$parentrow, \$parentcol, \$parentnid) = \$this->table[\$lvl][\$nid]['nestedpos'];
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$c = \$this->_uncacheCell(\$this->table[(\$lvl-1)][\$parentnid]['cells'][\$parentrow][\$parentcol], \$this->table[(\$lvl-1)][\$parentnid]['cache'], null);
\t\t\t\t}
\t\t\t\telse
\t\t\t\t\t\$c =& \$this->table[(\$lvl-1)][\$parentnid]['cells'][\$parentrow][\$parentcol];

\t\t\t\tif (isset(\$c['colspan']) && \$c['colspan']> 1) {
\t\t\t\t   \$parentwidth = 0;
\t\t\t\t   for(\$cs=0;\$cs<\$c['colspan'] ; \$cs++) {
\t\t\t\t\t\$parentwidth += \$this->table[(\$lvl-1)][\$parentnid]['wc'][\$parentcol+\$cs];
\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse { \$parentwidth = \$this->table[(\$lvl-1)][\$parentnid]['wc'][\$parentcol]; }

\t\t\t\t//\$parentwidth -= ALLOW FOR PADDING ETC.in parent cell
\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t if (\$this->packTableData) {
\t\t\t\t \tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$c['borderbin']);
\t\t\t\t }
\t\t\t\t else {
\t\t\t\t\t\$br = \$c['border_details']['R']['w'];
\t\t\t\t\t\$bl = \$c['border_details']['L']['w'];
\t\t\t\t }
\t\t\t\t if (\$this->table[\$lvl-1][\$parentnid]['borders_separate']) {
\t\t\t\t  \$parentwidth -= \$br + \$bl
\t\t\t\t\t+ \$c['padding']['L']
\t\t\t\t\t+ \$c['padding']['R']
\t\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['border_spacing_H'];
\t\t\t\t }
\t\t\t\t else {
\t\t\t\t  \$parentwidth -= \$br/2 + \$bl/2
\t\t\t\t\t+ \$c['padding']['L']
\t\t\t\t\t+ \$c['padding']['R'];
\t\t\t\t }
\t\t\t\t}
\t\t\t\telse if (\$this->simpleTables){
\t\t\t\t if (\$this->table[\$lvl-1][\$parentnid]['borders_separate']) {
\t\t\t\t  \$parentwidth -= \$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['L']['w']
\t\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['R']['w']
\t\t\t\t\t+ \$c['padding']['L']
\t\t\t\t\t+ \$c['padding']['R']
\t\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['border_spacing_H'];
\t\t\t\t }
\t\t\t\t else {
\t\t\t\t  \$parentwidth -= (\$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['L']['w']
\t\t\t\t\t+ \$this->table[(\$lvl-1)][\$parentnid]['simple']['border_details']['R']['w']) /2
\t\t\t\t\t+ \$c['padding']['L']
\t\t\t\t\t+ \$c['padding']['R'];
\t\t\t\t }
\t\t\t\t}
\t\t\t\tif (isset(\$this->table[\$lvl][\$nid]['wpercent']) && \$this->table[\$lvl][\$nid]['wpercent'] && \$lvl>1) {
\t\t\t\t\t\$this->table[\$lvl][\$nid]['w'] = \$parentwidth;
\t\t\t\t}
\t\t\t\telse if (\$parentwidth > \$this->table[\$lvl][\$nid]['maw']) {
\t\t\t\t\t\$this->table[\$lvl][\$nid]['w'] = \$this->table[\$lvl][\$nid]['maw'] ;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$this->table[\$lvl][\$nid]['w'] = \$parentwidth;
\t\t\t\t}
\t\t\t\tunset(\$c);
\t\t\t\t\$this->_tableWidth(\$this->table[\$lvl][\$nid]);
\t\t\t}
\t\t}

\t\t// Starting at \$this->innermostTableLevel
\t\t// Cascade back up nested tables: setting heights back up the tree
\t\tfor(\$lvl=\$this->innermostTableLevel;\$lvl>0;\$lvl--) {
\t\t\tfor (\$nid=1; \$nid<=\$this->tbctr[\$lvl]; \$nid++) {
\t\t\t\tlist(\$tableheight,\$maxrowheight,\$fullpage,\$remainingpage, \$maxfirstrowheight) = \$this->_tableHeight(\$this->table[\$lvl][\$nid]);\t\t\t}
\t\t}

\t\t// RESIZING ALGORITHM

\t\tif (\$maxrowheight > \$fullpage) { \$recalculate = \$this->tbsqrt(\$maxrowheight / \$fullpage, \$iteration); \$iteration++; }
\t\telse if (\$this->table_rotate && \$tableheight > \$remainingpage && !\$added_page) {
\t\t\t// If can fit on remainder of page whilst respecting autosize value..
\t\t\tif ((\$this->shrin_k * \$this->tbsqrt(\$tableheight / \$remainingpage, \$iteration)) <= \$this->shrink_this_table_to_fit) {
\t\t\t\t\$recalculate = \$this->tbsqrt(\$tableheight / \$remainingpage, \$iteration); \$iteration++;
\t\t\t}
\t\t\telse {
\t\t\t\tif (!\$added_page) {
\t\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t\t\$added_page = true;
\t\t\t\t\t\$this->kwt_moved = true;
\t\t\t\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 5) - \$this->kwt_height;
\t\t\t\t}
\t\t\t\t// 0.001 to force it to recalculate
\t\t\t\t\$recalculate = (1 / \$this->shrin_k) + 0.001; \t// undo any shrink
\t\t\t}
\t\t}
\t\telse if (\$this->table_keep_together || (\$this->table[1][1]['nr']==1 && !\$this->writingHTMLfooter)) {
\t\t\tif (\$tableheight > \$fullpage) {
\t\t\t\tif ((\$this->shrin_k * \$this->tbsqrt(\$tableheight / \$fullpage, \$iteration)) <= \$this->shrink_this_table_to_fit) {
\t\t\t\t\t\$recalculate = \$this->tbsqrt(\$tableheight / \$fullpage, \$iteration); \$iteration++;
\t\t\t\t}
\t\t\t\telse if (\$this->tableMinSizePriority) {
\t\t\t\t\t\$this->table_keep_together = false;
\t\t\t\t\t\$recalculate = (1 / \$this->shrin_k) + 0.001;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t   if (!\$added_page && \$this->y != \$this->tMargin) {
\t\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t\t\$added_page = true;
\t\t\t\t\t\$this->kwt_moved = true;
\t\t\t\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 5) - \$this->kwt_height;
\t\t\t\t   }
\t\t\t\t   \$recalculate = \$this->tbsqrt(\$tableheight / \$fullpage, \$iteration); \$iteration++;
\t\t\t\t}
\t\t\t}
\t\t\telse if (\$tableheight > \$remainingpage) {
\t\t\t\t// If can fit on remainder of page whilst respecting autosize value..
\t\t\t\tif ((\$this->shrin_k * \$this->tbsqrt(\$tableheight / \$remainingpage, \$iteration)) <= \$this->shrink_this_table_to_fit) {
\t\t\t\t\t\$recalculate = \$this->tbsqrt(\$tableheight / \$remainingpage, \$iteration);  \$iteration++;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\tif (!\$added_page) {
\t\t\t\t\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\t\t\t\t\$added_page = true;
\t\t\t\t\t\t\$this->kwt_moved = true;
\t\t\t\t\t\t\$this->tbrot_maxw = \$this->h - (\$this->y + \$this->bMargin + 5) - \$this->kwt_height;
\t\t\t\t\t}

\t\t\t\t\t//\$recalculate = \$this->tbsqrt(\$tableheight / \$fullpage, \$iteration); \$iteration++;
\t\t\t\t\t\$recalculate = (1 / \$this->shrin_k) + 0.001; \t// undo any shrink
\t\t\t\t}
\t\t\t}
\t\t\telse { \$recalculate = 1; }
\t\t}
\t\telse { \$recalculate = 1; }
\t  }


\t  if (\$maxfirstrowheight > \$remainingpage && !\$added_page && !\$this->table_rotate && !\$this->ColActive && !\$this->table_keep_together && !\$this->writingHTMLheader && !\$this->writingHTMLfooter) {
\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\$this->kwt_moved = true;
\t  }

\t  // keep-with-table: if page has advanced, print out buffer now, else done in fn. _Tablewrite()
\t  if (\$this->kwt_saved && \$this->kwt_moved) {
\t\t\$this->printkwtbuffer();
\t\t\$this->kwt_moved = false;
\t\t\$this->kwt_saved = false;
\t  }

\t  if (\$this->progressBar) { \$this->UpdateProgressBar(7,30,' '); }\t// *PROGRESS-BAR*
\t  // Recursively writes all tables starting at top level
\t  \$this->_tableWrite(\$this->table[1][1]);

\t  if (\$this->table_rotate && \$this->tablebuffer) {
\t\t\$this->PageBreakTrigger=\$this->h-\$this->bMargin;
\t\t\$save_tr = \$this->table_rotate;
\t\t\$save_y = \$this->y;
\t\t\$this->table_rotate = 0;
\t\t\$this->y = \$this->tbrot_y0;
\t\t\$h = \t\$this->tbrot_w;
\t\t\$this->DivLn(\$h,\$this->blklvl,true);

\t\t\$this->table_rotate = \$save_tr;
\t\t\$this->y = \$save_y;

\t\t\$this->printtablebuffer();
\t  }
\t  \$this->table_rotate = 0;
\t}


\t\$this->x = \$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'];

\t\$this->maxPosR = max(\$this->maxPosR , (\$this->x + \$this->table[1][1]['w']));

\t\$this->blockjustfinished=true;
\t\$this->lastblockbottommargin = \$this->table[1][1]['margin']['B'];
\t//Reset values

\tif (isset(\$this->table[1][1]['page_break_after'])) { \$page_break_after = \$this->table[1][1]['page_break_after']; }
\telse { \$page_break_after = ''; }

\t// Keep-with-table
\t\$this->kwt = false;
\t\$this->kwt_y0 = 0;
\t\$this->kwt_x0 = 0;
\t\$this->kwt_height = 0;
\t\$this->kwt_buffer = array();
\t\$this->kwt_Links = array();
\t\$this->kwt_Annots = array();
\t\$this->kwt_moved = false;
\t\$this->kwt_saved = false;

\t\$this->kwt_Reference = array();
\t\$this->kwt_BMoutlines = array();
\t\$this->kwt_toc = array();

\t\$this->shrin_k = 1;
\t\$this->shrink_this_table_to_fit = 0;

\tunset(\$this->table);
\t\$this->table=array(); //array
\t\$this->tableLevel=0;
\t\$this->tbctr=array();
\t\$this->innermostTableLevel=0;
\t\$this->cssmgr->tbCSSlvl = 0;
\t\$this->cssmgr->tablecascadeCSS = array();

\tunset(\$this->cell);
\t\$this->cell=array(); //array

\t\$this->col=-1; //int
\t\$this->row=-1; //int
\t\$this->Reset();

 \t\$this->cellPaddingL = 0;
 \t\$this->cellPaddingT = 0;
 \t\$this->cellPaddingR = 0;
 \t\$this->cellPaddingB = 0;
 \t\$this->cMarginL = 0;
 \t\$this->cMarginT = 0;
 \t\$this->cMarginR = 0;
 \t\$this->cMarginB = 0;
 \t\$this->default_font_size = \$this->original_default_font_size;
\t\$this->default_font = \$this->original_default_font;
   \t\$this->SetFontSize(\$this->default_font_size, false);
\t\$this->SetFont(\$this->default_font,'',0,false);
\t\$this->SetLineHeight();
\tif (isset(\$this->blk[\$this->blklvl]['InlineProperties'])) { \$this->restoreInlineProperties(\$this->blk[\$this->blklvl]['InlineProperties']);}
\tif (\$this->progressBar) { \$this->UpdateProgressBar(7,100,' '); }\t// *PROGRESS-BAR*

\tif (\$page_break_after) {
\t\t\$save_blklvl = \$this->blklvl;
\t\t\$save_blk = \$this->blk;
\t\t\$save_silp = \$this->saveInlineProperties();
\t\t\$save_ilp = \$this->InlineProperties;
\t\tif (\$this->blklvl>1) {
\t\t\t// Close any open block tags
\t\t\tfor (\$b= \$this->blklvl;\$b>0;\$b--) { \$this->CloseTag(\$this->blk[\$b]['tag']); }
\t\t\t// Output any text left in buffer
\t\t\tif (count(\$this->textbuffer)) { \$this->printbuffer(\$this->textbuffer); \$this->textbuffer=array(); }
\t\t}
/*-- COLUMNS --*/
\t\t\$save_cols = false;
\t\tif (\$this->ColActive) {
\t\t\t\$save_cols = true;
\t\t\t\$save_nbcol = \$this->NbCol;\t// other values of gap and vAlign will not change by setting Columns off
\t\t\t\$this->SetColumns(0);
\t\t}
/*-- END COLUMNS --*/
\t\tif (\$page_break_after == 'RIGHT') { \$this->AddPage(\$this->CurOrientation,'NEXT-ODD','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\telse if (\$page_break_after == 'LEFT') { \$this->AddPage(\$this->CurOrientation,'NEXT-EVEN','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\telse { \$this->AddPage(\$this->CurOrientation,'','','','','','', '','', '','','','','','',0,0,0,0,\$pagesel); }
\t\tif (!\$this->restoreBlockPagebreaks) {
\t\t\t\$this->blklvl = 0;
\t\t\t\$this->lastblocklevelchange = 0;
\t\t\t\$this->blk = array();
\t\t\t\$this->initialiseBlock(\$this->blk[0]);
\t\t\t\$this->blk[0]['width'] =& \$this->pgwidth;
\t\t\t\$this->blk[0]['inner_width'] =& \$this->pgwidth;
\t\t\t\$this->blk[0]['blockContext'] = \$this->blockContext;
\t\t\t\$properties = \$this->cssmgr->MergeCSS('BLOCK','BODY','');
\t\t\t\$this->setCSS(\$properties,'','BODY');
\t\t}

/*-- COLUMNS --*/
\t\tif (\$save_cols) {
\t\t\t// Restore columns
\t\t\t\$this->SetColumns(\$save_nbcol,\$this->colvAlign,\$this->ColGap);
\t\t}
/*-- END COLUMNS --*/
\t\tif (\$this->restoreBlockPagebreaks) {
\t\t\t\$this->blk = \$save_blk;
\t\t\t// Re-open block tags
\t\t\t\$t = \$this->blk[0]['tag'];
\t\t\t\$a = \$this->blk[0]['attr'];
\t\t\t\$this->blklvl = 0;
\t\t\tfor (\$b=0; \$b<=\$save_blklvl;\$b++) {
\t\t\t\t\$tc = \$t;
\t\t\t\t\$ac = \$a;
\t\t\t\t\$t = \$this->blk[\$b+1]['tag'];
\t\t\t\t\$a = \$this->blk[\$b+1]['attr'];
\t\t\t\tunset(\$this->blk[\$b+1]);
\t\t\t\t\$this->OpenTag(\$tc,\$ac);
\t\t\t}
\t\t\t\$this->InlineProperties = \$save_ilp;
\t\t\t\$this->restoreInlineProperties(\$save_silp);
\t\t}
\t}

    }
/*-- END TABLES --*/

/*-- LISTS --*/
\t// *********** LISTS ********************

    if(\$tag=='LI') {
\t\$this->lastoptionaltag = '';
\tunset(\$this->cssmgr->listcascadeCSS[\$this->cssmgr->listCSSlvl]);
\t\$this->cssmgr->listCSSlvl--;
\tif (isset(\$this->listoccur[\$this->listlvl]) && isset(\$this->InlineProperties['LIST'][\$this->listlvl][\$this->listoccur[\$this->listlvl]])) { \$this->restoreInlineProperties(\$this->InlineProperties['LIST'][\$this->listlvl][\$this->listoccur[\$this->listlvl]]); }
    }


    if((\$tag=='UL') or (\$tag=='OL')) {
      \$this->ignorefollowingspaces = true; //Eliminate exceeding left-side spaces
\tunset(\$this->cssmgr->listcascadeCSS[\$this->cssmgr->listCSSlvl]);
\t\$this->cssmgr->listCSSlvl--;

\t\$this->lastoptionaltag = '';
/*-- TABLES --*/
\t// A simple list for inside a table
\tif(\$this->tableLevel) {
\t\t\$this->listlist[\$this->listlvl]['MAXNUM'] = \$this->listnum; //save previous lvl's maxnum
\t\tunset(\$this->listlist[\$this->listlvl]);
\t\t\$this->listlvl--;
\t\tif (isset(\$this->listlist[\$this->listlvl]['MAXNUM'])) { \$this->listnum = \$this->listlist[\$this->listlvl]['MAXNUM']; } // restore previous levels
\t\tif (\$this->listlvl == 0) { \$this->listjustfinished = true; }
\t\treturn;
\t}
/*-- END TABLES --*/

\tif (\$this->listlvl > 1) { // returning one level
\t\t\$this->listjustfinished=true;
\t\tif (!empty(\$this->textbuffer)) {
\t\t\t\$this->listitem[] = array(\$this->listlvl,\$this->listnum,\$this->textbuffer,\$this->listoccur[\$this->listlvl],\$this->listitemtype);
\t\t}
\t\telse {
\t\t\t\$this->listnum--;
\t\t}

\t\t\$this->textbuffer = array();
\t\t\$occur = \$this->listoccur[\$this->listlvl];
\t\t\$this->listlist[\$this->listlvl][\$occur]['MAXNUM'] = \$this->listnum; //save previous lvl's maxnum
\t\t\$this->listlvl--;
\t\t\$occur = \$this->listoccur[\$this->listlvl];
\t\t\$this->listnum = \$this->listlist[\$this->listlvl][\$occur]['MAXNUM']; // recover previous level's number
\t\t\$this->listtype = \$this->listlist[\$this->listlvl][\$occur]['TYPE']; // recover previous level's type
\t\tif (\$this->InlineProperties['LIST'][\$this->listlvl][\$occur]) { \$this->restoreInlineProperties(\$this->InlineProperties['LIST'][\$this->listlvl][\$occur]); }

\t}
\telse { // We are closing the last OL/UL tag
\t\tif (!empty(\$this->textbuffer)) {
\t\t\t\$this->listitem[] = array(\$this->listlvl,\$this->listnum,\$this->textbuffer,\$this->listoccur[\$this->listlvl],\$this->listitemtype);
\t\t}
\t\telse {
\t\t\t\$this->listnum--;
\t\t}

\t\t\$occur = \$this->listoccur[\$this->listlvl];
\t\t\$this->listlist[\$this->listlvl][\$occur]['MAXNUM'] = \$this->listnum;
\t\t\$this->textbuffer = array();
\t\t\$this->listlvl--;

\t\t\$this->printlistbuffer();
\t\tunset(\$this->InlineProperties['LIST']);
\t\t// SPACING AFTER LIST (Top level only)
\t\t\$this->Ln(0);
\t\tif (\$this->list_margin_bottom) {
\t\t\t\$this->DivLn(\$this->list_margin_bottom,\$this->blklvl,true,1); \t// collapsible
\t\t}
\t\tif (isset(\$this->blk[\$this->blklvl]['InlineProperties'])) { \$this->restoreInlineProperties(\$this->blk[\$this->blklvl]['InlineProperties']);}
\t\t\$this->listjustfinished = true;
\t\t\$this->cssmgr->listCSSlvl = 0;
\t\t\$this->cssmgr->listcascadeCSS = array();
\t\t\$this->blockjustfinished=true;
\t\t\$this->lastblockbottommargin = \$this->list_margin_bottom;
\t}
    }
/*-- END LISTS --*/


}


/*-- TABLES --*/
// This function determines the shrink factor when resizing tables
// val is the table_height / page_height_available
// returns a scaling factor used as \$shrin_k to resize the table
// Overcompensating will be quicker but may unnecessarily shrink table too much
// Undercompensating means it will reiterate more times (taking more processing time)
function tbsqrt(\$val, \$iteration=3) {
\t\$k = 4;\t// Alters number of iterations until it returns \$val itself - Must be > 2
\t// Probably best guess and most accurate
\tif (\$iteration==1) return sqrt(\$val);
\t// Faster than using sqrt (because it won't undercompensate), and gives reasonable results
\t//return 1+((\$val-1)/2);
\t\$x = 2-((\$iteration-2)/(\$k-2));
\tif (\$x == 0) { \$ret = \$val+0.00001; }
\telse if (\$x < 0) { \$ret = 1 + ( pow(2, (\$iteration-2-\$k))/1000   ); }
\telse { \$ret = 1+((\$val-1)/\$x); }
\treturn \$ret;
}
/*-- END TABLES --*/


/*-- LISTS --*/
function printlistbuffer() {
    //Save x coordinate
    \$x = \$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'];
    \$this->cMarginL = 0;
    \$this->cMarginR = 0;
    \$currIndentLvl = -1;
    \$lastIndent = array();
    \$bak_page = \$this->page;
    \$indent = 0;
    foreach(\$this->listitem as \$item)
    {
\t// COLS
\t\$oldcolumn = \$this->CurrCol;

\t\$this->bulletarray = array();
\t//Get list's buffered data
\t\$this->listlvl = \$lvl = \$item[0];
\t\$num = \$item[1];
\t\$this->textbuffer = \$item[2];
\t\$occur = \$item[3];
\tif (\$item[4]) { \$type = \$item[4]; }\t// listitemtype
\telse { \$type = \$this->listlist[\$lvl][\$occur]['TYPE']; }
\t\$maxnum = \$this->listlist[\$lvl][\$occur]['MAXNUM'];
\t\$this->restoreInlineProperties(\$this->InlineProperties['LIST'][\$lvl][\$occur]);
\t\$this->SetFont(\$this->FontFamily,\$this->FontStyle,\$this->FontSizePt,true,true);\t// force to write
\t\$clh = \$this->FontSize;

\t\$this->SetLineHeight(\$this->FontSizePt,\$this->list_lineheight[\$lvl][\$occur]);
\t\$this->listOcc = \$occur;
\t\$this->listnum = \$num;

\tif (isset(\$this->list_align[\$this->listlvl][\$occur])) { \$this->divalign = \$this->list_align[\$this->listlvl][\$occur]; }
\telse {
\t\tif (isset(\$this->blk[\$this->blklvl]['direction']) && \$this->blk[\$this->blklvl]['direction']=='rtl') { \$this->divalign = 'R'; }
\t\telse { \$this->divalign = 'L'; }
\t}

\t// Set the bullet fontsize
\t\$bullfs = \$this->InlineProperties['LISTITEM'][\$lvl][\$occur][\$num]['size'];

\t\$space_width = \$this->GetCharWidth(' ',false) * 1.5;

\t//Set default width & height values
\t\$this->divwidth = \$this->blk[\$this->blklvl]['inner_width'];
\t\$this->divheight = \$this->lineheight;
\t\$typefont = \$this->FontFamily;
\tif (preg_match('/U\\+([a-fA-F0-9]+)/i',\$type,\$m)) {
\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'],hexdec(\$m[1]))) { \$list_item_marker = codeHex2utf(\$m[1]); }
\t\telse { \$list_item_marker = '-'; }
\t\t\$blt_width = \$this->GetStringWidth(\$list_item_marker);
\t\t\$typefont = '';
\t\tif (preg_match('/rgb\\(.*?\\)/',\$type,\$m)) {
\t\t\t\$list_item_color = \$this->ConvertColor(\$m[0]);
\t\t}
\t}
\telse {
\t\t\$list_item_color = false;

\t  switch(\$type) //Format type
\t  {
          case '1':
\t\t  if (\$this->listDir == 'rtl') { \$list_item_marker = \$this->list_number_suffix . \$num; }
\t\t  else { \$list_item_marker = \$num . \$this->list_number_suffix; }
\t        \$blt_width = \$this->GetStringWidth(str_repeat('5',strlen(\$maxnum)).\$this->list_number_suffix);
              break;
          case 'none':
\t\t  \$list_item_marker = '';
  \t        \$blt_width = 0;
             break;
          case 'A':
\t\t  \$anum = \$this->dec2alpha(\$num,true);
\t\t  \$maxnum = \$this->dec2alpha(\$maxnum,true);
\t\t  if (\$this->listDir == 'rtl') { \$list_item_marker = \$this->list_number_suffix . \$anum; }
\t\t  else { \$list_item_marker = \$anum . \$this->list_number_suffix; }
  \t        \$blt_width = \$this->GetStringWidth(str_repeat('W',strlen(\$maxnum)).\$this->list_number_suffix);
             break;
          case 'a':
              \$anum = \$this->dec2alpha(\$num,false);
\t\t  \$maxnum = \$this->dec2alpha(\$maxnum,false);
\t\t  if (\$this->listDir == 'rtl') { \$list_item_marker = \$this->list_number_suffix . \$anum; }
\t\t  else { \$list_item_marker = \$anum . \$this->list_number_suffix; }
\t\t  \$blt_width = \$this->GetStringWidth(str_repeat('m',strlen(\$maxnum)).\$this->list_number_suffix);
             break;
          case 'I':
              \$anum = \$this->dec2roman(\$num,true);
\t\t  if (\$this->listDir == 'rtl') { \$list_item_marker = \$this->list_number_suffix . \$anum; }
\t\t  else { \$list_item_marker = \$anum . \$this->list_number_suffix; }

\t\t  if (\$maxnum>87) { \$bbit = 87; }
\t\t  else if (\$maxnum>86) { \$bbit = 86; }
\t\t  else if (\$maxnum>37) { \$bbit = 38; }
\t\t  else if (\$maxnum>36) { \$bbit = 37; }
\t\t  else if (\$maxnum>27) { \$bbit = 28; }
\t\t  else if (\$maxnum>26) { \$bbit = 27; }
\t\t  else if (\$maxnum>17) { \$bbit = 18; }
\t\t  else if (\$maxnum>16) { \$bbit = 17; }
\t\t  else if (\$maxnum>7) { \$bbit = 8; }
\t\t  else if (\$maxnum>6) { \$bbit = 7; }
\t\t  else if (\$maxnum>3) { \$bbit = 4; }
\t\t  else { \$bbit = \$maxnum; }
              \$maxlnum = \$this->dec2roman(\$bbit,true);
\t        \$blt_width = \$this->GetStringWidth(\$maxlnum.\$this->list_number_suffix);
              break;
          case 'i':
              \$anum = \$this->dec2roman(\$num,false);
\t\t  if (\$this->listDir == 'rtl') { \$list_item_marker = \$this->list_number_suffix . \$anum; }
\t\t  else { \$list_item_marker = \$anum . \$this->list_number_suffix; }

\t\t  if (\$maxnum>87) { \$bbit = 87; }
\t\t  else if (\$maxnum>86) { \$bbit = 86; }
\t\t  else if (\$maxnum>37) { \$bbit = 38; }
\t\t  else if (\$maxnum>36) { \$bbit = 37; }
\t\t  else if (\$maxnum>27) { \$bbit = 28; }
\t\t  else if (\$maxnum>26) { \$bbit = 27; }
\t\t  else if (\$maxnum>17) { \$bbit = 18; }
\t\t  else if (\$maxnum>16) { \$bbit = 17; }
\t\t  else if (\$maxnum>7) { \$bbit = 8; }
\t\t  else if (\$maxnum>6) { \$bbit = 7; }
\t\t  else if (\$maxnum>3) { \$bbit = 4; }
\t\t  else { \$bbit = \$maxnum; }
              \$maxlnum = \$this->dec2roman(\$bbit,false);

\t        \$blt_width = \$this->GetStringWidth(\$maxlnum.\$this->list_number_suffix);
              break;
          case 'disc':
\t\t  if (\$this->PDFA || \$this->PDFX) {
\t\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'],8226)) { \$list_item_marker = \"\\xe2\\x80\\xa2\"; } \t// &#8226;
\t\t\telse { \$list_item_marker = '-'; }
  \t\t\t\$blt_width = \$this->GetCharWidth(\$list_item_marker);
\t\t\tbreak;
\t\t  }
              \$list_item_marker = chr(108); // bullet disc in Zapfdingbats  'l'
\t\t  \$typefont = 'czapfdingbats';
\t\t  \$blt_width = (0.791 * \$this->FontSize/2.5);
              break;
          case 'circle':
\t\t  if (\$this->PDFA || \$this->PDFX) {
\t\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'],9900)) { \$list_item_marker = \"\\xe2\\x9a\\xac\"; } // &#9900;
\t\t\telse { \$list_item_marker = '-'; }
  \t\t\t\$blt_width = \$this->GetCharWidth(\$list_item_marker);
\t\t\tbreak;
\t\t  }
              \$list_item_marker = chr(109); // circle in Zapfdingbats   'm'
\t\t  \$typefont = 'czapfdingbats';
\t\t  \$blt_width = (0.873 * \$this->FontSize/2.5);
              break;
          case 'square':
\t\t  if (\$this->PDFA || \$this->PDFX) {
\t\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'],9642)) { \$list_item_marker = \"\\xe2\\x96\\xaa\"; } // &#9642;
\t\t\telse { \$list_item_marker = '-'; }
  \t\t\t\$blt_width = \$this->GetCharWidth(\$list_item_marker);
\t\t\tbreak;
\t\t  }
              \$list_item_marker = chr(110); //black square in Zapfdingbats font   'n'
\t\t  \$typefont = 'czapfdingbats';
\t\t  \$blt_width = (0.761 * \$this->FontSize/2.5);
              break;

/*  CSS3 list-styles numeric + I added tamil
arabic-indic | bengali | cambodian | devanagari | gujarati | gurmukhi | kannada | khmer | lao | malayalam | mongolian | myanmar | oriya | persian | telugu | tibetan | thai | urdu
*/
          case 'arabic-indic':
\t\t  \$cp = 0x0660;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$this->list_number_suffix . \$rnum; \t// RTL
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'persian':
          case 'urdu':
\t\t  \$cp = 0x06F0;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$this->list_number_suffix . \$rnum; \t// RTL
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'bengali':
\t\t  \$cp = 0x09E6;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'devanagari':
\t\t  \$cp = 0x0966;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'gujarati':
\t\t  \$cp = 0x0AE6;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'gurmukhi':
\t\t  \$cp = 0x0A66;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'kannada':
\t\t  \$cp = 0x0CE6;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'malayalam':
\t\t  \$cp = 0x0D66;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(6, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'oriya':
\t\t  \$cp = 0x0B66;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'telugu':
\t\t  \$cp = 0x0C66;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'tamil':
\t\t  \$cp = 0x0BE6;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(9, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'thai':
\t\t  \$cp = 0x0E50;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(5, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'khmer':
          case 'cambodian':
\t\t  \$cp = 0x17E0;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(3, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
          case 'lao':
\t\t  \$cp = 0x0ED0;
\t\t  \$rnum = \$this->dec2other(\$num, \$cp);
\t\t  \$list_item_marker = \$rnum . \$this->list_number_suffix;
  \t        \$blt_width = \$this->GetStringWidth(str_repeat(\$this->dec2other(6, \$cp),strlen(\$maxnum)).\$this->list_number_suffix);
\t\t  break;
\t    default:
\t\t  if (\$this->listDir == 'rtl') { \$list_item_marker = \$this->list_number_suffix . \$num; }
\t\t  else { \$list_item_marker = \$num . \$this->list_number_suffix; }
\t        \$blt_width = \$this->GetStringWidth(str_repeat('5',strlen(\$maxnum)).\$this->list_number_suffix);
              break;
\t  }
\t}

\tif (isset(\$item[5]) && \$item[5]) { \$list_item_marker = ''; }

\tif (\$currIndentLvl < \$lvl) {
\t\tif (\$lvl > 1 || \$this->list_indent_first_level) {
\t\t\t\$indent += \$this->list_indent[\$lvl][\$occur];
\t\t\t\$lastIndent[\$lvl] = \$this->list_indent[\$lvl][\$occur];
\t\t}
\t}
\telse if (\$currIndentLvl > \$lvl) {
\t    while (\$currIndentLvl > \$lvl) {
\t\t\$indent -= \$lastIndent[\$currIndentLvl];
\t\t\$currIndentLvl--;
\t    }
\t}
\t\$currIndentLvl = \$lvl;


/*-- RTL --*/

\tif (\$this->listDir == 'rtl') {
\t  // list_align_style  Determines alignment of numbers in numbered lists
\t  if (\$this->list_align_style == 'L') { \$lalign = 'R'; }
\t  else { \$lalign = 'L';  }
        \$this->divwidth = \$this->blk[\$this->blklvl]['width'] - (\$indent + \$blt_width + \$space_width) ;
        \$xb = \$this->blk[\$this->blklvl]['inner_width'] + \$this->blk[\$this->blklvl]['border_left']['w'] + \$this->blk[\$this->blklvl]['padding_left'] - \$indent - \$blt_width; //Bullet position (relative)
        //Output bullet
\t  \$this->bulletarray = array('w'=>\$blt_width,'h'=>\$clh,'txt'=>\$list_item_marker,'x'=>\$xb,'align'=>\$lalign,'font'=>\$typefont,'level'=>\$lvl, 'occur'=>\$occur, 'num'=>\$num, 'fontsize'=>\$bullfs, 'col'=>\$list_item_color );
\t  \$this->x = \$x;
\t}
\telse {
/*-- END RTL --*/

\t  if (\$this->list_align_style == 'L') { \$lalign = 'L'; }
\t  else { \$lalign = 'R';  }
        \$this->divwidth = \$this->blk[\$this->blklvl]['width'] - (\$indent + \$blt_width + \$space_width) ;
\t  \$xb =  \$this->blk[\$this->blklvl]['padding_left'] + \$this->blk[\$this->blklvl]['border_left']['w'] - \$blt_width - \$space_width;
        //Output bullet
\t  \$this->bulletarray = array('w'=>\$blt_width,'h'=>\$clh,'txt'=>\$list_item_marker,'x'=>\$xb,'align'=>\$lalign,'font'=>\$typefont,'level'=>\$lvl, 'occur'=>\$occur, 'num'=>\$num, 'fontsize'=>\$bullfs, 'col'=>\$list_item_color );
\t  \$this->x = \$x + \$indent + \$blt_width + \$space_width;
\t}\t// *RTL*

      //Print content
  \t\$this->printbuffer(\$this->textbuffer,'',false,true);
      \$this->textbuffer=array();

\t// Added to correct for OddEven Margins
   \tif  (\$this->page != \$bak_page) {
\t\tif ((\$this->page-\$bak_page) % 2 == 1) {
\t\t\t\$x += \$this->MarginCorrection;
\t\t}
\t\t\$bak_page = \$this->page;
\t}
/*-- COLUMNS --*/
\t// OR COLUMN CHANGE
\tif (\$this->CurrCol != \$oldcolumn) {
\t\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\t\$x -= (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);\t// *RTL*
\t\t}\t// *RTL*
\t\telse {\t// *RTL*
\t\t\t\$x += (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);
\t\t}\t// *RTL*
\t\t\$oldcolumn = \$this->CurrCol;
\t}
/*-- END COLUMNS --*/

    }

    //Reset all used values
    \$this->listoccur = array();
    \$this->listitem = array();
    \$this->listlist = array();
    \$this->listlvl = 0;
    \$this->listnum = 0;
    \$this->listtype = '';
    \$this->textbuffer = array();
    \$this->divwidth = 0;
    \$this->divheight = 0;
    \$this->x = \$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'];
}
/*-- END LISTS --*/

function _saveTextBuffer(\$t, \$link = '', \$intlink = '') {
//\t\$this->textbuffer[] = array(\$t,\$link,\$this->currentfontstyle,\$this->colorarray,\$this->currentfontfamily,\$this->SUP,\$this->SUB,\$intlink,\$this->strike,\$this->textparam,\$this->spanbgcolorarray,\$this->currentfontsize,\$this->ReqFontStyle,\$this->kerning,\$this->lSpacingCSS,\$this->wSpacingCSS,\$this->spanborddet, \$this->textshadow);
\t// mPDF 5.6.14
\t\$arr = array();
\t\$arr[0] = \$t;
\tif (isset(\$link) && \$link) \$arr[1] = \$link;
\t\$arr[2] = \$this->currentfontstyle;
\tif (isset(\$this->colorarray) && \$this->colorarray) \$arr[3] = \$this->colorarray;
\t\$arr[4] = \$this->currentfontfamily;
\tif (isset(\$this->SUP) && \$this->SUP) \$arr[5] = \$this->SUP;
\tif (isset(\$this->SUB) && \$this->SUB) \$arr[6] = \$this->SUB;
\tif (isset(\$intlink) && \$intlink) \$arr[7] = \$intlink;
\tif (isset(\$this->strike) && \$this->strike) \$arr[8] = \$this->strike;
\tif (isset(\$this->textparam) && \$this->textparam) \$arr[9] = \$this->textparam;
\tif (isset(\$this->spanbgcolorarray) && \$this->spanbgcolorarray) \$arr[10] = \$this->spanbgcolorarray;
\t\$arr[11] = \$this->currentfontsize;
\tif (isset(\$this->ReqFontStyle) && \$this->ReqFontStyle) \$arr[12] = \$this->ReqFontStyle;
\tif (isset(\$this->kerning) && \$this->kerning) \$arr[13] = \$this->kerning;
\tif (isset(\$this->lSpacingCSS) && \$this->lSpacingCSS) \$arr[14] = \$this->lSpacingCSS;
\tif (isset(\$this->wSpacingCSS) && \$this->wSpacingCSS) \$arr[15] = \$this->wSpacingCSS;
\tif (isset(\$this->spanborddet) && \$this->spanborddet) \$arr[16] = \$this->spanborddet;
\tif (isset(\$this->textshadow) && \$this->textshadow) \$arr[17] = \$this->textshadow;
\t\$this->textbuffer[] = \$arr;
}

function _saveCellTextBuffer(\$t, \$link = '', \$intlink = '') {
//\t \$this->cell[\$this->row][\$this->col]['textbuffer'][] = array(\$t,\$link,\$this->currentfontstyle,\$this->colorarray,\$this->currentfontfamily,\$this->SUP,\$this->SUB,\$intlink,\$this->strike,\$this->textparam,\$this->spanbgcolorarray,\$this->currentfontsize,\$this->ReqFontStyle,\$this->kerning,\$this->lSpacingCSS,\$this->wSpacingCSS,\$this->spanborddet, \$this->textshadow);
\t// mPDF 5.6.14
\t\$arr = array();
\t\$arr[0] = \$t;
\tif (isset(\$link) && \$link) \$arr[1] = \$link;
\t\$arr[2] = \$this->currentfontstyle;
\tif (isset(\$this->colorarray) && \$this->colorarray) \$arr[3] = \$this->colorarray;
\t\$arr[4] = \$this->currentfontfamily;
\tif (isset(\$this->SUP) && \$this->SUP) \$arr[5] = \$this->SUP;
\tif (isset(\$this->SUB) && \$this->SUB) \$arr[6] = \$this->SUB;
\tif (isset(\$intlink) && \$intlink) \$arr[7] = \$intlink;
\tif (isset(\$this->strike) && \$this->strike) \$arr[8] = \$this->strike;
\tif (isset(\$this->textparam) && \$this->textparam) \$arr[9] = \$this->textparam;
\tif (isset(\$this->spanbgcolorarray) && \$this->spanbgcolorarray) \$arr[10] = \$this->spanbgcolorarray;
\t\$arr[11] = \$this->currentfontsize;
\tif (isset(\$this->ReqFontStyle) && \$this->ReqFontStyle) \$arr[12] = \$this->ReqFontStyle;
\tif (isset(\$this->kerning) && \$this->kerning) \$arr[13] = \$this->kerning;
\tif (isset(\$this->lSpacingCSS) && \$this->lSpacingCSS) \$arr[14] = \$this->lSpacingCSS;
\tif (isset(\$this->wSpacingCSS) && \$this->wSpacingCSS) \$arr[15] = \$this->wSpacingCSS;
\tif (isset(\$this->spanborddet) && \$this->spanborddet) \$arr[16] = \$this->spanborddet;
\tif (isset(\$this->textshadow) && \$this->textshadow) \$arr[17] = \$this->textshadow;
\t\$this->cell[\$this->row][\$this->col]['textbuffer'][] = \$arr;
}


function printbuffer(\$arrayaux,\$blockstate=0,\$is_table=false,\$is_list=false)
{
// \$blockstate = 0;\t// NO margins/padding
// \$blockstate = 1;\t// Top margins/padding only
// \$blockstate = 2;\t// Bottom margins/padding only
// \$blockstate = 3;\t// Top & bottom margins/padding
\t\$this->spanbgcolorarray = '';
\t\$this->spanbgcolor = false;
\t\$this->spanborder = false;
\t\$this->spanborddet = array();
\t\$paint_ht_corr = 0;

/*-- CSS-FLOAT --*/
\tif (count(\$this->floatDivs)) {
\t\tlist(\$l_exists, \$r_exists, \$l_max, \$r_max, \$l_width, \$r_width) = \$this->GetFloatDivInfo(\$this->blklvl);
\t\tif ((\$this->blk[\$this->blklvl]['inner_width']-\$l_width-\$r_width) < (2*\$this->GetCharWidth('W',false))) {
\t\t\t// Too narrow to fit - try to move down past L or R float
\t\t\tif (\$l_max < \$r_max && (\$this->blk[\$this->blklvl]['inner_width']-\$r_width) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('LEFT', \$this->blklvl);
\t\t\t}
\t\t\telse if (\$r_max < \$l_max && (\$this->blk[\$this->blklvl]['inner_width']-\$l_width) > (2*\$this->GetCharWidth('W',false))) {
\t\t\t\t\$this->ClearFloats('RIGHT', \$this->blklvl);
\t\t\t}
\t\t\telse { \$this->ClearFloats('BOTH', \$this->blklvl); }
\t\t}
\t}
/*-- END CSS-FLOAT --*/
    \t\$bak_y = \$this->y;
\t\$bak_x = \$this->x;
\t\$align = '';
\tif (!\$is_table && !\$is_list) {
\t\tif (isset(\$this->blk[\$this->blklvl]['align']) && \$this->blk[\$this->blklvl]['align']) { \$align = \$this->blk[\$this->blklvl]['align']; }
\t\t// Block-align is set by e.g. <.. align=\"center\"> Takes priority for this block but not inherited
\t\tif (isset(\$this->blk[\$this->blklvl]['block-align']) && \$this->blk[\$this->blklvl]['block-align']) { \$align = \$this->blk[\$this->blklvl]['block-align']; }
\t\tif (isset(\$this->blk[\$this->blklvl]['direction'])) \$blockdir = \$this->blk[\$this->blklvl]['direction'];
\t\telse \$blockdir = \"\";
\t\t\$this->divwidth = \$this->blk[\$this->blklvl]['width'];
\t}
\telse {
\t\t\$align = \$this->divalign;
\t\tif (\$is_table) { \$blockdir = \$this->table[\$this->tableLevel][\$this->tbctr[\$this->tableLevel]]['direction']; }
\t\telse { \$blockdir = \$this->listDir; }
\t}
\t\$oldpage = \$this->page;

\t// ADDED for Out of Block now done as Flowing Block
\tif (\$this->divwidth == 0) {
\t\t\$this->divwidth = \$this->pgwidth;
\t}

\tif (!\$is_table && !\$is_list) { \$this->SetLineHeight(\$this->FontSizePt,\$this->blk[\$this->blklvl]['line_height']); }
\t\$this->divheight = \$this->lineheight;
\t\$old_height = \$this->divheight;

    // As a failsafe - if font has been set but not output to page
    \$this->SetFont(\$this->default_font,'',\$this->default_font_size,true,true);\t// force output to page

    \$array_size = count(\$arrayaux);
    \$this->newFlowingBlock( \$this->divwidth,\$this->divheight,\$align,\$is_table,\$is_list,\$blockstate,true,\$blockdir);

\t// Added - Otherwise <div><div><p> did not output top margins/padding for 1st/2nd div
    if (\$array_size == 0) { \$this->finishFlowingBlock(true); }\t// true = END of flowing block

    for(\$i=0;\$i < \$array_size; \$i++)
    {
\t// COLS
\t\$oldcolumn = \$this->CurrCol;

\t\$vetor = \$arrayaux[\$i];
\tif (\$i == 0 and \$vetor[0] != \"\\n\" and !\$this->ispre) {
\t\t\$vetor[0] = ltrim(\$vetor[0]);
\t}

\t// FIXED TO ALLOW IT TO SHOW '0'
\tif (empty(\$vetor[0]) && !(\$vetor[0]==='0') && empty(\$vetor[7])) { //Ignore empty text and not carrying an internal link
\t\t//Check if it is the last element. If so then finish printing the block
\t     \tif (\$i == (\$array_size-1)) { \$this->finishFlowingBlock(true); }\t// true = END of flowing block
\t\tcontinue;
\t}


\t//Activating buffer properties
\tif(isset(\$vetor[11]) and \$vetor[11] != '') { \t // Font Size
\t\tif (\$is_table && \$this->shrin_k) {
\t\t\t\$this->SetFontSize(\$vetor[11]/\$this->shrin_k,false);
\t\t}
\t\telse {
\t\t\t\$this->SetFontSize(\$vetor[11],false);
\t\t}
\t}

\tif(isset(\$vetor[17]) && !empty(\$vetor[17])) { //TextShadow
\t\t\$this->textshadow = \$vetor[17];
\t}
\tif(isset(\$vetor[16]) && !empty(\$vetor[16])) { //Border
\t\t\$this->spanborddet = \$vetor[16];
\t\t\$this->spanborder = true;
\t}

\tif(isset(\$vetor[15])) { \t // Word spacing
\t\t\$this->wSpacingCSS = \$vetor[15];
\t\tif (\$this->wSpacingCSS && strtoupper(\$this->wSpacingCSS) != 'NORMAL') {
\t\t\t\$this->minwSpacing = \$this->ConvertSize(\$this->wSpacingCSS,\$this->FontSize)/\$this->shrin_k; // mPDF 5.7.3
\t\t}
\t}
\tif(isset(\$vetor[14])) { \t // Letter spacing
\t\t\$this->lSpacingCSS = \$vetor[14];
\t\tif ((\$this->lSpacingCSS || \$this->lSpacingCSS==='0') && strtoupper(\$this->lSpacingCSS) != 'NORMAL') {
\t\t\t\$this->fixedlSpacing = \$this->ConvertSize(\$this->lSpacingCSS,\$this->FontSize)/\$this->shrin_k; // mPDF 5.7.3
\t\t}
\t}
\tif(isset(\$vetor[13])) { \t // Font Kerning
\t\t\$this->kerning = \$vetor[13];
\t}


\tif(isset(\$vetor[10]) and !empty(\$vetor[10])) //Background color
\t{
\t\t\$this->spanbgcolorarray = \$vetor[10];
\t\t\$this->spanbgcolor = true;
\t}
\tif(isset(\$vetor[9]) and !empty(\$vetor[9])) // Text parameters - Outline + hyphens
\t{
\t\t\$this->textparam = \$vetor[9] ;\t\t\t// mPDF 5.6.14
\t\t\$this->SetTextOutline(\$this->textparam);\t\t// mPDF 5.6.07
\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\tif (\$is_table && \$this->shrin_k) {
\t\t\tif (isset(\$this->textparam['text-baseline'])) { \$this->textparam['text-baseline'] /= \$this->shrin_k; }
\t\t\tif (isset(\$this->textparam['decoration-baseline'])) { \$this->textparam['decoration-baseline'] /= \$this->shrin_k; }
\t\t\tif (isset(\$this->textparam['decoration-fontsize'])) { \$this->textparam['decoration-fontsize'] /= \$this->shrin_k; }
\t\t}
\t}
\tif(isset(\$vetor[8]) and \$vetor[8] === true) // strike-through the text
\t{
\t    \$this->strike = true;
\t}
\tif(isset(\$vetor[7]) and \$vetor[7] != '') // internal target: <a name=\"anyvalue\">
\t{
\t  \$ily = \$this->y;
\t  if (\$this->keep_block_together) { \$this->internallink[\$vetor[7]] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"kt\"=>true ); }
\t  else if (\$this->table_rotate) { \$this->internallink[\$vetor[7]] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"tbrot\"=>true ); }
\t  else if (\$this->kwt) { \$this->internallink[\$vetor[7]] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"kwt\"=>true ); }
\t  else if (\$this->ColActive) { \$this->internallink[\$vetor[7]] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"col\"=>\$this->CurrCol ); }
\t  else
\t\t\$this->internallink[\$vetor[7]] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page );
\t  if (empty(\$vetor[0])) { //Ignore empty text
\t\t//Check if it is the last element. If so then finish printing the block
\t\tif (\$i == (\$array_size-1)) { \$this->finishFlowingBlock(true); }\t// true = END of flowing block
\t\tcontinue;
\t  }
\t}
\tif(isset(\$vetor[6]) and \$vetor[6] === true) // Subscript
\t{
\t\t\$this->SUB = true;
\t}
\tif(isset(\$vetor[5]) and \$vetor[5] === true) // Superscript
\t{
\t\t\$this->SUP = true;
\t}
\tif(isset(\$vetor[4]) and \$vetor[4] != '') {  // Font Family
\t\t\$font = \$this->SetFont(\$vetor[4],\$this->FontStyle,0,false);
\t}
\tif (!empty(\$vetor[3])) //Font Color
\t{
\t\t\$cor = \$vetor[3];
\t\t\$this->SetTColor(\$cor);
\t}
\tif(isset(\$vetor[2]) and \$vetor[2] != '') //Bold,Italic,Underline styles
\t{
\t\t\$this->SetStyles(\$vetor[2]);
\t}

\tif(isset(\$vetor[12]) and \$vetor[12] != '') { //Requested Bold,Italic,Underline
\t\t\$this->ReqFontStyle = \$vetor[12];
\t}
\tif(isset(\$vetor[1]) and \$vetor[1] != '') //LINK
\t{
\t  if (strpos(\$vetor[1],\".\") === false && strpos(\$vetor[1],\"@\") !== 0) //assuming every external link has a dot indicating extension (e.g: .html .txt .zip www.somewhere.com etc.)
\t  {
\t    //Repeated reference to same anchor?
\t    while(array_key_exists(\$vetor[1],\$this->internallink)) \$vetor[1]=\"#\".\$vetor[1];
\t    \$this->internallink[\$vetor[1]] = \$this->AddLink();
\t    \$vetor[1] = \$this->internallink[\$vetor[1]];
\t  }
\t  \$this->HREF = \$vetor[1];\t\t\t\t\t// HREF link style set here ******
\t}

\t// SPECIAL CONTENT - IMAGES & FORM OBJECTS
\t//Print-out special content

\tif (substr(\$vetor[0],0,3) == \"\\xbb\\xa4\\xac\") { //identifier has been identified!

\t  \$objattr = \$this->_getObjAttr(\$vetor[0]);

/*-- TABLES --*/
\t  if (\$objattr['type'] == 'nestedtable') {
\t\tif (\$objattr['nestedcontent']) {
\t\t\t\$level = \$objattr['level'];
\t\t\t\$table = &\$this->table[\$level][\$objattr['table']];
\t\t\tif (\$this->cacheTables) {
\t\t\t\t\$fh = fopen(\$table['cache'], \"r+b\");
\t\t\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$objattr['row']][\$objattr['col']], '', \$fh);
\t\t\t}
\t\t\telse {
\t\t\t\t\$fh = null;
\t\t\t\t\$cell = &\$table['cells'][\$objattr['row']][\$objattr['col']];
\t\t\t}
\t\t\t\$this->finishFlowingBlock(false,'nestedtable');
\t\t\t\$save_dw = \$this->divwidth ;
\t\t\t\$save_buffer = \$this->cellBorderBuffer;
\t\t\t\$this->cellBorderBuffer = array();
\t\t\t\$ncx = \$this->x;
\t\t\tlist(\$dummyx,\$w) = \$this->_tableGetWidth(\$table, \$objattr['row'], \$objattr['col'], \$fh);
\t\t\t\$ntw = \$this->table[(\$level+1)][\$objattr['nestedcontent']]['w'];\t// nested table width
\t\t\tif (!\$this->simpleTables){
\t\t\t\tif (\$this->packTableData) {
\t\t\t \t   \tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$cell['borderbin']);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$br = \$cell['border_details']['R']['w'];
\t\t\t\t\t\$bl = \$cell['border_details']['L']['w'];
\t\t\t\t}
\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\$innerw = \$w - \$bl - \$br - \$cell['padding']['L'] - \$cell['padding']['R'] - \$table['border_spacing_H'];
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$innerw = \$w - \$bl/2 - \$br/2 - \$cell['padding']['L'] - \$cell['padding']['R'];
\t\t\t\t}
\t\t\t}
\t\t\telse if (\$this->simpleTables){
\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\$innerw = \$w - \$table['simple']['border_details']['L']['w'] - \$table['simple']['border_details']['R']['w'] - \$cell['padding']['L'] - \$cell['padding']['R'] - \$table['border_spacing_H'];
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$innerw = \$w - \$table['simple']['border_details']['L']['w']/2 - \$table['simple']['border_details']['R']['w']/2 - \$cell['padding']['L'] - \$cell['padding']['R'];
\t\t\t\t}
\t\t\t}
\t\t\tif (\$cell['a']=='C' || \$this->table[(\$level+1)][\$objattr['nestedcontent']]['a']=='C') {
\t\t\t\t\$ncx += (\$innerw-\$ntw)/2;
\t\t\t}
\t\t\telseif (\$cell['a']=='R' || \$this->table[(\$level+1)][\$objattr['nestedcontent']]['a']=='R') {
\t\t\t\t\$ncx += \$innerw- \$ntw;
\t\t\t}
\t\t\t\$this->x = \$ncx ;
\t\t\tif (\$this->cacheTables) { fclose(\$fh); }

\t\t\t\$this->_tableWrite(\$this->table[(\$level+1)][\$objattr['nestedcontent']]);
\t\t\t\$this->cellBorderBuffer = \$save_buffer;
\t\t\t\$this->x = \$bak_x ;
\t\t\t\$this->divwidth  = \$save_dw;
\t\t\t\$this->newFlowingBlock( \$this->divwidth,\$this->divheight,\$align,\$is_table,\$is_list,\$blockstate,false,\$blockdir);
\t\t}
\t  }
\t  else {
/*-- END TABLES --*/
\t\tif (\$is_table) {\t// *TABLES*
\t\t\t\$maxWidth = \$this->divwidth; \t// *TABLES*
\t\t}\t// *TABLES*
\t\telse {\t// *TABLES*
\t\t\t\$maxWidth = \$this->divwidth - (\$this->blk[\$this->blklvl]['padding_left'] + \$this->blk[\$this->blklvl]['border_left']['w'] + \$this->blk[\$this->blklvl]['padding_right'] + \$this->blk[\$this->blklvl]['border_right']['w']);
\t\t}\t// *TABLES*

/*-- CSS-IMAGE-FLOAT --*/
\t\t// If float (already) exists at this level
\t\tif (isset(\$this->floatmargins['R']) && \$this->y <= \$this->floatmargins['R']['y1'] && \$this->y >= \$this->floatmargins['R']['y0']) { \$maxWidth -= \$this->floatmargins['R']['w']; }
\t\tif (isset(\$this->floatmargins['L']) && \$this->y <= \$this->floatmargins['L']['y1'] && \$this->y >= \$this->floatmargins['L']['y0']) { \$maxWidth -= \$this->floatmargins['L']['w']; }
/*-- END CSS-IMAGE-FLOAT --*/

\t\tlist(\$skipln) = \$this->inlineObject(\$objattr['type'], '', \$this->y, \$objattr,\$this->lMargin, (\$this->flowingBlockAttr['contentWidth']/_MPDFK), \$maxWidth, \$this->flowingBlockAttr['height'], false, \$is_table);
\t\t//  1 -> New line needed because of width
\t\t// -1 -> Will fit width on line but NEW PAGE REQUIRED because of height
\t\t// -2 -> Will not fit on line therefore needs new line but thus NEW PAGE REQUIRED
\t\t\$iby = \$this->y;
\t\t\$oldpage = \$this->page;
\t\t\$oldcol = \$this->CurrCol;
\t\tif ((\$skipln == 1 || \$skipln == -2) && !isset(\$objattr['float'])) {
\t\t\t\$this->finishFlowingBlock(false,\$objattr['type']);
\t\t     \t\$this->newFlowingBlock( \$this->divwidth,\$this->divheight,\$align,\$is_table,\$is_list,\$blockstate,false,\$blockdir);
\t\t}
\t\t\$thispage = \$this->page;
\t\tif (\$this->CurrCol!=\$oldcol) { \$changedcol = true; }
\t\telse { \$changedcol=false; }

\t\t// the previous lines can already have triggered page break or column change
\t\tif (!\$changedcol && \$skipln <0 && \$this->AcceptPageBreak() && \$thispage==\$oldpage) {

\t\t\t\$this->AddPage(\$this->CurOrientation);

\t  \t\t// Added to correct Images already set on line before page advanced
\t\t\t// i.e. if second inline image on line is higher than first and forces new page
\t\t\tif (count(\$this->objectbuffer)) {
\t\t\t\t\$yadj = \$iby - \$this->y;
\t\t\t\tforeach(\$this->objectbuffer AS \$ib=>\$val) {
\t\t\t\t\tif (\$this->objectbuffer[\$ib]['OUTER-Y'] ) \$this->objectbuffer[\$ib]['OUTER-Y'] -= \$yadj;
\t\t\t\t\tif (\$this->objectbuffer[\$ib]['BORDER-Y']) \$this->objectbuffer[\$ib]['BORDER-Y'] -= \$yadj;
\t\t\t\t\tif (\$this->objectbuffer[\$ib]['INNER-Y']) \$this->objectbuffer[\$ib]['INNER-Y'] -= \$yadj;
\t\t\t\t}
\t\t\t}
\t\t}

\t  \t// Added to correct for OddEven Margins
   \t  \tif  (\$this->page != \$oldpage) {
\t\t\tif ((\$this->page-\$oldpage) % 2 == 1) {
\t\t\t\t\$bak_x += \$this->MarginCorrection;
\t\t\t}
\t\t\t\$oldpage = \$this->page;
\t\t\t\t\$y = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$this->oldy = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$old_height = 0;
\t\t}
\t\t\$this->x = \$bak_x;
/*-- COLUMNS --*/
\t\t// COLS
\t\t// OR COLUMN CHANGE
\t\tif (\$this->CurrCol != \$oldcolumn) {
\t\t\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\t\t\$bak_x -= (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);\t// *RTL*
\t\t\t}\t// *RTL*
\t\t\telse {\t// *RTL*
\t\t\t\t\$bak_x += (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);
\t\t\t}\t// *RTL*
\t\t\t\$this->x = \$bak_x;
\t\t\t\$oldcolumn = \$this->CurrCol;
\t\t\t\$y = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$this->oldy = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$old_height = 0;
\t\t}
/*-- END COLUMNS --*/

/*-- CSS-IMAGE-FLOAT --*/
\t\tif (\$objattr['type'] == 'image' && isset(\$objattr['float'])) {
\t\t  \$fy = \$this->y;

\t\t  // DIV TOP MARGIN/BORDER/PADDING
\t\t  if (\$this->flowingBlockAttr['newblock'] && (\$this->flowingBlockAttr['blockstate']==1 || \$this->flowingBlockAttr['blockstate']==3) && \$this->flowingBlockAttr['lineCount']== 0) {
\t\t\t\$fy += \$this->blk[\$this->blklvl]['margin_top'] + \$this->blk[\$this->blklvl]['padding_top'] + \$this->blk[\$this->blklvl]['border_top']['w'];
\t\t  }

\t\t  if (\$objattr['float']=='R') {
\t\t\t\$fx = \$this->w - \$this->rMargin - \$objattr['width'] - (\$this->blk[\$this->blklvl]['outer_right_margin'] + \$this->blk[\$this->blklvl]['border_right']['w'] + \$this->blk[\$this->blklvl]['padding_right']);


\t\t  }
\t\t  else if (\$objattr['float']=='L') {
\t\t\t\$fx = \$this->lMargin + (\$this->blk[\$this->blklvl]['outer_left_margin'] + \$this->blk[\$this->blklvl]['border_left']['w'] + \$this->blk[\$this->blklvl]['padding_left']);
\t\t  }
\t\t  \$w = \$objattr['width'];
\t\t  \$h = abs(\$objattr['height']);

\t\t  \$widthLeft = \$maxWidth - (\$this->flowingBlockAttr['contentWidth']/_MPDFK);
\t\t  \$maxHeight = \$this->h - (\$this->tMargin + \$this->margin_header + \$this->bMargin + 10) ;
\t\t  // For Images
\t\t  \$extraWidth = (\$objattr['border_left']['w'] + \$objattr['border_right']['w'] + \$objattr['margin_left']+ \$objattr['margin_right']);
\t\t  \$extraHeight = (\$objattr['border_top']['w'] + \$objattr['border_bottom']['w'] + \$objattr['margin_top']+ \$objattr['margin_bottom']);

\t\t  if (\$objattr['itype'] == 'wmf' || \$objattr['itype'] == 'svg') {
\t\t  \t\$file = \$objattr['file'];
 \t\t  \t\$info=\$this->formobjects[\$file];
\t\t  }
\t\t  else {
\t\t  \t\$file = \$objattr['file'];
\t\t  \t\$info=\$this->images[\$file];
\t\t  }
\t\t  \$img_w = \$w - \$extraWidth ;
\t\t  \$img_h = \$h - \$extraHeight ;
\t\t  if (\$objattr['border_left']['w']) {
\t\t  \t\$objattr['BORDER-WIDTH'] = \$img_w + ((\$objattr['border_left']['w'] + \$objattr['border_right']['w'])/2) ;
\t\t  \t\$objattr['BORDER-HEIGHT'] = \$img_h + ((\$objattr['border_top']['w'] + \$objattr['border_bottom']['w'])/2) ;
\t\t  \t\$objattr['BORDER-X'] = \$fx + \$objattr['margin_left'] + ((\$objattr['border_left']['w'])/2) ;
\t\t  \t\$objattr['BORDER-Y'] = \$fy + \$objattr['margin_top'] + ((\$objattr['border_top']['w'])/2) ;
\t\t  }
\t\t  \$objattr['INNER-WIDTH'] = \$img_w;
\t\t  \$objattr['INNER-HEIGHT'] = \$img_h;
\t\t  \$objattr['INNER-X'] = \$fx + \$objattr['margin_left'] + (\$objattr['border_left']['w']);
\t\t  \$objattr['INNER-Y'] = \$fy + \$objattr['margin_top'] + (\$objattr['border_top']['w']) ;
\t\t  \$objattr['ID'] = \$info['i'];
\t\t  \$objattr['OUTER-WIDTH'] = \$w;
\t\t  \$objattr['OUTER-HEIGHT'] = \$h;
\t\t  \$objattr['OUTER-X'] = \$fx;
\t\t  \$objattr['OUTER-Y'] = \$fy;
\t\t  if (\$objattr['float']=='R') {
\t\t\t// If R float already exists at this level
\t\t \t\$this->floatmargins['R']['skipline'] = false;
\t\t\tif (isset(\$this->floatmargins['R']['y1']) && \$this->floatmargins['R']['y1'] > 0 && \$fy < \$this->floatmargins['R']['y1']) {
\t\t\t\t\$this->WriteFlowingBlock(\$vetor[0]);
\t\t\t}
\t\t\t// If L float already exists at this level
\t\t\telse if (isset(\$this->floatmargins['L']['y1']) && \$this->floatmargins['L']['y1'] > 0 && \$fy < \$this->floatmargins['L']['y1']) {
\t\t\t\t// Final check distance between floats is not now too narrow to fit text
\t\t\t\t\$mw = 2*\$this->GetCharWidth('W',false);
\t\t\t\tif ((\$this->blk[\$this->blklvl]['inner_width'] - \$w - \$this->floatmargins['L']['w']) < \$mw) {
\t\t\t\t\t\$this->WriteFlowingBlock(\$vetor[0]);
\t\t\t\t}
\t\t\t\telse {
\t\t  \t\t\t\$this->floatmargins['R']['x'] = \$fx;
\t\t  \t\t\t\$this->floatmargins['R']['w'] = \$w;
\t\t  \t\t\t\$this->floatmargins['R']['y0'] = \$fy;
\t\t  \t\t\t\$this->floatmargins['R']['y1'] = \$fy + \$h;
\t\t \t\t\tif (\$skipln == 1) {
\t\t \t\t\t \t\$this->floatmargins['R']['skipline'] = true;
\t\t \t\t\t \t\$this->floatmargins['R']['id'] = count(\$this->floatbuffer)+0;
\t\t\t\t\t\t\$objattr['skipline'] = true;
\t\t\t\t\t}
\t\t\t\t\t\$this->floatbuffer[] = \$objattr;
\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t  \t\t\$this->floatmargins['R']['x'] = \$fx;
\t\t  \t\t\$this->floatmargins['R']['w'] = \$w;
\t\t  \t\t\$this->floatmargins['R']['y0'] = \$fy;
\t\t  \t\t\$this->floatmargins['R']['y1'] = \$fy + \$h;
\t\t \t\tif (\$skipln == 1) {
\t\t \t\t \t\$this->floatmargins['R']['skipline'] = true;
\t\t \t\t \t\$this->floatmargins['R']['id'] = count(\$this->floatbuffer)+0;
\t\t\t\t\t\$objattr['skipline'] = true;
\t\t\t\t}
\t\t\t\t\$this->floatbuffer[] = \$objattr;
\t\t\t}
\t\t  }
\t\t  else if (\$objattr['float']=='L') {
\t\t\t// If L float already exists at this level
\t\t \t\$this->floatmargins['L']['skipline'] = false;
\t\t\tif (isset(\$this->floatmargins['L']['y1']) && \$this->floatmargins['L']['y1'] > 0 && \$fy < \$this->floatmargins['L']['y1']) {
\t\t \t\t\$this->floatmargins['L']['skipline'] = false;
\t\t\t\t\$this->WriteFlowingBlock(\$vetor[0]);
\t\t\t}
\t\t\t// If R float already exists at this level
\t\t\telse if (isset(\$this->floatmargins['R']['y1']) && \$this->floatmargins['R']['y1'] > 0 && \$fy < \$this->floatmargins['R']['y1']) {
\t\t\t\t// Final check distance between floats is not now too narrow to fit text
\t\t\t\t\$mw = 2*\$this->GetCharWidth('W',false);
\t\t\t\tif ((\$this->blk[\$this->blklvl]['inner_width'] - \$w - \$this->floatmargins['R']['w']) < \$mw) {
\t\t\t\t\t\$this->WriteFlowingBlock(\$vetor[0]);
\t\t\t\t}
\t\t\t\telse {
\t\t  \t\t\t\$this->floatmargins['L']['x'] = \$fx + \$w;
\t\t  \t\t\t\$this->floatmargins['L']['w'] = \$w;
\t\t  \t\t\t\$this->floatmargins['L']['y0'] = \$fy;
\t\t  \t\t\t\$this->floatmargins['L']['y1'] = \$fy + \$h;
\t\t \t\t\tif (\$skipln == 1) {
\t\t \t\t\t \t\$this->floatmargins['L']['skipline'] = true;
\t\t \t\t\t \t\$this->floatmargins['L']['id'] = count(\$this->floatbuffer)+0;
\t\t\t\t\t\t\$objattr['skipline'] = true;
\t\t\t\t\t}
\t\t\t\t\t\$this->floatbuffer[] = \$objattr;
\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t  \t\t\$this->floatmargins['L']['x'] = \$fx + \$w;
\t\t  \t\t\$this->floatmargins['L']['w'] = \$w;
\t\t  \t\t\$this->floatmargins['L']['y0'] = \$fy;
\t\t  \t\t\$this->floatmargins['L']['y1'] = \$fy + \$h;
\t\t \t\tif (\$skipln == 1) {
\t\t \t\t \t\$this->floatmargins['L']['skipline'] = true;
\t\t \t\t \t\$this->floatmargins['L']['id'] = count(\$this->floatbuffer)+0;
\t\t\t\t\t\$objattr['skipline'] = true;
\t\t\t\t}
\t\t\t\t\$this->floatbuffer[] = \$objattr;
\t\t\t}
\t\t  }
\t\t}
\t\telse {
/*-- END CSS-IMAGE-FLOAT --*/
\t\t\t\$this->WriteFlowingBlock(\$vetor[0]);
/*-- CSS-IMAGE-FLOAT --*/
\t\t}
/*-- END CSS-IMAGE-FLOAT --*/
\t  }\t// *TABLES*

\t}\t// END If special content
      else { //THE text
\t  if (\$this->tableLevel) { \$paint_ht_corr = 0; }\t// To move the y up when new column/page started if div border needed
\t  else { \$paint_ht_corr = \$this->blk[\$this->blklvl]['border_top']['w']; }

        if (\$vetor[0] == \"\\n\") { //We are reading a <BR> now turned into newline (\"\\n\")
\t\tif (\$this->flowingBlockAttr['content']) {
\t\t\t\$this->finishFlowingBlock(false,'br');
\t\t}
\t\telse if (\$is_table) {
\t\t\t\$this->y+= \$this->_computeLineheight(\$this->table_lineheight);
\t\t}
\t\telse if (!\$is_table) {
\t\t\t\$this->DivLn(\$this->lineheight);
\t\t\tif (\$this->ColActive) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*
\t\t}
\t  \t// Added to correct for OddEven Margins
   \t  \tif  (\$this->page != \$oldpage) {
\t\t\tif ((\$this->page-\$oldpage) % 2 == 1) {
\t\t\t\t\$bak_x += \$this->MarginCorrection;
\t\t\t}
\t\t\t\$oldpage = \$this->page;
\t\t\t\t\$y = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$this->oldy = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$old_height = 0;
\t\t}
\t\t\$this->x = \$bak_x;
/*-- COLUMNS --*/
\t\t// COLS
\t\t// OR COLUMN CHANGE
\t\tif (\$this->CurrCol != \$oldcolumn) {
\t\t\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\t\t\$bak_x -= (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);\t// *RTL*
\t\t\t}\t// *RTL*
\t\t\telse {\t// *RTL*
\t\t\t\t\$bak_x += (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);
\t\t\t}\t// *RTL*
\t\t\t\$this->x = \$bak_x;
\t\t\t\$oldcolumn = \$this->CurrCol;
\t\t\t\$y = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$this->oldy = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$old_height = 0;
\t\t}
/*-- END COLUMNS --*/
\t\t\$this->newFlowingBlock( \$this->divwidth,\$this->divheight,\$align,\$is_table,\$is_list,\$blockstate,false,\$blockdir);
         }
         else {
\t\t\$this->WriteFlowingBlock( \$vetor[0]);

\t\t  // Added to correct for OddEven Margins
   \t\t  if  (\$this->page != \$oldpage) {
\t\t\tif ((\$this->page-\$oldpage) % 2 == 1) {
\t\t\t\t\$bak_x += \$this->MarginCorrection;
\t\t\t\t\$this->x = \$bak_x;
\t\t\t}
\t\t\t\$oldpage = \$this->page;
\t\t\t\t\$y = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$this->oldy = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$old_height = 0;
\t\t  }
/*-- COLUMNS --*/
\t\t// COLS
\t\t// OR COLUMN CHANGE
\t\tif (\$this->CurrCol != \$oldcolumn) {
\t\t\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\t\t\$bak_x -= (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);\t// *RTL*
\t\t\t}\t// *RTL*
\t\t\telse {\t// *RTL*
\t\t\t\t\$bak_x += (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);
\t\t\t}\t// *RTL*
\t\t\t\$this->x = \$bak_x;
\t\t\t\$oldcolumn = \$this->CurrCol;
\t\t\t\$y = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$this->oldy = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$old_height = 0;
\t\t}
/*-- END COLUMNS --*/
\t    }


      }

      //Check if it is the last element. If so then finish printing the block
      if (\$i == (\$array_size-1)) {
\t\t\$this->finishFlowingBlock(true);\t// true = END of flowing block
\t\t  // Added to correct for OddEven Margins
   \t\t  if  (\$this->page != \$oldpage) {
\t\t\tif ((\$this->page-\$oldpage) % 2 == 1) {
\t\t\t\t\$bak_x += \$this->MarginCorrection;
\t\t\t\t\$this->x = \$bak_x;
\t\t\t}
\t\t\t\$oldpage = \$this->page;
\t\t\t\t\$y = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$this->oldy = \$this->tMargin - \$paint_ht_corr ;
\t\t\t\t\$old_height = 0;
\t\t  }

/*-- COLUMNS --*/
\t\t// COLS
\t\t// OR COLUMN CHANGE
\t\tif (\$this->CurrCol != \$oldcolumn) {
\t\t\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\t\t\$bak_x -= (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);\t// *RTL*
\t\t\t}\t// *RTL*
\t\t\telse {\t// *RTL*
\t\t\t\t\$bak_x += (\$this->CurrCol - \$oldcolumn) * (\$this->ColWidth+\$this->ColGap);
\t\t\t}\t// *RTL*
\t\t\t\$this->x = \$bak_x;
\t\t\t\$oldcolumn = \$this->CurrCol;
\t\t\t\$y = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$this->oldy = \$this->y0 - \$paint_ht_corr ;
\t\t\t\$old_height = 0;
\t\t}
/*-- END COLUMNS --*/

\t}

\t// RESETTING VALUES
\t\$this->SetTColor(\$this->ConvertColor(0));
\t\$this->SetDColor(\$this->ConvertColor(0));
\t\$this->SetFColor(\$this->ConvertColor(255));
\t\$this->colorarray = '';
\t\$this->spanbgcolorarray = '';
\t\$this->spanbgcolor = false;
\t\$this->spanborder = false;
\t\$this->spanborddet = array();
\t\$this->HREF = '';
\t\$this->textparam = array();
\t\$this->SetTextOutline();
\t\$this->SUP = false;
\t\$this->SUB = false;

\t\$this->strike = false;
\t\$this->textshadow = '';

\t\$this->currentfontfamily = '';
\t\$this->currentfontsize = '';
\t\$this->currentfontstyle = '';
/*-- TABLES --*/
\tif (\$this->tableLevel) {
\t\t\$this->SetLineHeight('',\$this->table_lineheight);\t// *TABLES*
\t}
\telse
/*-- END TABLES --*/
/*-- LISTS --*/
\tif (\$is_list && \$this->list_lineheight[\$this->listlvl][\$this->listOcc]) {
\t\t\$this->SetLineHeight('',\$this->list_lineheight[\$this->listlvl][\$this->listOcc]);\t// sets default line height
\t}
\telse
/*-- END LISTS --*/
\tif (isset(\$this->blk[\$this->blklvl]['line_height']) && \$this->blk[\$this->blklvl]['line_height']) {
\t\t\$this->SetLineHeight('',\$this->blk[\$this->blklvl]['line_height']);\t// sets default line height
\t}
\t\$this->ResetStyles();
\t\$this->toupper = false;
\t\$this->tolower = false;
\t\$this->capitalize = false;
\t\$this->kerning = false;
\t\$this->lSpacingCSS = '';
\t\$this->wSpacingCSS = '';
\t\$this->fixedlSpacing = false;
\t\$this->minwSpacing = 0;
\t\$this->SetDash();
\t\$this->dash_on = false;
\t\$this->dotted_on = false;

    }//end of for(i=0;i<arraysize;i++)


    // PAINT DIV BORDER\t// DISABLED IN COLUMNS AS DOESN'T WORK WHEN BROKEN ACROSS COLS??
    if ((isset(\$this->blk[\$this->blklvl]['border']) || isset(\$this->blk[\$this->blklvl]['bgcolor']) || isset(\$this->blk[\$this->blklvl]['box_shadow'])) && \$blockstate  && (\$this->y != \$this->oldy)) {
\t\$bottom_y = \$this->y;\t// Does not include Bottom Margin
\tif (isset(\$this->blk[\$this->blklvl]['startpage']) && \$this->blk[\$this->blklvl]['startpage'] != \$this->page && \$blockstate != 1) {
\t\t\$this->PaintDivBB('pagetop',\$blockstate);
\t}

\telse if (\$blockstate != 1) {
\t\t\$this->PaintDivBB('',\$blockstate);
\t}
\t\$this->y = \$bottom_y;
\t\$this->x = \$bak_x;
    }

    // Reset Font
    \$this->SetFontSize(\$this->default_font_size,false);


}

function _setDashBorder(\$style, \$div, \$cp, \$side) {
\tif (\$style == 'dashed' && ((\$side=='L' || \$side=='R') || (\$side=='T' && \$div != 'pagetop' && !\$cp) || (\$side=='B' && \$div!='pagebottom') )) {
\t\t\$dashsize = 2;\t// final dash will be this + 1*linewidth
\t\t\$dashsizek = 1.5;\t// ratio of Dash/Blank
\t\t\$this->SetDash(\$dashsize,(\$dashsize/\$dashsizek)+(\$this->LineWidth*2));
\t}
\telse if (\$style == 'dotted' || (\$side=='T' && (\$div == 'pagetop' || \$cp)) || (\$side=='B' && \$div == 'pagebottom')) {
  \t\t//Round join and cap
\t\t\$this->SetLineJoin(1);
\t\t\$this->SetLineCap(1);
\t\t\$this->SetDash(0.001,(\$this->LineWidth*3));
\t}
}

function _setBorderLine(\$b, \$k=1) {
\t\$this->SetLineWidth(\$b['w']/\$k);
\t\$this->SetDColor(\$b['c']);
\tif (\$b['c'][0]==5) {\t// RGBa
\t\t\$this->SetAlpha(ord(\$b['c'][4])/100, 'Normal', false, 'S').\"\\n\";\t// mPDF 5.7.2
\t}
\telse if (\$b['c'][0]==6) {\t// CMYKa
\t\t\$this->SetAlpha(ord(\$b['c'][5])/100, 'Normal', false, 'S').\"\\n\";\t// mPDF 5.7.2
\t}
}

// mPDF 5.6.52
function PaintDivBB(\$divider='',\$blockstate=0,\$blvl=0) {
\t// Borders & backgrounds are done elsewhere for columns - messes up the repositioning in printcolumnbuffer
\tif (\$this->ColActive) { return ; }\t// *COLUMNS*
\t\$save_y = \$this->y;
\tif (!\$blvl) { \$blvl = \$this->blklvl; }
\t\$x0 = \$x1 = \$y0 = \$y1 = 0;

\t// Added mPDF 3.0 Float DIV
\tif (isset(\$this->blk[\$blvl]['bb_painted'][\$this->page]) && \$this->blk[\$blvl]['bb_painted'][\$this->page]) { return; }\t// *CSS-FLOAT*

\tif (isset(\$this->blk[\$blvl]['x0'])) { \$x0 = \$this->blk[\$blvl]['x0']; }\t// left
\tif (isset(\$this->blk[\$blvl]['y1'])) { \$y1 = \$this->blk[\$blvl]['y1']; }\t// bottom

\t// Added mPDF 3.0 Float DIV - ensures backgrounds/borders are drawn to bottom of page
\tif (\$y1==0) {
\t\tif (\$divider=='pagebottom') { \$y1 = \$this->h-\$this->bMargin; }
\t\telse { \$y1 = \$this->y; }
\t}

\tif (isset(\$this->blk[\$blvl]['startpage']) && \$this->blk[\$blvl]['startpage'] != \$this->page) { \$continuingpage = true; } else { \$continuingpage = false; }

\tif (isset(\$this->blk[\$blvl]['y0'])) { \$y0 = \$this->blk[\$blvl]['y0']; }
\t\$h = \$y1 - \$y0;
\t\$w = \$this->blk[\$blvl]['width'];
\t\$x1 = \$x0 + \$w;

\t// Set border-widths as used here
\t\$border_top = \$this->blk[\$blvl]['border_top']['w'];
\t\$border_bottom = \$this->blk[\$blvl]['border_bottom']['w'];
\t\$border_left = \$this->blk[\$blvl]['border_left']['w'];
\t\$border_right = \$this->blk[\$blvl]['border_right']['w'];
\tif (!\$this->blk[\$blvl]['border_top'] || \$divider == 'pagetop' || \$continuingpage) {
\t\t\$border_top = 0;
\t}
\tif (!\$this->blk[\$blvl]['border_bottom'] || \$blockstate == 1 || \$divider == 'pagebottom') {
\t\t\$border_bottom = 0;
\t}

\t\t\$brTL_H = 0;
\t\t\$brTL_V = 0;
\t\t\$brTR_H = 0;
\t\t\$brTR_V = 0;
\t\t\$brBL_H = 0;
\t\t\$brBL_V = 0;
\t\t\$brBR_H = 0;
\t\t\$brBR_V = 0;

\t\$brset = false;
/*-- BORDER-RADIUS --*/
\tif (isset(\$this->blk[\$blvl]['border_radius_TL_H'])) { \$brTL_H = \$this->blk[\$blvl]['border_radius_TL_H']; \$brset = true; }
\tif (isset(\$this->blk[\$blvl]['border_radius_TL_V'])) { \$brTL_V = \$this->blk[\$blvl]['border_radius_TL_V']; \$brset = true; }
\tif (isset(\$this->blk[\$blvl]['border_radius_TR_H'])) { \$brTR_H = \$this->blk[\$blvl]['border_radius_TR_H']; \$brset = true; }
\tif (isset(\$this->blk[\$blvl]['border_radius_TR_V'])) { \$brTR_V = \$this->blk[\$blvl]['border_radius_TR_V']; \$brset = true; }
\tif (isset(\$this->blk[\$blvl]['border_radius_BR_H'])) { \$brBR_H = \$this->blk[\$blvl]['border_radius_BR_H']; \$brset = true; }
\tif (isset(\$this->blk[\$blvl]['border_radius_BR_V'])) { \$brBR_V = \$this->blk[\$blvl]['border_radius_BR_V']; \$brset = true; }
\tif (isset(\$this->blk[\$blvl]['border_radius_BL_H'])) { \$brBL_H = \$this->blk[\$blvl]['border_radius_BL_H']; \$brset = true; }
\tif (isset(\$this->blk[\$blvl]['border_radius_BL_V'])) { \$brBL_V = \$this->blk[\$blvl]['border_radius_BL_V']; \$brset = true; }

\t// mPDF 5.4.17
\t//if (!\$this->blk[\$blvl]['border_top'] || \$divider == 'pagetop' || \$continuingpage || \$this->keep_block_together) {
\tif (!\$this->blk[\$blvl]['border_top'] || \$divider == 'pagetop' || \$continuingpage) {
\t\t\$brTL_H = 0;
\t\t\$brTL_V = 0;
\t\t\$brTR_H = 0;
\t\t\$brTR_V = 0;
\t}
\t// mPDF 5.4.17
\t//if (!\$this->blk[\$blvl]['border_bottom'] || \$blockstate == 1 || \$divider == 'pagebottom' || \$this->keep_block_together) {
\tif (!\$this->blk[\$blvl]['border_bottom'] || \$blockstate == 1 || \$divider == 'pagebottom') {
\t\t\$brBL_H = 0;
\t\t\$brBL_V = 0;
\t\t\$brBR_H = 0;
\t\t\$brBR_V = 0;
\t}

\t// Disallow border-radius if it is smaller than the border width.
\tif (\$brTL_H < min(\$border_left, \$border_top)) { \$brTL_H = \$brTL_V = 0; }
\tif (\$brTL_V < min(\$border_left, \$border_top)) { \$brTL_V = \$brTL_H = 0; }
\tif (\$brTR_H < min(\$border_right, \$border_top)) { \$brTR_H = \$brTR_V = 0; }
\tif (\$brTR_V < min(\$border_right, \$border_top)) { \$brTR_V = \$brTR_H = 0; }
\tif (\$brBL_H < min(\$border_left, \$border_bottom)) { \$brBL_H = \$brBL_V = 0; }
\tif (\$brBL_V < min(\$border_left, \$border_bottom)) { \$brBL_V = \$brBL_H = 0; }
\tif (\$brBR_H < min(\$border_right, \$border_bottom)) { \$brBR_H = \$brBR_V = 0; }
\tif (\$brBR_V < min(\$border_right, \$border_bottom)) { \$brBR_V = \$brBR_H = 0; }

\t// CHECK FOR radii that sum to > width or height of div ********
\t\$f = min(\$h/(\$brTL_V + \$brBL_V + 0.001), \$h/(\$brTR_V + \$brBR_V + 0.001), \$w/(\$brTL_H + \$brTR_H + 0.001),  \$w/(\$brBL_H + \$brBR_H + 0.001));
\tif (\$f < 1) {
\t\t\$brTL_H *= \$f;
\t\t\$brTL_V *= \$f;
\t\t\$brTR_H *= \$f;
\t\t\$brTR_V *= \$f;
\t\t\$brBL_H *= \$f;
\t\t\$brBL_V *= \$f;
\t\t\$brBR_H *= \$f;
\t\t\$brBR_V *= \$f;
\t}
/*-- END BORDER-RADIUS --*/

\t\$tbcol = \$this->ConvertColor(255);
\tfor(\$l=0; \$l <= \$blvl; \$l++) {
\t\tif (\$this->blk[\$l]['bgcolor']) {
\t\t\t\$tbcol = \$this->blk[\$l]['bgcolorarray'];
\t\t}
\t}

\t// BORDERS
\tif (isset(\$this->blk[\$blvl]['y0']) && \$this->blk[\$blvl]['y0']) { \$y0 = \$this->blk[\$blvl]['y0']; }
\t\$h = \$y1 - \$y0;
\t\$w = \$this->blk[\$blvl]['width'];

\t//if (\$this->blk[\$blvl]['border_top']) {
\t// Reinstate line above for dotted line divider when block border crosses a page
\tif (\$this->blk[\$blvl]['border_top'] && \$divider != 'pagetop' && !\$continuingpage) {
\t\t\$tbd = \$this->blk[\$blvl]['border_top'];

\t\t// mPDF 5.4.18
\t\t\$legend = '';
\t\tif (isset(\$this->blk[\$blvl]['border_legend']) && \$this->blk[\$blvl]['border_legend']) {
\t\t\t\$legend = \$this->blk[\$blvl]['border_legend'];\t// Same structure array as textbuffer
\t\t\t\$txt = ltrim(\$legend[0]);

\t\t\t//Set font, size, style, color
\t\t\t\$this->SetFont(\$legend[4],\$legend[2],\$legend[11]);
\t\t\tif (\$legend[3]) {
\t\t\t\t\$cor = \$legend[3];
\t\t\t\t\$this->SetTColor(\$cor);
\t\t\t}
\t\t\t\$stringWidth = \$this->GetStringWidth(\$txt );
\t\t\t\$save_x = \$this->x;
\t\t\t\$save_y = \$this->y;
\t\t\t\$save_currentfontfamily = \$this->FontFamily;
\t\t\t\$save_currentfontsize = \$this->FontSizePt;
\t\t\t\$save_currentfontstyle = \$this->FontStyle.(\$this->U ? 'U' : '').(\$this->S ? 'S' : '');
\t\t\t\$this->y = \$y0 - \$this->FontSize/2  + \$this->blk[\$blvl]['border_top']['w']/2;
\t\t\t\$this->x = \$x0 + \$this->blk[\$blvl]['padding_left'] + \$this->blk[\$blvl]['border_left']['w'];

\t\t\t// Set the distance from the border line to the text ? make configurable variable
\t\t\t\$gap = 0.2 * \$this->FontSize;

\t\t\t\$legbreakL = \$this->x - \$gap;
\t\t\t\$legbreakR = \$this->x + \$stringWidth + \$gap;

\t\t\t\$this->Cell( \$stringWidth, \$this->FontSize, \$txt , '', 0, 'C', \$fill, '', 0, 0,0,'M', \$fill);
\t\t\t// Reset
\t\t\t\$this->x = \$save_x;
\t\t\t\$this->y = \$save_y;
\t\t\t\$this->SetFont(\$save_currentfontfamily,\$save_currentfontstyle,\$save_currentfontsize);
\t\t\t\$this->SetTColor(\$this->ConvertColor(0));
\t\t}

\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') {
\t\t\t\t\$this->_out('q');
\t\t\t\t\$this->SetLineWidth(0);
\t\t\t\t\$this->_out(sprintf('%.3F %.3F m ',(\$x0)*_MPDFK, (\$this->h-(\$y0))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$border_left)*_MPDFK, (\$this->h-(\$y0 + \$border_top))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$w - \$border_right)*_MPDFK, (\$this->h-(\$y0 + \$border_top))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$w)*_MPDFK, (\$this->h-(\$y0))*_MPDFK));
\t\t\t\t\$this->_out(' h W n ');\t// Ends path no-op & Sets the clipping path
\t\t\t}

\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') {
\t\t\t\t\$legbreakL -= \$border_top/2;\t// because line cap different
\t\t\t\t\$legbreakR += \$border_top/2;
\t\t\t\t\$this->_setDashBorder(\$tbd['style'],\$divider,\$continuingpage,'T');
\t\t\t}
/*-- BORDER-RADIUS --*/
 \t\t\telse if ((\$brTL_V && \$brTL_H) || (\$brTR_V && \$brTR_H) || \$tbd['style']=='solid' || \$tbd['style']=='double' ) {  // mPDF 5.6.58
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t}
\t\t\t\$s = '';
\t\t\tif (\$brTR_H && \$brTR_V) {
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$w - \$brTR_H, \$y0 + \$brTR_V, \$brTR_H - \$border_top/2 , \$brTR_V - \$border_top/2 , 1, 2, true)).\"\\n\";
\t\t\t}
\t\t\telse
/*-- END BORDER-RADIUS --*/
\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + \$w)*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\telse {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + \$w - (\$border_top/2))*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t}
/*-- BORDER-RADIUS --*/
\t\t\tif (\$brTL_H && \$brTL_V ) {
\t\t\t\t// mPDF 5.4.18
\t\t\t\tif (\$legend) {
\t\t\t\t\tif (\$legbreakR < (\$x0 + \$w - \$brTR_H)) {
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ', \$legbreakR*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t}
\t\t\t\t\tif (\$legbreakL > (\$x0 + \$brTL_H )) {
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',\$legbreakL*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$brTL_H )*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK).\"\\n\");
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + \$brTL_H )*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$brTL_H )*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t}
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$brTL_H, \$y0 + \$brTL_V, \$brTL_H - \$border_top/2 , \$brTL_V - \$border_top/2 , 2, 1)).\"\\n\";
\t\t\t}
\t\t\telse {
/*-- END BORDER-RADIUS --*/
\t\t\t\t// mPDF 5.4.18
\t\t\t\tif (\$legend) {
\t\t\t\t\tif (\$legbreakR < (\$x0 + \$w)) {
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',\$legbreakR*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t}
\t\t\t\t\tif (\$legbreakL > (\$x0)) {
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',\$legbreakL*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0)*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + (\$border_top/2))*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\telse if (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F m ', (\$x0)*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$s .= (sprintf('%.3F %.3F m ', (\$x0 + \$border_top/2)*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse if (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0)*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + (\$border_top/2))*_MPDFK, (\$this->h-(\$y0 + (\$border_top/2)))*_MPDFK)).\"\\n\";
\t\t\t\t}
/*-- BORDER-RADIUS --*/
\t\t\t}
/*-- END BORDER-RADIUS --*/
\t\t\t\$s .= 'S'.\"\\n\";
\t\t\t\$this->_out(\$s);

\t\t\tif (\$tbd['style']=='double') {
\t\t\t\t\$this->SetLineWidth(\$tbd['w']/3);
\t\t\t\t\$this->SetDColor(\$tbcol);
\t\t\t\t\$this->_out(\$s);
\t\t\t}
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') { \$this->_out('Q'); }

\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineWidth(0.1);\t// mPDF 5.6.57
\t\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\t//if (\$this->blk[\$blvl]['border_bottom'] && \$blockstate != 1) {
\t// Reinstate line above for dotted line divider when block border crosses a page
\tif (\$this->blk[\$blvl]['border_bottom'] && \$blockstate != 1 && \$divider != 'pagebottom') {
\t\t\$tbd = \$this->blk[\$blvl]['border_bottom'];
\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') {
\t\t\t\t\$this->_out('q');
\t\t\t\t\$this->SetLineWidth(0);
\t\t\t\t\$this->_out(sprintf('%.3F %.3F m ',(\$x0)*_MPDFK, (\$this->h-(\$y0 + \$h))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$border_left)*_MPDFK, (\$this->h-(\$y0 + \$h - \$border_bottom))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$w - \$border_right)*_MPDFK, (\$this->h-(\$y0 + \$h - \$border_bottom))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$w)*_MPDFK, (\$this->h-(\$y0 + \$h))*_MPDFK));
\t\t\t\t\$this->_out(' h W n ');\t// Ends path no-op & Sets the clipping path
\t\t\t}

\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') { \$this->_setDashBorder(\$tbd['style'],\$divider,\$continuingpage,'B'); }
/*-- BORDER-RADIUS --*/
 \t\t\telse if ((\$brBL_V && \$brBL_H) || (\$brBR_V && \$brBR_H) || \$tbd['style']=='solid' || \$tbd['style']=='double' ) {  // mPDF 5.6.58
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t}
\t\t\t\$s = '';
\t\t\tif (\$brBL_H && \$brBL_V) {
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$brBL_H, \$y0 + \$h - \$brBL_V, \$brBL_H - \$border_bottom/2 , \$brBL_V - \$border_bottom/2 , 3, 2, true)).\"\\n\";
\t\t\t}
\t\t\telse
/*-- END BORDER-RADIUS --*/
\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0)*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_bottom/2)))*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\telse {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + (\$border_bottom/2))*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_bottom/2)))*_MPDFK)).\"\\n\";
\t\t\t}
/*-- BORDER-RADIUS --*/
\t\t\tif (\$brBR_H && \$brBR_V ) {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$w - (\$border_bottom/2) - \$brBR_H )*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_bottom/2)))*_MPDFK)).\"\\n\";
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$w - \$brBR_H, \$y0 + \$h - \$brBR_V, \$brBR_H - \$border_bottom/2 , \$brBR_V - \$border_bottom/2 , 4, 1)).\"\\n\";
\t\t\t}
\t\t\telse
/*-- END BORDER-RADIUS --*/
\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$w)*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_bottom/2)))*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\telse {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$w - (\$border_bottom/2))*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_bottom/2)))*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\t\$s .= 'S'.\"\\n\";
\t\t\t\$this->_out(\$s);

\t\t\tif (\$tbd['style']=='double') {
\t\t\t\t\$this->SetLineWidth(\$tbd['w']/3);
\t\t\t\t\$this->SetDColor(\$tbcol);
\t\t\t\t\$this->_out(\$s);
\t\t\t}
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') { \$this->_out('Q'); }


\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineWidth(0.1);\t// mPDF 5.6.57
\t\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$this->blk[\$blvl]['border_left']) {
\t\t\$tbd = \$this->blk[\$blvl]['border_left'];
\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') {
\t\t\t\t\$this->_out('q');
\t\t\t\t\$this->SetLineWidth(0);
\t\t\t\t\$this->_out(sprintf('%.3F %.3F m ',(\$x0)*_MPDFK, (\$this->h-(\$y0))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$border_left)*_MPDFK, (\$this->h-(\$y0+\$border_top))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$border_left)*_MPDFK, (\$this->h-(\$y0 + \$h - \$border_bottom))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0)*_MPDFK, (\$this->h-(\$y0 + \$h))*_MPDFK));
\t\t\t\t\$this->_out(' h W n ');\t// Ends path no-op & Sets the clipping path
\t\t\t}

\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') { \$this->_setDashBorder(\$tbd['style'],\$divider,\$continuingpage,'L'); }
/*-- BORDER-RADIUS --*/
 \t\t\telse if ((\$brTL_V && \$brTL_H) || (\$brBL_V && \$brBL_H) || \$tbd['style']=='solid' || \$tbd['style']=='double' ) {  // mPDF 5.6.58
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t}
\t\t\t\$s = '';
\t\t\tif (\$brTL_V && \$brTL_H) {
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$brTL_H, \$y0 + \$brTL_V, \$brTL_H - \$border_left/2 , \$brTL_V - \$border_left/2, 2, 2, true)).\"\\n\";
\t\t\t}
\t\t\telse
/*-- END BORDER-RADIUS --*/
\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + (\$border_left/2))*_MPDFK, (\$this->h-(\$y0))*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\telse {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + (\$border_left/2))*_MPDFK, (\$this->h-(\$y0 + (\$border_left/2)))*_MPDFK)).\"\\n\";
\t\t\t}
/*-- BORDER-RADIUS --*/
\t\t\tif (\$brBL_V && \$brBL_H ) {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + (\$border_left/2))*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_left/2)- \$brBL_V) )*_MPDFK)).\"\\n\";
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$brBL_H, \$y0 + \$h - \$brBL_V, \$brBL_H - \$border_left/2 , \$brBL_V - \$border_left/2, 3, 1)).\"\\n\";
\t\t\t}
\t\t\telse
/*-- END BORDER-RADIUS --*/
\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + (\$border_left/2))*_MPDFK, (\$this->h-(\$y0 + \$h) )*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\telse {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + (\$border_left/2))*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_left/2)) )*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\t\$s .= 'S'.\"\\n\";
\t\t\t\$this->_out(\$s);

\t\t\tif (\$tbd['style']=='double') {
\t\t\t\t\$this->SetLineWidth(\$tbd['w']/3);
\t\t\t\t\$this->SetDColor(\$tbcol);
\t\t\t\t\$this->_out(\$s);
\t\t\t}
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') { \$this->_out('Q'); }

\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineWidth(0.1);\t// mPDF 5.6.57
\t\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$this->blk[\$blvl]['border_right']) {
\t\t\$tbd = \$this->blk[\$blvl]['border_right'];
\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') {
\t\t\t\t\$this->_out('q');
\t\t\t\t\$this->SetLineWidth(0);
\t\t\t\t\$this->_out(sprintf('%.3F %.3F m ',(\$x0 + \$w)*_MPDFK, (\$this->h-(\$y0))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$w - \$border_right)*_MPDFK, (\$this->h-(\$y0+\$border_top))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$w - \$border_right)*_MPDFK, (\$this->h-(\$y0 + \$h - \$border_bottom))*_MPDFK));
\t\t\t\t\$this->_out(sprintf('%.3F %.3F l ',(\$x0 + \$w)*_MPDFK, (\$this->h-(\$y0 + \$h))*_MPDFK));
\t\t\t\t\$this->_out(' h W n ');\t// Ends path no-op & Sets the clipping path
\t\t\t}

\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') { \$this->_setDashBorder(\$tbd['style'],\$divider,\$continuingpage,'R'); }
/*-- BORDER-RADIUS --*/
 \t\t\telse if ((\$brTR_V && \$brTR_H) || (\$brBR_V && \$brBR_H) || \$tbd['style']=='solid' || \$tbd['style']=='double' ) { // mPDF 5.6.58
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t}
\t\t\t\$s = '';
\t\t\tif (\$brBR_V && \$brBR_H) {
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$w - \$brBR_H, \$y0 + \$h - \$brBR_V, \$brBR_H - \$border_right/2 , \$brBR_V - \$border_right/2, 4, 2, true)).\"\\n\";
\t\t\t}
\t\t\telse
/*-- END BORDER-RADIUS --*/
\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + \$w - (\$border_right/2))*_MPDFK, (\$this->h-(\$y0 + \$h))*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\telse {
\t\t\t\t\$s .= (sprintf('%.3F %.3F m ',(\$x0 + \$w - (\$border_right/2))*_MPDFK, (\$this->h-(\$y0 + \$h - (\$border_right/2)))*_MPDFK)).\"\\n\";
\t\t\t}
/*-- BORDER-RADIUS --*/
\t\t\tif (\$brTR_V && \$brTR_H ) {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$w - (\$border_right/2))*_MPDFK, (\$this->h-(\$y0 + (\$border_right/2) + \$brTR_V) )*_MPDFK)).\"\\n\";
\t\t\t\t\$s .= (\$this->_EllipseArc(\$x0 + \$w - \$brTR_H, \$y0 + \$brTR_V, \$brTR_H - \$border_right/2 , \$brTR_V - \$border_right/2, 1, 1)).\"\\n\";
\t\t\t}
\t\t\telse
/*-- END BORDER-RADIUS --*/
\t\t\tif (\$tbd['style']=='solid' || \$tbd['style']=='double') {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$w - (\$border_right/2))*_MPDFK, (\$this->h-(\$y0) )*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\telse {
\t\t\t\t\$s .= (sprintf('%.3F %.3F l ',(\$x0 + \$w - (\$border_right/2))*_MPDFK, (\$this->h-(\$y0 + (\$border_right/2)) )*_MPDFK)).\"\\n\";
\t\t\t}
\t\t\t\$s .= 'S'.\"\\n\";
\t\t\t\$this->_out(\$s);

\t\t\tif (\$tbd['style']=='double') {
\t\t\t\t\$this->SetLineWidth(\$tbd['w']/3);
\t\t\t\t\$this->SetDColor(\$tbcol);
\t\t\t\t\$this->_out(\$s);
\t\t\t}
\t\t\tif (!\$brset && \$tbd['style']!='dotted' && \$tbd['style']!='dashed') { \$this->_out('Q'); }

\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineWidth(0.1);\t// mPDF 5.6.57
\t\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}


\t\$this->SetDash();
\t\$this->y = \$save_y;


\t// BACKGROUNDS are disabled in columns/kbt/headers - messes up the repositioning in printcolumnbuffer
\tif (\$this->ColActive || \$this->kwt || \$this->keep_block_together) { return ; }


\t\$bgx0 = \$x0;
\t\$bgx1 = \$x1;
\t\$bgy0 = \$y0;
\t\$bgy1 = \$y1;

\t// Defined br values represent the radius of the outer curve - need to take border-width/2 from each radius for drawing the borders
\tif (isset(\$this->blk[\$blvl]['background_clip']) && \$this->blk[\$blvl]['background_clip'] == 'padding-box') {
\t\t\$brbgTL_H = max(0, \$brTL_H - \$this->blk[\$blvl]['border_left']['w']);
\t\t\$brbgTL_V = max(0, \$brTL_V - \$this->blk[\$blvl]['border_top']['w']);
\t\t\$brbgTR_H = max(0, \$brTR_H - \$this->blk[\$blvl]['border_right']['w']);
\t\t\$brbgTR_V = max(0, \$brTR_V - \$this->blk[\$blvl]['border_top']['w']);
\t\t\$brbgBL_H = max(0, \$brBL_H - \$this->blk[\$blvl]['border_left']['w']);
\t\t\$brbgBL_V = max(0, \$brBL_V - \$this->blk[\$blvl]['border_bottom']['w']);
\t\t\$brbgBR_H = max(0, \$brBR_H - \$this->blk[\$blvl]['border_right']['w']);
\t\t\$brbgBR_V = max(0, \$brBR_V - \$this->blk[\$blvl]['border_bottom']['w']);
\t\t\$bgx0 += \$this->blk[\$blvl]['border_left']['w'];
\t\t\$bgx1 -= \$this->blk[\$blvl]['border_right']['w'];
\t\tif (\$this->blk[\$blvl]['border_top'] && \$divider != 'pagetop' && !\$continuingpage) {
\t\t\t\$bgy0 += \$this->blk[\$blvl]['border_top']['w'];
\t\t}
\t\tif (\$this->blk[\$blvl]['border_bottom'] && \$blockstate != 1 && \$divider != 'pagebottom') {
\t\t\t\$bgy1 -= \$this->blk[\$blvl]['border_bottom']['w'];
\t\t}
\t}
\t// mPDF 5.6.09
\telse if (isset(\$this->blk[\$blvl]['background_clip']) && \$this->blk[\$blvl]['background_clip'] == 'content-box') {
\t\t\$brbgTL_H = max(0, \$brTL_H - \$this->blk[\$blvl]['border_left']['w'] - \$this->blk[\$blvl]['padding_left']);
\t\t\$brbgTL_V = max(0, \$brTL_V - \$this->blk[\$blvl]['border_top']['w'] - \$this->blk[\$blvl]['padding_top']);
\t\t\$brbgTR_H = max(0, \$brTR_H - \$this->blk[\$blvl]['border_right']['w'] - \$this->blk[\$blvl]['padding_right']);
\t\t\$brbgTR_V = max(0, \$brTR_V - \$this->blk[\$blvl]['border_top']['w'] - \$this->blk[\$blvl]['padding_top']);
\t\t\$brbgBL_H = max(0, \$brBL_H - \$this->blk[\$blvl]['border_left']['w'] - \$this->blk[\$blvl]['padding_left']);
\t\t\$brbgBL_V = max(0, \$brBL_V - \$this->blk[\$blvl]['border_bottom']['w'] - \$this->blk[\$blvl]['padding_bottom']);
\t\t\$brbgBR_H = max(0, \$brBR_H - \$this->blk[\$blvl]['border_right']['w'] - \$this->blk[\$blvl]['padding_right']);
\t\t\$brbgBR_V = max(0, \$brBR_V - \$this->blk[\$blvl]['border_bottom']['w'] - \$this->blk[\$blvl]['padding_bottom']);
\t\t\$bgx0 +=  \$this->blk[\$blvl]['border_left']['w'] + \$this->blk[\$blvl]['padding_left'];
\t\t\$bgx1 -= \$this->blk[\$blvl]['border_right']['w'] + \$this->blk[\$blvl]['padding_right'];
\t\tif ((\$this->blk[\$blvl]['border_top']['w'] || \$this->blk[\$blvl]['padding_top']) && \$divider != 'pagetop' && !\$continuingpage) {
\t\t\t\$bgy0 += \$this->blk[\$blvl]['border_top']['w'] + \$this->blk[\$blvl]['padding_top'];
\t\t}
\t\tif ((\$this->blk[\$blvl]['border_bottom']['w'] || \$this->blk[\$blvl]['padding_bottom']) && \$blockstate != 1 && \$divider != 'pagebottom') {
\t\t\t\$bgy1 -= \$this->blk[\$blvl]['border_bottom']['w'] + \$this->blk[\$blvl]['padding_bottom'];
\t\t}
\t}
\telse {
\t\t\$brbgTL_H = \$brTL_H;
\t\t\$brbgTL_V = \$brTL_V;
\t\t\$brbgTR_H = \$brTR_H;
\t\t\$brbgTR_V = \$brTR_V;
\t\t\$brbgBL_H = \$brBL_H;
\t\t\$brbgBL_V = \$brBL_V;
\t\t\$brbgBR_H = \$brBR_H;
\t\t\$brbgBR_V = \$brBR_V;
\t}

\t// Set clipping path
\t\$s = ' q 0 w ';\t// Line width=0
\t\$s .= sprintf('%.3F %.3F m ', (\$bgx0+\$brbgTL_H )*_MPDFK, (\$this->h-\$bgy0)*_MPDFK);\t// start point TL before the arc
/*-- BORDER-RADIUS --*/
\tif (\$brbgTL_H || \$brbgTL_V) {
\t\t\$s .= \$this->_EllipseArc(\$bgx0+\$brbgTL_H, \$bgy0+\$brbgTL_V, \$brbgTL_H , \$brbgTL_V , 2);\t// segment 2 TL
\t}
/*-- END BORDER-RADIUS --*/
\t\$s .= sprintf('%.3F %.3F l ', (\$bgx0)*_MPDFK, (\$this->h-(\$bgy1-\$brbgBL_V ))*_MPDFK);\t// line to BL
/*-- BORDER-RADIUS --*/
\tif (\$brbgBL_H || \$brbgBL_V) {
\t\t\$s .= \$this->_EllipseArc(\$bgx0+\$brbgBL_H, \$bgy1-\$brbgBL_V, \$brbgBL_H , \$brbgBL_V , 3);\t// segment 3 BL
\t}
/*-- END BORDER-RADIUS --*/
\t\$s .= sprintf('%.3F %.3F l ', (\$bgx1-\$brbgBR_H )*_MPDFK, (\$this->h-(\$bgy1))*_MPDFK);\t// line to BR
/*-- BORDER-RADIUS --*/
\tif (\$brbgBR_H || \$brbgBR_V) {
\t\t\$s .= \$this->_EllipseArc(\$bgx1-\$brbgBR_H, \$bgy1-\$brbgBR_V, \$brbgBR_H , \$brbgBR_V , 4);\t// segment 4 BR
\t}
/*-- END BORDER-RADIUS --*/
\t\$s .= sprintf('%.3F %.3F l ', (\$bgx1)*_MPDFK, (\$this->h-(\$bgy0+\$brbgTR_V))*_MPDFK);\t// line to TR
/*-- BORDER-RADIUS --*/
\tif (\$brbgTR_H || \$brbgTR_V) {
\t\t\$s .= \$this->_EllipseArc(\$bgx1-\$brbgTR_H, \$bgy0+\$brbgTR_V, \$brbgTR_H , \$brbgTR_V , 1);\t// segment 1 TR
\t}
/*-- END BORDER-RADIUS --*/
\t\$s .= sprintf('%.3F %.3F l ', (\$bgx0+\$brbgTL_H )*_MPDFK, (\$this->h-\$bgy0)*_MPDFK);\t// line to TL


\t// Box Shadow
\t\$shadow = '';
\tif (isset(\$this->blk[\$blvl]['box_shadow']) && \$this->blk[\$blvl]['box_shadow'] && \$h > 0) {
\t\tforeach(\$this->blk[\$blvl]['box_shadow'] AS \$sh) {
\t\t\t// Colors
\t\t\tif (\$sh['col']{0}==1) {
\t\t\t\t\$colspace = 'Gray';
\t\t\t\tif (\$sh['col']{2}==1) { \$col1 = '1'.\$sh['col'][1].'1'.\$sh['col'][3]; }
\t\t\t\telse { \$col1 = '1'.\$sh['col'][1].'1'.chr(100); }
\t\t\t\t\$col2 = '1'.\$sh['col'][1].'1'.chr(0);
\t\t\t}
\t\t\telse if (\$sh['col']{0}==4) {\t// CMYK
\t\t\t\t\$colspace = 'CMYK';
\t\t\t\t\$col1 = '6'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].\$sh['col'][4].chr(100);
\t\t\t\t\$col2 = '6'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].\$sh['col'][4].chr(0);
\t\t\t}
\t\t\telse if (\$sh['col']{0}==5) {\t// RGBa
\t\t\t\t\$colspace = 'RGB';
\t\t\t\t\$col1 = '5'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].\$sh['col'][4];
\t\t\t\t\$col2 = '5'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].chr(0);
\t\t\t}
\t\t\telse if (\$sh['col']{0}==6) {\t// CMYKa
\t\t\t\t\$colspace = 'CMYK';
\t\t\t\t\$col1 = '6'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].\$sh['col'][4].\$sh['col'][5];
\t\t\t\t\$col2 = '6'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].\$sh['col'][4].chr(0);
\t\t\t}
\t\t\telse {
\t\t\t\t\$colspace = 'RGB';
\t\t\t\t\$col1 = '5'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].chr(100);
\t\t\t\t\$col2 = '5'.\$sh['col'][1].\$sh['col'][2].\$sh['col'][3].chr(0);
\t\t\t}

\t\t\t// Use clipping path as set above (and rectangle around page) to clip area outside box
\t\t\t\$shadow .= \$s;\t// Use the clipping path with W*
\t\t\t\$shadow .= sprintf('0 %.3F m %.3F %.3F l ', \$this->h*_MPDFK, \$this->w*_MPDFK, \$this->h*_MPDFK);
\t\t\t\$shadow .= sprintf('%.3F 0 l 0 0 l 0 %.3F l ', \$this->w*_MPDFK, \$this->h*_MPDFK);
\t\t\t\$shadow .= 'W n'.\"\\n\";

\t\t\t\$sh['blur'] = abs(\$sh['blur']);\t// cannot have negative blur value
\t\t\t// Ensure spread/blur do not make effective shadow width/height < 0
\t\t\t// Could do more complex things but this just adjusts spread value
\t\t\tif (-\$sh['spread'] + \$sh['blur']/2 > min(\$w/2, \$h/2)) {
\t\t\t\t\$sh['spread'] = \$sh['blur']/2 - min(\$w/2, \$h/2) + 0.01;
\t\t\t}
\t\t\t// Shadow Offset
\t\t\tif (\$sh['x'] || \$sh['y']) \$shadow .= sprintf(' q 1 0 0 1 %.4F %.4F cm', \$sh['x']*_MPDFK, -\$sh['y']*_MPDFK).\"\\n\";

\t\t\t// Set path for INNER shadow
\t\t\t\$shadow .= ' q 0 w ';
\t\t\t\$shadow .= \$this->SetFColor(\$col1, true).\"\\n\";
\t\t\tif (\$col1{0}==5 && ord(\$col1{4})<100) {\t// RGBa
\t\t\t\t\$shadow .= \$this->SetAlpha(ord(\$col1{4})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t}
\t\t\telse if (\$col1{0}==6 && ord(\$col1{5})<100) {\t// CMYKa
\t\t\t\t\$shadow .= \$this->SetAlpha(ord(\$col1{5})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t}
\t\t\telse if (\$col1{0}==1 && \$col1{2}==1 && ord(\$col1{3})<100) {\t// Gray
\t\t\t\t\$shadow .= \$this->SetAlpha(ord(\$col1{3})/100, 'Normal', true, 'F').\"\\n\";
\t\t\t}

\t\t\t// Blur edges
\t\t\t\$mag = 0.551784;\t// Bezier Control magic number for 4-part spline for circle/ellipse
\t\t\t\$mag2 = 0.551784;\t// Bezier Control magic number to fill in edge of blurred rectangle
\t\t\t\$d1 = \$sh['spread']+\$sh['blur']/2;
\t\t\t\$d2 = \$sh['spread']-\$sh['blur']/2;
\t\t\t\$bl = \$sh['blur'];
\t\t\t\$x00 = \$x0 - \$d1;
\t\t\t\$y00 = \$y0 - \$d1;
\t\t\t\$w00 = \$w + \$d1*2;
\t\t\t\$h00 = \$h + \$d1*2;

\t\t\t// If any border-radius is greater width-negative spread(inner edge), ignore radii for shadow or screws up
\t\t\t\$flatten = false;
\t\t\tif (max(\$brbgTR_H, \$brbgTL_H, \$brbgBR_H, \$brbgBL_H) >= \$w+\$d2) { \$flatten = true; }
\t\t\tif (max(\$brbgTR_V, \$brbgTL_V, \$brbgBR_V, \$brbgBL_V) >= \$h+\$d2) { \$flatten = true; }


\t\t\t// TOP RIGHT corner
\t\t\t\$p1x = \$x00+\$w00-\$d1-\$brbgTR_H;\t\$p1c2x = \$p1x +(\$d2+\$brbgTR_H)*\$mag;
\t\t\t\$p1y = \$y00+\$bl;
\t\t\t\$p2x = \$x00+\$w00-\$d1-\$brbgTR_H;\t\$p2c2x = \$p2x + (\$d1+\$brbgTR_H)*\$mag;
\t\t\t\$p2y = \$y00;\t\t\t\t\$p2c1y = \$p2y + \$bl/2;
\t\t\t\$p3x = \$x00+\$w00;\t\t\t\t\$p3c2x = \$p3x - \$bl/2;
\t\t\t\$p3y = \$y00+\$d1+\$brbgTR_V;\t\t\$p3c1y = \$p3y - (\$d1+\$brbgTR_V)*\$mag;
\t\t\t\$p4x = \$x00+\$w00-\$bl;
\t\t\t\$p4y = \$y00+\$d1+\$brbgTR_V;\t\t\$p4c2y = \$p4y - (\$d2+\$brbgTR_V)*\$mag;
\t\t\tif (-\$d2 > min(\$brbgTR_H, \$brbgTR_V) || \$flatten) {
\t\t\t\t\$p1x = \$x00+\$w00-\$bl;\t\$p1c2x = \$p1x;
\t\t\t\t\$p2x = \$x00+\$w00-\$bl;\t\$p2c2x = \$p2x + \$bl*\$mag2;
\t\t\t\t\$p3y = \$y00+\$bl;\t\t\$p3c1y = \$p3y - \$bl*\$mag2;
\t\t\t\t\$p4y = \$y00+\$bl;\t\t\$p4c2y = \$p4y ;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F m ', (\$p1x )*_MPDFK, (\$this->h-(\$p1y ))*_MPDFK);
\t\t\t\$shadow .= sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c ', (\$p1c2x)*_MPDFK, (\$this->h-(\$p1y))*_MPDFK, (\$p4x)*_MPDFK, (\$this->h-(\$p4c2y))*_MPDFK, (\$p4x)*_MPDFK, (\$this->h-(\$p4y))*_MPDFK);
\t\t\t\$patch_array[0]['f']=0;
\t\t\t\$patch_array[0]['points']=array(\$p1x,\$p1y, \$p1x,\$p1y,
\t\t\t\t\$p2x,\$p2c1y, \$p2x,\$p2y, \$p2c2x,\$p2y,
\t\t\t\t\$p3x,\$p3c1y, \$p3x,\$p3y, \$p3c2x,\$p3y,
\t\t\t\t\$p4x,\$p4y, \$p4x,\$p4y, \$p4x,\$p4c2y,
\t\t\t\t\$p1c2x,\$p1y);
\t\t\t\$patch_array[0]['colors'] = array(\$col1,\$col2,\$col2,\$col1);


\t\t\t// RIGHT
\t\t\t\$p1x = \$x00+\$w00;\t// control point only matches p3 preceding
\t\t\t\$p1y = \$y00+\$d1+\$brbgTR_V;
\t\t\t\$p2x = \$x00+\$w00-\$bl;\t// control point only matches p4 preceding
\t\t\t\$p2y = \$y00+\$d1+\$brbgTR_V;
\t\t\t\$p3x = \$x00+\$w00-\$bl;
\t\t\t\$p3y = \$y00+\$h00-\$d1-\$brbgBR_V;
\t\t\t\$p4x = \$x00+\$w00;\t\t\$p4c1x = \$p4x-\$bl/2;
\t\t\t\$p4y = \$y00+\$h00-\$d1-\$brbgBR_V;
\t\t\tif (-\$d2 > min(\$brbgTR_H, \$brbgTR_V) || \$flatten) {
\t\t\t\t\$p1y = \$y00+\$bl;
\t\t\t\t\$p2y = \$y00+\$bl;
\t\t\t}
\t\t\tif (-\$d2 > min(\$brbgBR_H, \$brbgBR_V) || \$flatten) {
\t\t\t\t\$p3y = \$y00+\$h00-\$bl;
\t\t\t\t\$p4y = \$y00+\$h00-\$bl;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F l ', (\$p3x )*_MPDFK, (\$this->h-(\$p3y ))*_MPDFK);
\t\t\t\$patch_array[1]['f']=2;
\t\t\t\$patch_array[1]['points']=array(\$p2x,\$p2y,
\t\t\t\t\$p3x,\$p3y, \$p3x,\$p3y, \$p3x,\$p3y,
\t\t\t\t\$p4c1x,\$p4y, \$p4x,\$p4y, \$p4x,\$p4y,
\t\t\t\t\$p1x,\$p1y);
\t\t\t\$patch_array[1]['colors'] = array(\$col1,\$col2);


\t\t\t// BOTTOM RIGHT corner
\t\t\t\$p1x = \$x00+\$w00-\$bl;\t\t// control points only matches p3 preceding
\t\t\t\$p1y = \$y00+\$h00-\$d1-\$brbgBR_V;\t\t\$p1c2y = \$p1y + (\$d2+\$brbgBR_V)*\$mag;
\t\t\t\$p2x = \$x00+\$w00;\t\t\t\t\t// control point only matches p4 preceding
\t\t\t\$p2y = \$y00+\$h00-\$d1-\$brbgBR_V;\t\t\$p2c2y = \$p2y + (\$d1+\$brbgBR_V)*\$mag;
\t\t\t\$p3x = \$x00+\$w00-\$d1-\$brbgBR_H;\t\t\$p3c1x = \$p3x + (\$d1+\$brbgBR_H)*\$mag;
\t\t\t\$p3y = \$y00+\$h00;\t\t\t\t\t\$p3c2y = \$p3y - \$bl/2;
\t\t\t\$p4x = \$x00+\$w00-\$d1-\$brbgBR_H;\t\t\$p4c2x = \$p4x + (\$d2+\$brbgBR_H)*\$mag;
\t\t\t\$p4y = \$y00+\$h00-\$bl;

\t\t\tif (-\$d2 > min(\$brbgBR_H, \$brbgBR_V) || \$flatten) {
\t\t\t\t\$p1y = \$y00+\$h00-\$bl;\t\t\$p1c2y = \$p1y;
\t\t\t\t\$p2y = \$y00+\$h00-\$bl;\t\t\$p2c2y = \$p2y + \$bl*\$mag2;
\t\t\t\t\$p3x = \$x00+\$w00-\$bl;\t\t\$p3c1x = \$p3x + \$bl*\$mag2;
\t\t\t\t\$p4x = \$x00+\$w00-\$bl;\t\t\$p4c2x = \$p4x;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c ', (\$p1x)*_MPDFK, (\$this->h-(\$p1c2y))*_MPDFK, (\$p4c2x)*_MPDFK, (\$this->h-(\$p4y))*_MPDFK, (\$p4x)*_MPDFK, (\$this->h-(\$p4y))*_MPDFK);
\t\t\t\$patch_array[2]['f']=2;
\t\t\t\$patch_array[2]['points']=array(\$p2x,\$p2c2y,
\t\t\t\t\$p3c1x,\$p3y, \$p3x,\$p3y, \$p3x,\$p3c2y,
\t\t\t\t\$p4x,\$p4y, \$p4x,\$p4y, \$p4c2x,\$p4y,
\t\t\t\t\$p1x,\$p1c2y);
\t\t\t\$patch_array[2]['colors'] = array(\$col2,\$col1);



\t\t\t// BOTTOM
\t\t\t\$p1x = \$x00+\$w00-\$d1-\$brbgBR_H;\t// control point only matches p3 preceding
\t\t\t\$p1y = \$y00+\$h00;
\t\t\t\$p2x = \$x00+\$w00-\$d1-\$brbgBR_H;\t// control point only matches p4 preceding
\t\t\t\$p2y = \$y00+\$h00-\$bl;
\t\t\t\$p3x = \$x00+\$d1+\$brbgBL_H;
\t\t\t\$p3y = \$y00+\$h00-\$bl;
\t\t\t\$p4x = \$x00+\$d1+\$brbgBL_H;
\t\t\t\$p4y = \$y00+\$h00;\t\t\$p4c1y = \$p4y - \$bl/2;

\t\t\tif (-\$d2 > min(\$brbgBR_H, \$brbgBR_V) || \$flatten) {
\t\t\t\t\$p1x = \$x00+\$w00-\$bl;
\t\t\t\t\$p2x = \$x00+\$w00-\$bl;
\t\t\t}
\t\t\tif (-\$d2 > min(\$brbgBL_H, \$brbgBL_V) || \$flatten) {
\t\t\t\t\$p3x = \$x00+\$bl;
\t\t\t\t\$p4x = \$x00+\$bl;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F l ', (\$p3x )*_MPDFK, (\$this->h-(\$p3y ))*_MPDFK);
\t\t\t\$patch_array[3]['f']=2;
\t\t\t\$patch_array[3]['points']=array(\$p2x,\$p2y,
\t\t\t\t\$p3x,\$p3y, \$p3x,\$p3y, \$p3x,\$p3y,
\t\t\t\t\$p4x,\$p4c1y, \$p4x,\$p4y, \$p4x,\$p4y,
\t\t\t\t\$p1x,\$p1y);
\t\t\t\$patch_array[3]['colors'] = array(\$col1,\$col2);

\t\t\t// BOTTOM LEFT corner
\t\t\t\$p1x = \$x00+\$d1+\$brbgBL_H;\t\t\$p1c2x = \$p1x - (\$d2+\$brbgBL_H)*\$mag;\t// control points only matches p3 preceding
\t\t\t\$p1y = \$y00+\$h00-\$bl;
\t\t\t\$p2x = \$x00+\$d1+\$brbgBL_H;\t\t\$p2c2x = \$p2x - (\$d1+\$brbgBL_H)*\$mag;\t// control point only matches p4 preceding
\t\t\t\$p2y = \$y00+\$h00;
\t\t\t\$p3x = \$x00;\t\t\t\t\$p3c2x = \$p3x + \$bl/2;
\t\t\t\$p3y = \$y00+\$h00-\$d1-\$brbgBL_V;\t\$p3c1y = \$p3y + (\$d1+\$brbgBL_V)*\$mag;
\t\t\t\$p4x = \$x00+\$bl;
\t\t\t\$p4y = \$y00+\$h00-\$d1-\$brbgBL_V;\t\$p4c2y = \$p4y + (\$d2+\$brbgBL_V)*\$mag;
\t\t\tif (-\$d2 > min(\$brbgBL_H, \$brbgBL_V) || \$flatten) {
\t\t\t\t\$p1x = \$x00+\$bl;\t\t\$p1c2x = \$p1x;
\t\t\t\t\$p2x = \$x00+\$bl;\t\t\$p2c2x = \$p2x - \$bl*\$mag2;
\t\t\t\t\$p3y = \$y00+\$h00-\$bl;\t\$p3c1y = \$p3y + \$bl*\$mag2;
\t\t\t\t\$p4y = \$y00+\$h00-\$bl;\t\$p4c2y = \$p4y;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c ', (\$p1c2x)*_MPDFK, (\$this->h-(\$p1y))*_MPDFK, (\$p4x)*_MPDFK, (\$this->h-(\$p4c2y))*_MPDFK, (\$p4x)*_MPDFK, (\$this->h-(\$p4y))*_MPDFK);
\t\t\t\$patch_array[4]['f']=2;
\t\t\t\$patch_array[4]['points']=array(\$p2c2x,\$p2y,
\t\t\t\t\$p3x,\$p3c1y, \$p3x,\$p3y, \$p3c2x,\$p3y,
\t\t\t\t\$p4x,\$p4y, \$p4x,\$p4y, \$p4x,\$p4c2y,
\t\t\t\t\$p1c2x,\$p1y);
\t\t\t\$patch_array[4]['colors'] = array(\$col2,\$col1);


\t\t\t// LEFT - joins on the right (C3-C4 of previous): f = 2
\t\t\t\$p1x = \$x00;\t// control point only matches p3 preceding
\t\t\t\$p1y = \$y00+\$h00-\$d1-\$brbgBL_V;
\t\t\t\$p2x = \$x00+\$bl;\t// control point only matches p4 preceding
\t\t\t\$p2y = \$y00+\$h00-\$d1-\$brbgBL_V;
\t\t\t\$p3x = \$x00+\$bl;
\t\t\t\$p3y = \$y00+\$d1+\$brbgTL_V;
\t\t\t\$p4x = \$x00;\t\t\$p4c1x = \$p4x + \$bl/2;
\t\t\t\$p4y = \$y00+\$d1+\$brbgTL_V;
\t\t\tif (-\$d2 > min(\$brbgBL_H, \$brbgBL_V) || \$flatten) {
\t\t\t\t\$p1y = \$y00+\$h00-\$bl;
\t\t\t\t\$p2y = \$y00+\$h00-\$bl;
\t\t\t}
\t\t\tif (-\$d2 > min(\$brbgTL_H, \$brbgTL_V) || \$flatten) {
\t\t\t\t\$p3y = \$y00+\$bl;
\t\t\t\t\$p4y = \$y00+\$bl;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F l ', (\$p3x )*_MPDFK, (\$this->h-(\$p3y ))*_MPDFK);
\t\t\t\$patch_array[5]['f']=2;
\t\t\t\$patch_array[5]['points']=array(\$p2x,\$p2y,
\t\t\t\t\$p3x,\$p3y, \$p3x,\$p3y, \$p3x,\$p3y,
\t\t\t\t\$p4c1x,\$p4y, \$p4x,\$p4y, \$p4x,\$p4y,
\t\t\t\t\$p1x,\$p1y);
\t\t\t\$patch_array[5]['colors'] = array(\$col1,\$col2);

\t\t\t// TOP LEFT corner
\t\t\t\$p1x = \$x00+\$bl;\t\t// control points only matches p3 preceding
\t\t\t\$p1y = \$y00+\$d1+\$brbgTL_V;\t\$p1c2y = \$p1y  - (\$d2+\$brbgTL_V)*\$mag;
\t\t\t\$p2x = \$x00;\t\t\t// control point only matches p4 preceding
\t\t\t\$p2y = \$y00+\$d1+\$brbgTL_V;\t\$p2c2y = \$p2y - (\$d1+\$brbgTL_V)*\$mag;
\t\t\t\$p3x = \$x00+\$d1+\$brbgTL_H;\t\$p3c1x = \$p3x - (\$d1+\$brbgTL_H)*\$mag;
\t\t\t\$p3y = \$y00;\t\t\t\$p3c2y = \$p3y + \$bl/2;
\t\t\t\$p4x = \$x00+\$d1+\$brbgTL_H;\t\$p4c2x = \$p4x - (\$d2+\$brbgTL_H)*\$mag;
\t\t\t\$p4y = \$y00+\$bl;

\t\t\tif (-\$d2 > min(\$brbgTL_H, \$brbgTL_V) || \$flatten) {
\t\t\t\t\$p1y = \$y00+\$bl;\t\$p1c2y = \$p1y;
\t\t\t\t\$p2y = \$y00+\$bl;\t\$p2c2y = \$p2y - \$bl*\$mag2;
\t\t\t\t\$p3x = \$x00+\$bl;\t\$p3c1x = \$p3x - \$bl*\$mag2;
\t\t\t\t\$p4x = \$x00+\$bl;\t\$p4c2x = \$p4x ;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c ', (\$p1x)*_MPDFK, (\$this->h-(\$p1c2y))*_MPDFK, (\$p4c2x)*_MPDFK, (\$this->h-(\$p4y))*_MPDFK, (\$p4x)*_MPDFK, (\$this->h-(\$p4y))*_MPDFK);
\t\t\t\$patch_array[6]['f']=2;
\t\t\t\$patch_array[6]['points']=array(\$p2x,\$p2c2y,
\t\t\t\t\$p3c1x,\$p3y, \$p3x,\$p3y, \$p3x,\$p3c2y,
\t\t\t\t\$p4x,\$p4y, \$p4x,\$p4y, \$p4c2x,\$p4y,
\t\t\t\t\$p1x,\$p1c2y);
\t\t\t\$patch_array[6]['colors'] = array(\$col2,\$col1);


\t\t\t// TOP - joins on the right (C3-C4 of previous): f = 2
\t\t\t\$p1x = \$x00+\$d1+\$brbgTL_H;\t// control point only matches p3 preceding
\t\t\t\$p1y = \$y00;
\t\t\t\$p2x = \$x00+\$d1+\$brbgTL_H;\t// control point only matches p4 preceding
\t\t\t\$p2y = \$y00+\$bl;
\t\t\t\$p3x = \$x00+\$w00-\$d1-\$brbgTR_H;
\t\t\t\$p3y = \$y00+\$bl;
\t\t\t\$p4x = \$x00+\$w00-\$d1-\$brbgTR_H;
\t\t\t\$p4y = \$y00;\t\t\$p4c1y = \$p4y + \$bl/2;
\t\t\tif (-\$d2 > min(\$brbgTL_H, \$brbgTL_V) || \$flatten) {
\t\t\t\t\$p1x = \$x00+\$bl;
\t\t\t\t\$p2x = \$x00+\$bl;
\t\t\t}
\t\t\tif (-\$d2 > min(\$brbgTR_H, \$brbgTR_V) || \$flatten) {
\t\t\t\t\$p3x = \$x00+\$w00-\$bl;
\t\t\t\t\$p4x = \$x00+\$w00-\$bl;
\t\t\t}

\t\t\t\$shadow .= sprintf('%.3F %.3F l ', (\$p3x )*_MPDFK, (\$this->h-(\$p3y ))*_MPDFK);
\t\t\t\$patch_array[7]['f']=2;
\t\t\t\$patch_array[7]['points']=array(\$p2x,\$p2y,
\t\t\t\t\$p3x,\$p3y, \$p3x,\$p3y, \$p3x,\$p3y,
\t\t\t\t\$p4x,\$p4c1y, \$p4x,\$p4y, \$p4x,\$p4y,
\t\t\t\t\$p1x,\$p1y);
\t\t\t\$patch_array[7]['colors'] = array(\$col1,\$col2);

\t\t\t\$shadow .= ' h f Q '.\"\\n\";\t// Close path and Fill the inner solid shadow

\t\t\tif (\$bl) \$shadow .= \$this->grad->CoonsPatchMesh(\$x00,\$y00,\$w00,\$h00,\$patch_array,\$x00,\$x00+\$w00,\$y00,\$y00+\$h00, \$colspace, true);

\t\t\tif (\$sh['x'] || \$sh['y']) \$shadow .= ' Q'.\"\\n\"; \t// Shadow Offset
\t\t\t\$shadow .= ' Q'.\"\\n\";\t// Ends path no-op & Sets the clipping path

\t\t}
\t}

\t\$s .= ' W n ';\t// Ends path no-op & Sets the clipping path

\tif (\$this->blk[\$blvl]['bgcolor']) {
\t\t\$this->pageBackgrounds[\$blvl][] = array('x'=>\$x0, 'y'=>\$y0, 'w'=>\$w, 'h'=>\$h, 'col'=>\$this->blk[\$blvl]['bgcolorarray'], 'clippath'=>\$s, 'visibility'=>\$this->visibility, 'shadow'=>\$shadow, 'z-index'=>\$this->current_layer);\t// mPDF 5.6.01
\t}
\telse \tif (\$shadow) {
\t\t\$this->pageBackgrounds[\$blvl][] = array('shadowonly'=>true, 'col'=>'', 'clippath'=>'', 'visibility'=>\$this->visibility, 'shadow'=>\$shadow, 'z-index'=>\$this->current_layer);\t// mPDF 5.6.01
\t}

/*-- BACKGROUNDS --*/
\tif (isset(\$this->blk[\$blvl]['gradient'])) {
\t\t\$g = \$this->grad->parseBackgroundGradient(\$this->blk[\$blvl]['gradient']);
\t\tif (\$g) {
\t\t\t\$gx = \$x0;
\t\t\t\$gy = \$y0;
\t\t\t\$this->pageBackgrounds[\$blvl][] = array('gradient'=>true, 'x'=>\$gx, 'y'=>\$gy, 'w'=>\$w, 'h'=>\$h, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>\$s, 'visibility'=>\$this->visibility, 'z-index'=>\$this->current_layer);\t// mPDF 5.6.01
\t\t}
\t}
\tif (isset(\$this->blk[\$blvl]['background-image'])) {
\t   if (\$this->blk[\$blvl]['background-image']['gradient']  && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$this->blk[\$blvl]['background-image']['gradient'] )) {
\t\t\$g = \$this->grad->parseMozGradient( \$this->blk[\$blvl]['background-image']['gradient'] );
\t\tif (\$g) {
\t\t\t\$gx = \$x0;
\t\t\t\$gy = \$y0;
\t\t\t// mPDF 5.6.11
\t\t\t// origin specifies the background-positioning-area (bpa)
\t\t\tif (\$this->blk[\$blvl]['background-image']['origin'] == 'padding-box') {
\t\t\t\t\$gx += \$this->blk[\$blvl]['border_left']['w'];
\t\t\t\t\$w -= (\$this->blk[\$blvl]['border_left']['w'] + \$this->blk[\$blvl]['border_right']['w']);
\t\t\t\tif (\$this->blk[\$blvl]['border_top'] && \$divider != 'pagetop' && !\$continuingpage) {
\t\t\t\t\t\$gy += \$this->blk[\$blvl]['border_top']['w'];
\t\t\t\t}
\t\t\t\tif (\$this->blk[\$blvl]['border_bottom'] && \$blockstate != 1 && \$divider != 'pagebottom') {
\t\t\t\t\t\$gy1 = \$y1 - \$this->blk[\$blvl]['border_bottom']['w'];
\t\t\t\t}
\t\t\t\telse { \$gy1 = \$y1; }
\t\t\t\t\$h = \$gy1 - \$gy;
\t\t\t}
\t\t\telse if (\$this->blk[\$blvl]['background-image']['origin'] == 'content-box') {
\t\t\t\t\$gx += \$this->blk[\$blvl]['border_left']['w'] + \$this->blk[\$blvl]['padding_left'];
\t\t\t\t\$w -= (\$this->blk[\$blvl]['border_left']['w'] + \$this->blk[\$blvl]['padding_left'] + \$this->blk[\$blvl]['border_right']['w'] + \$this->blk[\$blvl]['padding_right']);
\t\t\t\tif (\$this->blk[\$blvl]['border_top'] && \$divider != 'pagetop' && !\$continuingpage) {
\t\t\t\t\t\$gy += \$this->blk[\$blvl]['border_top']['w'] + \$this->blk[\$blvl]['padding_top'];
\t\t\t\t}
\t\t\t\tif (\$this->blk[\$blvl]['border_bottom'] && \$blockstate != 1 && \$divider != 'pagebottom') {
\t\t\t\t\t\$gy1 = \$y1 - (\$this->blk[\$blvl]['border_bottom']['w'] + \$this->blk[\$blvl]['padding_bottom']);
\t\t\t\t}
\t\t\t\telse { \$gy1 = \$y1 - \$this->blk[\$blvl]['padding_bottom']; }
\t\t\t\t\$h = \$gy1 - \$gy;
\t\t\t}

\t\t\tif (isset(\$this->blk[\$blvl]['background-image']['size']['w']) && \$this->blk[\$blvl]['background-image']['size']['w']) {
\t\t\t\t\$size = \$this->blk[\$blvl]['background-image']['size'];
\t\t\t\tif (\$size['w']!='contain' && \$size['w']!='cover') {
\t\t\t\t\tif (stristr(\$size['w'] ,'%')) {
\t\t\t\t\t\t\$size['w'] += 0;
\t\t\t\t\t\t\$size['w'] /= 100;
\t\t\t\t\t\t\$w *= \$size['w'];
\t\t\t\t\t}
\t\t\t\t\telse if (\$size['w']!='auto') {
\t\t\t\t\t\t\$w = \$size['w'];
\t\t\t\t\t}
\t\t\t\t\tif (stristr(\$size['h'] ,'%')) {
\t\t\t\t\t\t\$size['h'] += 0;
\t\t\t\t\t\t\$size['h'] /= 100;
\t\t\t\t\t\t\$h *= \$size['h'];
\t\t\t\t\t}
\t\t\t\t\telse if (\$size['h']!='auto') {
\t\t\t\t\t\t\$h = \$size['h'];
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t\$this->pageBackgrounds[\$blvl][] = array('gradient'=>true, 'x'=>\$gx, 'y'=>\$gy, 'w'=>\$w, 'h'=>\$h, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>\$s, 'visibility'=>\$this->visibility, 'z-index'=>\$this->current_layer);\t// mPDF 5.6.01
\t\t}
\t   }
\t   else {
\t\t\$image_id = \$this->blk[\$blvl]['background-image']['image_id'];
\t\t\$orig_w = \$this->blk[\$blvl]['background-image']['orig_w'];
\t\t\$orig_h = \$this->blk[\$blvl]['background-image']['orig_h'];
\t\t\$x_pos = \$this->blk[\$blvl]['background-image']['x_pos'];
\t\t\$y_pos = \$this->blk[\$blvl]['background-image']['y_pos'];
\t\t\$x_repeat = \$this->blk[\$blvl]['background-image']['x_repeat'];
\t\t\$y_repeat = \$this->blk[\$blvl]['background-image']['y_repeat'];
\t\t\$resize = \$this->blk[\$blvl]['background-image']['resize'];
\t\t\$opacity = \$this->blk[\$blvl]['background-image']['opacity'];
\t\t\$itype = \$this->blk[\$blvl]['background-image']['itype'];
\t\t\$size = \$this->blk[\$blvl]['background-image']['size'];\t// mPDF 5.6.10
\t\t// mPDF 5.6.10
\t\t// origin specifies the background-positioning-area (bpa)
\t\t\$bpa = array('x'=>\$x0, 'y'=>\$y0, 'w'=>\$w, 'h'=>\$h);
\t\tif (\$this->blk[\$blvl]['background-image']['origin'] == 'padding-box') {
\t\t\t\$bpa['x'] = \$x0 + \$this->blk[\$blvl]['border_left']['w'];
\t\t\t\$bpa['w'] = \$w - (\$this->blk[\$blvl]['border_left']['w'] + \$this->blk[\$blvl]['border_right']['w']);
\t\t\tif (\$this->blk[\$blvl]['border_top'] && \$divider != 'pagetop' && !\$continuingpage) {
\t\t\t\t\$bpa['y'] = \$y0 + \$this->blk[\$blvl]['border_top']['w'];
\t\t\t}
\t\t\telse { \$bpa['y'] = \$y0; }
\t\t\tif (\$this->blk[\$blvl]['border_bottom'] && \$blockstate != 1 && \$divider != 'pagebottom') {
\t\t\t\t\$bpay = \$y1 - \$this->blk[\$blvl]['border_bottom']['w'];
\t\t\t}
\t\t\telse { \$bpay = \$y1; }
\t\t\t\$bpa['h'] = \$bpay - \$bpa['y'];
\t\t}
\t\t// mPDF 5.6.09
\t\telse if (\$this->blk[\$blvl]['background-image']['origin'] == 'content-box') {
\t\t\t\$bpa['x'] = \$x0 + \$this->blk[\$blvl]['border_left']['w'] + \$this->blk[\$blvl]['padding_left'];
\t\t\t\$bpa['w'] = \$w - (\$this->blk[\$blvl]['border_left']['w'] + \$this->blk[\$blvl]['padding_left'] + \$this->blk[\$blvl]['border_right']['w'] + \$this->blk[\$blvl]['padding_right']);
\t\t\tif (\$this->blk[\$blvl]['border_top'] && \$divider != 'pagetop' && !\$continuingpage) {
\t\t\t\t\$bpa['y'] = \$y0 + \$this->blk[\$blvl]['border_top']['w'] + \$this->blk[\$blvl]['padding_top'];
\t\t\t}
\t\t\telse { \$bpa['y'] = \$y0 + \$this->blk[\$blvl]['padding_top']; }
\t\t\tif (\$this->blk[\$blvl]['border_bottom'] && \$blockstate != 1 && \$divider != 'pagebottom') {
\t\t\t\t\$bpay = \$y1 - (\$this->blk[\$blvl]['border_bottom']['w'] + \$this->blk[\$blvl]['padding_bottom']);
\t\t\t}
\t\t\telse { \$bpay = \$y1 - \$this->blk[\$blvl]['padding_bottom']; }
\t\t\t\$bpa['h'] = \$bpay - \$bpa['y'];
\t\t}
\t\t\$this->pageBackgrounds[\$blvl][] = array('x'=>\$x0, 'y'=>\$y0, 'w'=>\$w, 'h'=>\$h, 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>\$s, 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype, 'visibility'=>\$this->visibility, 'z-index'=>\$this->current_layer, 'size'=>\$size, 'bpa'=>\$bpa );\t// mPDF 5.6.01  5.6.10
\t   }
\t}
/*-- END BACKGROUNDS --*/

\t// Float DIV
\t\$this->blk[\$blvl]['bb_painted'][\$this->page] = true;

}

/*-- BORDER-RADIUS --*/

function _EllipseArc(\$x0, \$y0, \$rx, \$ry, \$seg = 1, \$part=false, \$start=false) {\t// Anticlockwise segment 1-4 TR-TL-BL-BR (part=1 or 2)
\t\$s = '';
   \tif (\$rx<0) { \$rx = 0; }
\tif (\$ry<0) { \$ry = 0; }
\t\$rx *= _MPDFK;
\t\$ry *= _MPDFK;
\t\$astart = 0;
\tif (\$seg == 1) {\t// Top Right
\t\t\$afinish = 90;
\t\t\$nSeg = 4;
\t}
\telse if (\$seg == 2) {\t// Top Left
\t\t\$afinish = 180;
\t\t\$nSeg = 8;
\t}
\telse if (\$seg == 3) {\t// Bottom Left
\t\t\$afinish = 270;
\t\t\$nSeg = 12;
\t}
\telse {\t\t\t// Bottom Right
\t\t\$afinish = 360;
\t\t\$nSeg = 16;
\t}
\t\$astart = deg2rad((float) \$astart);
\t\$afinish = deg2rad((float) \$afinish);
\t\$totalAngle = \$afinish - \$astart;
\t\$dt = \$totalAngle / \$nSeg;\t// segment angle
\t\$dtm = \$dt/3;
\t\$x0 *= _MPDFK;
\t\$y0 = (\$this->h - \$y0) * _MPDFK;
\t\$t1 = \$astart;
\t\$a0 = \$x0 + (\$rx * cos(\$t1));
\t\$b0 = \$y0 + (\$ry * sin(\$t1));
\t\$c0 = -\$rx * sin(\$t1);
\t\$d0 = \$ry * cos(\$t1);
\t\$op = false;
\tfor (\$i = 1; \$i <= \$nSeg; \$i++) {
\t\t// Draw this bit of the total curve
\t\t\$t1 = (\$i * \$dt) + \$astart;
\t\t\$a1 = \$x0 + (\$rx * cos(\$t1));
\t\t\$b1 = \$y0 + (\$ry * sin(\$t1));
\t\t\$c1 = -\$rx * sin(\$t1);
\t\t\$d1 = \$ry * cos(\$t1);
\t\tif (\$i>(\$nSeg-4) && (!\$part || (\$part == 1 && \$i<=\$nSeg-2) || (\$part == 2 && \$i>\$nSeg-2))) {
\t\t\tif (\$start && !\$op) {
           \t\t\t\$s .= sprintf('%.3F %.3F m ', \$a0, \$b0);
\t\t\t}
\t\t\t\$s .= sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c ', (\$a0 + (\$c0 * \$dtm)), (\$b0 + (\$d0 * \$dtm)), (\$a1 - (\$c1 * \$dtm)) , (\$b1 - (\$d1 * \$dtm)), \$a1 , \$b1 );
\t\t\t\$op = true;
\t\t}
\t\t\$a0 = \$a1;
\t\t\$b0 = \$b1;
\t\t\$c0 = \$c1;
\t\t\$d0 = \$d1;
\t}
\treturn \$s;
}
/*-- END BORDER-RADIUS --*/



function PaintDivLnBorder(\$state=0,\$blvl=0,\$h) {
\t// \$state = 0 normal; 1 top; 2 bottom; 3 top and bottom
\t\$this->ColDetails[\$this->CurrCol]['bottom_margin'] = \$this->y + \$h;

\t\$save_y = \$this->y;

\t\$w = \$this->blk[\$blvl]['width'];
\t\$x0 = \$this->x;\t\t\t\t// left
\t\$y0 = \$this->y;\t\t\t\t// top
\t\$x1 = \$this->x + \$w;\t\t\t// bottom
\t\$y1 = \$this->y + \$h;\t\t\t// bottom

\tif (\$this->blk[\$blvl]['border_top'] && (\$state==1 || \$state==3)) {
\t\t\$tbd = \$this->blk[\$blvl]['border_top'];
\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\t\$this->y = \$y0 + (\$tbd['w']/2);
\t\t\t// mPDF 5.6.56
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') {
\t\t\t\t\$this->_setDashBorder(\$tbd['style'],'',\$continuingpage,'T');
\t\t\t\t\$this->Line(\$x0 + (\$tbd['w']/2) , \$this->y , \$x0 + \$w - (\$tbd['w']/2), \$this->y);
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t\t\$this->Line(\$x0, \$this->y , \$x0 + \$w, \$this->y);
\t\t\t}
\t\t\t\$this->y += \$tbd['w'];
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$this->blk[\$blvl]['border_left']) {
\t\t\$tbd = \$this->blk[\$blvl]['border_left'];
\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\t// mPDF 5.6.56
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') {
\t\t\t\t\$this->y = \$y0 + (\$tbd['w']/2);
\t\t\t\t\$this->_setDashBorder(\$tbd['style'],'',\$continuingpage,'L');
\t\t\t\t\$this->Line(\$x0 + (\$tbd['w']/2), \$this->y, \$x0 + (\$tbd['w']/2), \$y0 + \$h -(\$tbd['w']/2));
\t\t\t}
\t\t\telse {
\t\t \t\t\$this->y = \$y0;
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t\t\$this->Line(\$x0 + (\$tbd['w']/2), \$this->y, \$x0 + (\$tbd['w']/2), \$y0 + \$h);
\t\t\t}
\t\t\t\$this->y += \$tbd['w'];
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$this->blk[\$blvl]['border_right']) {
\t\t\$tbd = \$this->blk[\$blvl]['border_right'];
\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\t// mPDF 5.6.56
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') {
\t\t \t\t\$this->y = \$y0 + (\$tbd['w']/2);
\t\t\t\t\$this->_setDashBorder(\$tbd['style'],'',\$continuingpage,'R');
\t\t\t\t\$this->Line(\$x0 + \$w - (\$tbd['w']/2), \$this->y, \$x0 + \$w - (\$tbd['w']/2), \$y0 + \$h - (\$tbd['w']/2));
\t\t\t}
\t\t\telse {
\t\t \t\t\$this->y = \$y0;
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t\t\$this->Line(\$x0 + \$w - (\$tbd['w']/2), \$this->y, \$x0 + \$w - (\$tbd['w']/2), \$y0 + \$h);
\t\t\t}
\t\t\t\$this->y += \$tbd['w'];
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$this->blk[\$blvl]['border_bottom'] && \$state > 1) {
\t\t\$tbd = \$this->blk[\$blvl]['border_bottom'];
\t\tif (isset(\$tbd['s']) && \$tbd['s']) {
\t\t\t\$this->_setBorderLine(\$tbd);
\t\t\t\$this->y = \$y0 + \$h - (\$tbd['w']/2);
\t\t\t// mPDF 5.6.56
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') {
\t\t\t\t\$this->_setDashBorder(\$tbd['style'],'',\$continuingpage,'B');
\t\t\t\t\$this->Line(\$x0 + (\$tbd['w']/2) , \$this->y, \$x0 + \$w - (\$tbd['w']/2), \$this->y);
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\$this->SetLineCap(0);
\t\t\t\t\$this->Line(\$x0, \$this->y, \$x0 + \$w, \$this->y);
\t\t\t}
\t\t\t\$this->y += \$tbd['w'];
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\t\$this->SetDash();
\t\$this->y = \$save_y;
}


function PaintImgBorder(\$objattr,\$is_table) {
\t// Borders are disabled in columns - messes up the repositioning in printcolumnbuffer
\tif (\$this->ColActive) { return ; }\t// *COLUMNS*
\tif (\$is_table) { \$k = \$this->shrin_k; } else { \$k = 1; }
\t\$h = (isset(\$objattr['BORDER-HEIGHT']) ? \$objattr['BORDER-HEIGHT'] : 0);
\t\$w = (isset(\$objattr['BORDER-WIDTH']) ? \$objattr['BORDER-WIDTH'] : 0);
\t\$x0 = (isset(\$objattr['BORDER-X']) ? \$objattr['BORDER-X'] : 0);
\t\$y0 = (isset(\$objattr['BORDER-Y']) ? \$objattr['BORDER-Y'] : 0);

\t// BORDERS
\tif (\$objattr['border_top']) {
\t\t\$tbd = \$objattr['border_top'];
\t\tif (!empty(\$tbd['s'])) {
\t\t\t\$this->_setBorderLine(\$tbd,\$k);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') { \$this->_setDashBorder(\$tbd['style'],'','','T'); }
\t\t\t\$this->Line(\$x0, \$y0, \$x0 + \$w, \$y0);
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$objattr['border_left']) {
\t\t\$tbd = \$objattr['border_left'];
\t\tif (!empty(\$tbd['s'])) {
\t\t\t\$this->_setBorderLine(\$tbd,\$k);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') { \$this->_setDashBorder(\$tbd['style'],'','','L'); }
\t\t\t\$this->Line(\$x0, \$y0, \$x0, \$y0 + \$h);
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$objattr['border_right']) {
\t\t\$tbd = \$objattr['border_right'];
\t\tif (!empty(\$tbd['s'])) {
\t\t\t\$this->_setBorderLine(\$tbd,\$k);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') { \$this->_setDashBorder(\$tbd['style'],'','','R'); }
\t\t\t\$this->Line(\$x0 + \$w, \$y0, \$x0 + \$w, \$y0 + \$h);
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\tif (\$objattr['border_bottom']) {
\t\t\$tbd = \$objattr['border_bottom'];
\t\tif (!empty(\$tbd['s'])) {
\t\t\t\$this->_setBorderLine(\$tbd,\$k);
\t\t\tif (\$tbd['style']=='dotted' || \$tbd['style']=='dashed') { \$this->_setDashBorder(\$tbd['style'],'','','B'); }
\t\t\t\$this->Line(\$x0, \$y0 + \$h, \$x0 + \$w, \$y0 + \$h);
\t\t\t// Reset Corners and Dash off
\t\t\t\$this->SetLineJoin(2);
\t\t\t\$this->SetLineCap(2);
\t\t\t\$this->SetDash();
\t\t}
\t}
\t\$this->SetDash();
\t\$this->SetAlpha(1);
}

/*-- END HTML-CSS --*/




function Reset() {
\t\$this->SetTColor(\$this->ConvertColor(0));
\t\$this->SetDColor(\$this->ConvertColor(0));
\t\$this->SetFColor(\$this->ConvertColor(255));
\t\$this->SetAlpha(1);
\t\$this->colorarray = '';

\t\$this->spanbgcolorarray = '';
\t\$this->spanbgcolor = false;
\t\$this->spanborder = false;
\t\$this->spanborddet = array();

\t\$this->ResetStyles();

\t\$this->HREF = '';
\t\$this->textparam = array();
\t\$this->SetTextOutline();

\t\$this->SUP = false;
\t\$this->SUB = false;
\t\$this->strike = false;
\t\$this->textshadow = '';

\t\$this->SetFont(\$this->default_font,'',0,false);
\t\$this->SetFontSize(\$this->default_font_size,false);

\t\$this->currentfontfamily = '';
\t\$this->currentfontsize = '';

/*-- TABLES --*/
\tif (\$this->tableLevel) {
\t\t\$this->SetLineHeight('',\$this->table_lineheight);\t// *TABLES*
\t}
\telse
/*-- END TABLES --*/
/*-- LISTS --*/

\tif (\$this->listlvl && \$this->list_lineheight[\$this->listlvl][\$this->bulletarray['occur']]) {
\t\t\$this->SetLineHeight('',\$this->list_lineheight[\$this->listlvl][\$this->bulletarray['occur']]);\t// sets default line height
\t}
\telse
/*-- END LISTS --*/
\tif (isset(\$this->blk[\$this->blklvl]['line_height']) && \$this->blk[\$this->blklvl]['line_height']) {
\t\t\$this->SetLineHeight('',\$this->blk[\$this->blklvl]['line_height']);\t// sets default line height
\t}

\t\$this->toupper = false;
\t\$this->tolower = false;
\t\$this->kerning = false;
\t\$this->lSpacingCSS = '';
\t\$this->wSpacingCSS = '';
\t\$this->fixedlSpacing = false;
\t\$this->minwSpacing = 0;
\t\$this->capitalize = false;
\t\$this->SetDash(); //restore to no dash
\t\$this->dash_on = false;
\t\$this->dotted_on = false;
\t\$this->divwidth = 0;
\t\$this->divheight = 0;
\t\$this->divalign = '';
\t\$this->divrevert = false;
\t\$this->oldy = -1;

\t\$bodystyle = array();
\tif (isset(\$this->cssmgr->CSS['BODY']['FONT-STYLE'])) { \$bodystyle['FONT-STYLE'] = \$this->cssmgr->CSS['BODY']['FONT-STYLE']; }
\tif (isset(\$this->cssmgr->CSS['BODY']['FONT-WEIGHT'])) { \$bodystyle['FONT-WEIGHT'] = \$this->cssmgr->CSS['BODY']['FONT-WEIGHT']; }
\tif (isset(\$this->cssmgr->CSS['BODY']['COLOR'])) { \$bodystyle['COLOR'] = \$this->cssmgr->CSS['BODY']['COLOR']; }
\tif (isset(\$bodystyle)) { \$this->setCSS(\$bodystyle,'BLOCK','BODY'); }

}

/*-- HTML-CSS --*/
function ReadMetaTags(\$html) {
\t// changes anykey=anyvalue to anykey=\"anyvalue\" (only do this when this happens inside tags)
\t\$regexp = '/ (\\\\w+?)=([^\\\\s>\"]+)/si';
 \t\$html = preg_replace(\$regexp,\" \\\$1=\\\"\\\$2\\\"\",\$html);
\tif (preg_match('/<title>(.*?)<\\/title>/si',\$html,\$m)) {
\t\t\$this->SetTitle(\$m[1]);
\t}
\tpreg_match_all('/<meta [^>]*?(name|content)=\"([^>]*?)\" [^>]*?(name|content)=\"([^>]*?)\".*?>/si',\$html,\$aux);
\t\$firstattr = \$aux[1];
\t\$secondattr = \$aux[3];
\tfor( \$i = 0 ; \$i < count(\$aux[0]) ; \$i++) {

\t\t\$name = ( strtoupper(\$firstattr[\$i]) == \"NAME\" )? strtoupper(\$aux[2][\$i]) : strtoupper(\$aux[4][\$i]);
\t\t\$content = ( strtoupper(\$firstattr[\$i]) == \"CONTENT\" )? \$aux[2][\$i] : \$aux[4][\$i];
\t\tswitch(\$name) {
\t\t\tcase \"KEYWORDS\": \$this->SetKeywords(\$content); break;
\t\t\tcase \"AUTHOR\": \$this->SetAuthor(\$content); break;
\t\t\tcase \"DESCRIPTION\": \$this->SetSubject(\$content); break;
\t\t}
\t}
}


function ReadCharset(\$html) {
\t// Charset conversion
\tif (\$this->allow_charset_conversion) {
\t   if (preg_match('/<head.*charset=([^\\'\\\"\\s]*).*<\\/head>/si',\$html,\$m)) {
\t\tif (strtoupper(\$m[1]) != 'UTF-8') {
\t\t\t\$this->charset_in = strtoupper(\$m[1]);
\t\t}
\t   }
\t}
}

function setCSS(\$arrayaux,\$type='',\$tag='') {\t// type= INLINE | BLOCK | LIST // tag= BODY
\tif (!is_array(\$arrayaux)) return; //Removes PHP Warning
\t// mPDF 5.7.3  inline text-decoration parameters
\t\$preceeding_fontkey = \$this->FontFamily . \$this->FontStyle;
\t\$preceeding_fontsize = \$this->FontSize;

\t// Set font size first so that e.g. MARGIN 0.83em works on font size for this element
\tif (isset(\$arrayaux['FONT-SIZE'])) {
\t\t\$v = \$arrayaux['FONT-SIZE'];
\t\tif(is_numeric(\$v[0])) {
\t\t\tif (\$type == 'BLOCK' && \$this->blklvl>0 && isset(\$this->blk[\$this->blklvl-1]['InlineProperties']) && isset(\$this->blk[\$this->blklvl-1]['InlineProperties']['size'])) {
\t\t\t\t\$mmsize = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['InlineProperties']['size']);
\t\t\t}
\t\t\telse {
\t\t\t\t\$mmsize = \$this->ConvertSize(\$v,\$this->FontSize);
\t\t\t}
\t\t\t\$this->SetFontSize( \$mmsize*(_MPDFK),false ); //Get size in points (pt)
\t\t}
\t\telse{
  \t\t\t\$v = strtoupper(\$v);
\t\t\tif (isset(\$this->fontsizes[\$v])) {
\t\t\t\t\$this->SetFontSize( \$this->fontsizes[\$v]* \$this->default_font_size,false);
\t\t\t}
\t\t}
\t\tif (\$tag == 'BODY') { \$this->SetDefaultFontSize(\$this->FontSizePt); }
\t}


\tif (\$this->useLang && !\$this->usingCoreFont) {
\t   if (isset(\$arrayaux['LANG']) && \$arrayaux['LANG'] && \$arrayaux['LANG'] != \$this->default_lang && ((strlen(\$arrayaux['LANG']) == 5 && \$arrayaux['LANG'] != 'UTF-8') || strlen(\$arrayaux['LANG']) == 2)) {
\t\tlist (\$coreSuitable,\$mpdf_pdf_unifonts) = GetLangOpts(\$arrayaux['LANG'], \$this->useAdobeCJK);
\t\tif (\$mpdf_pdf_unifonts) { \$this->RestrictUnicodeFonts(\$mpdf_pdf_unifonts); }
\t\telse { \$this->RestrictUnicodeFonts(\$this->default_available_fonts ); }
\t\tif (\$tag == 'BODY') {
\t\t\t\$this->currentLang = \$arrayaux['LANG'];
\t\t\t\$this->default_lang = \$arrayaux['LANG'];
\t\t\tif (\$mpdf_pdf_unifonts) { \$this->default_available_fonts = \$mpdf_pdf_unifonts; }
\t\t}
\t   }
\t   else {
\t\t\$this->RestrictUnicodeFonts(\$this->default_available_fonts );
\t   }
\t}

\t// FOR INLINE and BLOCK OR 'BODY'
\tif (isset(\$arrayaux['FONT-FAMILY'])) {
\t\t\$v = \$arrayaux['FONT-FAMILY'];
\t\t//If it is a font list, get all font types
\t\t\$aux_fontlist = explode(\",\",\$v);
\t\t\$found = 0;
\t\tforeach(\$aux_fontlist AS \$f) {
\t\t\t\$fonttype = trim(\$f);
\t\t\t\$fonttype = preg_replace('/[\"\\']*(.*?)[\"\\']*/','\\\\1',\$fonttype);
\t\t\t\$fonttype = preg_replace('/ /','',\$fonttype);
\t\t\t\$v = strtolower(trim(\$fonttype));
\t\t\tif (isset(\$this->fonttrans[\$v]) && \$this->fonttrans[\$v]) { \$v = \$this->fonttrans[\$v]; }
\t\t\tif ((!\$this->onlyCoreFonts && in_array(\$v,\$this->available_unifonts)) ||
\t\t\t\tin_array(\$v,array('ccourier','ctimes','chelvetica')) ||
\t\t\t\t(\$this->onlyCoreFonts && in_array(\$v,array('courier','times','helvetica','arial'))) ||
\t\t\t\tin_array(\$v, array('sjis','uhc','big5','gb'))) {
\t\t\t\t\$fonttype = \$v;
\t\t\t\t\$found = 1;
\t\t\t\tbreak;
\t\t\t}
\t\t}
\t\tif (!\$found) {
\t\t   foreach(\$aux_fontlist AS \$f) {
\t\t\t\$fonttype = trim(\$f);
\t\t\t\$fonttype = preg_replace('/[\"\\']*(.*?)[\"\\']*/','\\\\1',\$fonttype);
\t\t\t\$fonttype = preg_replace('/ /','',\$fonttype);
\t\t\t\$v = strtolower(trim(\$fonttype));
\t\t\tif (isset(\$this->fonttrans[\$v]) && \$this->fonttrans[\$v]) { \$v = \$this->fonttrans[\$v]; }
\t\t\tif (in_array(\$v,\$this->sans_fonts) || in_array(\$v,\$this->serif_fonts) || in_array(\$v,\$this->mono_fonts) ) {
\t\t\t\t\$fonttype = \$v;
\t\t\t\tbreak;
\t\t\t}
\t\t   }
\t\t}

\t\tif (\$tag == 'BODY') {
\t\t\t\$this->SetDefaultFont(\$fonttype);
\t\t}
\t\t\$this->SetFont(\$fonttype,\$this->currentfontstyle,0,false);
\t}
\telse {
\t\t\$this->SetFont(\$this->currentfontfamily,\$this->currentfontstyle,0,false);
\t}

   foreach(\$arrayaux as \$k => \$v) {
\tif (\$type != 'INLINE' && \$tag != 'BODY' && \$type != 'LIST') {
\t  switch(\$k){
\t\t// BORDERS
\t\tcase 'BORDER-TOP':
\t\t\t\$this->blk[\$this->blklvl]['border_top'] = \$this->border_details(\$v);
\t\t\tif (\$this->blk[\$this->blklvl]['border_top']['s']) { \$this->blk[\$this->blklvl]['border'] = 1; }
\t\t\tbreak;
\t\tcase 'BORDER-BOTTOM':
\t\t\t\$this->blk[\$this->blklvl]['border_bottom'] = \$this->border_details(\$v);
\t\t\tif (\$this->blk[\$this->blklvl]['border_bottom']['s']) { \$this->blk[\$this->blklvl]['border'] = 1; }
\t\t\tbreak;
\t\tcase 'BORDER-LEFT':
\t\t\t\$this->blk[\$this->blklvl]['border_left'] = \$this->border_details(\$v);
\t\t\tif (\$this->blk[\$this->blklvl]['border_left']['s']) { \$this->blk[\$this->blklvl]['border'] = 1; }
\t\t\tbreak;
\t\tcase 'BORDER-RIGHT':
\t\t\t\$this->blk[\$this->blklvl]['border_right'] = \$this->border_details(\$v);
\t\t\tif (\$this->blk[\$this->blklvl]['border_right']['s']) { \$this->blk[\$this->blklvl]['border'] = 1; }
\t\t\tbreak;

\t\t// PADDING
\t\tcase 'PADDING-TOP':
\t\t\t\$this->blk[\$this->blklvl]['padding_top'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'PADDING-BOTTOM':
\t\t\t\$this->blk[\$this->blklvl]['padding_bottom'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'PADDING-LEFT':
\t\t\t\$this->blk[\$this->blklvl]['padding_left'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'PADDING-RIGHT':
\t\t\t\$this->blk[\$this->blklvl]['padding_right'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;

\t\t// MARGINS
\t\tcase 'MARGIN-TOP':
\t\t\t\$tmp = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tif (isset(\$this->blk[\$this->blklvl]['lastbottommargin'])) {
\t\t\t\tif (\$tmp > \$this->blk[\$this->blklvl]['lastbottommargin']) {
\t\t\t\t\t\$tmp -= \$this->blk[\$this->blklvl]['lastbottommargin'];
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$tmp = 0;
\t\t\t\t}
\t\t\t}
\t\t\t\$this->blk[\$this->blklvl]['margin_top'] = \$tmp;
\t\t\tbreak;
\t\tcase 'MARGIN-BOTTOM':
\t\t\t\$this->blk[\$this->blklvl]['margin_bottom'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'MARGIN-LEFT':
\t\t\t\$this->blk[\$this->blklvl]['margin_left'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'MARGIN-RIGHT':
\t\t\t\$this->blk[\$this->blklvl]['margin_right'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;

/*-- BORDER-RADIUS --*/
\t\tcase 'BORDER-TOP-LEFT-RADIUS-H':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_TL_H'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'BORDER-TOP-LEFT-RADIUS-V':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_TL_V'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'BORDER-TOP-RIGHT-RADIUS-H':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_TR_H'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'BORDER-TOP-RIGHT-RADIUS-V':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_TR_V'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'BORDER-BOTTOM-LEFT-RADIUS-H':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_BL_H'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'BORDER-BOTTOM-LEFT-RADIUS-V':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_BL_V'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'BORDER-BOTTOM-RIGHT-RADIUS-H':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_BR_H'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
\t\tcase 'BORDER-BOTTOM-RIGHT-RADIUS-V':
\t\t\t\$this->blk[\$this->blklvl]['border_radius_BR_V'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\tbreak;
/*-- END BORDER-RADIUS --*/

\t\tcase 'BOX-SHADOW':
\t\t\t\$bs = \$this->cssmgr->setCSSboxshadow(\$v);
\t\t\tif (\$bs) { \$this->blk[\$this->blklvl]['box_shadow'] = \$bs; }
\t\t\tbreak;

\t\tcase 'BACKGROUND-CLIP':
\t\t\tif (strtoupper(\$v) == 'PADDING-BOX') { \$this->blk[\$this->blklvl]['background_clip'] = 'padding-box'; }
\t\t\telse if (strtoupper(\$v) == 'CONTENT-BOX') { \$this->blk[\$this->blklvl]['background_clip'] = 'content-box'; }\t// mPDF 5.6.09
\t\t\tbreak;

\t\tcase 'PAGE-BREAK-AFTER':
\t\t\tif (strtoupper(\$v) == 'AVOID') { \$this->blk[\$this->blklvl]['page_break_after_avoid'] = true; }
\t\t\telse if (strtoupper(\$v) == 'ALWAYS' || strtoupper(\$v) == 'LEFT' || strtoupper(\$v) == 'RIGHT') { \$this->blk[\$this->blklvl]['page_break_after'] = strtoupper(\$v) ; }
\t\t\tbreak;

\t\tcase 'WIDTH':
\t\t\tif (strtoupper(\$v) != 'AUTO') {
\t\t\t\t\$this->blk[\$this->blklvl]['css_set_width'] = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl-1]['inner_width'],\$this->FontSize,false);
\t\t\t}
\t\t\tbreak;

\t\tcase 'TEXT-INDENT':
\t\t\t// Left as raw value (may include 1% or 2em)
\t\t\t\$this->blk[\$this->blklvl]['text_indent'] = \$v;
\t\t\tbreak;

\t  }//end of switch(\$k)
\t}


\tif (\$type != 'INLINE' && \$type != 'LIST') {\t// includes BODY tag
\t  switch(\$k){

\t\tcase 'MARGIN-COLLAPSE':\t// Custom tag to collapse margins at top and bottom of page
\t\t\tif (strtoupper(\$v) == 'COLLAPSE') { \$this->blk[\$this->blklvl]['margin_collapse'] = true; }
\t\t\tbreak;

\t\tcase 'LINE-HEIGHT':
\t\t\t\$this->blk[\$this->blklvl]['line_height'] = \$this->fixLineheight(\$v);
\t\t\tif (!\$this->blk[\$this->blklvl]['line_height'] ) { \$this->blk[\$this->blklvl]['line_height'] = \$this->normalLineheight; }
\t\t\tbreak;

\t\tcase 'TEXT-ALIGN': //left right center justify
\t\t\tswitch (strtoupper(\$v)) {
\t\t\t\tcase 'LEFT':
                        \$this->blk[\$this->blklvl]['align']=\"L\";
                        break;
\t\t\t\tcase 'CENTER':
                        \$this->blk[\$this->blklvl]['align']=\"C\";
                        break;
\t\t\t\tcase 'RIGHT':
                        \$this->blk[\$this->blklvl]['align']=\"R\";
                        break;
\t\t\t\tcase 'JUSTIFY':
                        \$this->blk[\$this->blklvl]['align']=\"J\";
                        break;
\t\t\t}
\t\t\tbreak;

/*-- BACKGROUNDS --*/
\t\tcase 'BACKGROUND-GRADIENT':
\t\t\tif (\$type  == 'BLOCK') {
\t\t\t\t\$this->blk[\$this->blklvl]['gradient'] = \$v;
\t\t\t}
\t\t\tbreak;
/*-- END BACKGROUNDS --*/

\t\tcase 'DIRECTION':
\t\t\tif (\$v) { \$this->blk[\$this->blklvl]['direction'] = strtolower(\$v); }
\t\t\tbreak;

\t  }//end of switch(\$k)
\t}

\t// FOR INLINE ONLY
\tif (\$type == 'INLINE' || \$type == 'LIST') {
\t  switch(\$k){
\t\tcase 'DISPLAY':\t// Custom tag to collapse margins at top and bottom of page
\t\t\tif (strtoupper(\$v) == 'NONE') { \$this->inlineDisplayOff = true; }
\t\t\tbreak;
\t\tcase 'DIRECTION':
\t\t\tbreak;
\t  }//end of switch(\$k)
\t}
\t// FOR INLINE ONLY
\tif (\$type == 'INLINE') {
\t  switch(\$k){
\t\t// BORDERS
\t\tcase 'BORDER-TOP':
\t\t\t\$this->spanborddet['T'] = \$this->border_details(\$v);
\t\t\t\$this->spanborder = true;
\t\t\tbreak;
\t\tcase 'BORDER-BOTTOM':
\t\t\t\$this->spanborddet['B'] = \$this->border_details(\$v);
\t\t\t\$this->spanborder = true;
\t\t\tbreak;
\t\tcase 'BORDER-LEFT':
\t\t\t\$this->spanborddet['L'] = \$this->border_details(\$v);
\t\t\t\$this->spanborder = true;
\t\t\tbreak;
\t\tcase 'BORDER-RIGHT':
\t\t\t\$this->spanborddet['R'] = \$this->border_details(\$v);
\t\t\t\$this->spanborder = true;
\t\t\tbreak;
\t\t// mPDF 5.6.26
\t\tcase 'VISIBILITY':\t// block is set in OpenTag
\t\t\t\$v = strtolower(\$v);
\t\t\tif (\$v == 'visible' || \$v == 'hidden' || \$v == 'printonly' || \$v == 'screenonly') {
\t\t\t\t\$this->textparam['visibility'] = \$v;
\t\t\t}
\t\t\tbreak;
\t  }//end of switch(\$k)
\t}


\t// FOR INLINE and BLOCK
\t  switch(\$k){
\t\tcase 'TEXT-ALIGN': //left right center justify
\t\t\tif (strtoupper(\$v) == 'NOJUSTIFY' && \$this->blk[\$this->blklvl]['align']==\"J\") {
                        \$this->blk[\$this->blklvl]['align']=\"\";
\t\t\t}
\t\t\tbreak;
\t\t// bgcolor only - to stay consistent with original html2fpdf
\t\tcase 'BACKGROUND':
\t\tcase 'BACKGROUND-COLOR':
\t\t\t\$cor = \$this->ConvertColor(\$v);
\t\t\tif (\$cor) {
\t\t\t   if (\$tag  == 'BODY') {
\t\t\t\t\$this->bodyBackgroundColor = \$cor;
\t\t\t   }
\t\t\t   else if (\$type == 'INLINE' || \$type == 'LIST') {
\t\t\t\t\$this->spanbgcolorarray = \$cor;
\t\t\t\t\$this->spanbgcolor = true;
\t\t\t   }
\t\t\t   else {
\t\t\t\t\$this->blk[\$this->blklvl]['bgcolorarray'] = \$cor;
\t\t\t\t\$this->blk[\$this->blklvl]['bgcolor'] = true;
\t\t\t   }
\t\t\t}
\t\t\telse if (\$type != 'INLINE' && \$type != 'LIST') {
  \t\t  \t\tif (\$this->ColActive || \$this->keep_block_together) {
\t\t\t\t\t\$this->blk[\$this->blklvl]['bgcolorarray'] = \$this->blk[\$this->blklvl-1]['bgcolorarray'] ;
\t\t\t\t\t\$this->blk[\$this->blklvl]['bgcolor'] = \$this->blk[\$this->blklvl-1]['bgcolor'] ;
\t\t\t\t}
\t\t\t}
\t\t\tbreak;

\t\t// auto | normal | none
\t\tcase 'FONT-KERNING':
\t\t\tif ((strtoupper(\$v) == 'NORMAL' || strtoupper(\$v) == 'AUTO') && \$this->useKerning) { \$this->kerning = true; }
\t\t\telse if (strtoupper(\$v) == 'NONE') { \$this->kerning = false; }
\t\t\tbreak;


\t\t// normal | <length>
\t\tcase 'LETTER-SPACING':
\t\t\t\$this->lSpacingCSS = \$v;
\t\t\tif ((\$this->lSpacingCSS || \$this->lSpacingCSS==='0') && strtoupper(\$this->lSpacingCSS) != 'NORMAL') {
\t\t\t\t\$this->fixedlSpacing = \$this->ConvertSize(\$this->lSpacingCSS,\$this->FontSize);
\t\t\t}
\t\t\tbreak;

\t\t// normal | <length>
\t\tcase 'WORD-SPACING':
\t\t\t\$this->wSpacingCSS = \$v;
\t\t\tif (\$this->wSpacingCSS && strtoupper(\$this->wSpacingCSS) != 'NORMAL') {
\t\t\t\t\$this->minwSpacing = \$this->ConvertSize(\$this->wSpacingCSS,\$this->FontSize);
\t\t\t}
\t\t\tbreak;

\t\tcase 'FONT-STYLE': // italic normal oblique
\t\t\tswitch (strtoupper(\$v)) {
\t\t\t\tcase 'ITALIC':
\t\t\t\tcase 'OBLIQUE':
            \t\t\t\$this->SetStyle('I',true);
\t\t\t\t\tbreak;
\t\t\t\tcase 'NORMAL':
            \t\t\t\$this->SetStyle('I',false);
\t\t\t\t\tbreak;
\t\t\t}
\t\t\tbreak;

\t\tcase 'FONT-WEIGHT': // normal bold //Does not support: bolder, lighter, 100..900(step value=100)
\t\t\tswitch (strtoupper(\$v))\t{
\t\t\t\tcase 'BOLD':
            \t\t\t\$this->SetStyle('B',true);
\t\t\t\t\tbreak;
\t\t\t\tcase 'NORMAL':
            \t\t\t\$this->SetStyle('B',false);
\t\t\t\t\tbreak;
\t\t\t}
\t\t\tbreak;

\t\tcase 'VERTICAL-ALIGN': //super and sub only dealt with here e.g. <SUB> and <SUP>
\t\t\tswitch (strtoupper(\$v)) {
\t\t\t  case 'SUPER':
                        \$this->SUP=true;
                        \$this->SUB=false;\t// mPDF 5.6.07
 \t\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\t\tif (isset(\$this->textparam['text-baseline'])) { \$this->textparam['text-baseline'] += (\$this->baselineSup)*\$preceeding_fontsize; }
\t\t\t\telse { \$this->textparam['text-baseline'] = (\$this->baselineSup)*\$preceeding_fontsize; }
\t\t\t\tbreak;
\t\t\t  case 'SUB':
                        \$this->SUB=true;
                        \$this->SUP=false;\t// mPDF 5.6.07
\t\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\t\tif (isset(\$this->textparam['text-baseline'])) { \$this->textparam['text-baseline'] += (\$this->baselineSub)*\$preceeding_fontsize; }
\t\t\t\telse { \$this->textparam['text-baseline'] = (\$this->baselineSub)*\$preceeding_fontsize; }
\t\t\t\tbreak;
\t\t\t  case 'BASELINE': \t// mPDF 5.6.07
                        \$this->SUB=false;
                        \$this->SUP=false;
\t\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\t\tif (isset(\$this->textparam['text-baseline'])) { unset(\$this->textparam['text-baseline']); }
\t\t\t\tbreak;
\t\t\t  // mPDF 5.7.3  inline text-decoration parameters
\t\t\t  default:
\t\t\t\t\$lh = \$this->_computeLineheight(\$this->blk[\$this->blklvl]['line_height']);
\t\t\t\t\$sz = \$this->ConvertSize(\$v,\$lh,\$this->FontSize,false);
                        \$this->SUP=false;
                        \$this->SUB=false;
\t\t\t\tif (\$sz) {
\t\t\t\t\tif (\$sz > 0) {
                        \t\t\$this->SUP=true;
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$this->SUB=true;
\t\t\t\t\t}
\t\t\t\t\tif (isset(\$this->textparam['text-baseline'])) { \$this->textparam['text-baseline'] += \$sz; }
\t\t\t\t\telse { \$this->textparam['text-baseline'] = \$sz; }
\t\t\t\t}
\t\t\t}
\t\t\tbreak;

\t\tcase 'FONT-VARIANT':
\t\t\tswitch (strtoupper(\$v)) {
\t\t\t\tcase 'SMALL-CAPS':
\t\t\t\t\t\$this->SetStyle('S',true);
\t\t\t\t\tbreak;
\t\t\t\tcase 'NORMAL':
\t\t\t\t\t\$this->SetStyle('S',false);
\t\t\t\t\tbreak;
\t\t\t}
\t\t\tbreak;

\t\tcase 'TEXT-TRANSFORM': // none uppercase lowercase //Does support: capitalize
\t\t\tswitch (strtoupper(\$v)) { //Not working 100%
\t\t\t\tcase 'CAPITALIZE':
\t\t\t\t\t\$this->capitalize=true;
\t\t\t\t\tbreak;
\t\t\t\tcase 'UPPERCASE':
\t\t\t\t\t\$this->toupper=true;
\t\t\t\t\tbreak;
\t\t\t\tcase 'LOWERCASE':
 \t\t\t\t\t\$this->tolower=true;
\t\t\t\t\tbreak;
\t\t\t\tcase 'NONE': break;
\t\t\t}
\t\t\tbreak;

\t\tcase 'TEXT-SHADOW':
\t\t\t\$ts = \$this->cssmgr->setCSStextshadow(\$v);
\t\t\tif (\$ts) { \$this->textshadow = \$ts; }
\t\t\tbreak;

\t\tcase 'HYPHENS':\t// mPDF 5.6.08
\t\t\tif (strtoupper(\$v)=='NONE') {
\t\t\t\t\$this->textparam['hyphens'] = 2;
\t\t\t}
\t\t\telse if (strtoupper(\$v)=='AUTO') {
\t\t\t\t\$this->textparam['hyphens'] = 1;
\t\t\t}
\t\t\telse if (strtoupper(\$v)=='MANUAL') {
\t\t\t\t\$this->textparam['hyphens'] = 0;
\t\t\t}
\t\t\tbreak;

\t\tcase 'TEXT-OUTLINE': \t// mPDF 5.6.07
\t\t\tif (strtoupper(\$v)=='NONE') {
\t\t\t\t\$this->textparam['outline-s'] = false;
\t\t\t}
\t\t\tbreak;

\t\tcase 'TEXT-OUTLINE-WIDTH': \t// mPDF 5.6.07
\t\tcase 'OUTLINE-WIDTH':
\t\t\tswitch(strtoupper(\$v)) {
\t\t\t\tcase 'THIN': \$v = '0.03em'; break;
\t\t\t\tcase 'MEDIUM': \$v = '0.05em'; break;
\t\t\t\tcase 'THICK': \$v = '0.07em'; break;
\t\t\t}
\t\t\t\$w = \$this->ConvertSize(\$v,\$this->blk[\$this->blklvl]['inner_width'],\$this->FontSize);
\t\t\tif (\$w) {
\t\t\t\t\$this->textparam['outline-WIDTH'] = \$w;
\t\t\t\t\$this->textparam['outline-s'] = true;
\t\t\t}
\t\t\telse { \$this->textparam['outline-s'] = false; }
\t\t\tbreak;

\t\tcase 'TEXT-OUTLINE-COLOR': \t// mPDF 5.6.07
\t\tcase 'OUTLINE-COLOR':
\t\t\tif (strtoupper(\$v) == 'INVERT') {
\t\t\t   if (\$this->colorarray) {
\t\t\t\t\$cor = \$this->colorarray;
\t\t\t\t\$this->textparam['outline-COLOR'] = \$this->_invertColor(\$cor);
\t\t\t   }
\t\t\t   else {
\t\t\t\t\$this->textparam['outline-COLOR'] = \$this->ConvertColor(255);
\t\t\t   }
\t\t\t}
\t\t\telse {
\t\t  \t  \$cor = \$this->ConvertColor(\$v);
\t\t\t  if (\$cor) { \$this->textparam['outline-COLOR'] = \$cor ; }
\t\t\t}
\t\t\tbreak;

\t\tcase 'COLOR': // font color
\t\t\t\$cor = \$this->ConvertColor(\$v);
\t\t\tif (\$cor) {
\t\t\t\t\$this->colorarray = \$cor;
\t\t\t\t\$this->SetTColor(\$cor);
\t\t\t}
\t\t  break;


\t  }//end of switch(\$k)


   }//end of foreach


\t// mPDF 5.7.3  inline text-decoration parameters
\t// Needs to be set at the end - after vertical-align = super/sub, so that textparam['text-baseline'] is set
\tif (isset(\$arrayaux['TEXT-DECORATION'])) {
\t\t\$v = \$arrayaux['TEXT-DECORATION']; // none underline line-through (strikeout) //Does not support: overline, blink
\t\tif (stristr(\$v,'LINE-THROUGH')) {
\t\t\t\$this->strike = true;
\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\tif (isset(\$this->textparam['text-baseline'])) { \$this->textparam['decoration-baseline'] = \$this->textparam['text-baseline']; }
\t\t\telse { \$this->textparam['decoration-baseline'] = 0; }
\t\t\t\$this->textparam['decoration-fontkey'] = \$this->FontFamily . \$this->FontStyle;
\t\t\t\$this->textparam['decoration-fontsize'] = \$this->FontSize;
\t\t\t\$this->textparam['s-decoration']['color'] = strtoupper(\$this->TextColor);\t// change 0 0 0 rg to 0 0 0 RG
\t\t}
\t\tif (stristr(\$v,'UNDERLINE')) {
            \t\$this->SetStyle('U',true);
\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\tif (isset(\$this->textparam['text-baseline'])) { \$this->textparam['decoration-baseline'] = \$this->textparam['text-baseline']; }
\t\t\telse { \$this->textparam['decoration-baseline'] = 0; }
\t\t\t\$this->textparam['decoration-fontkey'] = \$this->FontFamily . \$this->FontStyle;
\t\t\t\$this->textparam['decoration-fontsize'] = \$this->FontSize;
\t\t\t\$this->textparam['u-decoration']['color'] = strtoupper(\$this->TextColor);\t// change 0 0 0 rg to 0 0 0 RG
\t\t}
\t\tif (stristr(\$v,'NONE')) {
            \t\$this->SetStyle('U',false);
\t\t\t\$this->strike = false;
\t\t\t// mPDF 5.7.3  inline text-decoration parameters
\t\t\tif (isset(\$this->textparam['decoration-baseline'])) { unset(\$this->textparam['decoration-baseline']); }
\t\t\tif (isset(\$this->textparam['decoration-fontkey'])) { unset(\$this->textparam['decoration-fontkey']); }
\t\t\tif (isset(\$this->textparam['decoration-fontsize'])) { unset(\$this->textparam['decoration-fontsize']); }
\t\t\tif (isset(\$this->textparam['u-decoration'])) { unset(\$this->textparam['u-decoration']); }
\t\t\tif (isset(\$this->textparam['s-decoration'])) { unset(\$this->textparam['s-decoration']); }
\t\t}
\t}

}

/*-- END HTML-CSS --*/


function SetStyle(\$tag,\$enable) {
\t\$this->\$tag=\$enable;
\t\$style='';
\tforeach(array('B','I','U','S') as \$s) {
\t\tif(\$this->\$s) {
\t\t\t\$style.=\$s;
\t\t}
\t}
\tif (\$this->S && empty(\$this->upperCase)) { @include(_MPDF_PATH.'includes/upperCase.php'); }
\t\$this->currentfontstyle=\$style;
\t\$this->SetFont('',\$style,0,false);
}

// Set multiple styles at one \$str e.g. \"BIS\"
function SetStylesArray(\$arr) {
\t\$style='';
\tforeach(array('B','I','U','S') as \$s) {
\t  if (isset(\$arr[\$s])) {
\t\tif (\$arr[\$s]) {
\t\t\t\$this->\$s = true;
\t\t\t\$style.=\$s;
\t\t}
\t\telse { \$this->\$s = false; }
\t  }
\t  else if (\$this->\$s) {\t\$style.=\$s; }
\t}
\t\$this->currentfontstyle=\$style;
\t\$this->SetFont('',\$style,0,false);
}

// Set multiple styles at one \$str e.g. \"BIS\"
function SetStyles(\$str) {
\t\$style='';
\tforeach(array('B','I','U','S') as \$s) {
\t\tif (strpos(\$str,\$s) !== false) {
\t\t\t\$this->\$s = true;
\t\t\t\$style.=\$s;
\t\t}
\t\telse { \$this->\$s = false; }
\t}
\t\$this->currentfontstyle=\$style;
\t\$this->SetFont('',\$style,0,false);
}

function ResetStyles() {
\tforeach(array('B','I','U','S') as \$s) {
\t\t\$this->\$s = false;
\t}
\t\$this->currentfontstyle='';
\t\$this->SetFont('','',0,false);
}


function DisableTags(\$str='')
{
  if (\$str == '') //enable all tags
  {
\t//Insert new supported tags in the long string below.
\t\$this->enabledtags = \"<span><s><strike><del><bdo><big><small><ins><cite><acronym><font><sup><sub><b><u><i><a><strong><em><code><samp><tt><kbd><var><q><table><thead><tfoot><tbody><tr><th><td><ol><ul><li><dl><dt><dd><form><input><select><textarea><option><div><p><h1><h2><h3><h4><h5><h6><pre><center><blockquote><address><hr><img><br><indexentry><indexinsert><bookmark><watermarktext><watermarkimage><tts><ttz><tta><column_break><columnbreak><newcolumn><newpage><page_break><pagebreak><formfeed><columns><toc><tocentry><tocpagebreak><pageheader><pagefooter><setpageheader><setpagefooter><sethtmlpageheader><sethtmlpagefooter><annotation><template><jpgraph><barcode><dottab><caption><textcircle><fieldset><legend><article><aside><figure><figcaption><footer><header><hgroup><nav><section><mark><main><details><summary><meter><progress><time>\";\t// mPDF 5.7.3
  }
  else
  {
    \$str = explode(\",\",\$str);
    foreach(\$str as \$v) \$this->enabledtags = str_replace(trim(\$v),'',\$this->enabledtags);
  }
}


/*-- TABLES --*/

function finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight) {
\t\$af = 0; \t// Above font
\t\$bf = 0; \t// Below font
\t\$mta = 0;\t// Maximum top-aligned
\t\$mba = 0;\t// Maximum bottom-aligned
\tif (\$lhxt['BS']) {
\t\t\$af = max(\$af, (\$lhxt['BS'] - (\$maxfontsize * (0.5 + \$this->baselineC))));
\t}
\tif (\$lhxt['M']) {
\t\t\$af = max(\$af, (\$lhxt['M'] - \$maxfontsize)/2);
\t\t\$bf = max(\$bf, (\$lhxt['M'] - \$maxfontsize)/2);
\t}
\tif (\$lhxt['TT']) {
\t\t\$bf = max(\$bf, (\$lhxt['TT'] - \$maxfontsize));
\t}
\tif (\$lhxt['TB']) {
\t\t\$af = max(\$af, (\$lhxt['TB'] - \$maxfontsize));
\t}
\tif (\$lhxt['T']) {
\t\t\$mta = max(\$mta, \$lhxt['T']);
\t}
\tif (\$lhxt['B']) {
\t\t\$mba = max(\$mba, \$lhxt['B']);
\t}
\tif ((!\$lhfixed || !\$forceExactLineheight) && (\$af > ((\$maxlineHeight - \$maxfontsize)/2) || \$bf > ((\$maxlineHeight - \$maxfontsize)/2))) {
\t\t\$maxlineHeight = \$maxfontsize + \$af + \$bf;
\t}
\telse if (!\$lhfixed) { \$af = \$bf = (\$maxlineHeight - \$maxfontsize)/2; }
\tif (\$mta > \$maxlineHeight) {
\t\t\$bf += (\$mta - \$maxlineHeight);
\t\t\$maxlineHeight = \$mta;
\t}
\tif (\$mba > \$maxlineHeight) {
\t\t\$af += (\$mba - \$maxlineHeight);
\t\t\$maxlineHeight = \$mba;
\t}
\treturn \$maxlineHeight;
}

function TableWordWrap(\$maxwidth, \$forcewrap = 0, \$textbuffer = '', \$def_fontsize, \$returnarray=false) {\t// NB ** returnarray used in flowchart
   \$biggestword=0;
   \$toonarrow=false;

   \$textbuffer[0][0] = preg_replace('/^[ ]*/','',\$textbuffer[0][0]);
   if ((count(\$textbuffer) == 0) or ((count(\$textbuffer) == 1) && (\$textbuffer[0][0] == ''))) { return 0; }

   \$text = '';
   \$lhfixed = false;
   if (preg_match('/([0-9.,]+)mm/',\$this->table_lineheight)) { \$lhfixed = true; }
   if (\$lhfixed) { \$def_lineheight = \$this->_computeLineheight(\$this->table_lineheight, \$def_fontsize);}
   else { \$def_lineheight = 0; }
   // START OF NEW LINE
   // Initialise lineheight variables
   \$maxfontsize = 0;
   \$forceExactLineheight = true;
   \$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
   \$maxlineHeight = \$def_lineheight ;
   \$ch = 0;
   \$width = 0;
   \$ln = 1;\t// Counts line number
   \$mxw = \$this->GetCharWidth('W',false);
   for(\$cctr=0;\$cctr<count(\$textbuffer);\$cctr++) {\t// mPDF 5.6.22
\t\$chunk = \$textbuffer[\$cctr];\t// mPDF 5.6.22
\t\$line = \$chunk[0];
\t//IMAGE
      if (substr(\$line,0,3) == \"\\xbb\\xa4\\xac\") { //identifier has been identified!
\t\t\$objattr = \$this->_getObjAttr(\$line);
\t\tif (\$objattr['type'] == 'nestedtable') {
\t\t\t// END OF LINE
\t\t\t// Finalise & add lineheight
\t\t\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
\t\t\t\$level = \$objattr['level'];
\t\t\t\$ih = \$this->table[(\$level+1)][\$objattr['nestedcontent']]['h'];\t// nested table width
\t\t\t\$ch += \$ih;
\t\t\t// START OF NEW LINE
\t\t\t// Initialise lineheight variables
\t\t\t\$ln++;
\t\t\t\$maxfontsize = 0;
\t\t\t\$forceExactLineheight = true;
\t\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\t\$maxlineHeight = \$def_lineheight ;
\t\t\t\$width = 0;
\t\t\t\$text = \"\";
\t\t\tcontinue;
\t\t}

\t\tlist(\$skipln,\$iw,\$ih) = \$this->inlineObject((isset(\$specialcontent['type']) ? \$specialcontent['type'] : null),0,0, \$objattr, \$this->lMargin,\$width,\$maxwidth,\$maxlineHeight,false,true);
\t\tif (\$objattr['type'] == 'hr') {
\t\t\t// END OF LINE
\t\t\t// Finalise & add lineheight
\t\t\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
\t\t\t// Add HR height
\t\t\t\$ch += \$ih;
\t\t\t// START OF NEW LINE
\t\t\t// Initialise lineheight variables
\t\t\t\$ln++;
\t\t\t\$maxfontsize = 0;
\t\t\t\$forceExactLineheight = true;
\t\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\t\$maxlineHeight = \$def_lineheight ;
\t\t\t\$width = 0;
\t\t\t\$text = \"\";
\t\t\tcontinue;
\t\t}

\t\tif (\$skipln==1 || \$skipln==-2) {
\t\t\t// Finish last line
\t\t\t// END OF LINE
\t\t\t// Finalise & add lineheight
\t\t\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
\t\t\t// START OF NEW LINE
\t\t\t// Initialise lineheight variables
\t\t\t\$maxfontsize = 0;
\t\t\t\$forceExactLineheight = true;
\t\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\t\$maxlineHeight = \$def_lineheight ;
\t\t\t\$ln++;
\t\t\t\$width = 0;
\t\t\t\$text = \"\";
\t\t}
\t\t\$va = (isset(\$objattr['vertical-align']) ? \$objattr['vertical-align'] : null);
\t\tif (\$va) {
\t\t\t\$lhxt[\$va] = max(\$lhxt[\$va], \$ih);
\t\t}
\t\tif (\$lhfixed && \$ih > \$def_fontsize) { \$forceExactLineheight = false; }
\t\t\$maxlineHeight = max(\$maxlineHeight ,\$ih);
\t\t\$width += \$iw;
\t\tcontinue;
\t}

\t// SET FONT SIZE/STYLE from \$chunk[n]
\t// FONTSIZE
\tif(isset(\$chunk[11]) and \$chunk[11] != '') {
\t   if (\$this->shrin_k) {
\t\t\$this->SetFontSize(\$chunk[11]/\$this->shrin_k,false);
\t   }
\t   else {
\t\t\$this->SetFontSize(\$chunk[11],false);
\t   }
\t}
\tif (\$line == \"\\n\") {
\t\t// END OF LINE
\t\t\$maxfontsize = max(\$maxfontsize,\$this->FontSize);
\t\t\$fh = \$this->_computeLineheight(\$this->table_lineheight);
\t\tif (\$lhfixed && \$this->FontSize > \$def_fontsize) {
\t\t\t\$fh = \$this->FontSize;
\t\t\t\$forceExactLineheight = false;
\t\t}
\t\t\$maxlineHeight = max(\$maxlineHeight,\$fh);

\t\t// Finalise & add lineheight
\t\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
\t\t// START OF NEW LINE
\t\t// Initialise lineheight variables
\t\t\$maxfontsize = 0;
\t\t\$forceExactLineheight = true;
\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\$maxlineHeight = \$this->_computeLineheight(\$this->table_lineheight);
\t\t\$ln++;
\t\t\$text = \"\";
\t\t\$width = 0;
\t\tif(isset(\$chunk[11]) and \$chunk[11] != '') {
\t\t\t\$this->SetFontSize(\$this->default_font_size,false);
\t\t}
\t\tcontinue;
\t}

\t\$lbw = \$rbw = 0;\t// Border widths
\tif(isset(\$chunk[16]) && !empty(\$chunk[16])) {\t//Border
\t\t\$this->spanborddet = \$chunk[16];
\t\tif (isset(\$this->spanborddet['L'])) \$lbw = \$this->spanborddet['L']['w'];
\t\tif (isset(\$this->spanborddet['R'])) \$rbw = \$this->spanborddet['R']['w'];
\t}
      if(isset(\$chunk[15])) { \t // Word spacing
\t\t\$this->wSpacingCSS = \$chunk[15];
\t\tif (\$this->wSpacingCSS && strtoupper(\$this->wSpacingCSS) != 'NORMAL') {
\t\t\t\$this->minwSpacing = \$this->ConvertSize(\$this->wSpacingCSS,\$this->FontSize)/\$this->shrin_k; // mPDF 5.7.3
\t\t}
\t}
      if(isset(\$chunk[14])) { \t // Letter spacing
\t\t\$this->lSpacingCSS = \$chunk[14];
\t\tif ((\$this->lSpacingCSS || \$this->lSpacingCSS==='0') && strtoupper(\$this->lSpacingCSS) != 'NORMAL') {
\t\t\t\$this->fixedlSpacing = \$this->ConvertSize(\$this->lSpacingCSS,\$this->FontSize)/\$this->shrin_k; // mPDF 5.7.3
\t\t}
\t}
      if(isset(\$chunk[13])) { \t // Font Kerning
\t\t\$this->kerning = \$chunk[13];
\t}
      if(isset(\$chunk[9])) { \t // Text params - Outline, hyphens\t// mPDF 5.6.08
\t\t\$this->textparam = \$chunk[9];
\t}
\t// FONTFAMILY
\tif(isset(\$chunk[4]) and \$chunk[4] != '') { \$font = \$this->SetFont(\$chunk[4],\$this->FontStyle,0,false); }

\t// FONT STYLE B I U
\tif(isset(\$chunk[2]) and \$chunk[2] != '') {
\t\t\$this->SetStyles(\$chunk[2]);
\t}

\t\$space = \$this->GetCharWidth(' ',false);

\tif (mb_substr(\$line,0,1,\$this->mb_enc ) == ' ') { \t// line (chunk) starts with a space
\t\t\$width += \$space;
\t\t\$text .= ' ';
\t}

\tif (mb_substr(\$line,(mb_strlen(\$line,\$this->mb_enc )-1),1,\$this->mb_enc ) == ' ') { \$lsend = true; }\t// line (chunk) ends with a space
\telse { \$lsend = false; }
\t\$line= trim(\$line);
\tif (\$line == '') { continue; }

\t// mPDF ITERATION
\tif (\$this->iterationCounter) \$line = preg_replace('/{iteration ([a-zA-Z0-9_]+)}/','\\\\1', \$line);

\t\$words = explode(' ', \$line);

\tforeach (\$words as \$k=>\$word) {
\t\t\$word = trim(\$word);
\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\tif (\$k==0) { \$wordwidth += \$lbw; }
\t\tif (\$k==(count(\$words)-1)) { \$wordwidth += \$rbw; }
\t\t//maxwidth is insufficient for one word
\t\tif (\$wordwidth > \$maxwidth + 0.0001) {
\t\t\t\$firstchunk=true;
\t\t\twhile(\$wordwidth > \$maxwidth + 0.0001) {
\t\t\t\t\$chw = 0;\t// check width
\t\t\t\t\$oneCJKorphan = false;
\t\t\t\t\$mlen = mb_strlen(\$word, \$this->mb_enc );
\t\t\t\tfor ( \$i = 0; \$i < \$mlen; \$i++ ) {
\t\t\t\t\t\$chw = \$this->GetStringWidth(mb_substr(\$word,0,\$i+1,\$this->mb_enc ));
\t\t\t\t\tif (\$k==0) { \$chw += \$lbw; }
\t\t\t\t\tif (\$k==(count(\$words)-1)) { \$chw += \$rbw; }
\t\t\t\t\tif (\$chw > \$maxwidth) {
\t\t\t\t\t\tif (\$i==0 && \$firstchunk) {
\t\t\t\t\t\t\t// If first letter of line does not fit
\t\t\t\t\t\t\t\$wordwidth = \$maxwidth - 0.0001;
\t\t\t\t\t\t\tif (\$this->debug) { \$this->Error(\"Table cell width calculated less than that needed for one character!\"); }
\t\t\t\t\t\t\tbreak;
\t\t\t\t\t\t}
/*-- CJK-FONTS --*/
\t\t\t\t\t \t// mPDF 5.6.40\tmPDF 5.6.44
\t\t\t\t\t\tif (\$this->checkCJK && !\$this->usingCoreFont && preg_match(\"/[\".\$this->pregCJKchars.\"]/u\", \$word)) {\t// mPDF 5.6.44
\t\t\t\t\t\t\tif (!\$oneCJKorphan && preg_match('/['.\$this->CJKoverflow.']\$/u',mb_substr(\$word,0,\$i+1,\$this->mb_enc )) && \$this->allowCJKorphans) {
\t\t\t\t\t\t\t\t\$wordwidth = \$maxwidth - 0.0001;
\t\t\t\t\t\t\t\t\$oneCJKorphan = true;
\t\t\t\t\t\t\t\tcontinue;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\$cjkfix = 0;
\t\t\t\t\t\t\t// Last character that fits is not allowed to end a line - move lastchar(s) to start of next line
\t\t\t\t\t\t\tif (\$i>0 && preg_match(\"/[\".\$this->CJKleading.\"\$]/u\", mb_substr(\$word,0,\$i,\$this->mb_enc ))) {
\t\t\t\t\t\t\t\t\$cjkfix = 1;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t// Next character is not allowed to start a new line
\t\t\t\t\t\t\telse if (preg_match(\"/[\".\$this->CJKfollowing.\"]/u\", mb_substr(\$word,\$i,1,\$this->mb_enc ))) {
\t\t\t\t\t\t\t\t// try squeezing another character(s) onto this line = Oikomi
\t\t\t\t\t\t\t\tif (\$this->allowCJKorphans && !\$oneCJKorphan) {
\t\t\t\t\t\t\t\t\t//if lookahead is not another following char
\t\t\t\t\t\t\t\t\tif (\$i==(\$mlen-1) || (\$i<(\$mlen-1) && !preg_match(\"/[\".\$this->CJKfollowing.\"]/u\", mb_substr(\$word,\$i+1,1,\$this->mb_enc )))) {
\t\t\t\t\t\t\t\t\t\t\$wordwidth = \$maxwidth - 0.0001;
\t\t\t\t\t\t\t\t\t\t\$oneCJKorphan = true;
\t\t\t\t\t\t\t\t\t\tcontinue;
\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t// or move lastchar(s) to next line
\t\t\t\t\t\t\t\t\$cjkfix = 2;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t// mPDF 5.6.42
\t\t\t\t\t\t\t// CJK numerals kept together
\t\t\t\t\t\t\telse if (preg_match(\"/([\".\$this->pregCJKchars.\"]+[0-9\\x{ff10}-\\x{ff19}]+\$)/u\", mb_substr(\$word,0,\$i,\$this->mb_enc )) && preg_match(\"/^([0-9\\x{ff10}-\\x{ff19}]+[\".\$this->pregCJKchars.\"]+)/u\", mb_substr(\$word,\$i,16,\$this->mb_enc ))) {
\t\t\t\t\t\t\t\t\$cjkfix = 3;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\tif (\$cjkfix) {
\t\t\t\t\t\t\t\t//move lastchar(s) to next line
\t\t\t\t\t\t\t\t\$m0 = mb_substr(\$word,\$i-1,1,\$this->mb_enc );\t// chars to move
\t\t\t\t\t\t\t\t\$m1 = mb_substr(\$word,0,\$i-1,\$this->mb_enc );   // str after stripped chars to move
\t\t\t\t\t\t\t\t\$mi = \$i - 1;
\t\t\t\t\t\t\t\tif (\$cjkfix == 3) { \$match = \"0-9\\x{ff10}-\\x{ff19}\"; }
\t\t\t\t\t\t\t\telse { \$match = \$this->CJKleading; }
\t\t\t\t\t\t\t\twhile(preg_match(\"/[\".\$match.\"\$]/u\", \$m1) && mb_strlen(\$m1, \$this->mb_enc)>2) {
\t\t\t\t\t\t\t\t\t\$m0 = mb_substr(\$m1,\$mi-1,1,\$this->mb_enc ).\$m0;\t// chars to move
\t\t\t\t\t\t\t\t\t\$m1 = mb_substr(\$m1,0,\$mi-1,\$this->mb_enc );   // str after stripped chars to move
\t\t\t\t\t\t\t\t\t\$mi--;
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t// Insert \$m0 into \$word at \$i
\t\t\t\t\t\t\t\t\$word =  mb_substr(\$word,0,\$i,\$this->mb_enc ) . \$m0 .  mb_substr(\$word,\$i,mb_strlen(\$word, \$this->mb_enc )-\$i,\$this->mb_enc );
\t\t\t\t\t\t\t\t\$mlen = mb_strlen(\$word, \$this->mb_enc );\t// increment max for loop counter
\t\t\t\t\t\t\t}



\t\t\t\t\t\t}
/*-- END CJK-FONTS --*/

\t\t\t\t\t\tif (\$text && \$firstchunk) {
\t\t\t\t\t\t\t// END OF LINE
\t\t\t\t\t\t\t// Finalise & add lineheight
\t\t\t\t\t\t\t\$maxfontsize = max(\$maxfontsize,\$this->FontSize);
\t\t\t\t\t\t\t\$fh = \$this->_computeLineheight(\$this->table_lineheight);
\t\t\t\t\t\t\tif (\$lhfixed && \$this->FontSize > \$def_fontsize) {
\t\t\t\t\t\t\t\t\$fh = \$this->FontSize;
\t\t\t\t\t\t\t\t\$forceExactLineheight = false;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\$maxlineHeight = max(\$maxlineHeight,\$fh);
\t\t\t\t\t\t\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
\t\t\t\t\t\t\t// START OF NEW LINE
\t\t\t\t\t\t\t// Initialise lineheight variables
\t\t\t\t\t\t\t\$maxfontsize = \$this->FontSize;
\t\t\t\t\t\t\t\$forceExactLineheight = true;
\t\t\t\t\t\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\t\t\t\t\t\$maxlineHeight = \$this->_computeLineheight(\$this->table_lineheight);
\t\t\t\t\t\t\t\$ln++;
\t\t\t\t\t\t}
\t\t\t\t\t\t// END OF LINE
\t\t\t\t\t\t// Finalise & add lineheight
\t\t\t\t\t\t\$maxfontsize = max(\$maxfontsize,\$this->FontSize);
\t\t\t\t\t\t\$fh = \$this->_computeLineheight(\$this->table_lineheight);
\t\t\t\t\t\tif (\$lhfixed && \$this->FontSize > \$def_fontsize) {
\t\t\t\t\t\t\t\$fh = \$this->FontSize;
\t\t\t\t\t\t\t\$forceExactLineheight = false;
\t\t\t\t\t\t}
\t\t\t\t\t\t\$maxlineHeight = max(\$maxlineHeight,\$fh);
\t\t\t\t\t\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
\t\t\t\t\t\t// START OF NEW LINE
\t\t\t\t\t\t// Initialise lineheight variables
\t\t\t\t\t\t\$maxfontsize = \$this->FontSize;
\t\t\t\t\t\t\$forceExactLineheight = true;
\t\t\t\t\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\t\t\t\t\$maxlineHeight = \$this->_computeLineheight(\$this->table_lineheight);
\t\t\t\t\t\t\$ln++;
\t\t\t\t\t\t\$mxw = \$maxwidth;
\t\t\t\t\t\t\$text = mb_substr(\$word,0,\$i,\$this->mb_enc );
\t\t\t\t\t\t\$word = mb_substr(\$word,\$i,mb_strlen(\$word, \$this->mb_enc )-\$i,\$this->mb_enc );
\t\t\t\t\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\t\t\t\t\t\$width = 0;
\t\t\t\t\t\t\$firstchunk=false;
\t\t\t\t\t\tbreak;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\tif (mb_strlen(\$word, \$this->mb_enc )<2 && \$wordwidth > \$maxwidth + 0.0001) {
\t\t\t\t\t\$wordwidth = \$maxwidth - 0.0001;
\t\t\t\t\tif (\$this->debug) { \$this->Error(\"Table cell width calculated less than that needed for single character!\"); }
\t\t\t\t}
\t\t\t\t\$firstchunk=false;
\t\t\t}
\t\t}
\t\t// Word fits on line...
\t\tif (\$width + \$wordwidth  < \$maxwidth + 0.0001) {
\t\t\t\$mxw = max(\$mxw, (\$width+\$wordwidth));
\t\t\t\$width += \$wordwidth + \$space;
\t\t\t\$text .= \$word.' ';
\t\t}
\t\t// Word does not fit on line...
\t\telse {
\t\t\t\t// mPDF 5.6.21  hard hyphens
\t\t\t\tif (\$this->textparam['hyphens'] != 2 && preg_match('/\\-/',\$word)) {
\t\t\t\t\tlist(\$hardsuccess,\$pre,\$post,\$prelength) = \$this->hardHyphenate(\$word, (\$maxwidth - \$width)-\$this->GetCharWidth(\"-\", false));
\t\t\t\t\tif (\$hardsuccess) {
\t\t\t\t\t\t\$text .= \$pre.'-';
\t\t\t\t\t\t\$word = \$post;
\t\t\t\t\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\t\t\t\t\tif (\$k==(count(\$words)-1)) { \$wordwidth += \$rbw; }
\t\t\t\t\t}
\t\t\t\t}
/*-- HYPHENATION --*/
\t\t\t\t// Soft Hyphens chr(173)
\t\t\t\telse if (\$this->textparam['hyphens'] != 2 && (!\$this->usingCoreFont && preg_match(\"/\\xc2\\xad/\",\$word)) || (\$this->usingCoreFont && preg_match(\"/\".chr(173).\"/\",\$word) && (\$this->FontFamily!='csymbol' && \$this->FontFamily!='czapfdingbats')) ) {\t// mPDF 5.6.06  5.6.08
\t\t\t\t\tlist(\$success,\$pre,\$post,\$prelength) = \$this->softHyphenate(\$word, (\$maxwidth - \$width));
\t\t\t\t\tif (\$success) {
\t\t\t\t\t\t\$text .= \$pre.'-';
\t\t\t\t\t\t\$word = \$post;
\t\t\t\t\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\t\t\t\t\tif (\$k==(count(\$words)-1)) { \$wordwidth += \$rbw; }
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse if (\$this->textparam['hyphens'] == 1) { \t// mPDF 5.6.06   5.6.08
\t\t\t\t\tlist(\$success,\$pre,\$post,\$prelength) = \$this->hyphenateWord(\$word, (\$maxwidth - \$width));
\t\t\t\t\tif (\$success) {
\t\t\t\t\t\t\$text .= \$pre.'-';
\t\t\t\t\t\t\$word = \$post;
\t\t\t\t\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\t\t\t\t\tif (\$k==(count(\$words)-1)) { \$wordwidth += \$rbw; }
\t\t\t\t\t}
\t\t\t\t}
/*-- END HYPHENATION --*/


\t\t\t\t// mPDF 5.6.22
\t\t  \t\tif (\tcount(\$textbuffer)>1 && \$cctr > 0 && \$k==0
\t\t\t\t\t&& (substr(\$textbuffer[\$cctr][0],0,3) != \"\\xbb\\xa4\\xac\")
\t\t\t\t\t&& (substr(\$textbuffer[\$cctr-1][0],0,3) != \"\\xbb\\xa4\\xac\")
\t\t\t\t\t&& substr(\$textbuffer[\$cctr-1][0],-1,1) != ' '
\t\t\t\t\t&& substr(\$textbuffer[\$cctr][0],0,1) != ' '
\t\t\t\t\t) {
\t\t\t\t\t// Go back to find a space in a previous chunk of content
\t\t\t\t\t\$found = false;
\t\t\t\t\tfor (\$ix=\$cctr-1;\$ix>=0;\$ix--) {
\t\t\t\t\t\tif (preg_match('/[ ]/',\$textbuffer[\$ix][0])) { \$found = \$ix; break; }
\t\t\t\t\t}
\t\t\t\t\tif (\$found !== false) {
\t\t\t\t\t\t\$charpos = strrpos(\$textbuffer[\$found][0],' ');
\t\t\t\t\t\t// mPDF 5.6.24
\t\t\t\t\t\t\$a1 = \$a2 = \$textbuffer[\$found];
\t\t\t\t\t\t\$a1[0] = \"\\n\";
\t\t\t\t\t\t\$a2[0] = substr(\$textbuffer[\$found][0], \$charpos+1, strlen(\$textbuffer[\$found][0])-\$charpos);
\t\t\t\t\t\t\$textbuffer[\$found][0] = substr(\$textbuffer[\$found][0], 0, \$charpos);
\t\t\t\t\t\tarray_insert(\$textbuffer, \$a1, \$found+1);
\t\t\t\t\t\tarray_insert(\$textbuffer, \$a2, \$found+2);
\t\t\t\t\t\t// Initialise all variables
\t\t\t\t\t\t\$biggestword=0;
\t\t\t\t\t\t\$toonarrow=false;
\t\t\t\t\t\t\$lhfixed = false;
\t\t\t\t\t\tif (preg_match('/([0-9.,]+)mm/',\$this->table_lineheight)) { \$lhfixed = true; }
\t\t\t\t\t\tif (\$lhfixed) { \$def_lineheight = \$this->_computeLineheight(\$this->table_lineheight, \$def_fontsize);}
\t\t\t\t\t\telse { \$def_lineheight = 0; }
\t\t\t\t\t\t\$maxfontsize = 0;
\t\t\t\t\t\t\$forceExactLineheight = true;
\t\t\t\t\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\t\t\t\t\$maxlineHeight = \$def_lineheight ;
\t\t\t\t\t\t\$ch = 0;
\t\t\t\t\t\t\$width = 0;
\t\t\t\t\t\t\$ln = 1;\t// Counts line number
\t\t\t\t\t\t\$mxw = \$this->GetCharWidth('W',false);
\t\t\t\t\t\t\$text = '';

\t\t\t\t\t\t\$cctr = -1;
\t\t\t\t\t\tbreak;
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\t// END OF LINE
\t\t\t\t// Finalise & add lineheight
\t\t\t\t\$maxfontsize = max(\$maxfontsize,\$this->FontSize);
\t\t\t\t\$fh = \$this->_computeLineheight(\$this->table_lineheight);
\t\t\t\tif (\$lhfixed && \$this->FontSize > \$def_fontsize) {
\t\t\t\t\t\$fh = \$this->FontSize;
\t\t\t\t\t\$forceExactLineheight = false;
\t\t\t\t}
\t\t\t\t\$maxlineHeight = max(\$maxlineHeight,\$fh);
\t\t\t\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
\t\t\t\t\$mxw = \$maxwidth;
\t\t\t\t// START OF NEW LINE
\t\t\t\t// Initialise lineheight variables
\t\t\t\t\$maxfontsize = \$this->FontSize;
\t\t\t\t\$forceExactLineheight = true;
\t\t\t\t\$lhxt = array('BS'=>0, 'M'=>0, 'TT'=>0, 'TB'=>0, 'T'=>0, 'B'=>0);
\t\t\t\t\$maxlineHeight = \$this->_computeLineheight(\$this->table_lineheight);
\t\t\t\t\$ln++;
\t\t\t\t\$width = \$wordwidth + \$space;
\t\t\t\t\$text = \$word.' ';
          }
\t\t\$maxfontsize = max(\$maxfontsize,\$this->FontSize);
\t\t\$fh = \$this->_computeLineheight(\$this->table_lineheight);
\t\tif (\$lhfixed && \$this->FontSize > \$def_fontsize) {
\t\t\t\$fh = \$this->FontSize;
\t\t\t\$forceExactLineheight = false;
\t\t}
\t\t\$maxlineHeight = max(\$maxlineHeight,\$fh);
\t}

\t// End of textbuffer chunk
\tif (!\$lsend) {
\t\t\$width -= \$space;
\t\t\$text = rtrim(\$text);
\t}

\t// RESET FONT SIZE/STYLE
\t// RESETTING VALUES
\t//Now we must deactivate what we have used
\tif(isset(\$chunk[2]) and \$chunk[2] != '') {
\t\t\$this->ResetStyles();
\t}
\tif(isset(\$chunk[4]) and \$chunk[4] != '') {
\t\t\$this->SetFont(\$this->default_font,\$this->FontStyle,0,false);
\t}
\tif(isset(\$chunk[11]) and \$chunk[11] != '') {
\t\t\$this->SetFontSize(\$this->default_font_size,false);
\t}
\t\$this->spanborddet = array();
\t\$this->kerning = false;
\t\$this->lSpacingCSS = '';
\t\$this->wSpacingCSS = '';
\t\$this->fixedlSpacing = false;
\t\$this->minwSpacing = 0;
   }
   // Finalise lineheight if something output on line and add
   if (\$width) {
\t\$ch += \$this->finaliseCellLineHeight(\$lhxt, \$maxfontsize, \$maxlineHeight, \$lhfixed, \$forceExactLineheight);
   }
   if (\$returnarray) { return array(\$ch,\$ln,\$mxw); }
   else { return \$ch; }

}


function TableCheckMinWidth(\$maxwidth, \$forcewrap = 0, \$textbuffer) {
\t\$biggestword=0;
\t\$toonarrow=false;
\tif ((count(\$textbuffer) == 0) or ((count(\$textbuffer) == 1) && (\$textbuffer[0][0] == ''))) { return 0; }

\tforeach (\$textbuffer as \$chunk) {

\t\t\$line = \$chunk[0];
\t\t// mPDF ITERATION
\t\tif (\$this->iterationCounter) \$line = preg_replace('/{iteration ([a-zA-Z0-9_]+)}/','\\\\1', \$line);

\t\t// IMAGES & FORM ELEMENTS
      \tif (substr(\$line,0,3) == \"\\xbb\\xa4\\xac\") { //inline object - FORM element or IMAGE!
\t\t\t\$objattr = \$this->_getObjAttr(\$line);
\t\t\tif (\$objattr['type']!='hr' && isset(\$objattr['width']) && (\$objattr['width']/\$this->shrin_k) > (\$maxwidth + 0.0001) ) {
\t\t\t\tif ((\$objattr['width']/\$this->shrin_k) > \$biggestword) { \$biggestword = (\$objattr['width']/\$this->shrin_k); }
\t\t\t\t\$toonarrow=true;
\t\t\t}
\t\t\tcontinue;
\t\t}

\t\tif (\$line == \"\\n\") {
\t\t\tcontinue;
\t\t}
    \t\t\$line = trim(\$line );
\t\t// SET FONT SIZE/STYLE from \$chunk[n]

\t\t// FONTSIZE
\t      if(isset(\$chunk[11]) and \$chunk[11] != '') {
\t\t   if (\$this->shrin_k) {
\t\t\t\$this->SetFontSize(\$chunk[11]/\$this->shrin_k,false);
\t\t   }
\t\t   else {
\t\t\t\$this->SetFontSize(\$chunk[11],false);
\t\t   }
\t\t}
\t\t// FONTFAMILY
\t      if(isset(\$chunk[4]) and \$chunk[4] != '') { \$font = \$this->SetFont(\$chunk[4],\$this->FontStyle,0,false); }
\t\t// B I U
\t      if(isset(\$chunk[2]) and \$chunk[2] != '') {
\t\t\t\$this->SetStyles(\$chunk[2]);
\t      }

\t\t\$lbw = \$rbw = 0;\t// Border widths
\t\tif(isset(\$chunk[16]) && !empty(\$chunk[16])) { //Border
\t\t\t\$this->spanborddet = \$chunk[16];
\t\t\t\$lbw = \$this->spanborddet['L']['w'];
\t\t\t\$rbw = \$this->spanborddet['R']['w'];
\t\t}
\t      if(isset(\$chunk[15])) { \t // Word spacing
\t\t\t\$this->wSpacingCSS = \$chunk[15];
\t\t\tif (\$this->wSpacingCSS && strtoupper(\$this->wSpacingCSS) != 'NORMAL') {
\t\t\t\t\$this->minwSpacing = \$this->ConvertSize(\$this->wSpacingCSS,\$this->FontSize)/\$this->shrin_k; // mPDF 5.7.3
\t\t\t}
\t\t}
\t      if(isset(\$chunk[14])) { \t // Letter spacing
\t\t\t\$this->lSpacingCSS = \$chunk[14];
\t\t\tif ((\$this->lSpacingCSS || \$this->lSpacingCSS==='0') && strtoupper(\$this->lSpacingCSS) != 'NORMAL') {
\t\t\t\t\$this->fixedlSpacing = \$this->ConvertSize(\$this->lSpacingCSS,\$this->FontSize)/\$this->shrin_k; // mPDF 5.7.3
\t\t\t}
\t\t}
\t      if(isset(\$chunk[13])) { \t // Font Kerning
\t\t\t\$this->kerning = \$chunk[13];
\t\t}

\t\t\$words = explode(' ', \$line);
\t\tforeach (\$words as \$k=>\$word) {
\t\t\t\$word = trim(\$word);
\t\t\t\$wordwidth = \$this->GetStringWidth(\$word);
\t\t\tif (\$k==0) { \$wordwidth += \$lbw; }
\t\t\tif (\$k==(count(\$words)-1)) { \$wordwidth += \$rbw; }

\t\t\t//Warn user that maxwidth is insufficient
\t\t\tif (\$wordwidth > \$maxwidth + 0.0001) {
\t\t\t\tif (\$wordwidth > \$biggestword) { \$biggestword = \$wordwidth; }
\t\t\t\t\$toonarrow=true;
\t\t\t}
\t\t}

\t\t// RESET FONT SIZE/STYLE
\t\t// RESETTING VALUES
\t\t//Now we must deactivate what we have used
\t\tif(isset(\$chunk[2]) and \$chunk[2] != '') {
\t\t\t\$this->ResetStyles();
\t\t}
\t\tif(isset(\$chunk[4]) and \$chunk[4] != '') {
\t\t\t\$this->SetFont(\$this->default_font,\$this->FontStyle,0,false);
\t\t}
\t\tif(isset(\$chunk[11]) and \$chunk[11] != '') {
\t\t\t\$this->SetFontSize(\$this->default_font_size,false);
\t\t}
\t\t\$this->spanborddet = array();
\t\t\$this->kerning = false;
\t\t\$this->lSpacingCSS = '';
\t\t\$this->wSpacingCSS = '';
\t\t\$this->fixedlSpacing = false;
\t\t\$this->minwSpacing = 0;
\t}

\t//Return -(wordsize) if word is bigger than maxwidth
\t// ADDED
      if ((\$toonarrow) && (\$this->table_error_report)) {
\t\t\$this->Error(\"Word is too long to fit in table - \".\$this->table_error_report_param);
\t}
\tif (\$toonarrow) return -\$biggestword;
\telse return 1;
}

function shrinkTable(&\$table,\$k) {
 \t\t\$table['border_spacing_H'] /= \$k;
 \t\t\$table['border_spacing_V'] /= \$k;

\t\t\$table['padding']['T'] /= \$k;
\t\t\$table['padding']['R'] /= \$k;
\t\t\$table['padding']['B'] /= \$k;
\t\t\$table['padding']['L'] /= \$k;

\t\t\$table['margin']['T'] /= \$k;
\t\t\$table['margin']['R'] /= \$k;
\t\t\$table['margin']['B'] /= \$k;
\t\t\$table['margin']['L'] /= \$k;

\t\t\$table['border_details']['T']['w'] /= \$k;
\t\t\$table['border_details']['R']['w'] /= \$k;
\t\t\$table['border_details']['B']['w'] /= \$k;
\t\t\$table['border_details']['L']['w'] /= \$k;

\t\tif (isset(\$table['max_cell_border_width']['T'])) \$table['max_cell_border_width']['T'] /= \$k;
\t\tif (isset(\$table['max_cell_border_width']['R'])) \$table['max_cell_border_width']['R'] /= \$k;
\t\tif (isset(\$table['max_cell_border_width']['B'])) \$table['max_cell_border_width']['B'] /= \$k;
\t\tif (isset(\$table['max_cell_border_width']['L'])) \$table['max_cell_border_width']['L'] /= \$k;

\t\tif (\$this->simpleTables){
\t\t\t\$table['simple']['border_details']['T']['w'] /= \$k;
\t\t\t\$table['simple']['border_details']['R']['w'] /= \$k;
\t\t\t\$table['simple']['border_details']['B']['w'] /= \$k;
\t\t\t\$table['simple']['border_details']['L']['w'] /= \$k;
\t\t}

\t\t\$table['miw'] /= \$k;
\t\t\$table['maw'] /= \$k;

\t\tif (\$this->cacheTables) { \$fh = fopen(\$table['cache'], \"r+b\"); }

\t\tfor(\$j = 0 ; \$j < \$table['nc'] ; \$j++ ) { //columns

\t\t   \$table['wc'][\$j]['miw'] /= \$k;
\t\t   \$table['wc'][\$j]['maw'] /= \$k;

\t\t   // mPDF 5.6.13
\t\t   if (isset(\$table['decimal_align'][\$j]['maxs0']) && \$table['decimal_align'][\$j]['maxs0']) { \$table['decimal_align'][\$j]['maxs0'] /= \$k; }
\t\t   if (isset(\$table['decimal_align'][\$j]['maxs1']) && \$table['decimal_align'][\$j]['maxs1']) { \$table['decimal_align'][\$j]['maxs1'] /= \$k; }

\t\t   if (isset(\$table['wc'][\$j]['absmiw']) && \$table['wc'][\$j]['absmiw'] ) \$table['wc'][\$j]['absmiw'] /= \$k;

\t\t   for(\$i = 0 ; \$i < \$table['nr']; \$i++ ) { //rows
\t\t\tif (\$this->cacheTables) {
\t\t\t\t\$c = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t}
\t\t\telse
\t\t\t\t\$c = &\$table['cells'][\$i][\$j];
\t\t\tif (isset(\$c) && \$c)  {
\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t  if (\$this->packTableData) {
\t\t\t\t\t\$cell = \$this->_unpackCellBorder(\$c['borderbin'] );
\t\t\t\t\t\$cell['border_details']['T']['w'] /= \$k;
\t\t\t\t\t\$cell['border_details']['R']['w'] /= \$k;
\t\t\t\t\t\$cell['border_details']['B']['w'] /= \$k;
\t\t\t\t\t\$cell['border_details']['L']['w'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['TL'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['TR'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['BL'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['BR'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['LT'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['LB'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['RT'] /= \$k;
\t\t\t\t\t\$cell['border_details']['mbw']['RB'] /= \$k;
\t\t\t\t\t\$c['borderbin'] = \$this->_packCellBorder(\$cell);
\t\t\t\t  }
\t\t\t\t  else {
\t\t\t\t\t\$c['border_details']['T']['w'] /= \$k;
\t\t\t\t\t\$c['border_details']['R']['w'] /= \$k;
\t\t\t\t\t\$c['border_details']['B']['w'] /= \$k;
\t\t\t\t\t\$c['border_details']['L']['w'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['TL'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['TR'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['BL'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['BR'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['LT'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['LB'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['RT'] /= \$k;
\t\t\t\t\t\$c['border_details']['mbw']['RB'] /= \$k;
\t\t\t\t  }
\t\t\t\t}
\t\t\t\t\$c['padding']['T'] /= \$k;
\t\t\t\t\$c['padding']['R'] /= \$k;
\t\t\t\t\$c['padding']['B'] /= \$k;
\t\t\t\t\$c['padding']['L'] /= \$k;
\t\t\t\t\$c['maxs'] /= \$k;
\t\t\t\tif (isset(\$c['w'])) { \$c['w'] /= \$k; }
\t\t\t\t\$c['s'] /= \$k;
\t\t\t\t\$c['maw'] /= \$k;
\t\t\t\t\$c['miw'] /= \$k;
\t\t\t\tif (isset(\$c['absmiw'])) \$c['absmiw'] /= \$k;
\t\t\t\tif (isset(\$c['nestedmaw'])) \$c['nestedmaw'] /= \$k;
\t\t\t\tif (isset(\$c['nestedmiw'])) \$c['nestedmiw'] /= \$k;
\t\t\t\tif (isset(\$c['textbuffer'])) {
\t\t\t\t\tforeach(\$c['textbuffer'] AS \$n=>\$tb) {
\t\t\t\t\t\tif (!empty(\$tb[16])) {
\t\t\t\t\t\t\t\$c['textbuffer'][\$n][16]['T']['w'] /= \$k;
\t\t\t\t\t\t\t\$c['textbuffer'][\$n][16]['B']['w'] /= \$k;
\t\t\t\t\t\t\t\$c['textbuffer'][\$n][16]['L']['w'] /= \$k;
\t\t\t\t\t\t\t\$c['textbuffer'][\$n][16]['R']['w'] /= \$k;
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$this->_cacheCell(\$c, '', \"W\", \$fh, \$table['cells'][\$i][\$j]);
\t\t\t\t}
\t\t\t\tunset(\$c);
\t\t\t}
\t\t   }//rows
\t\t}//columns
\t\tif (\$this->cacheTables) { fclose(\$fh); }
}

function _cacheCell(\$c, \$file, \$mode=\"A\", \$fh=null, \$offset=0) {\t// mode = Append or (over)Write (needs offset and fh)
\t// Requires either \$file OR \$fh (file_handle)
\tif (!is_array(\$c) || !isset(\$c)) { return ''; }

\tif(isset(\$c['w'])) { \$cw = \$c['w']; } else { \$cw = -1; }
\tif(isset(\$c['w0'])) { \$cw0 = \$c['w0']; } else { \$cw0 = -1; }
\tif(isset(\$c['h0'])) { \$ch0 = \$c['h0']; } else { \$ch0 = -1; }

\t\$data = pack(\"n2d19A1A1n2sA32A128\",
\t\t\$c['colspan'],\t\t/* n  (16 bit; 2 bytes) [pos 0] */
\t\t\$c['rowspan'],\t\t/* n (16 bit; 2 bytes) [pos 2] */
\t\t\$c['s'],\t\t\t/* d NB machine-dependent size (64 bit; 8 bytes on test winOS) [pos 4] */
\t\t\$c['maxs'],\t\t\t/* d NB machine-dependent size [pos 4 + 1*D] */
\t\t\$c['nestedmaw'],\t\t/* d NB machine-dependent size [pos 4 + 2*D] */
\t\t\$c['nestedmiw'],\t\t/* d NB machine-dependent size [pos 4 + 3*D] */
\t\t\$c['padding']['L'],\t/* d NB machine-dependent size [pos 4 + 4*D] */
\t\t\$c['padding']['R'],\t/* d NB machine-dependent size [pos 4 + 5*D] */
\t\t\$c['padding']['T'],\t/* d NB machine-dependent size [pos 4 + 6*D] */
\t\t\$c['padding']['B'],\t/* d NB machine-dependent size [pos 4 + 7*D] */
\t\t\$c['dfs'],\t\t\t/* d NB machine-dependent size [pos 4 + 8*D] */
\t\t\$cw,\t\t\t\t/* d NB machine-dependent size [pos 4 + 9*D] */
\t\t\$c['h'],\t\t\t/* d NB machine-dependent size [pos 4 + 10*D] */
\t\t\$c['absmiw'],\t\t/* d NB machine-dependent size [pos 4 + 11*D] */
\t\t\$c['maw'],\t\t\t/* d NB machine-dependent size [pos 4 + 12*D] */
\t\t\$c['miw'],\t\t\t/* d NB machine-dependent size [pos 4 + 13*D] */
\t\t\$c['mih'],\t\t\t/* d NB machine-dependent size [pos 4 + 14*D] */
\t\t\$c['x0'],\t\t\t/* d NB machine-dependent size [pos 4 + 15*D] */
\t\t\$cw0,\t\t\t\t/* d NB machine-dependent size [pos 4 + 16*D] */
\t\t\$c['y0'],\t\t\t/* d NB machine-dependent size [pos 4 + 17*D] */
\t\t\$ch0,\t\t\t\t/* d NB machine-dependent size [pos 4 + 18*D] */
\t\t\$c['a'],\t\t\t/* A1 (1 byte) [pos 4 + 19*D] */
\t\t\$c['va'],\t\t\t/* A1 (1 byte) [pos 5 + 19*D] */
\t\t\$c['nowrap'],\t\t/* 1 or blank  n (16 bit; 2 bytes) [pos 6 + 19*D] */
\t\t\$c['wpercent'],\t\t/* 0 - 100  n (16 bit; 2 bytes) [pos 8 + 19*D] */
\t\t\$c['R'],\t\t\t/* 90 or -90 s (16 bit; 2 bytes) [pos 10 + 19*D] */
\t\t\$c['bgcolor'],\t\t/* A32 (32 bytes) [pos 12 + 19*D] */
\t\t\$c['gradient']\t\t/* A128 (128 bytes) [pos 44 + 19*D] */
\t);

\tif (\$c['background-image']) {
\t\t\$data .= pack(\"n2d2A6A6n3dA4A128\",
\t\tstrlen(\$data),\t\t/* offset in main data to start of bgimage data */
\t\t\$c['background-image']['image_id'],\t/* n */
\t\t\$c['background-image']['orig_w'],\t/* d NB machine-dependent size */
\t\t\$c['background-image']['orig_h'],\t/* d NB machine-dependent size */
\t\t\$c['background-image']['x_pos'],\t/* A6 calc size or \"50%\" */
\t\t\$c['background-image']['y_pos'],\t/* A6 calc size or \"50%\" */
\t\t\$c['background-image']['x_repeat'],\t/* n true or false*/
\t\t\$c['background-image']['y_repeat'],\t/* n true or false */
\t\t\$c['background-image']['resize'],\t/* n 0 - 6 */
\t\t\$c['background-image']['opacity'],\t/* d  0-1 */
\t\t\$c['background-image']['itype'],\t/* A4 jpg etc */
\t\t\$c['background-image']['gradient']\t/* A128 CSS string */
\t\t);
\t}
\telse \$data .= pack(\"n\",0);
\t\$tb_offset = 2 + 186 + 2 + strlen(\$data);
\t\$stb = serialize(\$c['textbuffer']).'        ';\t// buffer to allow updating in reverseTableDir
\t\$lentb = strlen(\$stb);
\t\$data2 = pack(\"nA\".\$lentb, \$lentb, \$stb);

\t\$tempfh = true;
\tif (\$mode==\"W\" && \$offset) {
\t\tif (!\$fh) { \$fh = fopen(\$file, \"r+b\"); }\t// Overwrite (but not truncate)
\t\telse \$tempfh = false;
\t\tfseek(\$fh, \$offset);
\t}
\telse {
\t\t\$fh = fopen(\$file, \"ab\");\t// APPEND
\t}
\tfwrite(\$fh, pack(\"n\",\$tb_offset));\t\t// Offset to Text buffer 2 bytes
\tfwrite(\$fh, \$c['borderbin']);\t\t\t// border details 186 bytes
\tfwrite(\$fh, pack(\"n\",strlen(\$data)));\t// Length of Main data
\tfwrite(\$fh, \$data);\t\t\t\t// Main data
\tfwrite(\$fh, \$data2);\t\t\t\t// Text buffer (starts with \"n\" length of text buffer)
\tif (\$tempfh) fclose(\$fh);
\treturn (\$tb_offset + 2 + \$lentb);
}

function _cacheUpdateTxB(\$c, \$fh, \$offset) {
\tfseek(\$fh, \$offset);
\t\$tb_offset = \$this->read_short(\$fh);\t\t// First entry = Offset to Text buffer  2 bytes
\tfseek(\$fh, (\$tb_offset-2), SEEK_CUR);
\t\$lentb = \$this->read_short(\$fh);\t\t\t// First entry in textbuffer = Length of serialized textbuffer - do not update
\t\$stb = serialize(\$c['textbuffer']);
\tfwrite(\$fh, pack(\"A\".\$lentb, \$stb));
}

function _cacheUpdateBorder(\$c, \$fh, \$offset) {
\t\$offset += 2;
\tfseek(\$fh, \$offset);
\tfwrite(\$fh, \$c['borderbin']);
}

function _cacheUpdateMtx(\$c, \$fh, \$offset, \$var) {
\tif (\$var=='mih') { \$offset += (2 + 186 + 2 + 4 + 14*_DSIZE); }
\telse if (\$var=='x0') { \$offset += (2 + 186 + 2 + 4 + 15*_DSIZE); }\t// x0 and w0
\telse if (\$var=='y0') { \$offset += (2 + 186 + 2 + 4 + 17*_DSIZE); }\t// y0 and h0
\tfseek(\$fh, \$offset);
\tif (\$var=='mih') { fwrite(\$fh, pack(\"d\",\$c['mih'])); }
\telse if (\$var=='x0') { fwrite(\$fh, pack(\"d2\",\$c['x0'],\$c['w0'])); }
\telse if (\$var=='y0') { fwrite(\$fh, pack(\"d2\",\$c['y0'],\$c['h0'])); }
}

function _uncacheCell(\$ptr, \$file, \$fh) {
\t// Requires either \$file or \$fh (file_handle)
\tif (\$ptr==0) { return null; }
\tif (is_array(\$ptr)) { \$this->Error(\"Probable cause - missing end tag &lt;/td&gt;. You may be able to change the configurable variable: allow_html_optional_endtags \"); }
\t\$tempfh = true;
\tif (!\$fh) { \$fh = fopen(\$file, \"rb\"); }
\telse \$tempfh = false;
\tfseek(\$fh, \$ptr);
\t\$c = array();
\t\$tb_offset = \$this->read_short(\$fh);\t\t// First entry = Offset to Text buffer  2 bytes
\t\$c['borderbin'] = fread(\$fh,186);\t\t\t// border details 186 bytes
\t\$maindatalen = \$this->read_short(\$fh);\t\t// Length of Main data (2 bytes)
\t\$str = fread(\$fh,\$maindatalen );\t\t\t// Main data
\t\$data = unpack(\"ncolspan/nrowspan/ds/dmaxs/dnmaw/dnmiw/dpl/dpr/dpt/dpb/ddfs/dw/dh/dabsmiw/dmaw/dmiw/dmih/dx0/dw0/dy0/dh0/A1a/A1va/nnowrap/nwpercent/sR/A32bgcol/A128grad/nbgimage\", \$str);

\t\tif (\$data['colspan']>0) \$c['colspan'] = \$data['colspan'];\t\t/* n */
\t\tif (\$data['rowspan']>0) \$c['rowspan'] = \$data['rowspan'];\t\t/* n */
\t\t\$c['s'] = \$data['s'];\t\t\t\t/* d NB machine-dependent size */
\t\t\$c['maxs'] = \$data['maxs'];\t\t\t/* d NB machine-dependent size */
\t\tif (\$data['nmaw']>0) \$c['nestedmaw'] = \$data['nmaw'];\t\t/* d NB machine-dependent size */
\t\tif (\$data['nmiw']>0) \$c['nestedmiw'] = \$data['nmiw'];\t\t/* d NB machine-dependent size */
\t\t\$c['padding']['L'] = \$data['pl'];\t\t/* d NB machine-dependent size */
\t\t\$c['padding']['R'] = \$data['pr'];\t\t/* d NB machine-dependent size */
\t\t\$c['padding']['T'] = \$data['pt'];\t\t/* d NB machine-dependent size */
\t\t\$c['padding']['B'] = \$data['pb'];\t\t/* d NB machine-dependent size */
\t\t\$c['dfs'] = \$data['dfs'];\t\t\t/* d NB machine-dependent size */
\t\tif (\$data['w']>=0) \$c['w'] = \$data['w'];\t/* d NB machine-dependent size */
\t\tif (\$data['h']>0) \$c['h'] = \$data['h'];\t/* d NB machine-dependent size */
\t\tif (\$data['absmiw']>0) \$c['absmiw'] = \$data['absmiw'];\t/* d NB machine-dependent size */
\t\tif (\$data['maw']>0) \$c['maw'] = \$data['maw'];\t/* d NB machine-dependent size */
\t\tif (\$data['miw']>0) \$c['miw'] = \$data['miw'];\t/* d NB machine-dependent size */
\t\tif (\$data['mih']>0) \$c['mih'] = \$data['mih'];\t/* d NB machine-dependent size */
\t\tif (\$data['w0']>=0) { \$c['w0'] = \$data['w0'];\t/* d NB machine-dependent size */
\t\t\t\$c['x0'] = \$data['x0']; }\t/* d NB machine-dependent size */
\t\tif (\$data['h0']>=0) { \$c['h0'] = \$data['h0'];\t/* d NB machine-dependent size */
\t\t\t\$c['y0'] = \$data['y0']; }\t/* d NB machine-dependent size */
\t\t\$c['a'] = trim(\$data['a']);\t\t\t/* A1 */
\t\t\$c['va'] = trim(\$data['va']);\t\t\t/* A1 */
\t\tif (\$data['nowrap']) \$c['nowrap'] = \$data['nowrap'];\t\t/* 1 or blank  n */
\t\t\telse \$c['nowrap'] = false;
\t\tif (\$data['wpercent']>0) \$c['wpercent'] = \$data['wpercent'];\t/* 0 - 100  n */
\t\tif (\$data['R']<>0) \$c['R'] = \$data['R'];\t\t\t\t/* 90 or -90 s */
\t\t\telse \$c['R'] = false;
\t\t\$c['bgcolor'] = trim(\$data['bgcol']);\t\t\t/* A32 */
\t\tif (trim(\$data['grad']))
\t\t\t\$c['gradient'] = trim(\$data['grad']);\t\t/* A128 */
\t\t  else \$c['gradient'] = false;
\t\tif (\$data['bgimage']>0) {
\t\t\t\$bgidata = substr(\$str, (\$data['bgimage']+2));
\t\t\t\$c['background-image'] = unpack(\"nimage_id/dorig_w/dorig_h/A6x_pos/A6y_pos/nx_repeat/ny_repeat/nresize/dopacity/A4itype/A128gradient\", \$bgidata);
\t\t}

\t\$tblen = \$this->read_short(\$fh);\t\t\t\t// Length of Textbuffer
\t\$tbsp = fread(\$fh,\$tblen);\t\t\t\t\t// Textbuffer (serialised and packed)
\t\$tbs = unpack(\"A\".\$tblen.\"textbuffer\",\$tbsp);\t\t// Textbuffer unpacked
\t\$c['textbuffer'] = unserialize(trim(\$tbs['textbuffer']));\t// Textbuffer unserialized

\tif (\$tempfh) { fclose(\$fh); }
\treturn (\$c);
}
function read_short(&\$fh) {
\t\t\$s = fread(\$fh,2);
\t\t\$a = (ord(\$s[0])<<8) + ord(\$s[1]);
\t\tif (\$a & (1 << 15) ) {
\t\t\t\$a = (\$a - (1 << 16));
\t\t}
\t\treturn \$a;
}
function _backupCacheFiles() {
\tforeach(\$this->table AS \$lvl=>\$t) {
\t\tforeach(\$this->table[\$lvl] AS \$c=>\$t2) {
///////////////////////////if (!file_exists(\$t2['cache'])) { echo \$lvl; echo \$c; print_r(\$this->table); exit; }
\t\t\tcopy( \$t2['cache'], \$t2['cache'].'.bak');
\t\t}
\t}
}
function _restoreCacheFiles() {
\tforeach(\$this->table AS \$lvl=>\$t) {
\t\tforeach(\$this->table[\$lvl] AS \$c=>\$t2) {
\t\t\tcopy( \$t2['cache'].'.bak', \$t2['cache']);
\t\t}
\t}
}


function _packCellBorder(\$cell) {
\tif (!is_array(\$cell) || !isset(\$cell)) { return ''; }

\tif (!\$this->packTableData) { return \$cell; }
\t// = 186 bytes
\t\$bindata = pack(\"nnda6A10nnda6A10nnda6A10nnda6A10nd9\",
\t\$cell['border'],
\t\$cell['border_details']['R']['s'],
\t\$cell['border_details']['R']['w'],
\t\$cell['border_details']['R']['c'],
\t\$cell['border_details']['R']['style'],
\t\$cell['border_details']['R']['dom'],

\t\$cell['border_details']['L']['s'],
\t\$cell['border_details']['L']['w'],
\t\$cell['border_details']['L']['c'],
\t\$cell['border_details']['L']['style'],
\t\$cell['border_details']['L']['dom'],

\t\$cell['border_details']['T']['s'],
\t\$cell['border_details']['T']['w'],
\t\$cell['border_details']['T']['c'],
\t\$cell['border_details']['T']['style'],
\t\$cell['border_details']['T']['dom'],

\t\$cell['border_details']['B']['s'],
\t\$cell['border_details']['B']['w'],
\t\$cell['border_details']['B']['c'],
\t\$cell['border_details']['B']['style'],
\t\$cell['border_details']['B']['dom'],

\t\$cell['border_details']['mbw']['BL'],
\t\$cell['border_details']['mbw']['BR'],
\t\$cell['border_details']['mbw']['RT'],
\t\$cell['border_details']['mbw']['RB'],
\t\$cell['border_details']['mbw']['TL'],
\t\$cell['border_details']['mbw']['TR'],
\t\$cell['border_details']['mbw']['LT'],
\t\$cell['border_details']['mbw']['LB'],

\t\$cell['border_details']['cellposdom']
\t);
\treturn \$bindata;
}



function _getBorderWidths(\$bindata) {
\tif (!\$bindata) { return array(0,0,0,0); }
\tif (!\$this->packTableData) { return array(\$bindata['border_details']['T']['w'], \$bindata['border_details']['R']['w'], \$bindata['border_details']['B']['w'], \$bindata['border_details']['L']['w']); }

\t\$bd = unpack(\"nbord/nrs/drw/a6rca/A10rst/nrd/nls/dlw/a6lca/A10lst/nld/nts/dtw/a6tca/A10tst/ntd/nbs/dbw/a6bca/A10bst/nbd/dmbl/dmbr/dmrt/dmrb/dmtl/dmtr/dmlt/dmlb/dcpd\", \$bindata);
\t\$cell['border_details']['R']['w'] = \$bd['rw'];
\t\$cell['border_details']['L']['w'] = \$bd['lw'];
\t\$cell['border_details']['T']['w'] = \$bd['tw'];
\t\$cell['border_details']['B']['w'] = \$bd['bw'];
\treturn array(\$bd['tw'], \$bd['rw'], \$bd['bw'], \$bd['lw']);
}


function _unpackCellBorder(\$bindata) {
\tif (!\$bindata) { return array(); }
\tif (!\$this->packTableData) { return \$bindata; }

\t\$bd = unpack(\"nbord/nrs/drw/a6rca/A10rst/nrd/nls/dlw/a6lca/A10lst/nld/nts/dtw/a6tca/A10tst/ntd/nbs/dbw/a6bca/A10bst/nbd/dmbl/dmbr/dmrt/dmrb/dmtl/dmtr/dmlt/dmlb/dcpd\", \$bindata);

\t\$cell['border'] = \$bd['bord'];
\t\$cell['border_details']['R']['s'] = \$bd['rs'];
\t\$cell['border_details']['R']['w'] = \$bd['rw'];
\t\$cell['border_details']['R']['c'] = \$bd['rca'];
\t\$cell['border_details']['R']['style'] = trim(\$bd['rst']);
\t\$cell['border_details']['R']['dom'] = \$bd['rd'];

\t\$cell['border_details']['L']['s'] = \$bd['ls'];
\t\$cell['border_details']['L']['w'] = \$bd['lw'];
\t\$cell['border_details']['L']['c'] = \$bd['lca'];
\t\$cell['border_details']['L']['style'] = trim(\$bd['lst']);
\t\$cell['border_details']['L']['dom'] = \$bd['ld'];

\t\$cell['border_details']['T']['s'] = \$bd['ts'];
\t\$cell['border_details']['T']['w'] = \$bd['tw'];
\t\$cell['border_details']['T']['c'] = \$bd['tca'];
\t\$cell['border_details']['T']['style'] = trim(\$bd['tst']);
\t\$cell['border_details']['T']['dom'] = \$bd['td'];

\t\$cell['border_details']['B']['s'] = \$bd['bs'];
\t\$cell['border_details']['B']['w'] = \$bd['bw'];
\t\$cell['border_details']['B']['c'] = \$bd['bca'];
\t\$cell['border_details']['B']['style'] = trim(\$bd['bst']);
\t\$cell['border_details']['B']['dom'] = \$bd['bd'];

\t\$cell['border_details']['mbw']['BL'] = \$bd['mbl'];
\t\$cell['border_details']['mbw']['BR'] = \$bd['mbr'];
\t\$cell['border_details']['mbw']['RT'] = \$bd['mrt'];
\t\$cell['border_details']['mbw']['RB'] = \$bd['mrb'];
\t\$cell['border_details']['mbw']['TL'] = \$bd['mtl'];
\t\$cell['border_details']['mbw']['TR'] = \$bd['mtr'];
\t\$cell['border_details']['mbw']['LT'] = \$bd['mlt'];
\t\$cell['border_details']['mbw']['LB'] = \$bd['mlb'];
\t\$cell['border_details']['cellposdom'] = \$bd['cpd'];

\treturn(\$cell);
}


////////////////////////TABLE CODE (from PDFTable)/////////////////////////////////////
////////////////////////TABLE CODE (from PDFTable)/////////////////////////////////////
////////////////////////TABLE CODE (from PDFTable)/////////////////////////////////////
//table\t\tArray of (w, h, bc, nr, wc, hr, cells)
//w\t\t\tWidth of table
//h\t\t\tHeight of table
//nc\t\t\tNumber column
//nr\t\t\tNumber row
//hr\t\t\tList of height of each row
//wc\t\t\tList of width of each column
//cells\t\tList of cells of each rows, cells[i][j] is a cell in the table
function _tableColumnWidth(&\$table,\$firstpass=false){
\t\$cs = &\$table['cells'];

\t\$nc = \$table['nc'];
\t\$nr = \$table['nr'];
\t\$listspan = array();

\tif (\$table['borders_separate']) {
\t\t\$tblbw = \$table['border_details']['L']['w'] + \$table['border_details']['R']['w'] + \$table['margin']['L'] + \$table['margin']['R'] +  \$table['padding']['L'] + \$table['padding']['R'] + \$table['border_spacing_H'];
\t}
\telse { \$tblbw = \$table['max_cell_border_width']['L']/2 + \$table['max_cell_border_width']['R']/2 + \$table['margin']['L'] + \$table['margin']['R']; }

\tif (\$this->cacheTables) { \$fh = fopen(\$table['cache'], \"r+b\"); }
\telse { \$fh = null; }

\t// ADDED table['l'][colno]
\t// = total length of text approx (using \$c['s']) in that column - used to approximately distribute col widths in _tableWidth
\t//
\tfor(\$j = 0 ; \$j < \$nc ; \$j++ ) { //columns
\t\t\$wc = &\$table['wc'][\$j];
\t\tfor(\$i = 0 ; \$i < \$nr ; \$i++ ) { //rows
\t\t\tif (isset(\$cs[\$i][\$j]) && \$cs[\$i][\$j])  {
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$c = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t\t}
\t\t\t\telse
\t\t\t\t\t\$c = &\$cs[\$i][\$j];

\t\t\t\tif (\$this->simpleTables){
\t\t\t\t\t   if (\$table['borders_separate']) {\t// NB twice border width
\t\t\t\t\t\t\$extrcw = \$table['simple']['border_details']['L']['w'] + \$table['simple']['border_details']['R']['w'] + \$c['padding']['L'] + \$c['padding']['R'] + \$table['border_spacing_H'];
\t\t\t\t\t   }
\t\t\t\t\t   else {
\t\t\t\t\t\t\$extrcw = \$table['simple']['border_details']['L']['w']/2 + \$table['simple']['border_details']['R']['w']/2 + \$c['padding']['L'] + \$c['padding']['R'];
\t\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse {
\t\t\t \t   if (\$this->packTableData) {
\t\t\t \t   \tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$c['borderbin']);
\t\t\t \t   }
\t\t\t \t   else {
\t\t\t\t\t\$br = \$c['border_details']['R']['w'];
\t\t\t\t\t\$bl = \$c['border_details']['L']['w'];
\t\t\t\t   }
\t\t\t\t   if (\$table['borders_separate']) {\t// NB twice border width
\t\t\t\t\t\$extrcw = \$bl + \$br + \$c['padding']['L'] + \$c['padding']['R'] + \$table['border_spacing_H'];
\t\t\t\t   }
\t\t\t\t   else {
\t\t\t\t\t\$extrcw = \$bl/2 + \$br/2 + \$c['padding']['L'] + \$c['padding']['R'];
\t\t\t\t   }
\t\t\t\t}
\t\t\t\t//\$mw = \$this->GetStringWidth('W') + \$extrcw ;
\t\t\t\t\$mw = 0;
\t\t\t\t// mPDF 5.6.13  Decimal point alignment
\t\t\t\tif(substr(\$c['a'],0,1) == 'D') {
\t\t\t\t\t\$mw = \$table['decimal_align'][\$j]['maxs0'] + \$table['decimal_align'][\$j]['maxs1'] + \$extrcw ;
\t\t\t\t}

\t\t\t\t\$c['absmiw'] = \$mw;

\t\t\t\tif (isset(\$c['R']) && \$c['R']) {
\t\t\t\t\t\$c['maw'] = \$c['miw'] = \$this->FontSize + \$extrcw ;
\t\t\t\t\tif (isset(\$c['w'])) {\t// If cell width is specified
\t\t\t\t\t\tif (\$c['miw'] <\$c['w'])\t{ \$c['miw'] = \$c['w']; }
\t\t\t\t\t}
\t\t\t\t\tif (!isset(\$c['colspan'])) {
\t\t\t\t\t\tif (\$wc['miw'] < \$c['miw']) { \$wc['miw']\t= \$c['miw']; }
\t\t\t\t\t\tif (\$wc['maw'] < \$c['maw']) { \$wc['maw']\t= \$c['maw']; }

\t\t\t\t\t\tif (\$firstpass) {
\t\t\t\t\t\t   if (isset(\$table['l'][\$j]) ) {
\t\t\t\t\t\t\t\$table['l'][\$j] += \$c['miw'] ;
\t\t\t\t\t\t   }
\t\t\t\t\t\t   else {
\t\t\t\t\t\t\t\$table['l'][\$j] = \$c['miw'] ;
\t\t\t\t\t\t   }
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\tif (\$c['miw'] > \$wc['miw']) { \$wc['miw'] = \$c['miw']; }
        \t\t\t\tif (\$wc['miw'] > \$wc['maw']) { \$wc['maw'] = \$wc['miw']; }
\t\t\t\t\tcontinue;
\t\t\t\t}

\t\t\t\tif (\$firstpass) {
\t\t\t\t\tif (isset(\$c['s'])) { \$c['s'] += \$extrcw; }
\t\t\t\t\tif (isset(\$c['maxs'])) { \$c['maxs'] += \$extrcw; }
\t\t\t\t\tif (isset(\$c['nestedmiw'])) { \$c['nestedmiw'] += \$extrcw; }
\t\t\t\t\tif (isset(\$c['nestedmaw'])) { \$c['nestedmaw'] += \$extrcw; }
\t\t\t\t}

\t\t\t\t// If minimum width has already been set by a nested table or inline object (image/form), use it
\t\t\t\tif (isset(\$c['nestedmiw']) && \$this->table[1][1]['overflow']!='visible') { \$miw = \$c['nestedmiw']; }
\t\t\t\telse  { \$miw = \$mw; }

\t\t\t\tif (isset(\$c['maxs']) && \$c['maxs'] != '') { \$c['s'] = \$c['maxs']; }

\t\t\t\t// If maximum width has already been set by a nested table, use it
\t\t\t\tif (isset(\$c['nestedmaw'])) { \$c['maw'] = \$c['nestedmaw']; }
\t\t\t\telse \$c['maw'] = \$c['s'];

\t\t\t\tif (isset(\$table['overflow']) && \$table['overflow']=='visible' && \$table['level']==1) {
\t\t\t\t\tif ((\$c['maw'] + \$tblbw) > \$this->blk[\$this->blklvl]['inner_width']) {
\t\t\t\t\t\t\$c['maw'] = \$this->blk[\$this->blklvl]['inner_width'] - \$tblbw;
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\tif (isset(\$c['nowrap']) && \$c['nowrap']) { \$miw = \$c['maw']; }

\t\t\t\tif (isset(\$c['wpercent']) && \$firstpass) {
\t \t\t\t\tif (isset(\$c['colspan'])) {\t// Not perfect - but % set on colspan is shared equally on cols.
\t\t\t\t\t   for(\$k=0;\$k<\$c['colspan'];\$k++) {
\t\t\t\t\t\t\$table['wc'][(\$j+\$k)]['wpercent'] = \$c['wpercent'] / \$c['colspan'];
\t\t\t\t\t   }
\t\t\t\t\t}
\t \t\t\t\telse {
\t\t\t\t\t\tif (isset(\$table['w']) && \$table['w']) { \$c['w'] = \$c['wpercent']/100 * (\$table['w'] - \$tblbw ); }
\t\t\t\t\t\t\$wc['wpercent'] = \$c['wpercent'];
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\tif (isset(\$table['overflow']) && \$table['overflow']=='visible' && \$table['level']==1) {
\t\t\t\t\tif ((\$c['w'] + \$tblbw) > \$this->blk[\$this->blklvl]['inner_width']) {
\t\t\t\t\t\t\$c['w'] = \$this->blk[\$this->blklvl]['inner_width'] - \$tblbw;
\t\t\t\t\t}
\t\t\t\t}


\t\t\t\tif (isset(\$c['w'])) {\t// If cell width is specified
\t\t\t\t\tif (\$miw<\$c['w'])\t{ \$c['miw'] = \$c['w']; }\t// Cell min width = that specified
\t\t\t\t\tif (\$miw>\$c['w'])\t{ \$c['miw'] = \$c['w'] = \$miw; } // If width specified is less than minimum allowed (W) increase it
\t\t\t\t\tif (!isset(\$wc['w'])) { \$wc['w'] = 1; }\t\t// If the Col width is not specified = set it to 1
\t\t\t\t\t\$c['maw'] = \$c['w'];\t// mPDF 5.7.3
\t\t\t\t}
\t\t\t\telse { \$c['miw'] = \$miw; }\t// If cell width not specified -> set Cell min width it to minimum allowed (W)

\t\t\t\tif (\$c['maw']  < \$c['miw']) { \$c['maw'] = \$c['miw']; }\t// If Cell max width < Minwidth - increase it to =
\t\t\t\tif (!isset(\$c['colspan'])) {
\t\t\t\t\tif (\$wc['miw'] < \$c['miw']) { \$wc['miw']\t= \$c['miw']; }\t// Update Col Minimum and maximum widths
\t\t\t\t\tif (\$wc['maw'] < \$c['maw']) { \$wc['maw']\t= \$c['maw']; }
\t\t\t\t\tif ((isset(\$wc['absmiw']) && \$wc['absmiw'] < \$c['absmiw']) || !isset(\$wc['absmiw'])) { \$wc['absmiw'] = \$c['absmiw']; }\t// Update Col Minimum and maximum widths

\t\t\t\t\tif (isset(\$table['l'][\$j]) ) {
\t\t\t\t\t\t\$table['l'][\$j] += \$c['s'];
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$table['l'][\$j] = \$c['s'];
\t\t\t\t\t}

\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$listspan[] = array(\$i,\$j);
\t\t\t\t}

\t\t\t\t//Check if minimum width of the whole column is big enough for largest word to fit
\t\t\t\tif (isset(\$c['textbuffer']) && (!isset(\$table['overflow']) || \$table['overflow']!='wrap')) {\t// mPDF 5.5.11
\t\t       \t\t\t\$minwidth = \$this->TableCheckMinWidth(\$wc['miw']- \$extrcw ,0,\$c['textbuffer']);
\t\t\t\t}
\t\t\t\telse { \$minwidth = 0; }
        \t\t\tif (\$minwidth < 0) {
\t\t\t\t\t//increase minimum width
\t\t\t\t\tif (!isset(\$c['colspan'])) {
\t\t\t\t\t\t\$wc['miw'] = max(\$wc['miw'],((-\$minwidth) + \$extrcw) );
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$c['miw'] = max(\$c['miw'],((-\$minwidth) + \$extrcw) );
\t\t\t\t\t}
\t\t\t\t}
 \t\t\t\tif (!isset(\$c['colspan'])) {
\t        \t\t\tif (\$wc['miw'] > \$wc['maw']) { \$wc['maw'] = \$wc['miw']; } //update maximum width, if needed
\t\t\t\t}
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$this->_cacheCell(\$c, '', \"W\", \$fh, \$table['cells'][\$i][\$j]);
\t\t\t\t}
\t\t\t}
\t\t\tunset(\$c);
\t\t}//rows
\t}//columns

\t// COLUMN SPANS
\t\$wc = &\$table['wc'];
\tforeach (\$listspan as \$span) {
\t\tlist(\$i,\$j) = \$span;
\t\tif (\$this->cacheTables) {
\t\t\t\$c = \$this->_uncacheCell(\$cs[\$i][\$j], '', \$fh);
\t\t}
\t\telse
\t\t\t\$c = &\$cs[\$i][\$j];
\t\t\$lc = \$j + \$c['colspan'];
\t\tif (\$lc > \$nc) { \$lc = \$nc; }
\t\t\$wis = \$wisa = 0;
\t\t\$was = \$wasa = 0;
\t\t\$list = array();
\t\tfor(\$k=\$j;\$k<\$lc;\$k++) {
\t\t\tif (isset(\$table['l'][\$k]) ) {
\t\t\t\tif (\$c['R']) { \$table['l'][\$k] += \$c['miw']/\$c['colspan'] ; }
\t\t\t\telse { \$table['l'][\$k] += \$c['s']/\$c['colspan']; }
\t\t\t}
\t\t\telse {
\t\t\t\tif (\$c['R']) { \$table['l'][\$k] = \$c['miw']/\$c['colspan'] ; }
\t\t\t\telse { \$table['l'][\$k] = \$c['s']/\$c['colspan']; }
\t\t\t}
\t\t\t\$wis += \$wc[\$k]['miw'];
\t\t\t\$was += \$wc[\$k]['maw'];
\t\t\tif (!isset(\$c['w'])) {
\t\t\t\t\$list[] = \$k;
\t\t\t\t\$wisa += \$wc[\$k]['miw'];
\t\t\t\t\$wasa += \$wc[\$k]['maw'];
\t\t\t}
\t\t}
\t\tif (\$c['miw'] > \$wis) {
\t\t\tif (!\$wis) {
\t\t\t\tfor(\$k=\$j;\$k<\$lc;\$k++) { \$wc[\$k]['miw'] = \$c['miw']/\$c['colspan']; }
\t\t\t}
\t\t\telse if (!count(\$list)) {
\t\t\t\t\$wi = \$c['miw'] - \$wis;
\t\t\t\tfor(\$k=\$j;\$k<\$lc;\$k++) { \$wc[\$k]['miw'] += (\$wc[\$k]['miw']/\$wis)*\$wi; }
\t\t\t}
\t\t\telse {
\t\t\t\t\$wi = \$c['miw'] - \$wis;
\t\t\t\tforeach (\$list as \$k) { if (!isset(\$wc[\$k]['w']) || !\$wc[\$k]['w']) \$wc[\$k]['miw'] += (\$wc[\$k]['miw']/\$wisa)*\$wi; }\t// mPDF 5.7.2
\t\t\t}
\t\t}
\t\tif (\$c['maw'] > \$was) {
\t\t\tif (!\$wis) {
\t\t\t\tfor(\$k=\$j;\$k<\$lc;\$k++) { \$wc[\$k]['maw'] = \$c['maw']/\$c['colspan']; }
\t\t\t}
\t\t\telse if (!count(\$list)) {
\t\t\t\t\$wi = \$c['maw'] - \$was;
\t\t\t\tfor(\$k=\$j;\$k<\$lc;\$k++) { \$wc[\$k]['maw'] += (\$wc[\$k]['maw']/\$was)*\$wi; }
\t\t\t}
\t\t\telse {
\t\t\t\t\$wi = \$c['maw'] - \$was;
\t\t\t\tforeach (\$list as \$k) { \$wc[\$k]['maw'] += (\$wc[\$k]['maw']/\$wasa)*\$wi; }
\t\t\t}
\t\t}
\t\tunset(\$c);
\t}

\tif (\$this->cacheTables) { fclose(\$fh); }

\t\$checkminwidth = 0;
\t\$checkmaxwidth = 0;
\t\$totallength = 0;

\tfor( \$i = 0 ; \$i < \$nc ; \$i++ ) {
\t\t\$checkminwidth += \$table['wc'][\$i]['miw'];
\t\t\$checkmaxwidth += \$table['wc'][\$i]['maw'];
\t\t\$totallength += \$table['l'][\$i];
\t}

\tif (!isset(\$table['w']) && \$firstpass) {
\t   \$sumpc = 0;
\t   \$notset = 0;
\t   for( \$i = 0 ; \$i < \$nc ; \$i++ ) {
\t\t  if (isset(\$table['wc'][\$i]['wpercent']) && \$table['wc'][\$i]['wpercent']) {
\t\t\t\$sumpc += \$table['wc'][\$i]['wpercent'];
\t\t  }
\t\t  else { \$notset++; }
\t   }

\t   // If sum of widths as %  >= 100% and not all columns are set
\t\t// Set a nominal width of 1% for unset columns
\t   if (\$sumpc >= 100 && \$notset) {
\t   \tfor( \$i = 0 ; \$i < \$nc ; \$i++ ) {
\t\t  if ((!isset(\$table['wc'][\$i]['wpercent']) || !\$table['wc'][\$i]['wpercent']) &&
\t\t\t(!isset(\$table['wc'][\$i]['w']) || !\$table['wc'][\$i]['w'])) {
\t\t\t\$table['wc'][\$i]['wpercent'] = 1;
\t\t  }
\t   \t}
\t   }


\t   if (\$sumpc) {\t// if any percents are set
\t\t\$sumnonpc = (100 - \$sumpc);
\t\t\$sumpc = max(\$sumpc,100);
\t      \$miwleft = 0;
\t\t\$miwleftcount = 0;
\t\t\$miwsurplusnonpc = 0;
\t\t\$maxcalcmiw  = 0;
\t      \$mawleft = 0;
\t\t\$mawleftcount = 0;
\t\t\$mawsurplusnonpc = 0;
\t\t\$maxcalcmaw  = 0;
\t\tfor( \$i = 0 ; \$i < \$nc ; \$i++ ) {
\t\t  if (isset(\$table['wc'][\$i]['wpercent'])) {
\t\t\t\$maxcalcmiw = max(\$maxcalcmiw, (\$table['wc'][\$i]['miw'] * \$sumpc /\$table['wc'][\$i]['wpercent']) );
\t\t\t\$maxcalcmaw = max(\$maxcalcmaw, (\$table['wc'][\$i]['maw'] * \$sumpc /\$table['wc'][\$i]['wpercent']) );
\t\t  }
\t\t  else {
\t\t\t\$miwleft += \$table['wc'][\$i]['miw'];
\t\t\t\$mawleft += \$table['wc'][\$i]['maw'];
\t\t  \tif (!isset(\$table['wc'][\$i]['w'])) { \$miwleftcount++; \$mawleftcount++; }
\t\t  }
\t\t}
\t\tif (\$miwleft && \$sumnonpc > 0) { \$miwnon = \$miwleft * 100 / \$sumnonpc; }
\t\tif (\$mawleft && \$sumnonpc > 0) { \$mawnon = \$mawleft * 100 / \$sumnonpc; }
\t\tif ((\$miwnon > \$checkminwidth || \$maxcalcmiw > \$checkminwidth) && \$this->keep_table_proportions) {
\t\t\tif (\$miwnon > \$maxcalcmiw) {
\t\t\t\t\$miwsurplusnonpc = round(((\$miwnon * \$sumnonpc / 100) - \$miwleft),3);
\t\t\t\t\$checkminwidth = \$miwnon;
\t\t\t}
\t\t\telse { \$checkminwidth = \$maxcalcmiw; }
\t\t\tfor( \$i = 0 ; \$i < \$nc ; \$i++ ) {
\t\t\t  if (isset(\$table['wc'][\$i]['wpercent'])) {
\t\t\t\t\$newmiw = \$checkminwidth * \$table['wc'][\$i]['wpercent']/100;
\t\t\t\tif (\$table['wc'][\$i]['miw'] < \$newmiw) {
\t\t\t\t  \$table['wc'][\$i]['miw'] = \$newmiw;
\t\t\t\t}
\t\t\t\t\$table['wc'][\$i]['w'] = 1;
\t\t\t  }
\t\t\t  else if (\$miwsurplusnonpc && !\$table['wc'][\$i]['w']) {
\t\t\t\t\$table['wc'][\$i]['miw'] +=  \$miwsurplusnonpc / \$miwleftcount;
\t\t\t  }
\t\t\t}
\t\t}
\t\tif ((\$mawnon > \$checkmaxwidth || \$maxcalcmaw > \$checkmaxwidth )) {
\t\t\tif (\$mawnon > \$maxcalcmaw) {
\t\t\t\t\$mawsurplusnonpc = round(((\$mawnon * \$sumnonpc / 100) - \$mawleft),3);
\t\t\t\t\$checkmaxwidth = \$mawnon;
\t\t\t}
\t\t\telse { \$checkmaxwidth = \$maxcalcmaw; }
\t\t\tfor( \$i = 0 ; \$i < \$nc ; \$i++ ) {
\t\t\t  if (isset(\$table['wc'][\$i]['wpercent'])) {
\t\t\t\t\$newmaw = \$checkmaxwidth * \$table['wc'][\$i]['wpercent']/100;
\t\t\t\tif (\$table['wc'][\$i]['maw'] < \$newmaw) {
\t\t\t\t  \$table['wc'][\$i]['maw'] = \$newmaw;
\t\t\t\t}
\t\t\t\t\$table['wc'][\$i]['w'] = 1;
\t\t\t  }
\t\t\t  else if (\$mawsurplusnonpc && !\$table['wc'][\$i]['w']) {
\t\t\t\t\$table['wc'][\$i]['maw'] +=  \$mawsurplusnonpc / \$mawleftcount;
\t\t\t  }
\t\t\t  if (\$table['wc'][\$i]['maw'] < \$table['wc'][\$i]['miw']) { \$table['wc'][\$i]['maw'] = \$table['wc'][\$i]['miw']; }
\t\t\t}
\t\t}
\t\tif (\$checkminwidth > \$checkmaxwidth) { \$checkmaxwidth = \$checkminwidth; }
\t   }
\t}

\tif (isset(\$table['wpercent']) && \$table['wpercent']) {
\t\t\$checkminwidth *= (100 / \$table['wpercent']);
\t\t\$checkmaxwidth *= (100 / \$table['wpercent']);
\t}


\t\$checkminwidth += \$tblbw ;
\t\$checkmaxwidth += \$tblbw ;

\t// Table['miw'] set by percent in first pass may be larger than sum of column miw
\tif ((isset(\$table['miw']) && \$checkminwidth > \$table['miw']) || !isset(\$table['miw'])) {  \$table['miw'] = \$checkminwidth; }
\tif ((isset(\$table['maw']) && \$checkmaxwidth > \$table['maw']) || !isset(\$table['maw'])) { \$table['maw'] = \$checkmaxwidth; }
\t\$table['tl'] = \$totallength ;

\tif (!\$this->tableCJK) {
\t\tif (\$this->table_rotate) {
\t\t\t\$mxw = \$this->tbrot_maxw;
\t\t}
\t\telse {
\t\t\t\$mxw = \$this->blk[\$this->blklvl]['inner_width'];
\t\t}
\t\tif(!isset(\$table['overflow'])) { \$table['overflow'] = null; }
\t\tif (\$table['overflow']=='visible') {
\t\t\treturn array(0,0);
\t\t}
\t\telse if (\$table['overflow']=='hidden' && !\$this->table_rotate && !\$this->ColActive && \$checkminwidth > \$mxw) {
\t\t\t\$table['w'] = \$table['miw'];
\t\t\treturn array(0,0);
\t\t}
\t\telse if (\$table['overflow']=='wrap') { return array(0,0); }

\t\tif (isset(\$table['w']) && \$table['w'] ) {
\t\t\tif (\$table['w'] >= \$checkminwidth && \$table['w'] <= \$mxw) { \$table['maw'] = \$mxw = \$table['w']; }
\t\t\telse if (\$table['w'] >= \$checkminwidth && \$table['w'] > \$mxw && \$this->keep_table_proportions) { \$checkminwidth = \$table['w']; }
\t\t\telse {
\t\t\t\tunset(\$table['w']);
\t\t\t}
\t\t}
\t\t\$ratio = \$checkminwidth/\$mxw;
\t\tif (\$checkminwidth > \$mxw) { return array((\$ratio +0.001),\$checkminwidth); }\t// 0.001 to allow for rounded numbers when resizing
\t}
\tunset(\$cs);
\treturn array(0,0);
}



function _tableWidth(&\$table){
\t\$widthcols = &\$table['wc'];
\t\$numcols = \$table['nc'];
\t\$tablewidth = 0;
\tif (\$table['borders_separate']) {
\t\t\$tblbw = \$table['border_details']['L']['w'] + \$table['border_details']['R']['w'] + \$table['margin']['L'] + \$table['margin']['R'] +  \$table['padding']['L'] + \$table['padding']['R'] + \$table['border_spacing_H'];
\t}
\telse { \$tblbw = \$table['max_cell_border_width']['L']/2 + \$table['max_cell_border_width']['R']/2 + \$table['margin']['L'] + \$table['margin']['R']; }

\tif (\$table['level']>1 && isset(\$table['w'])) {
\t\tif (isset(\$table['wpercent']) && \$table['wpercent']) {
\t\t\t\$table['w'] = \$temppgwidth = ((\$table['w']-\$tblbw) * \$table['wpercent'] / 100) + \$tblbw ;
\t\t}
\t\telse {
\t\t\t\$temppgwidth = \$table['w'] ;
\t\t}
\t}
\telse if (\$this->table_rotate) {
\t\t\$temppgwidth = \$this->tbrot_maxw;
\t\t// If it is less than 1/20th of the remaining page height to finish the DIV (i.e. DIV padding + table bottom margin)
\t\t// then allow for this
\t\t\$enddiv = \$this->blk[\$this->blklvl]['padding_bottom'] + \$this->blk[\$this->blklvl]['border_bottom']['w'];
\t\tif (\$enddiv/\$temppgwidth <0.05) { \$temppgwidth -= \$enddiv; }
\t}
\telse {
\t\tif (isset(\$table['w']) && \$table['w']< \$this->blk[\$this->blklvl]['inner_width']) {
\t\t\t\$notfullwidth = 1;
\t\t\t\$temppgwidth = \$table['w'] ;
\t\t}
\t\telse if (\$table['overflow']=='visible' && \$table['level'] ==1) {
\t\t\t\$temppgwidth = null;
\t\t}
\t\telse if (\$table['overflow']=='hidden' && !\$this->ColActive && isset(\$table['w']) && \$table['w'] > \$this->blk[\$this->blklvl]['inner_width'] && \$table['w']==\$table['miw']) {
\t\t\t//\$temppgwidth = \$this->blk[\$this->blklvl]['inner_width'];
\t\t\t\$temppgwidth = \$table['w'] ;
\t\t}
\t\telse { \$temppgwidth = \$this->blk[\$this->blklvl]['inner_width']; }
\t}


\t\$totaltextlength = 0;\t// Added - to sum \$table['l'][colno]
\t\$totalatextlength = 0;\t// Added - to sum \$table['l'][colno] for those columns where width not set
\t\$percentages_set = 0;
\tfor ( \$i = 0 ; \$i < \$numcols ; \$i++ ) {
\t\tif (isset(\$widthcols[\$i]['wpercent']))  { \$tablewidth += \$widthcols[\$i]['maw']; \$percentages_set = 1; }
\t\telse if (isset(\$widthcols[\$i]['w']))  { \$tablewidth += \$widthcols[\$i]['miw']; }
\t\telse { \$tablewidth += \$widthcols[\$i]['maw']; }
\t\t\$totaltextlength += \$table['l'][\$i];
\t}
\tif (!\$totaltextlength) { \$totaltextlength =1; }
\t\$tablewidth += \$tblbw;\t// Outer half of table borders

\tif (\$tablewidth > \$temppgwidth) {
\t\t\$table['w'] = \$temppgwidth;
\t}
\t// if any widths set as percentages and max width fits < page width
\telse if (\$tablewidth < \$temppgwidth && !isset(\$table['w']) && \$percentages_set) {
\t\t\$table['w'] = \$table['maw'];
\t}
\t// if table width is set and is > allowed width
\tif (isset(\$table['w']) && \$table['w'] > \$temppgwidth) { \$table['w'] = \$temppgwidth; }

\t// IF the table width is now set - Need to distribute columns widths
\t// mPDF 5.7.3
\t// If the table width is already set to the maximum width (e.g. nested table), then use maximum column widths exactly
\tif (isset(\$table['w']) && (\$table['w'] == \$tablewidth) && !\$percentages_set) {
\t\t// This sets the columns all to maximum width
\t\tfor (\$i=0;\$i<\$numcols;\$i++) {
\t\t\t\$widthcols[\$i] = \$widthcols[\$i]['maw'];
\t\t}
\t}
\t// Else If the table width is set distribute width using algorithm
\telse if (isset(\$table['w'])) {
\t\t\$wis = \$wisa = 0;
\t\t\$list = array();
\t\t\$notsetlist = array();
\t\tfor( \$i = 0 ; \$i < \$numcols ; \$i++ ) {
\t\t\t\$wis += \$widthcols[\$i]['miw'];
\t\t\tif (!isset(\$widthcols[\$i]['w']) || (\$widthcols[\$i]['w'] && \$table['w'] > \$temppgwidth && !\$this->keep_table_proportions && !\$notfullwidth )){
\t\t\t\t\$list[] = \$i;
\t\t\t\t\$wisa += \$widthcols[\$i]['miw'];
\t\t\t\t\$totalatextlength += \$table['l'][\$i];
\t\t\t}
\t\t}
\t\tif (!\$totalatextlength) { \$totalatextlength =1; }

\t\t// Allocate spare (more than col's minimum width) across the cols according to their approx total text length
\t\t// Do it by setting minimum width here
\t\tif (\$table['w'] > \$wis + \$tblbw) {
\t\t\t// First set any cell widths set as percentages
\t\t\tif (\$table['w'] < \$temppgwidth || \$this->keep_table_proportions) {
\t\t\t\tfor(\$k=0;\$k<\$numcols;\$k++) {
\t\t\t\t\tif (isset(\$widthcols[\$k]['wpercent'])) {
\t\t\t\t\t\t\$curr = \$widthcols[\$k]['miw'];
\t\t\t\t\t\t\$widthcols[\$k]['miw'] = (\$table['w']-\$tblbw) * \$widthcols[\$k]['wpercent']/100;
\t\t\t\t\t\t\$wis += \$widthcols[\$k]['miw'] - \$curr;
\t\t\t\t\t\t\$wisa += \$widthcols[\$k]['miw'] - \$curr;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t// Now allocate surplus up to maximum width of each column
\t\t\t\$surplus = 0;  \$ttl = 0;\t// number of surplus columns
\t\t\tif (!count(\$list)) {
\t\t\t\t\$wi = (\$table['w']-(\$wis + \$tblbw));\t//\ti.e. extra space to distribute
\t\t\t\tfor(\$k=0;\$k<\$numcols;\$k++) {
\t\t\t\t\t\$spareratio = (\$table['l'][\$k] / \$totaltextlength); //  gives ratio to divide up free space
\t\t\t\t\t// Don't allocate more than Maximum required width - save rest in surplus
\t\t\t\t\tif (\$widthcols[\$k]['miw'] + (\$wi * \$spareratio) >= \$widthcols[\$k]['maw']) {\t// mPDF 5.7.3
\t\t\t\t\t\t\$surplus += (\$wi * \$spareratio) - (\$widthcols[\$k]['maw']-\$widthcols[\$k]['miw']);
\t\t\t\t\t\t\$widthcols[\$k]['miw'] = \$widthcols[\$k]['maw'];
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$notsetlist[] = \$k;
\t\t\t\t\t\t\$ttl += \$table['l'][\$k];
\t\t\t\t\t\t\$widthcols[\$k]['miw'] += (\$wi * \$spareratio);
\t\t\t\t\t}

\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t\t\t\$wi = (\$table['w'] - (\$wis + \$tblbw));\t//\ti.e. extra space to distribute
\t\t\t\tforeach (\$list as \$k) {
\t\t\t\t\t\$spareratio = (\$table['l'][\$k] / \$totalatextlength); //  gives ratio to divide up free space
\t\t\t\t\t// Don't allocate more than Maximum required width - save rest in surplus
\t\t\t\t\tif (\$widthcols[\$k]['miw'] + (\$wi * \$spareratio) >= \$widthcols[\$k]['maw']) {\t// mPDF 5.7.3
\t\t\t\t\t\t\$surplus += (\$wi * \$spareratio) - (\$widthcols[\$k]['maw']-\$widthcols[\$k]['miw']);
\t\t\t\t\t\t\$widthcols[\$k]['miw'] = \$widthcols[\$k]['maw'];
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$notsetlist[] = \$k;
\t\t\t\t\t\t\$ttl += \$table['l'][\$k];
\t\t\t\t\t\t\$widthcols[\$k]['miw'] += (\$wi * \$spareratio);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t// If surplus still left over apportion it across columns
\t\t\tif (\$surplus) {
\t\t\t   // if some are set only add to remaining - otherwise add to all of them
\t\t\t   if (count(\$notsetlist) && count(\$notsetlist) < \$numcols) {
\t\t\t\tforeach (\$notsetlist AS \$i) {
\t\t\t\t\tif (\$ttl) \$widthcols[\$i]['miw'] += \$surplus * \$table['l'][\$i] / \$ttl ;
\t\t\t\t}
\t\t\t   }
\t\t\t   // If some widths are defined, and others have been added up to their maxmum
\t\t\t   else if (count(\$list) && count(\$list) < \$numcols) {
\t\t\t\tforeach (\$list AS \$i) {
\t\t\t\t\t\$widthcols[\$i]['miw'] += \$surplus / count(\$list) ;
\t\t\t\t}
\t\t\t   }
\t\t\t   else if (\$numcols) {\t// If all columns
\t\t\t\t\$ttl = array_sum(\$table['l']);
\t\t\t\tfor (\$i=0;\$i<\$numcols;\$i++) {
\t\t\t\t\t\$widthcols[\$i]['miw'] += \$surplus * \$table['l'][\$i] / \$ttl;
\t\t\t\t}
\t\t\t   }
\t\t\t}

\t\t}

\t\t// This sets the columns all to minimum width (which has been increased above if appropriate)
\t\tfor (\$i=0;\$i<\$numcols;\$i++) {
\t\t\t\$widthcols[\$i] = \$widthcols[\$i]['miw'];
\t\t}

\t\t// TABLE NOT WIDE ENOUGH EVEN FOR MINIMUM CONTENT WIDTH
\t\t// If sum of column widths set are too wide for table
\t\t\$checktablewidth = 0;
\t\tfor ( \$i = 0 ; \$i < \$numcols ; \$i++ ) {
\t\t\t\$checktablewidth += \$widthcols[\$i];
\t\t}
\t\tif (\$checktablewidth > (\$temppgwidth + 0.001 - \$tblbw)) {
\t\t   \$usedup = 0; \$numleft = 0;
\t\t   for (\$i=0;\$i<\$numcols;\$i++) {
\t\t\tif ((isset(\$widthcols[\$i]) && \$widthcols[\$i] > ((\$temppgwidth - \$tblbw) / \$numcols)) && (!isset(\$widthcols[\$i]['w']))) {
\t\t\t\t\$numleft++;
\t\t\t\tunset(\$widthcols[\$i]);
\t\t\t}
\t\t\telse { \$usedup += \$widthcols[\$i]; }
\t\t   }
\t\t   for (\$i=0;\$i<\$numcols;\$i++) {
\t\t\tif (!isset(\$widthcols[\$i]) || !\$widthcols[\$i]) {
\t\t\t\t\$widthcols[\$i] = (((\$temppgwidth - \$tblbw) - \$usedup)/ (\$numleft));
\t\t\t}
\t\t   }
\t\t}
\t}
\telse { //table has no width defined
\t\t\$table['w'] = \$tablewidth;
\t\tfor ( \$i = 0 ; \$i < \$numcols ; \$i++) {
\t\t\tif (isset(\$widthcols[\$i]['wpercent']) && \$this->keep_table_proportions)  { \$colwidth = \$widthcols[\$i]['maw']; }
\t\t\telse if (isset(\$widthcols[\$i]['w']))  { \$colwidth = \$widthcols[\$i]['miw']; }
\t\t\telse { \$colwidth = \$widthcols[\$i]['maw']; }
\t\t\tunset(\$widthcols[\$i]);
\t\t\t\$widthcols[\$i] = \$colwidth;
\t\t}
\t}

\tif (\$table['overflow']=='visible' && \$table['level'] ==1) {
\t\tif (\$tablewidth > \$this->blk[\$this->blklvl]['inner_width']) {
\t\t  if (\$this->cacheTables) { \$fh = fopen(\$table['cache'], \"r+b\"); }
\t\t  else { \$fh = null; }
\t\t  for (\$j = 0 ; \$j < \$numcols; \$j++) { //columns
\t\t\tfor (\$i = 0 ; \$i < \$table['nr']; \$i++) { //rows
\t\t\t\tif (isset(\$table['cells'][\$i][\$j]) && \$table['cells'][\$i][\$j]) {
\t\t\t\t  if (\$this->cacheTables) {
\t\t\t\t\t\$cc = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t\t\t\$colspan = \$cc['colspan'];
\t\t\t\t  }
\t\t\t\t  else
\t\t\t\t  \t\$colspan = \$table['cells'][\$i][\$j]['colspan'];
\t\t\t\t  if (\$colspan > 1) {
\t\t\t\t\t\$w = 0;
\t\t\t\t\tfor (\$c = \$j; \$c < (\$j + \$colspan); \$c++) {
\t\t\t\t\t\t\$w += \$widthcols[\$c];
\t\t\t\t\t}
\t\t\t\t\tif (\$w > \$this->blk[\$this->blklvl]['inner_width']) {
\t\t\t\t\t\t\$diff = \$w - (\$this->blk[\$this->blklvl]['inner_width'] - \$tblbw);
\t\t\t\t\t\tfor (\$c = \$j; \$c < (\$j + \$colspan); \$c++) {
\t\t\t\t\t\t\t\$widthcols[\$c] -= \$diff * (\$widthcols[\$c]/\$w);
\t\t\t\t\t\t}
\t\t\t\t\t\t\$table['w'] -= \$diff;
\t\t\t\t\t\t\$table['csp'][\$j] = \$w - \$diff;
\t\t\t\t\t}
\t\t\t\t  }
\t\t\t\t}

\t\t\t}
\t\t  }
\t\t  if (\$this->cacheTables) { fclose(\$fh); }
\t\t}
\t\t\$pgNo = 0;
\t\t\$currWc = 0;
\t\tfor (\$i = 0 ; \$i < \$numcols; \$i++) { //columns
\t\t\tif (isset(\$table['csp'][\$i])) {
\t\t\t\t\$w = \$table['csp'][\$i];
\t\t\t\tunset(\$table['csp'][\$i]);
\t\t\t}
\t\t\telse { \$w = \$widthcols[\$i]; }
\t\t\tif ((\$currWc + \$w + \$tblbw) > \$this->blk[\$this->blklvl]['inner_width']) {
\t\t\t\t\$pgNo++;
\t\t\t\t\$currWc = \$widthcols[\$i] ;
\t\t\t}
\t\t\telse { \$currWc += \$widthcols[\$i] ; }
\t\t\t\$table['colPg'][\$i] = \$pgNo;
\t\t}
\t}
}



function _tableHeight(&\$table){
\t\$level = \$table['level'];
\t\$levelid = \$table['levelid'];
\t\$cells = &\$table['cells'];
\t\$numcols = \$table['nc'];
\t\$numrows = \$table['nr'];
\t\$listspan = array();
\t\$checkmaxheight = 0;
\t\$headerrowheight = 0;
\t\$checkmaxheightplus = 0;
\t\$headerrowheightplus = 0;
\t\$firstrowheight = 0;

\t\$footerrowheight = 0;
\t\$footerrowheightplus = 0;
\tif (\$this->table_rotate) {
\t\t\$temppgheight = \$this->tbrot_maxh;
\t\t\$remainingpage = \$this->tbrot_maxh;
\t}
\telse {
\t\t\$temppgheight = (\$this->h - \$this->bMargin - \$this->tMargin) - \$this->kwt_height;
\t\t\$remainingpage = (\$this->h - \$this->bMargin - \$this->y) - \$this->kwt_height;

\t\t// If it is less than 1/20th of the remaining page height to finish the DIV (i.e. DIV padding + table bottom margin)
\t\t// then allow for this
\t\t\$enddiv = \$this->blk[\$this->blklvl]['padding_bottom'] + \$this->blk[\$this->blklvl]['border_bottom']['w'] + \$table['margin']['B'];
\t\tif (\$remainingpage > \$enddiv && \$enddiv/\$remainingpage <0.05) { \$remainingpage -= \$enddiv; }
\t\telse if (\$remainingpage == 0) { \$remainingpage = 0.001; }
\t\tif (\$temppgheight > \$enddiv && \$enddiv/\$temppgheight <0.05) { \$temppgheight -= \$enddiv; }
\t\telse if (\$temppgheight == 0) { \$temppgheight = 0.001; }
\t}
\tif (\$remainingpage < 0) { \$remainingpage = 0.001; }\t// mPDF 5.6.64
\tif (\$temppgheight < 0) { \$temppgheight = 0.001; }\t// mPDF 5.6.64

\tif (\$this->cacheTables) { \$fh = fopen(\$table['cache'], \"r+b\"); }
\telse { \$fh = null; }

\tfor( \$i = 0 ; \$i < \$numrows ; \$i++ ) { //rows
\t\t\$heightrow = &\$table['hr'][\$i];
\t\tfor( \$j = 0 ; \$j < \$numcols ; \$j++ ) { //columns
\t\t\tif (isset(\$cells[\$i][\$j]) && \$cells[\$i][\$j]) {
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$c = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t\t}
\t\t\t\telse
\t\t\t\t\t\$c = &\$cells[\$i][\$j];

\t\t\t\tif (\$this->simpleTables){
\t\t\t\t   if (\$table['borders_separate']) {\t// NB twice border width
\t\t\t\t\t\$extraWLR = (\$table['simple']['border_details']['L']['w']+\$table['simple']['border_details']['R']['w']) + (\$c['padding']['L']+\$c['padding']['R'])+\$table['border_spacing_H'];
\t\t\t\t\t\$extrh = (\$table['simple']['border_details']['T']['w']+\$table['simple']['border_details']['B']['w']) + (\$c['padding']['T']+\$c['padding']['B'])+\$table['border_spacing_V'];
\t\t\t\t   }
\t\t\t\t   else {
\t\t\t\t\t\$extraWLR = (\$table['simple']['border_details']['L']['w']+\$table['simple']['border_details']['R']['w'])/2 + (\$c['padding']['L']+\$c['padding']['R']);
\t\t\t\t\t\$extrh = (\$table['simple']['border_details']['T']['w']+\$table['simple']['border_details']['B']['w'])/2 + (\$c['padding']['T']+\$c['padding']['B']);
\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse  {
\t\t\t \t   if (\$this->packTableData) {
\t\t\t \t   \tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$c['borderbin']);
\t\t\t \t   }
\t\t\t \t   else {
\t\t\t\t\t\$bt = \$c['border_details']['T']['w'];
\t\t\t\t\t\$bb = \$c['border_details']['B']['w'];
\t\t\t\t\t\$br = \$c['border_details']['R']['w'];
\t\t\t\t\t\$bl = \$c['border_details']['L']['w'];
\t\t\t\t   }
\t\t\t\t   if (\$table['borders_separate']) {\t// NB twice border width
\t\t\t\t\t\$extraWLR = \$bl + \$br + \$c['padding']['L'] + \$c['padding']['R'] + \$table['border_spacing_H'];
\t\t\t\t\t\$extrh = \$bt + \$bb + \$c['padding']['T'] + \$c['padding']['B'] + \$table['border_spacing_V'];
\t\t\t\t   }
\t\t\t\t   else {
\t\t\t\t\t\$extraWLR = \$bl/2 + \$br/2 + \$c['padding']['L'] + \$c['padding']['R'];
\t\t\t\t\t\$extrh = \$bt/2 + \$bb/2 + \$c['padding']['T']+\$c['padding']['B'];
\t\t\t\t   }
\t\t\t\t}

\t\t\t\tif (\$table['overflow']=='visible' && \$level==1)
\t\t\t\t\tlist(\$x,\$cw) = \$this->_splitTableGetWidth(\$table, \$i,\$j, \$fh);
\t\t\t\telse
\t\t\t\t\tlist(\$x,\$cw) = \$this->_tableGetWidth(\$table, \$i,\$j, \$fh);

\t\t\t\t// Get CELL HEIGHT
\t\t\t\t// ++ extra parameter forces wrap to break word
\t\t\t\tif (\$c['R'] && isset(\$c['textbuffer'])) {\t// mPDF 5.4.01
\t\t\t\t\t\$str = '';
\t\t\t\t\tforeach(\$c['textbuffer'] AS \$t) { \$str .= \$t[0].' '; }
\t\t\t\t\t\$str = trim(\$str);
\t\t\t\t\t\$s_fs = \$this->FontSizePt;
\t\t\t\t\t\$s_f = \$this->FontFamily;
\t\t\t\t\t\$s_st = \$this->FontStyle;
\t\t\t\t\t\$this->SetFont(\$c['textbuffer'][0][4],\$c['textbuffer'][0][2],\$c['textbuffer'][0][11] / \$this->shrin_k,true,true);
\t       \t\t\t\$tempch = \$this->GetStringWidth(\$str);
\t\t\t\t\tif (\$c['R'] >= 45 && \$c['R'] < 90) {
\t\t\t\t\t\t\$tempch = ((sin(deg2rad(\$c['R']))) * \$tempch ) + ((sin(deg2rad(\$c['R']))) * ((\$c['textbuffer'][0][11]/_MPDFK) / \$this->shrin_k));
\t\t\t\t\t}
\t\t\t\t\t\$this->SetFont(\$s_f,\$s_st,\$s_fs,true,true);
\t\t\t\t\t\$ch = (\$tempch ) + \$extrh ;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t   if (isset(\$c['textbuffer'])) {
\t\t\t\t\t\$tempch = \$this->TableWordWrap((\$cw-\$extraWLR),1,\$c['textbuffer'], \$c['dfs']);
\t\t\t\t   }
\t\t\t\t   else { \$tempch = 0; }

\t\t\t\t\t// Added cellpadding top and bottom. (Lineheight already adjusted to table_lineheight)
\t\t\t\t\t\$ch = \$tempch + \$extrh ;
\t\t\t\t}
\t\t\t\t//If height is defined and it is bigger than calculated \$ch then update values
\t\t\t\tif (isset(\$c['h']) && \$c['h'] > \$ch) {
\t\t\t\t\t\$c['mih'] = \$ch; //in order to keep valign working
\t\t\t\t\t\$ch = \$c['h'];
\t\t\t\t}
\t\t\t\telse \$c['mih'] = \$ch;
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$this->_cacheUpdateMtx(\$c, \$fh, \$table['cells'][\$i][\$j], 'mih');
\t\t\t\t}
\t\t\t\tif (isset(\$c['rowspan']))\t\$listspan[] = array(\$i,\$j);
\t\t\t\telseif (\$heightrow < \$ch) \$heightrow = \$ch;

\t\t\t\t// this is the extra used in _tableWrite to determine whether to trigger a page change
\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t  if (\$i == (\$numrows-1) || (isset(\$c['rowspan']) && (\$i+\$c['rowspan']) == (\$numrows)) ) {
\t\t\t\t\t\$extra = \$table['margin']['B'] + \$table['padding']['B'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V']/2;
\t\t\t\t  }
\t\t\t\t  else {
\t\t\t\t\t\$extra = \$table['border_spacing_V']/2;
\t\t\t\t  }
\t\t\t\t}
\t  \t\t\telse {
\t\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t\t\t\$extra = \$bb/2;
\t\t\t\t\t}
\t\t\t\t\telse if (\$this->simpleTables){
\t\t\t\t\t\t\$extra = \$table['simple']['border_details']['B']['w'] /2;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\tif (isset(\$table['is_thead'][\$i]) && \$table['is_thead'][\$i]) {
\t\t\t\t   if (\$j==0) {
\t\t\t\t\t\$headerrowheight += \$ch;
\t\t\t\t\t\$headerrowheightplus += \$ch+\$extra;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse if (isset(\$table['is_tfoot'][\$i]) && \$table['is_tfoot'][\$i]) {
\t\t\t\t   if (\$j==0) {
\t\t\t\t\t\$footerrowheight += \$ch;
\t\t\t\t\t\$footerrowheightplus += \$ch+\$extra;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$checkmaxheight = max(\$checkmaxheight,\$ch);
\t\t\t\t\t\$checkmaxheightplus = max(\$checkmaxheightplus,\$ch+\$extra);
\t\t\t\t}
\t\t\t\tif (\$this->tableLevel==1 && \$i == \$table['headernrows']) { \$firstrowheight = max(\$ch,\$firstrowheight); }
\t\t\t\tunset(\$c);
\t\t\t}
\t\t}//end of columns
\t}//end of rows

\t\$heightrow = &\$table['hr'];
\tforeach (\$listspan as \$span) {
\t\tlist(\$i,\$j) = \$span;
\t\tif (\$this->cacheTables) {
\t\t\t\$c = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t}
\t\telse
\t\t\t\$c = &\$cells[\$i][\$j];
\t\t\$lr = \$i + \$c['rowspan'];
\t\tif (\$lr > \$numrows) \$lr = \$numrows;
\t\t\$hs = \$hsa = 0;
\t\t\$list = array();
\t\tfor(\$k=\$i;\$k<\$lr;\$k++) {
\t\t\t\$hs += \$heightrow[\$k];
\t\t\tif (!isset(\$c['h'])) {
\t\t\t\t\$list[] = \$k;
\t\t\t\t\$hsa += \$heightrow[\$k];
\t\t\t}
\t\t}

\t\tif (\$table['borders_separate']) {
\t\t  if (\$i == (\$numrows-1) || (\$i+\$c['rowspan']) == (\$numrows) ) {
\t\t\t\$extra = \$table['margin']['B'] + \$table['padding']['B'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V']/2;
\t\t  }
\t\t  else {
\t\t\t\$extra = \$table['border_spacing_V']/2;
\t\t  }
\t\t}
\t  \telse {
\t\t\tif (!\$this->simpleTables){
\t\t\t \tif (\$this->packTableData) {
\t\t\t \t\tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$c['borderbin']);
\t\t\t \t}
\t\t\t \telse {
\t\t\t\t\t\$bb = \$c['border_details']['B']['w'];
\t\t\t\t}
\t\t\t\t\$extra = \$bb/2;
\t\t\t}
\t\t\telse if (\$this->simpleTables){
\t\t\t\t\$extra = \$table['simple']['border_details']['B']['w'] /2;
\t\t\t}
\t\t}
\t\tif (!empty(\$table['is_thead'][\$i])) {
\t\t\t\$headerrowheight = max(\$headerrowheight,\$hs);
\t\t\t\$headerrowheightplus = max(\$headerrowheightplus,\$hs+\$extra);
\t\t}
\t\telse if (!empty(\$table['is_tfoot'][\$i])) {
\t\t\t\$footerrowheight = max(\$footerrowheight,\$hs);
\t\t\t\$footerrowheightplus = max(\$footerrowheightplus,\$hs+\$extra);
\t\t}
\t\telse {
\t\t\t\$checkmaxheight = max(\$checkmaxheight,\$hs);
\t\t\t\$checkmaxheightplus = max(\$checkmaxheightplus,\$hs+\$extra);
\t\t}
\t\tif (\$this->tableLevel==1 && \$i == \$table['headernrows']) { \$firstrowheight = max(\$hs,\$firstrowheight); }

\t\tif (\$c['mih'] > \$hs) {
\t\t\tif (!\$hs) {
\t\t\t\tfor(\$k=\$i;\$k<\$lr;\$k++) \$heightrow[\$k] = \$c['mih']/\$c['rowspan'];
\t\t\t}
\t\t\telseif (!count(\$list)) {
\t\t\t\t\$hi = \$c['mih'] - \$hs;
\t\t\t\tfor(\$k=\$i;\$k<\$lr;\$k++) \$heightrow[\$k] += (\$heightrow[\$k]/\$hs)*\$hi;
\t\t\t}
\t\t\telse {
\t\t\t\t\$hi = \$c['mih'] - \$hsa;
\t\t\t\tforeach (\$list as \$k) \$heightrow[\$k] += (\$heightrow[\$k]/\$hsa)*\$hi;
\t\t\t}
\t\t}
\t\tunset(\$c);

\t\t// If rowspans overlap so that one or more rows do not have a height set...
\t\t// i.e. for one or more rows, the only cells (explicit) in that row have rowspan>1
\t\t// so heightrow is still == 0
\t\tif (\$heightrow[\$i]==0) {
\t\t\t// Get row extent to analyse above and below
\t\t\t\$top = \$i;
\t\t\tforeach (\$listspan as \$checkspan) {
\t\t\t\tlist(\$cki,\$ckj) = \$checkspan;
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$c = \$this->_uncacheCell(\$table['cells'][\$cki][\$ckj], '', \$fh);
\t\t\t\t}
\t\t\t\telse
\t\t\t\t\t\$c = &\$cells[\$cki][\$ckj];
\t\t\t\tif (isset(\$c['rowspan']) && \$c['rowspan']>1) {
\t\t\t\t\tif ((\$cki + \$c['rowspan']-1) >= \$i) { \$top = min(\$top, \$cki); }
\t\t\t\t}
\t\t\t}
\t\t\t\$bottom = \$i + \$c['rowspan']-1;
\t\t\t// Check for overconstrained conditions
\t\t\tfor (\$k=\$top; \$k<=\$bottom; \$k++) {
\t\t\t\t// if ['hr'] for any of the others is also 0, then abort (too complicated)
\t\t\t\tif (\$k != \$i && \$heightrow[\$k]==0) { break(1); }
\t\t\t\t// check again that top and bottom are not crossed by rowspans - or abort (too complicated)
\t\t\t\tif (\$k==\$top) {
\t\t\t\t\t// ???? take account of colspan as well???
\t\t\t\t\tfor( \$m = 0 ; \$m < \$numcols ; \$m++ ) { //columns
\t\t\t\t\t\tif (!isset(\$cells[\$k][\$m]) || \$cells[\$k][\$m]==0) {
\t\t\t\t\t\t\tbreak(2);
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse if (\$k==\$bottom) {
\t\t\t\t\t// ???? take account of colspan as well???
\t\t\t\t\tfor( \$m = 0 ; \$m < \$numcols ; \$m++ ) { //columns
\t\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\t\$c = \$this->_uncacheCell(\$table['cells'][\$k][\$m], '', \$fh);
\t\t\t\t\t\t}
\t\t\t\t\t\telse
\t\t\t\t\t\t\t\$c = &\$cells[\$k][\$m];
\t\t\t\t\t\tif (isset(\$c['rowspan']) && \$c['rowspan']>1) {
\t\t\t\t\t\t\tbreak(2);
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t// By columns add up col height using ['h'] if set or ['mih'] if not
\t\t\t// Intentionally do not substract border-spacing
\t\t\t\$colH = array();
\t\t\t\$extH = 0;
\t\t\t\$newhr = array();
\t\t\tfor( \$m = 0 ; \$m < \$numcols ; \$m++ ) { //columns
\t\t\t   for (\$k=\$top; \$k<=\$bottom; \$k++) {
\t\t\t\tif (isset(\$cells[\$k][\$m]) && \$cells[\$k][\$m]!=0) {
\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\$c = \$this->_uncacheCell(\$table['cells'][\$k][\$m], '', \$fh);
\t\t\t\t\t}
\t\t\t\t\telse
\t\t\t\t\t\t\$c = &\$cells[\$k][\$m];
\t\t\t\t\tif (isset(\$c['h']) && \$c['h']) {
\t\t\t\t\t\t\$useh = \$c['h'];
\t\t\t\t\t}
\t\t\t\t\t// ???? take account of colspan as well???
\t\t\t\t\telse {
\t\t\t\t\t\t\$useh = \$c['mih'];
\t\t\t\t\t}
\t\t\t\t\t\$colH[\$m] += \$useh;
\t\t\t\t\tif (!isset(\$c['rowspan']) || \$c['rowspan']<2) { \$newhr[\$k] = max(\$newhr[\$k], \$useh); }
\t\t\t\t}
\t\t\t   }
\t\t\t   \$extH = max(\$tabH, \$colH[\$m]);
\t\t\t}
\t\t\t\$newhr[\$i] = \$extH - array_sum(\$newhr);
\t\t\tfor (\$k=\$top; \$k<=\$bottom; \$k++) { \$heightrow[\$k] = \$newhr[\$k]; }
\t\t}


\t\tunset(\$c);
\t}

\t\$table['h'] = array_sum(\$heightrow);
\tunset(\$heightrow);

\tif (\$this->cacheTables) { fclose(\$fh); }

\tif (\$table['borders_separate']) {
\t\t\$table['h'] += \$table['margin']['T'] + \$table['margin']['B'] + \$table['border_details']['T']['w'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V'] + \$table['padding']['T'] +  \$table['padding']['B'];
\t}
\telse {
\t\t\$table['h'] += \$table['margin']['T'] + \$table['margin']['B'] + \$table['max_cell_border_width']['T']/2 + \$table['max_cell_border_width']['B']/2;
\t}

\t\$maxrowheight = \$checkmaxheightplus + \$headerrowheightplus + \$footerrowheightplus;
\t\$maxfirstrowheight = \$firstrowheight + \$headerrowheightplus + \$footerrowheightplus;\t// includes thead, 1st row and tfoot
\treturn array(\$table['h'],\$maxrowheight,\$temppgheight,\$remainingpage,\$maxfirstrowheight);
}

function _tableGetWidth(&\$table, \$i,\$j, \$fh){
\tif (\$this->cacheTables) {
\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t}
\telse
\t\t\$cell = &\$table['cells'][\$i][\$j];
\tif (\$cell) {
\t\tif (isset(\$cell['x0'])) { return array(\$cell['x0'], \$cell['w0']); }
\t\t\$x = 0;
\t\t\$widthcols = &\$table['wc'];
\t\tfor( \$k = 0 ; \$k < \$j ; \$k++ ) \$x += \$widthcols[\$k];
\t\t\$w = \$widthcols[\$j];
\t\tif (isset(\$cell['colspan'])) {
\t\t\t for ( \$k = \$j+\$cell['colspan']-1 ; \$k > \$j ; \$k-- )\t\$w += \$widthcols[\$k];
\t\t}
\t\t\$cell['x0'] = \$x;
\t\t\$cell['w0'] = \$w;
\t\tif (\$this->cacheTables) {
\t\t\t\$this->_cacheUpdateMtx(\$cell, \$fh, \$table['cells'][\$i][\$j], 'x0');
\t\t}
\t\treturn array(\$x, \$w);
\t}
\treturn array(0,0);
}

function _splitTableGetWidth(&\$table, \$i,\$j, \$fh){
\tif (\$this->cacheTables) {
\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t}
\telse
\t\t\$cell = &\$table['cells'][\$i][\$j];
\tif (\$cell) {
\t\tif (isset(\$cell['x0'])) return array(\$cell['x0'], \$cell['w0']);
\t\t\$x = 0;
\t\t\$widthcols = &\$table['wc'];
\t\t\$pg = \$table['colPg'][\$j];
\t\tfor( \$k = 0 ; \$k < \$j ; \$k++ ) {
\t\t\tif (\$table['colPg'][\$k]==\$pg) \$x += \$widthcols[\$k];
\t\t}
\t\t\$w = \$widthcols[\$j];
\t\tif (isset(\$cell['colspan'])) {
\t\t\t for ( \$k = \$j+\$cell['colspan']-1 ; \$k > \$j ; \$k-- )\tif (\$table['colPg'][\$k]==\$pg) \$w += \$widthcols[\$k];
\t\t}
\t\t\$cell['x0'] = \$x;
\t\t\$cell['w0'] = \$w;
\t\tif (\$this->cacheTables) {
\t\t\t\$this->_cacheUpdateMtx(\$cell, \$fh, \$table['cells'][\$i][\$j], 'x0');
\t\t}
\t\treturn array(\$x, \$w);
\t}
\treturn array(0,0);
}


function _tableGetHeight(&\$table, \$i,\$j, \$fh){
\tif (\$this->cacheTables) {
\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t}
\telse
\t\t\$cell = &\$table['cells'][\$i][\$j];
\tif (\$cell){
\t\tif (isset(\$cell['y0'])) return array(\$cell['y0'], \$cell['h0']);
\t\t\$y = 0;
\t\t\$heightrow = &\$table['hr'];
\t\tfor (\$k=0;\$k<\$i;\$k++) \$y += \$heightrow[\$k];
\t\t\$h = \$heightrow[\$i];
\t\tif (isset(\$cell['rowspan'])){
\t\t\tfor (\$k=\$i+\$cell['rowspan']-1;\$k>\$i;\$k--)
\t\t\t\t\$h += \$heightrow[\$k];
\t\t}
\t\t\$cell['y0'] = \$y;
\t\t\$cell['h0'] = \$h;
\t\tif (\$this->cacheTables) {
\t\t\t\$this->_cacheUpdateMtx(\$cell, \$fh, \$table['cells'][\$i][\$j], 'y0');
\t\t}
\t\treturn array(\$y, \$h);
\t}
\treturn array(0,0);
}

function _tableGetMaxRowHeight(\$table, \$row, \$fh) {
\tif (\$row==\$table['nc']-1) { return \$table['hr'][\$row]; }
\t\$maxrowheight = \$table['hr'][\$row];
\tfor (\$i=\$row+1;\$i<\$table['nr'];\$i++) {
\t\t\$cellsset = 0;
\t\tfor (\$j=0;\$j<\$table['nc'];\$j++) {
\t\t\tif (\$this->cacheTables) {
\t\t\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t\tif (\$cell) {
\t\t\t\t\tif (isset(\$cell['colspan'])) {  \$cellsset += \$cell['colspan']; }
\t\t\t\t\telse \$cellsset += 1;
\t\t\t\t}
\t\t\t}
\t\t\telse {
\t\t\t\tif (\$table['cells'][\$i][\$j]) {
\t\t\t\t\tif (isset(\$table['cells'][\$i][\$j]['colspan'])) {  \$cellsset += \$table['cells'][\$i][\$j]['colspan']; }
\t\t\t\t\telse \$cellsset += 1;
\t\t\t\t}
\t\t\t}
\t\t}
\t\tif (\$cellsset == \$table['nc']) { return \$maxrowheight; }
\t\telse { \$maxrowheight += \$table['hr'][\$i]; }
\t}
\treturn \$maxrowheight;
}


// CHANGED TO ALLOW TABLE BORDER TO BE SPECIFIED CORRECTLY - added border_details
function _tableRect(\$x, \$y, \$w, \$h, \$bord=-1, \$details=array(), \$buffer=false, \$bSeparate=false, \$cort='cell', \$tablecorner='', \$bsv=0, \$bsh=0) {
\t\$cellBorderOverlay = array();

\tif (\$bord==-1) { \$this->Rect(\$x, \$y, \$w, \$h); }
\telse if (\$this->simpleTables && (\$cort=='cell')) {
\t\t\$this->SetLineWidth(\$details['L']['w']);
\t\tif (\$details['L']['c']) {
\t\t\t\$this->SetDColor(\$details['L']['c']);
\t\t}
\t\telse { \$this->SetDColor(\$this->ConvertColor(0)); }
\t\t\$this->SetLineJoin(0);
\t\t\$this->Rect(\$x, \$y, \$w, \$h);
\t}
\telse if (\$bord){
\t   if (!\$bSeparate && \$buffer) {
\t\t\$priority = 'LRTB';
\t\tfor(\$p=0;\$p<strlen(\$priority);\$p++) {
\t\t\t\$side = \$priority[\$p];
\t\t\t\$details['p'] = \$side ;

\t\t\t\$dom = 0;
\t\t\tif (isset(\$details[\$side]['w'])) { \$dom += (\$details[\$side]['w'] * 100000); }
\t\t\tif (isset(\$details[\$side]['style'])) { \$dom += (array_search(\$details[\$side]['style'],\$this->borderstyles)*100) ; }
\t\t\tif (isset(\$details[\$side]['dom'])) { \$dom += (\$details[\$side]['dom']*10); }

\t\t\t// Precedence to darker colours at joins
\t\t\t\$coldom = 0;
\t\t\tif (isset(\$details[\$side]['c']) && is_array(\$details[\$side]['c'])) {
\t\t\t\tif (\$details[\$side]['c']{0}==3) { \t// RGB
\t\t\t\t\t\$coldom = 10-(((ord(\$details[\$side]['c']{1})*1.00)+(ord(\$details[\$side]['c']{2})*1.00)+(ord(\$details[\$side]['c']{3})*1.00))/76.5);
\t\t\t\t}
\t\t\t} // 10 black - 0 white
\t\t\tif (\$coldom) { \$dom += \$coldom; }
\t\t\t// Lastly precedence to RIGHT and BOTTOM cells at joins
\t\t\tif (isset(\$details['cellposdom'])) { \$dom += \$details['cellposdom']; }

\t\t\t\$save = false;
\t\t\tif (\$side == 'T' && \$this->issetBorder(\$bord, _BORDER_TOP)) { \$cbord = _BORDER_TOP; \$save = true; }
\t\t\telse if (\$side == 'L' && \$this->issetBorder(\$bord, _BORDER_LEFT)) { \$cbord = _BORDER_LEFT; \$save = true; }
\t\t\telse if (\$side == 'R' && \$this->issetBorder(\$bord, _BORDER_RIGHT)) { \$cbord = _BORDER_RIGHT; \$save = true; }
\t\t\telse if (\$side == 'B' && \$this->issetBorder(\$bord, _BORDER_BOTTOM)) { \$cbord = _BORDER_BOTTOM; \$save = true; }

\t\t\tif (\$save) {
\t\t\t\t\$this->cellBorderBuffer[] = pack(\"A16nCnda6A10d14\",
\t\t\t\t\tstr_pad(sprintf(\"%08.7f\", \$dom),16,\"0\",STR_PAD_LEFT),
\t\t\t\t\t\$cbord,
\t\t\t\t\tord(\$side),
\t\t\t\t\t\$details[\$side]['s'],
\t\t\t\t\t\$details[\$side]['w'],
\t\t\t\t\t\$details[\$side]['c'],
\t\t\t\t\t\$details[\$side]['style'],
\t\t\t\t\t\$x, \$y, \$w, \$h,
\t\t\t\t\t\$details['mbw']['BL'],
\t\t\t\t\t\$details['mbw']['BR'],
\t\t\t\t\t\$details['mbw']['RT'],
\t\t\t\t\t\$details['mbw']['RB'],
\t\t\t\t\t\$details['mbw']['TL'],
\t\t\t\t\t\$details['mbw']['TR'],
\t\t\t\t\t\$details['mbw']['LT'],
\t\t\t\t\t\$details['mbw']['LB'],
\t\t\t\t\t\$details['cellposdom'],
\t\t\t\t\t0
\t\t\t\t);
\t\t\t   if (\$details[\$side]['style'] == 'ridge' || \$details[\$side]['style'] == 'groove' || \$details[\$side]['style'] == 'inset' || \$details[\$side]['style'] == 'outset' || \$details[\$side]['style'] == 'double' ) {
\t\t\t\t\$details[\$side]['overlay'] = true;
\t\t\t\t\$this->cellBorderBuffer[] = pack(\"A16nCnda6A10d14\",
\t\t\t\t\tstr_pad(sprintf(\"%08.7f\", (\$dom+4)),16,\"0\",STR_PAD_LEFT),
\t\t\t\t\t\$cbord,
\t\t\t\t\tord(\$side),
\t\t\t\t\t\$details[\$side]['s'],
\t\t\t\t\t\$details[\$side]['w'],
\t\t\t\t\t\$details[\$side]['c'],
\t\t\t\t\t\$details[\$side]['style'],
\t\t\t\t\t\$x, \$y, \$w, \$h,
\t\t\t\t\t\$details['mbw']['BL'],
\t\t\t\t\t\$details['mbw']['BR'],
\t\t\t\t\t\$details['mbw']['RT'],
\t\t\t\t\t\$details['mbw']['RB'],
\t\t\t\t\t\$details['mbw']['TL'],
\t\t\t\t\t\$details['mbw']['TR'],
\t\t\t\t\t\$details['mbw']['LT'],
\t\t\t\t\t\$details['mbw']['LB'],
\t\t\t\t\t\$details['cellposdom'],
\t\t\t\t\t1
\t\t\t\t);
\t\t\t   }
\t\t\t}
\t\t}
\t\treturn;
\t   }

\t   if (isset(\$details['p']) && strlen(\$details['p'])>1) { \$priority = \$details['p']; }
\t   else { \$priority='LTRB'; }
\t   \$Tw = 0;
\t   \$Rw = 0;
\t   \$Bw = 0;
\t   \$Lw = 0;
\t\tif (isset(\$details['T']['w'])) { \$Tw = \$details['T']['w']; }
\t\tif (isset(\$details['R']['w'])) { \$Rw = \$details['R']['w']; }
\t\tif (isset(\$details['B']['w'])) { \$Bw = \$details['B']['w']; }
\t\tif (isset(\$details['L']['w'])) { \$Lw = \$details['L']['w']; }

\t   \$x2 = \$x + \$w; \$y2 = \$y + \$h;
\t   \$oldlinewidth = \$this->LineWidth;

\t   for(\$p=0;\$p<strlen(\$priority);\$p++) {
\t\t\$side = \$priority[\$p];
\t\t\$xadj = 0;
\t\t\$xadj2 = 0;
\t\t\$yadj = 0;
\t\t\$yadj2 = 0;
\t\t\$print = false;
\t\tif (\$Tw && \$side=='T' && \$this->issetBorder(\$bord, _BORDER_TOP)) {\t// TOP
\t\t\t\$ly1 = \$y;
\t\t\t\$ly2 = \$y;
\t\t\t\$lx1 = \$x;
\t\t\t\$lx2 = \$x2;
\t\t\t\$this->SetLineWidth(\$Tw);
\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'L')!==false) {
\t\t\t\tif (\$Tw > \$Lw) \$xadj = (\$Tw - \$Lw)/2;
\t\t\t\tif (\$Tw < \$Lw) \$xadj = (\$Tw + \$Lw)/2;
\t\t\t}
\t\t\telse { \$xadj = \$Tw/2 - \$bsh/2; }
\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'R')!==false) {
\t\t\t\tif (\$Tw > \$Rw) \$xadj2 = (\$Tw - \$Rw)/2;
\t\t\t\tif (\$Tw < \$Rw) \$xadj2 = (\$Tw + \$Rw)/2;
\t\t\t}
\t\t\telse { \$xadj2 = \$Tw/2 - \$bsh/2; }
\t\t\tif (!\$bSeparate && \$details['mbw']['TL']) {
\t\t\t\t\$xadj = (\$Tw - \$details['mbw']['TL'])/2 ;
\t\t\t}
\t\t\tif (!\$bSeparate && \$details['mbw']['TR']) {
\t\t\t\t\$xadj2 = (\$Tw - \$details['mbw']['TR'])/2;
\t\t\t}
\t\t\t\$print = true;
\t\t}
\t\tif (\$Lw && \$side=='L' && \$this->issetBorder(\$bord, _BORDER_LEFT)) {\t// LEFT
\t\t\t\$ly1 = \$y;
\t\t\t\$ly2 = \$y2;
\t\t\t\$lx1 = \$x;
\t\t\t\$lx2 = \$x;
\t\t\t\$this->SetLineWidth(\$Lw);
\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'T')!==false) {
\t\t\t\tif (\$Lw > \$Tw) \$yadj = (\$Lw - \$Tw)/2;
\t\t\t\tif (\$Lw < \$Tw) \$yadj = (\$Lw + \$Tw)/2;
\t\t\t}
\t\t\telse { \$yadj = \$Lw/2 - \$bsv/2; }
\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'B')!==false) {
\t\t\t\tif (\$Lw > \$Bw) \$yadj2 = (\$Lw - \$Bw)/2;
\t\t\t\tif (\$Lw < \$Bw) \$yadj2 = (\$Lw + \$Bw)/2;
\t\t\t}
\t\t\telse { \$yadj2 = \$Lw/2 - \$bsv/2; }
\t\t\tif (!\$bSeparate && \$details['mbw']['LT']) {
\t\t\t\t\$yadj = (\$Lw - \$details['mbw']['LT'])/2;
\t\t\t}
\t\t\tif (!\$bSeparate && \$details['mbw']['LB']) {
\t\t\t\t\$yadj2 = (\$Lw - \$details['mbw']['LB'])/2;
\t\t\t}
\t\t\t\$print = true;
\t\t}
\t\tif (\$Rw && \$side=='R' && \$this->issetBorder(\$bord, _BORDER_RIGHT)) {\t// RIGHT
\t\t\t\$ly1 = \$y;
\t\t\t\$ly2 = \$y2;
\t\t\t\$lx1 = \$x2;
\t\t\t\$lx2 = \$x2;
\t\t\t\$this->SetLineWidth(\$Rw);
\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'T')!==false) {
\t\t\t\tif (\$Rw < \$Tw) \$yadj = (\$Rw + \$Tw)/2;
\t\t\t\tif (\$Rw > \$Tw) \$yadj = (\$Rw - \$Tw)/2;
\t\t\t}
\t\t\telse { \$yadj = \$Rw/2 - \$bsv/2; }

\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'B')!==false) {
\t\t\t\tif (\$Rw > \$Bw) \$yadj2 = (\$Rw - \$Bw)/2;
\t\t\t\tif (\$Rw < \$Bw) \$yadj2 = (\$Rw + \$Bw)/2;
\t\t\t}
\t\t\telse { \$yadj2 = \$Rw/2 - \$bsv/2; }

\t\t\tif (!\$bSeparate && \$details['mbw']['RT']) {
\t\t\t\t\$yadj = (\$Rw - \$details['mbw']['RT'])/2;
\t\t\t}
\t\t\tif (!\$bSeparate && \$details['mbw']['RB']) {
\t\t\t\t\$yadj2 = (\$Rw - \$details['mbw']['RB'])/2;
\t\t\t}
\t\t\t\$print = true;
\t\t}
\t\tif (\$Bw && \$side=='B' && \$this->issetBorder(\$bord, _BORDER_BOTTOM)) {\t// BOTTOM
\t\t\t\$ly1 = \$y2;
\t\t\t\$ly2 = \$y2;
\t\t\t\$lx1 = \$x;
\t\t\t\$lx2 = \$x2;
\t\t\t\$this->SetLineWidth(\$Bw);
\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'L')!==false) {
\t\t\t\tif (\$Bw > \$Lw) \$xadj = (\$Bw - \$Lw)/2;
\t\t\t\tif (\$Bw < \$Lw) \$xadj = (\$Bw + \$Lw)/2;
\t\t\t}
\t\t\telse { \$xadj = \$Bw/2 - \$bsh/2; }
\t\t\tif (\$cort == 'cell' || strpos(\$tablecorner,'R')!==false) {
\t\t\t\tif (\$Bw > \$Rw) \$xadj2 = (\$Bw - \$Rw)/2;
\t\t\t\tif (\$Bw < \$Rw) \$xadj2 = (\$Bw + \$Rw)/2;
\t\t\t}
\t\t\telse { \$xadj2 = \$Bw/2 - \$bsh/2; }
\t\t\tif (!\$bSeparate && \$details['mbw']['BL']) {
\t\t\t\t\$xadj = (\$Bw - \$details['mbw']['BL'])/2;
\t\t\t}
\t\t\tif (!\$bSeparate && \$details['mbw']['BR']) {
\t\t\t\t\$xadj2 = (\$Bw - \$details['mbw']['BR'])/2;
\t\t\t}
\t\t\t\$print = true;
\t\t}

\t\t// Now draw line
\t\tif (\$print) {
/*-- TABLES-ADVANCED-BORDERS --*/
\t\t if (\$details[\$side]['style'] == 'double') {
\t\t   if (!isset(\$details[\$side]['overlay']) || !\$details[\$side]['overlay'] || \$bSeparate) {
\t\t\tif (\$details[\$side]['c']) {
\t\t\t\t\$this->SetDColor(\$details[\$side]['c']);
\t\t\t}
\t\t\telse { \$this->SetDColor(\$this->ConvertColor(0)); }
\t\t\t\$this->Line(\$lx1 + \$xadj, \$ly1 + \$yadj, \$lx2 - \$xadj2, \$ly2 - \$yadj2);
\t\t   }
\t\t   if ((isset(\$details[\$side]['overlay']) && \$details[\$side]['overlay']) || \$bSeparate) {
\t\t\tif (\$bSeparate && \$cort=='table') {
\t\t\t\tif (\$side=='T') {
\t\t\t\t   \$xadj -= \$this->LineWidth/2;
\t\t\t\t   \$xadj2 -= \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_LEFT)) {
\t\t\t\t\t\$xadj += \$this->LineWidth/2;
\t\t\t\t   }
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_RIGHT)) {
\t\t\t\t\t\$xadj2 += \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='L') {
\t\t\t\t   \$yadj -= \$this->LineWidth/2;
\t\t\t\t   \$yadj2 -= \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_TOP)) {
\t\t\t\t\t\$yadj += \$this->LineWidth/2;
\t\t\t\t   }
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_BOTTOM)) {
\t\t\t\t\t\$yadj2 += \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='B') {
\t\t\t\t   \$xadj -= \$this->LineWidth/2;
\t\t\t\t   \$xadj2 -= \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_LEFT)) {
\t\t\t\t\t\$xadj += \$this->LineWidth/2;
\t\t\t\t   }
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_RIGHT)) {
\t\t\t\t\t\$xadj2 += \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='R') {
\t\t\t\t   \$yadj -= \$this->LineWidth/2;
\t\t\t\t   \$yadj2 -= \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_TOP)) {
\t\t\t\t\t\$yadj += \$this->LineWidth/2;
\t\t\t\t   }
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_BOTTOM)) {
\t\t\t\t\t\$yadj2 += \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t}

\t\t\t\$this->SetLineWidth(\$this->LineWidth/3);

\t\t\t\$tbcol = \$this->ConvertColor(255);
\t\t\tfor(\$l=0; \$l <= \$this->blklvl; \$l++) {
\t\t\t\tif (\$this->blk[\$l]['bgcolor']) {
\t\t\t\t\t\$tbcol = (\$this->blk[\$l]['bgcolorarray']);\t// mPDF 5.6.53
\t\t\t\t}
\t\t\t}

\t\t\tif (\$bSeparate) {
\t\t\t   \$cellBorderOverlay[] = array(
\t\t\t\t'x' => \$lx1 + \$xadj,
\t\t\t\t'y' => \$ly1 + \$yadj,
\t\t\t\t'x2' => \$lx2 - \$xadj2,
\t\t\t\t'y2' => \$ly2 - \$yadj2,
\t\t\t\t'col' => \$tbcol,
\t\t\t\t'lw' => \$this->LineWidth,
\t\t\t   );
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->SetDColor(\$tbcol);
\t\t\t\t\$this->Line(\$lx1 + \$xadj, \$ly1 + \$yadj, \$lx2 - \$xadj2, \$ly2 - \$yadj2);
\t\t\t}
\t\t   }
\t\t }


\t\t else if (isset(\$details[\$side]['style']) && (\$details[\$side]['style'] == 'ridge' || \$details[\$side]['style'] == 'groove' || \$details[\$side]['style'] == 'inset' || \$details[\$side]['style'] == 'outset')) {
\t\t   if (!isset(\$details[\$side]['overlay']) || !\$details[\$side]['overlay'] || \$bSeparate) {
\t\t\tif (\$details[\$side]['c']) {
\t\t\t\t\$this->SetDColor(\$details[\$side]['c']);
\t\t\t}
\t\t\telse { \$this->SetDColor(\$this->ConvertColor(0)); }
\t\t\tif (\$details[\$side]['style'] == 'outset' || \$details[\$side]['style'] == 'groove') {
\t\t\t\t\$nc = \$this->_darkenColor(\$details[\$side]['c']);
\t\t\t\t\$this->SetDColor(\$nc);
\t\t\t}
\t\t\telse if (\$details[\$side]['style'] == 'ridge' || \$details[\$side]['style'] == 'inset') {
\t\t\t\t\$nc = \$this->_lightenColor(\$details[\$side]['c']);
\t\t\t\t\$this->SetDColor(\$nc);
\t\t\t}
\t\t\t\$this->Line(\$lx1 + \$xadj, \$ly1 + \$yadj, \$lx2 - \$xadj2, \$ly2 - \$yadj2);
\t\t   }
\t\t   if ((isset(\$details[\$side]['overlay']) && \$details[\$side]['overlay']) || \$bSeparate) {
\t\t\tif (\$details[\$side]['c']) {
\t\t\t\t\$this->SetDColor(\$details[\$side]['c']);
\t\t\t}
\t\t\telse { \$this->SetDColor(\$this->ConvertColor(0)); }
\t\t\t\$doubleadj = (\$this->LineWidth)/3;
\t\t\t\$this->SetLineWidth(\$this->LineWidth/2);
\t\t\t\$xadj3 = \$yadj3 = \$wadj3 = \$hadj3 = 0;

\t\t\tif (\$details[\$side]['style'] == 'ridge' || \$details[\$side]['style'] == 'inset') {
\t\t\t   \$nc = \$this->_darkenColor(\$details[\$side]['c']);

\t\t\t   if (\$bSeparate && \$cort=='table') {
\t\t\t\tif (\$side=='T') {
\t\t\t\t   \$yadj3 = \$this->LineWidth/2;
\t\t\t\t   \$xadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$wadj3 = \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_LEFT)) {
\t\t\t\t\t\$xadj3 += \$this->LineWidth; \$wadj3 -= \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_RIGHT)) {
\t\t\t\t\t\$wadj3 -= \$this->LineWidth*2;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='L') {
\t\t\t\t   \$xadj3 = \$this->LineWidth/2;
\t\t\t\t   \$yadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$hadj3 = \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_TOP)) {
\t\t\t\t\t\$yadj3 += \$this->LineWidth; \$hadj3 -= \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_BOTTOM)) {
\t\t\t\t\t\$hadj3 -= \$this->LineWidth*2;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='B') {
\t\t\t\t   \$yadj3 = \$this->LineWidth/2;
\t\t\t\t   \$xadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$wadj3 = \$this->LineWidth;
\t\t\t\t}
\t\t\t\tif (\$side=='R') {
\t\t\t\t   \$xadj3 = \$this->LineWidth/2;
\t\t\t\t   \$yadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$hadj3 = \$this->LineWidth;
\t\t\t\t}
\t\t\t   }

\t\t\t   else if (\$side=='T') { \$yadj3 = \$this->LineWidth/2; \$xadj3 = \$this->LineWidth/2; \$wadj3 = -\$this->LineWidth*2; }
\t\t\t   else if (\$side=='L') { \$xadj3 = \$this->LineWidth/2; \$yadj3 = \$this->LineWidth/2; \$hadj3 = -\$this->LineWidth*2; }

\t\t\t   else if (\$side=='B' && \$bSeparate) { \$yadj3 = \$this->LineWidth/2; \$wadj3 = \$this->LineWidth/2; }
\t\t\t   else if (\$side=='R' && \$bSeparate) { \$xadj3 = \$this->LineWidth/2; \$hadj3 = \$this->LineWidth/2; }

\t\t\t   else if (\$side=='B') { \$yadj3 = \$this->LineWidth/2; \$xadj3 = \$this->LineWidth/2; }
\t\t\t   else if (\$side=='R') { \$xadj3 = \$this->LineWidth/2; \$yadj3 = \$this->LineWidth/2; }
\t\t\t}
\t\t\telse {
\t\t\t   \$nc = \$this->_lightenColor(\$details[\$side]['c']);

\t\t\t   if (\$bSeparate && \$cort=='table') {
\t\t\t\tif (\$side=='T') {
\t\t\t\t   \$yadj3 = \$this->LineWidth/2;
\t\t\t\t   \$xadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$wadj3 = \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_LEFT)) {
\t\t\t\t\t\$xadj3 += \$this->LineWidth; \$wadj3 -= \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='L') {
\t\t\t\t   \$xadj3 = \$this->LineWidth/2;
\t\t\t\t   \$yadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$hadj3 = \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_TOP)) {
\t\t\t\t\t\$yadj3 += \$this->LineWidth; \$hadj3 -= \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='B') {
\t\t\t\t   \$yadj3 = \$this->LineWidth/2;
\t\t\t\t   \$xadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$wadj3 = \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_LEFT)) {
\t\t\t\t\t\$xadj3 += \$this->LineWidth; \$wadj3 -= \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t\tif (\$side=='R') {
\t\t\t\t   \$xadj3 = \$this->LineWidth/2;
\t\t\t\t   \$yadj3 = -\$this->LineWidth/2;
\t\t\t\t   \$hadj3 = \$this->LineWidth;
\t\t\t\t   if (\$this->issetBorder(\$bord, _BORDER_TOP)) {
\t\t\t\t\t\$yadj3 += \$this->LineWidth; \$hadj3 -= \$this->LineWidth;
\t\t\t\t   }
\t\t\t\t}
\t\t\t   }

\t\t\t   else if (\$side=='T') { \$yadj3 = \$this->LineWidth/2; \$xadj3 = \$this->LineWidth/2; }
\t\t\t   else if (\$side=='L') { \$xadj3 = \$this->LineWidth/2; \$yadj3 = \$this->LineWidth/2; }

\t\t\t   else if (\$side=='B' && \$bSeparate) { \$yadj3 = \$this->LineWidth/2; \$xadj3 = \$this->LineWidth/2; }
\t\t\t   else if (\$side=='R' && \$bSeparate) { \$xadj3 = \$this->LineWidth/2; \$yadj3 = \$this->LineWidth/2; }

\t\t\t   else if (\$side=='B') { \$yadj3 = \$this->LineWidth/2; \$xadj3 = -\$this->LineWidth/2; \$wadj3 = \$this->LineWidth; }
\t\t\t   else if (\$side=='R') { \$xadj3 = \$this->LineWidth/2; \$yadj3 = -\$this->LineWidth/2;  \$hadj3 = \$this->LineWidth; }

\t\t\t}

\t\t\tif (\$bSeparate) {
\t\t\t   \$cellBorderOverlay[] = array(
\t\t\t\t'x' => \$lx1 + \$xadj + \$xadj3,
\t\t\t\t'y' => \$ly1 + \$yadj + \$yadj3,
\t\t\t\t'x2' => \$lx2 - \$xadj2 + \$xadj3 + \$wadj3,
\t\t\t\t'y2' => \$ly2 - \$yadj2 + \$yadj3 + \$hadj3,
\t\t\t\t'col' => \$nc,
\t\t\t\t'lw' => \$this->LineWidth,
\t\t\t   );
\t\t\t}
\t\t\telse {
\t\t\t   \$this->SetDColor(\$nc);
\t\t\t   \$this->Line(\$lx1 + \$xadj + \$xadj3, \$ly1 + \$yadj + \$yadj3, \$lx2 - \$xadj2 + \$xadj3 + \$wadj3, \$ly2 - \$yadj2 + \$yadj3 + \$hadj3);
\t\t\t}
\t\t   }
\t\t }


\t\t else {
/*-- END TABLES-ADVANCED-BORDERS --*/
\t\t   if (\$details[\$side]['style'] == 'dashed') {
\t\t\t\$dashsize = 2;\t// final dash will be this + 1*linewidth
\t\t\t\$dashsizek = 1.5;\t// ratio of Dash/Blank
\t\t\t\$this->SetDash(\$dashsize,(\$dashsize/\$dashsizek)+(\$this->LineWidth*2));
\t\t   }
\t\t   else if (\$details[\$side]['style'] == 'dotted') {
\t\t\t\$this->SetLineJoin(1);
\t\t\t\$this->SetLineCap(1);
\t\t\t\$this->SetDash(0.001,(\$this->LineWidth*2));
\t\t   }
\t\t   if (\$details[\$side]['c']) {
\t\t\t\$this->SetDColor(\$details[\$side]['c']);
\t\t   }
\t\t   else { \$this->SetDColor(\$this->ConvertColor(0)); }
\t\t   \$this->Line(\$lx1 + \$xadj, \$ly1 + \$yadj, \$lx2 - \$xadj2, \$ly2 - \$yadj2);
/*-- TABLES-ADVANCED-BORDERS --*/
\t\t }
/*-- END TABLES-ADVANCED-BORDERS --*/

\t   \t  // Reset Corners
\t   \t  \$this->SetDash();
  \t\t  //BUTT style line cap
\t\t  \$this->SetLineCap(2);
\t\t}
\t   }

\t   if (\$bSeparate && count(\$cellBorderOverlay)) {
\t\tforeach(\$cellBorderOverlay AS \$cbo) {
\t\t\t\$this->SetLineWidth(\$cbo['lw']);
\t\t\t\$this->SetDColor(\$cbo['col']);
\t\t\t\$this->Line(\$cbo['x'], \$cbo['y'], \$cbo['x2'], \$cbo['y2']);
\t\t}
\t   }

\t   // \$this->SetLineWidth(\$oldlinewidth);
\t   // \$this->SetDColor(\$this->ConvertColor(0));
\t}
}


/*-- TABLES --*/
/*-- TABLES-ADVANCED-BORDERS --*/
function _lightenColor(\$c) {
\tif (is_array(\$c)) { die('Color error in _lightencolor'); }
\tif (\$c{0}==3 || \$c{0}==5) { \t// RGB
\t\tlist(\$h,\$s,\$l) = \$this->rgb2hsl(ord(\$c{1})/255,ord(\$c{2})/255,ord(\$c{3})/255);
\t\t\$l += ((1 - \$l)*0.8);
\t\tlist(\$r,\$g,\$b) = \$this->hsl2rgb(\$h,\$s,\$l);
\t\t\$ret = array(3,\$r,\$g,\$b);
\t}
\telse if (\$c{0}==4 || \$c{0}==6) { \t// CMYK
\t\t\$ret = array(4, max(0,(ord(\$c{1})-20)), max(0,(ord(\$c{2})-20)), max(0,(ord(\$c{3})-20)), max(0,(ord(\$c{4})-20)) );
\t}
\telse if (\$c{0}==1) {\t// Grayscale
\t\t\$ret = array(1,min(255,(ord(\$c{1})+32)));
\t}
\t\$c = array_pad(\$ret, 6, 0);
\t\$cstr = pack(\"a1ccccc\", \$c[0], (\$c[1] & 0xFF), (\$c[2] & 0xFF), (\$c[3] & 0xFF), (\$c[4] & 0xFF), (\$c[5] & 0xFF) );
\treturn \$cstr;
}


function _darkenColor(\$c) {
\tif (is_array(\$c)) { die('Color error in _darkenColor'); }
\tif (\$c{0}==3 || \$c{0}==5) { \t// RGB
\t\tlist(\$h,\$s,\$l) = \$this->rgb2hsl(ord(\$c{1})/255,ord(\$c{2})/255,ord(\$c{3})/255);
\t\t\$s *= 0.25;
\t\t\$l *= 0.75;
\t\tlist(\$r,\$g,\$b) = \$this->hsl2rgb(\$h,\$s,\$l);
\t\t\$ret = array(3,\$r,\$g,\$b);
 \t}
\telse if (\$c{0}==4 || \$c{0}==6) { \t// CMYK
\t\t\$ret = array(4, min(100,(ord(\$c{1})+20)), min(100,(ord(\$c{2})+20)), min(100,(ord(\$c{3})+20)), min(100,(ord(\$c{4})+20)) );
 \t}
\telse if (\$c{0}==1) {\t// Grayscale
\t\t\$ret = array(1,max(0,(ord(\$c{1})-32)));
 \t}
\t\$c = array_pad(\$ret, 6, 0);
\t\$cstr = pack(\"a1ccccc\", \$c[0], (\$c[1] & 0xFF), (\$c[2] & 0xFF), (\$c[3] & 0xFF), (\$c[4] & 0xFF), (\$c[5] & 0xFF) );
\treturn \$cstr;
}

/*-- END TABLES-ADVANCED-BORDERS --*/



function setBorder(&\$var, \$flag, \$set = true) {
\t\$flag = intval(\$flag);
\tif (\$set) { \$set = true; }
\t\$var = intval(\$var);
\t\$var = \$set ? (\$var | \$flag) : (\$var & ~\$flag);
}
function issetBorder(\$var, \$flag) {
\t\$flag = intval(\$flag);
\t\$var = intval(\$var);
\treturn ((\$var & \$flag) == \$flag);
}


function _table2cellBorder(&\$tableb, &\$cbdb, &\$cellb, \$bval) {
\tif (\$tableb && \$tableb['w'] > \$cbdb['w']) {
\t\t\$cbdb = \$tableb;
\t\t\$this->setBorder(\$cellb, \$bval);
\t}
\telse if (\$tableb && \$tableb['w'] == \$cbdb['w']
\t\t&& array_search(\$tableb['style'],\$this->borderstyles) > array_search(\$cbdb['style'],\$this->borderstyles)) {
\t\t\$cbdb = \$tableb;
\t\t\$this->setBorder(\$cellb, \$bval);
\t}
}

// FIX BORDERS ********************************************
function _fixTableBorders(&\$table){
\tif (\$this->cacheTables) { \$fh = fopen(\$table['cache'], \"r+b\"); }
\telse { \$fh = null; }

\tif (!\$table['borders_separate'] && \$table['border_details']['L']['w']) {
\t\t\$table['max_cell_border_width']['L'] = \$table['border_details']['L']['w'];
\t}
\tif (!\$table['borders_separate'] && \$table['border_details']['R']['w']) {
\t\t\$table['max_cell_border_width']['R'] = \$table['border_details']['R']['w'];
\t}
\tif (!\$table['borders_separate'] && \$table['border_details']['T']['w']) {
\t\t\$table['max_cell_border_width']['T'] = \$table['border_details']['T']['w'];
\t}
\tif (!\$table['borders_separate'] && \$table['border_details']['B']['w']) {
\t\t\$table['max_cell_border_width']['B'] = \$table['border_details']['B']['w'];
\t}
\tif (\$this->simpleTables) { return; }
\t\$cells = &\$table['cells'];
\t\$numcols = \$table['nc'];
\t\$numrows = \$table['nr'];
/*-- TABLES-ADVANCED-BORDERS --*/
\tif (isset(\$table['topntail']) && \$table['topntail']) { \$tntborddet = \$this->border_details(\$table['topntail']); }
\tif (isset(\$table['thead-underline']) && \$table['thead-underline']) { \$thuborddet = \$this->border_details(\$table['thead-underline']); }
/*-- END TABLES-ADVANCED-BORDERS --*/

\tfor( \$i = 0 ; \$i < \$numrows ; \$i++ ) { //Rows
\t  for( \$j = 0 ; \$j < \$numcols ; \$j++ ) { //Columns
\t\tif (isset(\$cells[\$i][\$j]) && \$cells[\$i][\$j]) {
\t\t\tif (\$this->cacheTables) {
\t\t\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t}
\t\t\telse
\t\t\t\t\$cell = &\$cells[\$i][\$j];
\t\t\tif (\$this->packTableData) {\t// includes \$this->cacheTables
\t\t\t\t\$cbord = \$this->_unpackCellBorder(\$cell['borderbin']);
\t\t\t}
\t\t\telse {
\t\t\t\t\$cbord = &\$cells[\$i][\$j];
\t\t\t}
\t\t\t// mPDF 5.7.3
  \t\t\tif (!\$cbord['border'] && \$cbord['border']!==0 && isset(\$table['border']) && \$table['border'] && \$this->table_border_attr_set) {
\t\t\t\t\$cbord['border'] = \$table['border'];
\t\t\t\t\$cbord['border_details'] = \$table['border_details'];
\t\t\t}

\t\t\tif (isset(\$cell['colspan']) && \$cell['colspan']>1) { \$ccolsp = \$cell['colspan']; }
\t\t\telse { \$ccolsp = 1; }
\t\t\tif (isset(\$cell['rowspan']) && \$cell['rowspan']>1) { \$crowsp = \$cell['rowspan']; }
\t\t\telse { \$crowsp = 1; }

\t\t\t\$cbord['border_details']['cellposdom'] = (((\$i+1)/\$numrows) / 10000 ) + (((\$j+1)/\$numcols) / 10 );
\t\t\t// Inherit Cell border from Table border
\t\t\tif (\$this->table_border_css_set && !\$table['borders_separate']) {
\t\t\t\tif (\$i == 0) {
\t\t\t\t  \$this->_table2cellBorder(\$table['border_details']['T'], \$cbord['border_details']['T'], \$cbord['border'], _BORDER_TOP);
\t\t\t\t}
\t\t\t\tif (\$i == (\$numrows-1) || (\$i+\$crowsp) == (\$numrows) ) {
\t\t\t\t  \$this->_table2cellBorder(\$table['border_details']['B'], \$cbord['border_details']['B'], \$cbord['border'], _BORDER_BOTTOM);
\t\t\t\t}
\t\t\t\tif (\$j == 0) {
\t\t\t\t  \$this->_table2cellBorder(\$table['border_details']['L'], \$cbord['border_details']['L'], \$cbord['border'], _BORDER_LEFT);
\t\t\t\t}
\t\t\t\tif (\$j == (\$numcols-1) || (\$j+\$ccolsp) == (\$numcols) ) {
\t\t\t\t  \$this->_table2cellBorder(\$table['border_details']['R'], \$cbord['border_details']['R'], \$cbord['border'], _BORDER_RIGHT);
\t\t\t\t}
\t\t\t}

/*-- TABLES-ADVANCED-BORDERS --*/
\t\t\t\$fixbottom = true;
\t\t\tif (isset(\$table['topntail']) && \$table['topntail']) {
\t\t\t\tif (\$i == 0) {
\t\t\t\t  \$cbord['border_details']['T'] = \$tntborddet;
\t\t\t\t  \$this->setBorder(\$cbord['border'], _BORDER_TOP);
\t\t\t\t}
\t\t\t\tif (\$this->tableLevel==1 && \$table['headernrows']>0 && \$i == \$table['headernrows']-1) {
\t\t\t\t\t\$cbord['border_details']['B'] = \$tntborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_BOTTOM);
\t\t\t\t\t\$fixbottom = false;
\t\t\t\t}
\t\t\t\telse if (\$this->tableLevel==1 && \$table['headernrows']>0 && \$i == \$table['headernrows']) {
\t\t\t\t  if (!\$table['borders_separate']) {
\t\t\t\t\t\$cbord['border_details']['T'] = \$tntborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_TOP);
\t\t\t\t  }
\t\t\t\t}
\t\t\t\tif (\$this->tableLevel==1 && \$table['footernrows']>0 && \$i == (\$numrows-\$table['footernrows']-1)) {
\t\t\t\t  if (!\$table['borders_separate']) {
\t\t\t\t\t\$cbord['border_details']['B'] = \$tntborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_BOTTOM);
\t\t\t\t\t\$fixbottom = false;
\t\t\t\t  }
\t\t\t\t}
\t\t\t\telse if (\$this->tableLevel==1 && \$table['footernrows']>0 && \$i == (\$numrows-\$table['footernrows'])) {
\t\t\t\t\t\$cbord['border_details']['T'] = \$tntborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_TOP);
\t\t\t\t}
\t\t\t\tif (\$this->tabletheadjustfinished) {\t// \$this->tabletheadjustfinished called from tableheader
\t\t\t\t  if (!\$table['borders_separate']) {
\t\t\t\t\t\$cbord['border_details']['T'] = \$tntborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_TOP);
\t\t\t\t  }
\t\t\t\t}
\t\t\t\tif (\$i == (\$numrows-1) || (\$i+\$crowsp) == (\$numrows) ) {
\t\t\t\t\t\$cbord['border_details']['B'] = \$tntborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_BOTTOM);
\t\t\t\t}
\t\t\t}
\t\t\tif (isset(\$table['thead-underline']) && \$table['thead-underline']) {
\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t  if (\$i == 0) {
\t\t\t\t\t\$cbord['border_details']['B'] = \$thuborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_BOTTOM);
\t\t\t\t\t\$fixbottom = false;
\t\t\t\t  }
\t\t\t\t}
\t\t\t\telse  {
\t\t\t\t  if (\$this->tableLevel==1 && \$table['headernrows']>0 && \$i == \$table['headernrows']-1) {
\t\t\t\t\t\$cbord['border_details']['T'] = \$thuborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_TOP);
\t\t\t\t  }
\t\t\t\t  else if (\$this->tabletheadjustfinished) {\t// \$this->tabletheadjustfinished called from tableheader
\t\t\t\t\t\$cbord['border_details']['T'] = \$thuborddet;
\t\t\t\t\t\$this->setBorder(\$cbord['border'], _BORDER_TOP);
\t\t\t\t  }
\t\t\t\t}
\t\t\t}

\t\t\t// Collapse Border - Algorithm for conflicting borders
\t\t\t// Hidden >> Width >> double>solid>dashed>dotted... >> style set on cell>table >> top/left>bottom/right
\t\t\t// Do not turn off border which is overridden
\t\t\t// Needed for page break for TOP/BOTTOM both to be defined in Collapsed borders
\t\t\t// Means it is painted twice. (Left/Right can still disable overridden border)
\t\t\tif (!\$table['borders_separate']) {
\t\t\t  if ((\$i < (\$numrows-1)  || (\$i+\$crowsp) < \$numrows ) && \$fixbottom ) {\t// Bottom
\t\t\t   for (\$cspi = 0; \$cspi<\$ccolsp; \$cspi++) {
\t\t\t\t// already defined Top for adjacent cell below
\t\t\t\tif (isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi])) {
\t\t\t\t   if (\$this->packTableData) {
\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\$adjc = \$this->_uncacheCell(\$table['cells'][\$i+\$crowsp][\$j+\$cspi], '', \$fh);
\t\t\t\t\t}
\t\t\t\t\telse { \$adjc = \$cells[(\$i+\$crowsp)][\$j+\$cspi]; }
\t\t\t\t\t\$celladj = \$this->_unpackCellBorder(\$adjc['borderbin']);
\t\t\t\t   }
\t\t\t\t   else { \$celladj =& \$cells[(\$i+\$crowsp)][\$j+\$cspi]; }
\t\t\t\t}
\t\t\t\telse { \$celladj = false; }
\t\t\t\tif (\$celladj && \$celladj['border_details']['T']['s'] == 1)  {
\t\t\t\t   \$csadj = \$celladj['border_details']['T']['w'];
\t\t\t\t   \$csthis = \$cbord['border_details']['B']['w'];
\t\t\t\t   // Hidden
\t\t\t\t   if (\$cbord['border_details']['B']['style']=='hidden') {
\t\t\t\t\t\$celladj['border_details']['T'] = \$cbord['border_details']['B'];
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_TOP, false);
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_BOTTOM , false);
\t\t\t\t   }
\t\t\t\t   else if (\$celladj['border_details']['T']['style']=='hidden') {
\t\t\t\t\t\$cbord['border_details']['B'] = \$celladj['border_details']['T'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_BOTTOM , false);
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_TOP, false);
\t\t\t\t   }
\t\t\t\t   // Width
\t\t\t\t   else if (\$csthis > \$csadj) {
\t\t\t\t    if (!isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) || (isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) && \$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['T'] = \$cbord['border_details']['B'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_BOTTOM);
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t   else if (\$csadj > \$csthis) {
\t\t\t\t    if (\$ccolsp < 2) {\t// don't overwrite this cell if it spans
\t\t\t\t\t\$cbord['border_details']['B'] = \$celladj['border_details']['T'];
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_TOP);
\t\t\t\t    }
\t\t\t\t   }

\t\t\t\t   // double>solid>dashed>dotted...
\t\t\t\t   else if (array_search(\$cbord['border_details']['B']['style'],\$this->borderstyles) > array_search(\$celladj['border_details']['T']['style'],\$this->borderstyles)) {
\t\t\t\t    if (!isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) || (isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) && \$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['T'] = \$cbord['border_details']['B'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_BOTTOM );
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t   else if (array_search(\$celladj['border_details']['T']['style'],\$this->borderstyles) > array_search(\$cbord['border_details']['B']['style'],\$this->borderstyles)) {
\t\t\t\t    if (\$ccolsp < 2) {\t// don't overwrite this cell if it spans
\t\t\t\t\t\$cbord['border_details']['B'] = \$celladj['border_details']['T'];
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_TOP);
\t\t\t\t    }
\t\t\t\t   }



\t\t\t\t   // Style set on cell vs. table
\t\t\t\t   else if (\$celladj['border_details']['T']['dom'] > \$cbord['border_details']['B']['dom']) {
\t\t\t\t    if (\$ccolsp < 2) {\t// don't overwrite this cell if it spans
\t\t\t\t\t\$cbord['border_details']['B'] = \$celladj['border_details']['T'];
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_TOP);
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t   // Style set on cell vs. table  - OR - LEFT/TOP (cell) in preference to BOTTOM/RIGHT
\t\t\t\t   else {
\t\t\t\t    if (!isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) || (isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) && \$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['T'] = \$cbord['border_details']['B'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_BOTTOM );
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse if (\$celladj) {
\t\t\t\t    if (!isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) || (isset(\$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']) && \$cells[(\$i+\$crowsp)][\$j+\$cspi]['colspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['T'] = \$cbord['border_details']['B'];
\t\t\t\t    }
\t\t\t\t}
\t\t\t\tif (\$celladj && \$this->packTableData) {
\t\t\t\t\t\$celladj['borderbin'] = \$this->_packCellBorder(\$celladj);
\t\t\t\t\tunset(\$celladj['border']);
\t\t\t\t\tunset(\$celladj['border_details']);
\t\t\t\t}
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$this->_cacheUpdateBorder(\$celladj, \$fh, \$table['cells'][\$i+\$crowsp][\$j+\$cspi]);
\t\t\t\t}
\t\t\t\tunset(\$celladj);
\t\t\t   }
\t\t\t  }

\t\t\t  if (\$j < (\$numcols-1)  || (\$j+\$ccolsp) < \$numcols ) {\t// Right-Left
\t\t\t   for (\$cspi = 0; \$cspi<\$crowsp; \$cspi++) {
\t\t\t\t// already defined Left for adjacent cell to R
\t\t\t\tif (isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp])) {
\t\t\t\t   if (\$this->packTableData) {
\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\$adjc = \$this->_uncacheCell(\$table['cells'][\$i+\$cspi][\$j+\$ccolsp], '', \$fh);
\t\t\t\t\t}
\t\t\t\t\telse { \$adjc = \$cells[(\$i+\$cspi)][\$j+\$ccolsp]; }
\t\t\t\t\t\$celladj = \$this->_unpackCellBorder(\$adjc['borderbin']);
\t\t\t\t   }
\t\t\t\t   else { \$celladj =& \$cells[\$i+\$cspi][\$j+\$ccolsp]; }
\t\t\t\t}
\t\t\t\telse { \$celladj = false; }
\t\t\t\tif (\$celladj && \$celladj['border_details']['L']['s'] == 1) {
\t\t\t\t   \$csadj = \$celladj['border_details']['L']['w'];
\t\t\t\t   \$csthis = \$cbord['border_details']['R']['w'];
\t\t\t\t   // Hidden
\t\t\t\t   if (\$cbord['border_details']['R']['style']=='hidden') {
\t\t\t\t\t\$celladj['border_details']['L'] = \$cbord['border_details']['R'];
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_LEFT, false);
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_RIGHT , false);
\t\t\t\t   }
\t\t\t\t   else if (\$celladj['border_details']['L']['style']=='hidden') {
\t\t\t\t\t\$cbord['border_details']['R'] = \$celladj['border_details']['L'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_RIGHT , false);
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_LEFT, false);
\t\t\t\t   }
\t\t\t\t   // Width
\t\t\t\t   else if (\$csthis > \$csadj) {
\t\t\t\t    if (!isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) || (isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) && \$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['L'] = \$cbord['border_details']['R'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_RIGHT);
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_LEFT, false);
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t   else if (\$csadj > \$csthis) {
\t\t\t\t    if (\$crowsp < 2) {\t// don't overwrite this cell if it spans
\t\t\t\t\t\$cbord['border_details']['R'] = \$celladj['border_details']['L'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_RIGHT, false);
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_LEFT);
\t\t\t\t    }
\t\t\t\t   }

\t\t\t\t   // double>solid>dashed>dotted...
\t\t\t\t   else if (array_search(\$cbord['border_details']['R']['style'],\$this->borderstyles) > array_search(\$celladj['border_details']['L']['style'],\$this->borderstyles)) {
\t\t\t\t    if (!isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) || (isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) && \$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['L'] = \$cbord['border_details']['R'];
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_LEFT, false);
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_RIGHT);
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t   else if (array_search(\$celladj['border_details']['L']['style'],\$this->borderstyles) > array_search(\$cbord['border_details']['R']['style'],\$this->borderstyles)) {
\t\t\t\t    if (\$crowsp < 2) {\t// don't overwrite this cell if it spans
\t\t\t\t\t\$cbord['border_details']['R'] = \$celladj['border_details']['L'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_RIGHT , false);
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_LEFT);
\t\t\t\t    }
\t\t\t\t   }


\t\t\t\t   // Style set on cell vs. table
\t\t\t\t   else if (\$celladj['border_details']['L']['dom'] > \$cbord['border_details']['R']['dom']) {
\t\t\t\t    if (\$crowsp < 2) {\t// don't overwrite this cell if it spans
\t\t\t\t\t\$cbord['border_details']['R'] = \$celladj['border_details']['L'];
\t\t\t\t\t\$this->setBorder(\$celladj['border'] , _BORDER_LEFT);
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t   // Style set on cell vs. table  - OR - LEFT/TOP (cell) in preference to BOTTOM/RIGHT
\t\t\t\t   else {
\t\t\t\t    if (!isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) || (isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) && \$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['L'] = \$cbord['border_details']['R'];
\t\t\t\t\t\$this->setBorder(\$cbord['border'] , _BORDER_RIGHT);
\t\t\t\t    }
\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse if (\$celladj) {
\t\t\t\t   // if right-cell border is not set
\t\t\t\t    if (!isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) || (isset(\$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']) && \$cells[(\$i+\$cspi)][\$j+\$ccolsp]['rowspan']<2)) {\t// don't overwrite bordering cells that span
\t\t\t\t\t\$celladj['border_details']['L'] = \$cbord['border_details']['R'];
\t\t\t\t    }
\t\t\t\t}
\t\t\t\tif (\$celladj && \$this->packTableData) {
\t\t\t\t\t\$celladj['borderbin'] = \$this->_packCellBorder(\$celladj);
\t\t\t\t\tunset(\$celladj['border']);
\t\t\t\t\tunset(\$celladj['border_details']);
\t\t\t\t}
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$this->_cacheUpdateBorder(\$celladj, \$fh, \$table['cells'][\$i+\$cspi][\$j+\$ccolsp]);
\t\t\t\t}
\t\t\t\tunset(\$celladj);
\t\t\t   }
\t\t\t  }
\t\t\t}


\t\t\t// Set maximum cell border width meeting at LRTB edges of cell - used for extended cell border
\t\t\t// ['border_details']['mbw']['LT'] = meeting border width - Left border - Top end
\t\t\tif (!\$table['borders_separate']) {
\t\t\t  \$cbord['border_details']['mbw']['BL'] = max(\$cbord['border_details']['mbw']['BL'], \$cbord['border_details']['L']['w']);
\t\t\t  \$cbord['border_details']['mbw']['BR'] = max(\$cbord['border_details']['mbw']['BR'], \$cbord['border_details']['R']['w']);
\t\t\t  \$cbord['border_details']['mbw']['RT'] = max(\$cbord['border_details']['mbw']['RT'], \$cbord['border_details']['T']['w']);
\t\t\t  \$cbord['border_details']['mbw']['RB'] = max(\$cbord['border_details']['mbw']['RB'], \$cbord['border_details']['B']['w']);
\t\t\t  \$cbord['border_details']['mbw']['TL'] = max(\$cbord['border_details']['mbw']['TL'], \$cbord['border_details']['L']['w']);
\t\t\t  \$cbord['border_details']['mbw']['TR'] = max(\$cbord['border_details']['mbw']['TR'], \$cbord['border_details']['R']['w']);
\t\t\t  \$cbord['border_details']['mbw']['LT'] = max(\$cbord['border_details']['mbw']['LT'], \$cbord['border_details']['T']['w']);
\t\t\t  \$cbord['border_details']['mbw']['LB'] = max(\$cbord['border_details']['mbw']['LB'], \$cbord['border_details']['B']['w']);
\t\t\t  if ((\$i+\$crowsp) < \$numrows && isset(\$cells[\$i+\$crowsp][\$j])) {\t// Has Bottom adjoining cell
\t\t\t\tif (\$this->packTableData) {
\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\$adjc = \$this->_uncacheCell(\$table['cells'][\$i+\$crowsp][\$j], '', \$fh);
\t\t\t\t\t}
\t\t\t\t\telse { \$adjc = \$cells[\$i+\$crowsp][\$j]; }
\t\t\t\t\t\$celladj = \$this->_unpackCellBorder(\$adjc['borderbin']);
\t\t\t\t}
\t\t\t\telse { \$celladj =& \$cells[\$i+\$crowsp][\$j]; }
\t\t\t\t\$cbord['border_details']['mbw']['BL'] = max(\$cbord['border_details']['mbw']['BL'], \$celladj['border_details']['L']['w'], \$celladj['border_details']['mbw']['TL']);
\t\t\t\t\$cbord['border_details']['mbw']['BR'] = max(\$cbord['border_details']['mbw']['BR'], \$celladj['border_details']['R']['w'], \$celladj['border_details']['mbw']['TR']);
\t\t\t\t\$cbord['border_details']['mbw']['LB'] = max(\$cbord['border_details']['mbw']['LB'], \$celladj['border_details']['mbw']['LT']);
\t\t\t\t\$cbord['border_details']['mbw']['RB'] = max(\$cbord['border_details']['mbw']['RB'], \$celladj['border_details']['mbw']['RT']);
\t\t\t\tunset(\$celladj);
\t\t\t  }
\t\t\t  if ((\$j+\$ccolsp) < \$numcols && isset(\$cells[\$i][\$j+\$ccolsp])) {\t// Has Right adjoining cell
\t\t\t\tif (\$this->packTableData) {
\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\$adjc = \$this->_uncacheCell(\$table['cells'][\$i][\$j+\$ccolsp], '', \$fh);
\t\t\t\t\t}
\t\t\t\t\telse { \$adjc = \$cells[\$i][\$j+\$ccolsp]; }
\t\t\t\t\t\$celladj = \$this->_unpackCellBorder(\$adjc['borderbin']);
\t\t\t\t}
\t\t\t\telse { \$celladj =& \$cells[\$i][\$j+\$ccolsp]; }
\t\t\t\t\$cbord['border_details']['mbw']['RT'] = max(\$cbord['border_details']['mbw']['RT'], \$celladj['border_details']['T']['w'], \$celladj['border_details']['mbw']['LT']);
\t\t\t\t\$cbord['border_details']['mbw']['RB'] = max(\$cbord['border_details']['mbw']['RB'], \$celladj['border_details']['B']['w'], \$celladj['border_details']['mbw']['LB']);
\t\t\t\t\$cbord['border_details']['mbw']['TR'] = max(\$cbord['border_details']['mbw']['TR'], \$celladj['border_details']['mbw']['TL']);
\t\t\t\t\$cbord['border_details']['mbw']['BR'] = max(\$cbord['border_details']['mbw']['BR'], \$celladj['border_details']['mbw']['BL']);
\t\t\t\tunset(\$celladj);
\t\t\t  }

\t\t\t  if (\$i > 0 && isset(\$cells[\$i-1][\$j]) && ((\$this->packTableData && \$cells[\$i-1][\$j]['borderbin']) || \$cells[\$i-1][\$j]['border'])) {\t// Has Top adjoining cell
\t\t\t\tif (\$this->packTableData) {
\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\$adjc = \$this->_uncacheCell(\$table['cells'][\$i-1][\$j], '', \$fh);
\t\t\t\t\t}
\t\t\t\t\telse { \$adjc = \$cells[\$i-1][\$j]; }
\t\t\t\t\t\$celladj = \$this->_unpackCellBorder(\$adjc['borderbin']);
\t\t\t\t}
\t\t\t\telse { \$celladj =& \$cells[\$i-1][\$j]; }
\t\t\t\t\$cbord['border_details']['mbw']['TL'] = max(\$cbord['border_details']['mbw']['TL'], \$celladj['border_details']['L']['w'], \$celladj['border_details']['mbw']['BL']);
\t\t\t\t\$cbord['border_details']['mbw']['TR'] = max(\$cbord['border_details']['mbw']['TR'], \$celladj['border_details']['R']['w'], \$celladj['border_details']['mbw']['BR']);
\t\t\t\t\$cbord['border_details']['mbw']['LT'] = max(\$cbord['border_details']['mbw']['LT'], \$celladj['border_details']['mbw']['LB']);
\t\t\t\t\$cbord['border_details']['mbw']['RT'] = max(\$cbord['border_details']['mbw']['RT'], \$celladj['border_details']['mbw']['RB']);

\t\t\t\tif (\$celladj['border_details']['mbw']['BL']) {
\t\t\t\t\t\$celladj['border_details']['mbw']['BL'] = max(\$cbord['border_details']['mbw']['TL'], \$celladj['border_details']['mbw']['BL']);
\t\t\t\t}
\t\t\t\tif (\$celladj['border_details']['mbw']['BR'] ) {
\t\t\t\t\t\$celladj['border_details']['mbw']['BR'] = max(\$celladj['border_details']['mbw']['BR'], \$cbord['border_details']['mbw']['TR']);
\t\t\t\t}
\t\t\t\tif (\$this->packTableData) { \$cells[\$i-1][\$j]['borderbin'] = \$this->_packCellBorder(\$celladj); }
\t\t\t\tunset(\$celladj);
\t\t\t  }
\t\t\t  if (\$j > 0 && isset(\$cells[\$i][\$j-1]) && ((\$this->packTableData && \$cells[\$i][\$j-1]['borderbin']) || \$cells[\$i][\$j-1]['border'])) {\t// Has Left adjoining cell
\t\t\t\tif (\$this->packTableData) {
\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\$adjc = \$this->_uncacheCell(\$table['cells'][\$i][\$j-1], '', \$fh);
\t\t\t\t\t}
\t\t\t\t\telse { \$adjc = \$cells[\$i][\$j-1]; }
\t\t\t\t\t\$celladj = \$this->_unpackCellBorder(\$adjc['borderbin']);
\t\t\t\t}
\t\t\t\telse { \$celladj =& \$cells[\$i][\$j-1]; }
\t\t\t\t\$cbord['border_details']['mbw']['LT'] = max(\$cbord['border_details']['mbw']['LT'], \$celladj['border_details']['T']['w'], \$celladj['border_details']['mbw']['RT']);
\t\t\t\t\$cbord['border_details']['mbw']['LB'] = max(\$cbord['border_details']['mbw']['LB'], \$celladj['border_details']['B']['w'], \$celladj['border_details']['mbw']['RB']);
\t\t\t\t\$cbord['border_details']['mbw']['BL'] = max(\$cbord['border_details']['mbw']['BL'], \$celladj['border_details']['mbw']['BR']);
\t\t\t\t\$cbord['border_details']['mbw']['TL'] = max(\$cbord['border_details']['mbw']['TL'], \$celladj['border_details']['mbw']['TR']);

\t\t\t\tif (\$celladj['border_details']['mbw']['RT']) {
\t\t\t\t\t\$celladj['border_details']['mbw']['RT'] = max(\$celladj['border_details']['mbw']['RT'], \$cbord['border_details']['mbw']['LT']);
\t\t\t\t}
\t\t\t\tif (\$celladj['border_details']['mbw']['RB']) {
\t\t\t\t\t\$celladj['border_details']['mbw']['RB'] = max(\$celladj['border_details']['mbw']['RB'], \$cbord['border_details']['mbw']['LB']);
\t\t\t\t}
\t\t\t\tif (\$this->packTableData) { \$cells[\$i][\$j-1]['borderbin'] = \$this->_packCellBorder(\$celladj); }
\t\t\t\tunset(\$celladj);
\t\t\t  }


\t\t\t  // Update maximum cell border width at LRTB edges of table - used for overall table width
\t\t\t  if (\$j == 0 && \$cbord['border_details']['L']['w']) {
\t\t\t\t\$table['max_cell_border_width']['L'] = max(\$table['max_cell_border_width']['L'],\$cbord['border_details']['L']['w']);
\t\t\t  }
\t\t\t  if ((\$j == (\$numcols-1) || (\$j+\$ccolsp) == \$numcols ) && \$cbord['border_details']['R']['w']) {
\t\t\t\t\$table['max_cell_border_width']['R'] = max(\$table['max_cell_border_width']['R'],\$cbord['border_details']['R']['w']);
\t\t\t  }
\t\t\t  if (\$i == 0 && \$cbord['border_details']['T']['w']) {
\t\t\t\t\$table['max_cell_border_width']['T'] = max(\$table['max_cell_border_width']['T'],\$cbord['border_details']['T']['w']);
\t\t\t  }
\t\t\t  if ((\$i == (\$numrows-1) || (\$i+\$crowsp) == \$numrows ) && \$cbord['border_details']['B']['w']) {
\t\t\t\t\$table['max_cell_border_width']['B'] = max(\$table['max_cell_border_width']['B'],\$cbord['border_details']['B']['w']);
\t\t\t  }
\t\t\t}
/*-- END TABLES-ADVANCED-BORDERS --*/

\t\t\tif (\$this->packTableData) { \$cell['borderbin'] = \$this->_packCellBorder(\$cbord); }

\t\t\tif (\$this->cacheTables) {
\t\t\t\t\$this->_cacheUpdateBorder(\$cell, \$fh, \$table['cells'][\$i][\$j]);
\t\t\t}
\t\t\tunset(\$cbord );
\t\t\tunset(\$cell );
\t\t}
\t  }
\t}
\tif (\$this->cacheTables) { fclose(\$fh); }
\tunset(\$cell );
}
// END FIX BORDERS ************************************************************************************


function _reverseTableDir(&\$table) {
\tif (\$this->cacheTables) { \$fh = fopen(\$table['cache'], \"r+b\"); }
\t\$cells = &\$table['cells'];
\t\$numcols = \$table['nc'];
\t\$numrows = \$table['nr'];
\tfor( \$i = 0 ; \$i < \$numrows ; \$i++ ) { //Rows
\t\t\$row = array();
\t  \tfor( \$j = (\$numcols-1) ; \$j >= 0 ; \$j-- ) { //Columns
\t\t\tif (isset(\$cells[\$i][\$j]) && \$cells[\$i][\$j]) {
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t\t}
\t\t\t\telse
\t\t\t\t\t\$cell = &\$cells[\$i][\$j];
\t\t\t\t\$col = \$numcols - \$j - 1;
\t\t\t\tif (isset(\$cell['colspan']) && \$cell['colspan'] > 1) { \$col -= (\$cell['colspan']-1); }
\t\t\t\t// Nested content
\t\t\t\tfor (\$n=0; \$n < count(\$cell['textbuffer']); \$n++) {
\t\t\t\t\t\$t = \$cell['textbuffer'][\$n][0];
\t\t\t\t\tif (substr(\$t,0,19) == \"\\xbb\\xa4\\xactype=nestedtable\") {
\t\t\t\t\t\t\$objattr = \$this->_getObjAttr(\$t);
\t\t\t\t\t\t\$objattr['col'] = \$col;
\t\t\t\t\t\t\$cell['textbuffer'][\$n][0] = \"\\xbb\\xa4\\xactype=nestedtable,objattr=\".serialize(\$objattr).\"\\xbb\\xa4\\xac\";
\t\t\t\t\t\t\$this->table[(\$this->tableLevel+1)][\$objattr['nestedcontent']]['nestedpos'][1] = \$col;
\t\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\t\$this->_cacheUpdateTxB(\$cell, \$fh, \$table['cells'][\$i][\$j]);
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\t\$row[\$col] = \$cells[\$i][\$j];
\t\t\t\tunset(\$cell);
\t\t\t}
\t\t}
\t  \tfor(\$f=0; \$f < \$numcols; \$f++) {
\t\t\tif (!isset(\$row[\$f])) { \$row[\$f] = 0; }
\t\t}
\t\t\$table['cells'][\$i] = \$row;
\t}
\tif (\$this->cacheTables) { fclose(\$fh); }
}


function _tableWrite(&\$table, \$split=false, \$startrow=0, \$startcol=0, \$splitpg=0, \$rety = 0){
\t\$level = \$table['level'];
\t\$levelid = \$table['levelid'];

\t\$cells = &\$table['cells'];
\t\$numcols = \$table['nc'];
\t\$numrows = \$table['nr'];

\tif (\$this->ColActive && \$level==1) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*

\tif (!\$split || (\$startrow==0 && \$splitpg==0) || \$startrow>0){
\t\t// TABLE TOP MARGIN
\t\tif (\$table['margin']['T']) {
\t\t   if (!\$this->table_rotate && \$level==1) {
\t\t\t\$this->DivLn(\$table['margin']['T'],\$this->blklvl,true,1); \t// collapsible
\t\t   }
\t\t   else {
\t\t\t\$this->y += (\$table['margin']['T']);
\t\t   }
\t\t}
\t\t// Advance down page by half width of top border
\t\tif (\$table['borders_separate']) {
\t\t\tif (\$startrow>0 && (!isset(\$table['is_thead']) || count(\$table['is_thead'])==0))
\t\t\t\t\$adv = \$table['border_spacing_V']/2;
\t\t\telse
\t\t\t\t\$adv = \$table['padding']['T'] + \$table['border_details']['T']['w'] + \$table['border_spacing_V']/2;
\t\t}
\t\telse {
\t\t\t\$adv = \$table['max_cell_border_width']['T']/2;
\t\t}
\t\tif (!\$this->table_rotate && \$level==1) { \$this->DivLn(\$adv); }
\t\telse { \$this->y += \$adv; }
\t}

\tif (\$level==1) {
\t\t\$this->x = \$this->lMargin  + \$this->blk[\$this->blklvl]['outer_left_margin'] + \$this->blk[\$this->blklvl]['padding_left'] + \$this->blk[\$this->blklvl]['border_left']['w'];
\t\t\$x0 = \$this->x;
\t\t\$y0 = \$this->y;
\t\t\$right = \$x0 + \$this->blk[\$this->blklvl]['inner_width'];
\t\t\$outerfilled = \$this->y;\t// Keep track of how far down the outer DIV bgcolor is painted (NB rowspans)
\t\t\$this->outerfilled = \$this->y;
\t\t\$this->colsums = array();
\t}
\telse {
\t\t\$x0 = \$this->x;
\t\t\$y0 = \$this->y;
\t\t\$right = \$x0 + \$table['w'];
\t}

\tif (\$this->table_rotate) {
\t\t\$temppgwidth = \$this->tbrot_maxw;
\t\t\$this->PageBreakTrigger = \$pagetrigger = \$y0 + (\$this->blk[\$this->blklvl]['inner_width']);
\t   if (\$level==1) {
\t\t\$this->tbrot_y0 = \$this->y - \$adv - \$table['margin']['T'] ;
\t\t\$this->tbrot_x0 = \$this->x;
\t\t\$this->tbrot_w = \$table['w'];
\t\tif (\$table['borders_separate']) { \$this->tbrot_h = \$table['margin']['T'] + \$table['padding']['T'] + \$table['border_details']['T']['w'] + \$table['border_spacing_V']/2; }
\t\telse { \$this->tbrot_h = \$table['margin']['T'] + \$table['padding']['T'] + \$table['max_cell_border_width']['T']; }
\t   }
\t}
\telse {
\t\t\$this->PageBreakTrigger = \$pagetrigger = (\$this->h - \$this->bMargin);
\t   \tif (\$level==1) {
\t\t\t\$temppgwidth = \$this->blk[\$this->blklvl]['inner_width'];
\t   \t\tif (isset(\$table['a']) and (\$table['w'] < \$this->blk[\$this->blklvl]['inner_width'])) {
\t\t\t\tif (\$table['a']=='C') { \$x0 += (((\$right-\$x0) - \$table['w'])/2); }
\t\t\t\telse if (\$table['a']=='R') { \$x0 = \$right - \$table['w']; }
\t\t\t}
\t   \t}
\t\telse {
\t\t\t\$temppgwidth = \$table['w'];
\t\t}
\t}
\tif(!isset(\$table['overflow'])) { \$table['overflow'] = null; }
\tif (\$table['overflow']=='hidden' && \$level==1 && !\$this->table_rotate && !\$this->ColActive) {
\t\t//Bounding rectangle to clip
\t\t\$this->tableClipPath = sprintf('q %.3F %.3F %.3F %.3F re W n',\$x0*_MPDFK,\$this->h*_MPDFK,\$this->blk[\$this->blklvl]['inner_width']*_MPDFK,-\$this->h*_MPDFK);
\t\t\$this->_out(\$this->tableClipPath);
\t}
\telse { \$this->tableClipPath = ''; }


\tif (\$table['borders_separate']) { \$indent = \$table['margin']['L'] + \$table['border_details']['L']['w'] + \$table['padding']['L'] + \$table['border_spacing_H']/2; }
\telse { \$indent = \$table['margin']['L'] + \$table['max_cell_border_width']['L']/2; }
\t\$x0 += \$indent;

\t\$returny = 0;
\t\$lastCol = 0;
\t\$tableheader = array();
\t\$tablefooter = array();
\t\$tableheaderrowheight = 0;
\t\$tablefooterrowheight = 0;
\t\$footery = 0;

\t// mPD 3.0 Set the Page & Column where table starts
\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\$tablestartpage = 'EVEN';
\t}
\telse if ((\$this->mirrorMargins) && ((\$this->page)%2==1)) {\t// ODD
\t\t\$tablestartpage = 'ODD';
\t}
\telse { \$tablestartpage = ''; }
\tif (\$this->ColActive) { \$tablestartcolumn = \$this->CurrCol; }
\telse { \$tablestartcolumn = ''; }

\tif (\$this->cacheTables) { \$fh = fopen(\$table['cache'], \"r+b\"); }
\telse { \$fh = null; }

\t\$y = \$h = 0;
\tfor( \$i = 0; \$i < \$numrows ; \$i++ ) { //Rows
\t  if (\$this->progressBar) { \$this->UpdateProgressBar(7,intval(30 + (\$i*40/\$numrows)),' '); }\t// *PROGRESS-BAR*
\t  if (isset(\$table['is_tfoot'][\$i]) && \$table['is_tfoot'][\$i] && \$level==1) {
\t\t\$tablefooterrowheight += \$table['hr'][\$i];
\t\t\$tablefooter[\$i][0]['trbackground-images'] = \$table['trbackground-images'][\$i];
\t\t\$tablefooter[\$i][0]['trgradients'] = \$table['trgradients'][\$i];
\t\t\$tablefooter[\$i][0]['trbgcolor'] = \$table['bgcolor'][\$i];
\t  \tfor( \$j = \$startcol ; \$j < \$numcols ; \$j++ ) { //Columns
\t\t\tif (isset(\$cells[\$i][\$j]) && \$cells[\$i][\$j]) {
\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t\t}
\t\t\t\telse
\t\t\t\t\t\$cell = &\$cells[\$i][\$j];
\t\t\t\tif (\$split) {
\t\t\t\t\tif (\$table['colPg'][\$j] != \$splitpg) { continue; }
\t\t\t\t\tlist(\$x,\$w) = \$this->_splitTableGetWidth(\$table, \$i, \$j, \$fh);
\t\t\t\t\t\$js = \$j - \$startcol;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\tlist(\$x,\$w) = \$this->_tableGetWidth(\$table, \$i, \$j, \$fh);
\t\t\t\t\t\$js = \$j;
\t\t\t\t}

\t\t\t\tlist(\$y,\$h) = \$this->_tableGetHeight(\$table, \$i, \$j, \$fh);
\t\t\t\t\$x += \$x0;
\t\t\t\t\$y += \$y0;
\t\t\t\t//Get info of tfoot ==>> table footer
\t\t\t\t\$tablefooter[\$i][\$js]['x'] = \$x;
\t\t\t\t\$tablefooter[\$i][\$js]['y'] = \$y;
\t\t\t\t\$tablefooter[\$i][\$js]['h'] = \$h;
\t\t\t\t\$tablefooter[\$i][\$js]['w'] = \$w;
\t\t\t\tif (isset(\$cell['textbuffer'])) { \$tablefooter[\$i][\$js]['textbuffer'] = \$cell['textbuffer']; }
\t\t\t\telse { \$tablefooter[\$i][\$js]['textbuffer'] = ''; }
\t\t\t\t\$tablefooter[\$i][\$js]['a'] = \$cell['a'];
\t\t\t\t\$tablefooter[\$i][\$js]['R'] = \$cell['R'];
\t\t\t\t\$tablefooter[\$i][\$js]['va'] = \$cell['va'];
\t\t\t\t\$tablefooter[\$i][\$js]['mih'] = \$cell['mih'];
\t\t\t\t\$tablefooter[\$i][\$js]['gradient'] = \$cell['gradient'];\t// *BACKGROUNDS*
\t\t\t\t\$tablefooter[\$i][\$js]['background-image'] = \$cell['background-image'];\t// *BACKGROUNDS*
\t\t\t\t//CELL FILL BGCOLOR
\t\t\t\tif (!\$this->simpleTables){
\t\t\t \t\tif (\$this->packTableData) {
\t\t\t\t\t\t\$c = \$this->_unpackCellBorder(\$cell['borderbin']);
\t\t\t\t\t\t\$tablefooter[\$i][\$js]['border'] = \$c['border'];
\t\t\t\t\t\t\$tablefooter[\$i][\$js]['border_details'] = \$c['border_details'];
\t\t\t\t\t}
\t\t\t \t\telse {
\t\t\t\t\t\t\$tablefooter[\$i][\$js]['border'] = \$cell['border'];
\t\t\t\t\t\t\$tablefooter[\$i][\$js]['border_details'] = \$cell['border_details'];
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse if (\$this->simpleTables){
\t\t\t\t\t\$tablefooter[\$i][\$js]['border'] = \$table['simple']['border'];
\t\t\t\t\t\$tablefooter[\$i][\$js]['border_details'] = \$table['simple']['border_details'];
\t\t\t\t}
\t\t\t\t\$tablefooter[\$i][\$js]['bgcolor'] = \$cell['bgcolor'];
\t\t\t\t\$tablefooter[\$i][\$js]['padding'] = \$cell['padding'];
\t\t\t\t\$tablefooter[\$i][\$js]['rowspan'] = \$cell['rowspan'];
\t\t\t\t\$tablefooter[\$i][\$js]['colspan'] = \$cell['colspan'];
\t\t\t}
\t\t}
\t  }
\t}

\tif (\$level==1) { \$this->_out('___TABLE___BACKGROUNDS'.\$this->uniqstr); }
\t\$tableheaderadj = 0;
\t\$tablefooteradj = 0;

\t\$tablestartpageno = \$this->page;

\t//Draw Table Contents and Borders
\tfor( \$i = 0; \$i < \$numrows ; \$i++ ) { //Rows
\t  if (\$split && \$startrow > 0) {
\t\t\$thnr = (isset(\$table['is_thead']) ? count(\$table['is_thead']) : 0);
\t\tif (\$i >= \$thnr && \$i < \$startrow) { continue; }
\t\tif (\$i == \$startrow){ \$returny = \$rety - \$tableheaderrowheight; }
\t  }

\t  // Get Maximum row/cell height in row - including rowspan>1 + 1 overlapping
\t  \$maxrowheight = \$this->_tableGetMaxRowHeight(\$table, \$i, \$fh);

\t  \$skippage = false;
\t  \$newpagestarted = false;
\t  for( \$j = \$startcol ; \$j < \$numcols ; \$j++ ) { //Columns
\t\tif (\$split) {
\t\t\tif (\$table['colPg'][\$j] > \$splitpg) { break; }
\t\t\t\$lastCol = \$j;
\t\t}
\t\tif (isset(\$cells[\$i][\$j]) && \$cells[\$i][\$j]) {
\t\t\tif (\$this->cacheTables) {
\t\t\t\t\$cell = \$this->_uncacheCell(\$table['cells'][\$i][\$j], '', \$fh);
\t\t\t}
\t\t\telse
\t\t\t\t\$cell = &\$cells[\$i][\$j];
\t\t\tif (\$split) {
\t\t\t\t\$lastCol = \$j + (isset(\$cell['colspan']) ? (\$cell['colspan']-1) : 0) ;
\t\t\t\tlist(\$x,\$w) = \$this->_splitTableGetWidth(\$table, \$i, \$j, \$fh);
\t\t\t}
\t\t\telse { list(\$x,\$w) = \$this->_tableGetWidth(\$table, \$i, \$j, \$fh); }

\t\t\tlist(\$y,\$h) = \$this->_tableGetHeight(\$table, \$i, \$j, \$fh);
\t\t\t\$x += \$x0;
\t\t\t\$y += \$y0;
\t\t\t\$y -= \$returny;

\t\t\tif (\$table['borders_separate']) {
\t\t\t  if (!empty(\$tablefooter) || \$i == (\$numrows-1) || (isset(\$cell['rowspan']) && (\$i+\$cell['rowspan']) == \$numrows)  || (!isset(\$cell['rowspan']) && (\$i+1) == \$numrows) ) {
\t\t\t\t\$extra = \$table['padding']['B'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V']/2;
\t\t\t\t//\$extra = \$table['margin']['B'] + \$table['padding']['B'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V']/2;
\t\t\t  }
\t\t\t  else {
\t\t\t\t\$extra = \$table['border_spacing_V']/2;
\t\t\t  }
\t\t\t}
\t  \t\telse { \$extra = \$table['max_cell_border_width']['B']/2; }

\t\t\tif (\$j==\$startcol  && (((\$y + \$maxrowheight + \$extra ) > (\$pagetrigger+0.001)) || ((\$this->keepColumns || !\$this->ColActive) && !empty(\$tablefooter) && (\$y + \$maxrowheight + \$tablefooterrowheight + \$extra) > \$pagetrigger) && (\$this->tableLevel==1 && \$i < (\$numrows - \$table['headernrows']))) && (\$y0 >0 || \$x0 > 0) && !\$this->InFooter && \$this->autoPageBreak ) {

\t\t\t\tif (!\$skippage) {
\t\t\t\t\t\$finalSpread = true;
\t\t\t\t\t\$firstSpread = true;
\t\t\t\t\tif (\$split) {
\t\t\t\t\t\tfor(\$t=\$startcol; \$t<\$numcols; \$t++) {
\t\t\t\t\t\t\t// Are there more columns to print on a next page?
\t\t\t\t\t\t\tif (\$table['colPg'][\$t] > \$splitpg) {
\t\t\t\t\t\t\t\t\$finalSpread = false;
\t\t\t\t\t\t\t\tbreak;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t}
\t\t\t\t\t\tif (\$startcol>0) { \$firstSpread = false; }
\t\t\t\t\t}

\t\t      \t\tif ((\$this->keepColumns || !\$this->ColActive) && !empty(\$tablefooter) && \$i > 0 ) {
\t\t\t\t\t\t\$this->y = \$y;
\t\t\t\t\t\t\$ya = \$this->y;
\t\t\t\t\t\t\$this->TableHeaderFooter(\$tablefooter,\$tablestartpage,\$tablestartcolumn,'F',\$level, \$firstSpread, \$finalSpread);
\t\t\t\t\t\tif (\$this->table_rotate) {
\t\t\t\t\t\t\t\$this->tbrot_h += \$this->y - \$ya ;
\t\t\t\t\t\t}
\t\t\t\t\t\t\$tablefooteradj = \$this->y - \$ya ;
\t\t\t\t\t}
\t\t\t\t\t\$y -= \$y0;
\t\t\t\t\t\$returny += \$y;

\t\t\t\t\t\$oldcolumn = \$this->CurrCol;
\t\t\t\t\tif (\$this->AcceptPageBreak()) {
\t  \t\t\t\t\t\$newpagestarted = true;
\t\t\t\t\t\t\$this->y = \$y + \$y0;

\t\t\t\t\t\t// Move down to account for border-spacing or
\t\t\t\t\t\t// extra half border width in case page breaks in middle
\t\t\t\t\t\tif(\$i>0 && !\$this->table_rotate && \$level==1 && !\$this->ColActive) {
\t\t\t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\t\t\t\$adv = \$table['border_spacing_V']/2;
\t\t\t\t\t\t\t\t// If table footer
\t\t\t\t\t\t\t\tif ((\$this->keepColumns || !\$this->ColActive) && !empty(\$tablefooter) && \$i > 0 ) {
\t\t\t\t\t\t\t\t\t\$adv += (\$table['padding']['B'] + \$table['border_details']['B']['w']);
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\$maxbwtop = 0;
\t\t\t\t\t\t\t\t\$maxbwbottom = 0;
\t\t\t\t\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t\t\t\t\t\tif (!empty(\$tablefooter)) { \$maxbwbottom = \$table['max_cell_border_width']['B']; }
\t\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t   \$brow = \$i-1;
\t\t\t\t\t\t\t\t\t   for( \$ctj = 0 ; \$ctj < \$numcols ; \$ctj++ ) {
\t\t\t\t\t\t\t\t\t\tif (isset(\$cells[\$brow][\$ctj]) && \$cells[\$brow][\$ctj]) {
\t\t\t\t\t\t\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\t\t\t\t\t\t\$cadj = \$this->_uncacheCell(\$table['cells'][\$brow][\$ctj], '', \$fh);
\t\t\t \t   \t\t\t\t\t\t\t\tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$cadj['borderbin']);
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\telse if (\$this->packTableData) {
\t\t\t \t   \t\t\t\t\t\t\t\tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$cells[\$brow][\$ctj]['borderbin']);
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t\t\t\t\$bb = \$cells[\$brow][\$ctj]['border_details']['B']['w'];
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\t\$maxbwbottom = max(\$maxbwbottom , \$bb);
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t   }
\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\tif (!empty(\$tableheader)) { \$maxbwtop = \$table['max_cell_border_width']['T']; }
\t\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t   \$trow = \$i-1;
\t\t\t\t\t\t\t\t\t   for( \$ctj = 0 ; \$ctj < \$numcols ; \$ctj++ ) {
\t\t\t\t\t\t\t\t\t\tif (isset(\$cells[\$trow][\$ctj]) && \$cells[\$trow][\$ctj]) {
\t\t\t\t\t\t\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\t\t\t\t\t\t\$cadj = \$this->_uncacheCell(\$table['cells'][\$trow][\$ctj], '', \$fh);
\t\t\t \t   \t\t\t\t\t\t\t\tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$cadj['borderbin']);
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\telse if (\$this->packTableData) {
\t\t\t \t   \t\t\t\t\t\t\t\tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$cells[\$trow][\$ctj]['borderbin']);
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t\t\t\t\$bt = \$cells[\$trow][\$ctj]['border_details']['T']['w'];
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\t\$maxbwtop = max(\$maxbwtop , \$bt);
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t   }
\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\telse if (\$this->simpleTables){
\t\t\t\t\t\t\t\t\t\$maxbwtop = \$table['simple']['border_details']['T']['w'];
\t\t\t\t\t\t\t\t\t\$maxbwbottom = \$table['simple']['border_details']['B']['w'];
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\$adv = \$maxbwbottom /2;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\$this->y += \$adv;
\t\t\t\t\t\t}

\t\t\t\t\t\t// Rotated table split over pages - needs this->y for borders/backgrounds
\t\t\t\t\t\tif(\$i>0 && \$this->table_rotate && \$level==1) {
\t\t\t\t//\t\t\t\$this->y = \$y0 + \$this->tbrot_w;
\t\t\t\t\t\t}

\t\t\t\t\t\tif (\$this->tableClipPath ) { \$this->_out(\"Q\"); }

\t\t\t\t\t\t\$bx = \$x0;
\t\t\t\t\t\t\$by = \$y0;

\t\t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\t\t\$bx -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['border_spacing_H']/2);
\t\t\t\t\t\t\tif (\$tablestartpageno != \$this->page) {\t// IF already broken across a previous pagebreak
\t\t\t\t\t\t\t\t\$by += \$table['max_cell_border_width']['T']/2;
\t\t\t\t\t\t\t\tif (empty(\$tableheader)) { \$by -= (\$table['border_spacing_V']/2); }
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\$by -= (\$table['padding']['T'] + \$table['border_details']['T']['w'] + \$table['border_spacing_V']/2);
\t\t\t\t\t\t\t}
\t\t\t\t\t\t}

\t\t\t\t\t\telse if (\$tablestartpageno != \$this->page && !empty(\$tableheader)) { \$by += \$maxbwtop /2; }

\t\t\t\t\t\t\$by -= \$tableheaderadj;
\t\t\t\t\t\t\$bh = \$this->y - \$by + \$tablefooteradj;
  \t\t\t\t\t\tif (!\$table['borders_separate']) { \$bh -= \$adv ; }
\t\t\t\t\t\tif (\$split) {
\t\t\t\t\t\t\t\$bw = 0;
\t\t\t\t\t\t\tfor(\$t=\$startcol; \$t<\$numcols; \$t++) {
\t\t\t\t\t\t\t\tif (\$table['colPg'][\$t] == \$splitpg) { \$bw += \$table['wc'][\$t]; }
\t\t\t\t\t\t\t\tif (\$table['colPg'][\$t] > \$splitpg) { break; }
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\t\t\tif (\$firstSpread) {
\t\t\t\t\t\t\t\t\t\$bw += \$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['border_spacing_H'];
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t\$bx += (\$table['padding']['L'] + \$table['border_details']['L']['w']);
\t\t\t\t\t\t\t\t\t\$bw += \$table['border_spacing_H'];
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\tif (\$finalSpread) {
\t\t\t\t\t\t\t\t\t\$bw += \$table['padding']['R'] + \$table['border_details']['R']['w']/2 + \$table['border_spacing_H'];
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t}
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$bw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t\t\t\t\t\t}

\t\t\t\t\t\t// mPDF 5.4.16
\t\t      \t\t\tif (\$this->splitTableBorderWidth && (\$this->keepColumns || !\$this->ColActive) && empty(\$tablefooter) && \$i > 0 && \$table['border_details']['B']['w']) {
\t\t\t\t\t\t\t\$prevDrawColor = \$this->DrawColor;
\t\t\t\t\t\t\t\$lw = \$this->LineWidth;
\t\t\t\t\t\t\t\$this->SetLineWidth(\$this->splitTableBorderWidth);
\t\t\t\t\t\t\t\$this->SetDColor(\$table['border_details']['B']['c']);
\t\t\t\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\t\t\t\$this->SetLineCap(0);
 \t\t\t\t\t\t\t\$blx = \$bx;
\t\t\t\t\t\t\t\$blw = \$bw;
 \t\t\t\t\t\t\tif (!\$table['borders_separate']) {
\t\t\t\t\t\t\t\t\$blx -= (\$table['max_cell_border_width']['L']/2);
\t\t\t\t\t\t\t\t\$blw += (\$table['max_cell_border_width']['L']/2 + \$table['max_cell_border_width']['R']/2);
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\$this->Line(\$blx,\$this->y+(\$this->splitTableBorderWidth/2),\$blx+\$blw,\$this->y+(\$this->splitTableBorderWidth/2));
\t\t\t\t\t\t\t\$this->DrawColor = \$prevDrawColor;
\t\t\t\t\t\t\t\$this->_out(\$this->DrawColor);
\t\t\t\t\t\t\t\$this->SetLineWidth(\$lw);
\t\t\t\t\t\t\t\$this->SetLineJoin(2);
\t\t\t\t\t\t\t\$this->SetLineCap(2);
\t\t\t\t\t\t}

\t\t\t\t\t\tif (!\$this->ColActive && (\$i > 0 || \$j > 0)) {
\t\t\t\t\t\t\tif (isset(\$table['bgcolor'][-1])) {
\t\t\t\t\t  \t\t\t\$color = \$this->ConvertColor(\$table['bgcolor'][-1]);
\t\t\t\t\t  \t\t\tif (\$color) {
\t\t\t\t\t\t\t\t   if (!\$table['borders_separate']) { \$bh -= \$table['max_cell_border_width']['B']/2; }
\t\t\t\t\t\t\t\t   \$this->tableBackgrounds[\$level*9][] = array('gradient'=>false, 'x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'col'=>\$color);
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t}

/*-- BACKGROUNDS --*/
\t\t\t\t\t\t\tif (isset(\$table['gradient'])) {
\t\t\t\t\t\t\t\t\$g = \$this->grad->parseBackgroundGradient(\$table['gradient']);
\t\t\t\t\t\t\t\tif (\$g) {
\t\t\t\t\t\t\t\t   \$this->tableBackgrounds[\$level*9+1][] = array('gradient'=>true, 'x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t}

\t\t\t\t\t\t\tif (isset(\$table['background-image'])) {
\t\t\t\t\t\t\t   if (\$table['background-image']['gradient'] && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$table['background-image']['gradient'] )) {
\t\t\t\t\t\t\t\t\$g = \$this->grad->parseMozGradient( \$table['background-image']['gradient'] );
\t\t\t\t\t\t\t\tif (\$g) {
\t\t\t\t\t\t\t\t   \$this->tableBackgrounds[\$level*9+1][] = array('gradient'=>true, 'x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t   }
\t\t\t\t\t\t\t   else {
\t\t\t\t\t\t\t\t\$image_id = \$table['background-image']['image_id'];
\t\t\t\t\t\t\t\t\$orig_w = \$table['background-image']['orig_w'];
\t\t\t\t\t\t\t\t\$orig_h = \$table['background-image']['orig_h'];
\t\t\t\t\t\t\t\t\$x_pos = \$table['background-image']['x_pos'];
\t\t\t\t\t\t\t\t\$y_pos = \$table['background-image']['y_pos'];
\t\t\t\t\t\t\t\t\$x_repeat = \$table['background-image']['x_repeat'];
\t\t\t\t\t\t\t\t\$y_repeat = \$table['background-image']['y_repeat'];
\t\t\t\t\t\t\t\t\$resize = \$table['background-image']['resize'];
\t\t\t\t\t\t\t\t\$opacity = \$table['background-image']['opacity'];
\t\t\t\t\t\t\t\t\$itype = \$table['background-image']['itype'];
\t\t\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+2][] = array('x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>'', 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype);
\t\t\t\t\t\t\t   }
\t\t\t\t\t\t\t}
/*-- END BACKGROUNDS --*/
\t\t\t\t\t\t}

\t\t\t\t\t\t// \$this->AcceptPageBreak() has moved tablebuffer to \$this->pages content
\t\t\t\t\t\tif (\$this->tableBackgrounds) {
\t\t\t\t\t\t   \$s = \$this->PrintTableBackgrounds();
\t   \t\t\t\t\t   if (\$this->bufferoutput) {
\t\t\t\t\t\t\t\$this->headerbuffer = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->headerbuffer);
\t\t\t\t\t\t\t\$this->headerbuffer = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', \" \", \$this->headerbuffer );
\t\t\t\t\t\t   }
\t\t\t\t\t\t   else {
\t\t\t\t\t\t\t\$this->pages[\$this->page] = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\t\t\t\t\t\t\$this->pages[\$this->page] = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', \" \", \$this->pages[\$this->page]);
\t\t\t\t\t\t   }
\t\t\t\t\t\t   \$this->tableBackgrounds = array();
\t\t\t\t\t\t}

\t\t\t\t\t\tif (\$split) {
\t\t\t\t\t\t\tif (\$i == 0 && \$j == 0) { \$y0 = -1; }
\t\t\t\t\t\t\telse if (\$finalSpread) {
\t\t\t\t\t\t\t\t\$splitpg = 0;
\t\t\t\t\t\t\t\t\$startcol = 0;
\t\t\t\t\t\t\t\t\$startrow = \$i;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\$splitpg++;
\t\t\t\t\t\t\t\t\$startcol = \$t;
\t\t\t\t\t\t\t\t\$returny -= \$y;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\treturn array(false, \$startrow, \$startcol, \$splitpg, \$returny, \$y0);
\t\t\t\t\t\t}

\t\t\t\t\t\t\$this->AddPage(\$this->CurOrientation);

\t\t\t\t\t\t\$this->_out('___TABLE___BACKGROUNDS'.\$this->uniqstr);


\t\t\t\t\t\tif (\$this->tableClipPath ) { \$this->_out(\$this->tableClipPath); }

\t\t\t\t\t\t// Added to correct for OddEven Margins
\t\t\t\t\t\t\$x= \$x + \$this->MarginCorrection;
\t\t\t\t\t\t\$x0= \$x0 + \$this->MarginCorrection;

\t\t\t\t\t\t// mPDF 5.4.16
\t\t      \t\t\tif (\$this->splitTableBorderWidth && (\$this->keepColumns || !\$this->ColActive) && empty(\$tableheader) && \$i > 0 && \$table['border_details']['T']['w'] ) {
\t\t\t\t\t\t\t\$prevDrawColor = \$this->DrawColor;
\t\t\t\t\t\t\t\$lw = \$this->LineWidth;
\t\t\t\t\t\t\t\$this->SetLineWidth(\$this->splitTableBorderWidth);
\t\t\t\t\t\t\t\$this->SetDColor(\$table['border_details']['T']['c']);
\t\t\t\t\t\t\t\$this->SetLineJoin(0);
\t\t\t\t\t\t\t\$this->SetLineCap(0);
\t\t\t\t\t\t\t\$blx += \$this->MarginCorrection;
\t\t\t\t\t\t\t\$this->Line(\$blx,\$this->y-(\$this->splitTableBorderWidth/2),\$blx+\$blw,\$this->y-(\$this->splitTableBorderWidth/2));
\t\t\t\t\t\t\t\$this->DrawColor = \$prevDrawColor;
\t\t\t\t\t\t\t\$this->_out(\$this->DrawColor);
\t\t\t\t\t\t\t\$this->SetLineWidth(\$lw);
\t\t\t\t\t\t\t\$this->SetLineJoin(2);
\t\t\t\t\t\t\t\$this->SetLineCap(2);
\t\t\t\t\t\t}

\t\t\t\t\t\t// Move down to account for half of top border-spacing or
\t\t\t\t\t\t// extra half border width in case page was broken in middle
\t\t\t\t\t\tif(\$i>0 && !\$this->table_rotate && \$level==1 && \$table['headernrows']==0) {
\t\t\t\t\t\t\tif (\$table['borders_separate']) { \$adv = \$table['border_spacing_V']/2; }
\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\$maxbwtop = 0;
\t\t\t\t\t\t\t\tfor( \$ctj = 0 ; \$ctj < \$numcols ; \$ctj++ ) {
\t\t\t\t\t\t\t\t\tif (isset(\$cells[\$i][\$ctj]) && \$cells[\$i][\$ctj]) {
\t\t\t\t\t\t\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t\t\t\t\t\t\t\tif (\$this->cacheTables) {
\t\t\t\t\t\t\t\t\t\t\t\t\$celltj = \$this->_uncacheCell(\$table['cells'][\$i][\$ctj], '', \$fh);
\t\t\t \t   \t\t\t\t\t\t\t\tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$celltj['borderbin']);
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t \t\t\t\t\t\t\t\telse if (\$this->packTableData) {
\t\t\t \t   \t\t\t\t\t\t\t\tlist(\$bt,\$br,\$bb,\$bl) = \$this->_getBorderWidths(\$cells[\$i][\$ctj]['borderbin']);
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t\t\t\t\$bt = \$cells[\$i][\$ctj]['border_details']['T']['w'];
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\t\$maxbwtop = max(\$maxbwtop, \$bt);
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\telse if (\$this->simpleTables){
\t\t\t\t\t\t\t\t\t\t\t\$maxbwtop = max(\$maxbwtop, \$table['simple']['border_details']['T']['w']);
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\$adv = \$maxbwtop /2;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\$this->y += \$adv;
\t\t\t\t\t\t}


\t\t\t\t\t\tif (\$this->table_rotate) {
\t\t\t\t\t\t\t\$this->tbrot_x0 = \$this->lMargin  + \$this->blk[\$this->blklvl]['outer_left_margin'] + \$this->blk[\$this->blklvl]['padding_left'] + \$this->blk[\$this->blklvl]['border_left']['w'];
\t\t\t\t\t\t\tif (\$table['borders_separate']) { \$this->tbrot_h = \$table['margin']['T'] + \$table['padding']['T'] + \$table['border_details']['T']['w'] + \$table['border_spacing_V']/2; }
\t\t\t\t\t\t\telse { \$this->tbrot_h = \$table['margin']['T'] + \$table['max_cell_border_width']['T'] ; }
\t\t\t\t\t\t\t\$this->tbrot_y0 = \$this->y;
\t\t\t\t\t\t\t\$pagetrigger = \$y0 - \$tableheaderadj + (\$this->blk[\$this->blklvl]['inner_width']);
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$pagetrigger = \$this->PageBreakTrigger;
\t\t\t\t\t\t}

\t\t\t\t\t\tif (\$this->kwt_saved && \$level==1) {
\t\t\t\t\t\t\t\$this->kwt_moved = true;
\t\t\t\t\t\t}


\t\t\t\t\t\t// Disable Table header repeat if Keep Block together
             \t\t\t\tif (!\$this->keep_block_together && !empty(\$tableheader)) {
\t\t\t\t\t\t\t\$ya = \$this->y;
\t\t\t\t\t\t\t\$this->TableHeaderFooter(\$tableheader,\$tablestartpage,\$tablestartcolumn,'H',\$level);
\t\t\t\t\t\t\tif (\$this->table_rotate) {
\t\t\t\t\t\t\t\t\$this->tbrot_h = \$this->y - \$ya ;
\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\$tableheaderadj = \$this->y - \$ya ;
\t\t\t\t\t\t}

\t\t\t\t\t\telse if (\$i==0 && !\$this->keep_block_together && !\$this->table_rotate && \$level==1 && !\$this->ColActive) {
\t\t\t\t\t\t\t// Advance down page
\t\t\t\t\t\t\tif (\$table['borders_separate']) { \$adv = \$table['border_spacing_V']/2 + \$table['border_details']['T']['w'] + \$table['padding']['T'];  }
\t\t\t\t\t\t\telse { \$adv = \$table['max_cell_border_width']['T'] /2 ; }
\t\t\t\t\t\t\tif (\$adv) {
\t\t\t\t\t\t\t   if (\$this->table_rotate) {
\t\t\t\t\t\t\t\t\$this->y += (\$adv);
\t\t\t\t\t\t\t   }
\t\t\t\t\t\t\t   else {
\t\t\t\t\t\t\t\t\$this->DivLn(\$adv,\$this->blklvl,true);
\t\t\t\t\t\t\t   }
\t\t\t\t\t\t\t}
\t\t\t\t\t\t}

\t\t\t\t\t\t\$outerfilled = 0;
\t\t\t\t\t\t\$y = \$y0 = \$this->y;
\t\t\t\t\t}

/*-- COLUMNS --*/
\t\t\t\t\t// COLS
\t\t\t\t\t// COLUMN CHANGE
\t\t\t\t\tif (\$this->CurrCol != \$oldcolumn) {
\t\t\t\t\t\t// Added to correct for Columns
\t\t\t\t\t\t\$x += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t\t\t\t\t\$x0 += \$this->ChangeColumn * (\$this->ColWidth+\$this->ColGap);
\t\t\t\t\t\tif (\$this->CurrCol == 0) { \t// just added a page - possibly with tableheader
\t\t\t\t\t\t\t\$y0 = \$this->y; \t// this->y0 is global used by Columns - \$y0 is internal to tablewrite
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$y0 = \$this->y0; \t// this->y0 is global used by Columns - \$y0 is internal to tablewrite
\t\t\t\t\t\t}
\t\t\t\t\t\t\$y = \$y0;
\t\t\t\t\t\t\$outerfilled = 0;
\t\t      \t\t\tif (\$this->CurrCol != 0 && (\$this->keepColumns && \$this->ColActive) && !empty(\$tableheader) && \$i > 0 ) {
\t\t\t\t\t\t\t\$this->x = \$x;
\t\t\t\t\t\t\t\$this->y = \$y;
\t\t\t\t\t\t\t\$this->TableHeaderFooter(\$tableheader,\$tablestartpage,\$tablestartcolumn,'H',\$level);
\t\t\t\t\t\t\t\$y0 = \$y=\$this->y;
\t\t\t\t\t\t}
\t\t\t\t\t}
/*-- END COLUMNS --*/
\t\t\t\t}
\t\t\t\t\$skippage = true;
\t\t\t}

\t\t\t\$this->x = \$x;
\t\t\t\$this->y = \$y;

\t\t\tif (\$this->kwt_saved && \$level==1) {
\t\t\t\t\$this->printkwtbuffer();
\t\t\t\t\$x0 = \$x = \$this->x;
\t\t\t\t\$y0 = \$y = \$this->y;
\t\t\t\t\$this->kwt_moved = false;
\t\t\t\t\$this->kwt_saved = false;
\t\t\t}


\t\t\t// Set the Page & Column where table actually starts
\t\t\tif (\$i==0 && \$j==0 && \$level==1) {
\t\t\t\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t\t\t\t// EVEN
\t\t\t\t\t\$tablestartpage = 'EVEN';
\t\t\t\t}
\t\t\t\telse if ((\$this->mirrorMargins) && ((\$this->page)%2==1)) {\t\t\t\t// ODD
\t\t\t\t\t\$tablestartpage = 'ODD';
\t\t\t\t}
\t\t\t\telse { \$tablestartpage = ''; }
\t\t\t\t\$tablestartpageno = \$this->page;
\t\t\t\tif (\$this->ColActive) { \$tablestartcolumn = \$this->CurrCol; }\t// *COLUMNS*
\t\t\t}


\t\t\t//ALIGN
\t\t\t\$align = \$cell['a'];


/*-- COLUMNS --*/
\t\t\t// If outside columns, this is done in PaintDivBB
\t\t\tif (\$this->ColActive) {
\t\t\t //OUTER FILL BGCOLOR of DIVS
\t\t\t if (\$this->blklvl > 0 && (\$j==0) && !\$this->table_rotate && \$level==1) {
\t\t\t  \$firstblockfill = \$this->GetFirstBlockFill();
\t\t\t  if (\$firstblockfill && \$this->blklvl >= \$firstblockfill) {
\t\t\t   \$divh = \$maxrowheight;
\t\t\t   // Last row
\t  \t\t   if ((!isset(\$cell['rowspan']) && \$i == \$numrows-1) || (isset(\$cell['rowspan']) && ((\$i == \$numrows-1 && \$cell['rowspan']<2) || (\$cell['rowspan']>1 && (\$i + \$cell['rowspan']-1) == \$numrows-1)))) { \t// mPDF 5.6.54
\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\$adv = \$table['margin']['B'] + \$table['padding']['B'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V']/2;
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$adv = \$table['margin']['B'] + \$table['max_cell_border_width']['B']/2;
\t\t\t\t}
\t\t\t\t\$divh += \$adv;  //last row: fill bottom half of bottom border (y advanced at end)
\t\t\t   }

\t\t\t   if ((\$this->y + \$divh) > \$outerfilled ) {\t// if not already painted by previous rowspan
\t\t\t\t\$bak_x = \$this->x;
\t\t\t\t\$bak_y = \$this->y;
\t\t\t\tif (\$outerfilled > \$this->y) {
\t\t\t\t\t\$divh = (\$this->y + \$divh) - \$outerfilled;
\t\t\t\t\t\$this->y = \$outerfilled;
\t\t\t\t}

\t\t\t\t\$this->DivLn(\$divh,-3,false);
\t\t\t\t\$outerfilled = \$this->y + \$divh;
\t\t\t\t// Reset current block fill
\t\t\t\t\$bcor = \$this->blk[\$this->blklvl]['bgcolorarray'];
\t\t\t\tif (\$bcor ) \$this->SetFColor(\$bcor);
\t\t\t\t\$this->x = \$bak_x;
\t\t\t\t\$this->y = \$bak_y;
\t\t\t    }
\t\t\t  }
\t\t\t }
\t\t\t}


\t\t\t//TABLE BACKGROUND FILL BGCOLOR - for cellSpacing
\t\t\tif (\$this->ColActive) {
\t\t\t if (\$table['borders_separate']) {
\t\t\t   \$fill = isset(\$table['bgcolor'][-1]) ? \$table['bgcolor'][-1] : 0;
\t\t\t   if (\$fill) {
  \t\t\t\t\$color = \$this->ConvertColor(\$fill);
  \t\t\t\tif (\$color) {
\t\t\t\t\t\$xadj = (\$table['border_spacing_H']/2);
\t\t\t\t\t\$yadj = (\$table['border_spacing_V']/2);
\t\t\t\t\t\$wadj = \$table['border_spacing_H'];
\t\t\t\t\t\$hadj = \$table['border_spacing_V'];
 \t\t\t   \t\tif (\$i == 0) {\t\t// Top
\t\t\t\t\t\t\$yadj += \$table['padding']['T'] + \$table['border_details']['T']['w'] ;
\t\t\t\t\t\t\$hadj += \$table['padding']['T'] + \$table['border_details']['T']['w'] ;
\t\t\t   \t\t}
\t\t\t   \t\tif (\$j == 0) {\t\t// Left
\t\t\t\t\t\t\$xadj += \$table['padding']['L'] + \$table['border_details']['L']['w'] ;
\t\t\t\t\t\t\$wadj += \$table['padding']['L'] + \$table['border_details']['L']['w'] ;
\t\t\t   \t\t}
\t\t\t   \t\tif (\$i == (\$numrows-1) || (isset(\$cell['rowspan']) && (\$i+\$cell['rowspan']) == \$numrows)  || (!isset(\$cell['rowspan']) && (\$i+1) == \$numrows)) {\t// Bottom
\t\t\t\t\t\t\$hadj += \$table['padding']['B'] + \$table['border_details']['B']['w'] ;
\t\t\t   \t\t}
\t\t\t   \t\tif (\$j == (\$numcols-1) || (isset(\$cell['colspan']) && (\$j+\$cell['colspan']) == \$numcols)  || (!isset(\$cell['colspan']) && (\$j+1) == \$numcols)) {\t// Right
\t\t\t\t\t\t\$wadj += \$table['padding']['R'] + \$table['border_details']['R']['w'] ;
\t\t\t   \t\t}
\t\t\t\t\t\$this->SetFColor(\$color);
\t\t\t\t\t\$this->Rect(\$x - \$xadj, \$y - \$yadj, \$w + \$wadj, \$h + \$hadj, 'F');
\t\t\t\t}
\t\t\t   }
\t\t\t }
\t\t\t}
/*-- END COLUMNS --*/

\t\t\tif (\$table['empty_cells']!='hide' || !empty(\$cell['textbuffer']) || (isset(\$cell['nestedcontent']) && \$cell['nestedcontent']) || !\$table['borders_separate']  ) { \$paintcell = true; }
\t\t\telse { \$paintcell = false; }

\t\t\t//Set Borders
\t\t\t\$bord = 0;
\t\t\t\$bord_det = array();

\t\t\tif (!\$this->simpleTables){
\t\t\t \tif (\$this->packTableData) {
\t  \t\t\t   if (\$cell['borderbin']) {
\t\t\t\t\t\$c = \$this->_unpackCellBorder(\$cell['borderbin']);
\t\t\t\t\t\$bord = \$c['border'];
\t\t\t\t\t\$bord_det = \$c['border_details'];
\t\t\t\t   }
\t\t\t\t}
\t\t\t\telse if (\$cell['border']) {
\t\t\t\t\t\$bord = \$cell['border'];
\t\t\t\t\t\$bord_det = \$cell['border_details'];
\t\t\t\t}
\t\t\t}
\t\t\telse if (\$this->simpleTables){
\t  \t\t\tif (\$table['simple']['border']) {
\t\t\t\t\t\$bord = \$table['simple']['border'];
\t\t\t\t\t\$bord_det = \$table['simple']['border_details'];
\t\t\t\t}
\t\t\t}

\t\t\t//TABLE ROW OR CELL FILL BGCOLOR
\t\t\t\$fill = 0;
\t\t\tif (isset(\$cell['bgcolor']) && \$cell['bgcolor'] && \$cell['bgcolor']!='transparent') {
\t\t\t\t\$fill = \$cell['bgcolor'];
\t\t\t\t\$leveladj = 6;
\t\t\t}
\t\t\telse if (isset(\$table['bgcolor'][\$i]) && \$table['bgcolor'][\$i] && \$table['bgcolor'][\$i]!='transparent') { // Row color
\t\t\t\t\$fill = \$table['bgcolor'][\$i];
\t\t\t\t\$leveladj = 3;
\t\t\t}
\t\t\tif (\$fill && \$paintcell) {
  \t\t\t\t\$color = \$this->ConvertColor(\$fill);
  \t\t\t\tif (\$color) {
 \t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t   if (\$this->ColActive) {
\t\t\t\t\t\t\$this->SetFColor(\$color);
\t\t\t\t\t\t\$this->Rect(\$x+ (\$table['border_spacing_H']/2), \$y+ (\$table['border_spacing_V']/2), \$w- \$table['border_spacing_H'], \$h- \$table['border_spacing_V'], 'F');
\t\t\t\t\t   }
\t\t\t\t\t   else {
\t\t   \t\t\t\t\$this->tableBackgrounds[\$level*9+\$leveladj][] = array('gradient'=>false, 'x'=>(\$x + (\$table['border_spacing_H']/2)), 'y'=>(\$y + (\$table['border_spacing_V']/2)), 'w'=>(\$w - \$table['border_spacing_H']), 'h'=>(\$h - \$table['border_spacing_V']), 'col'=>\$color);
\t\t\t\t\t   }
\t\t\t\t\t}
 \t\t\t\t\telse {
\t\t\t\t\t   if (\$this->ColActive) {
\t\t\t\t\t\t\$this->SetFColor(\$color);
\t \t\t\t\t\t\$this->Rect(\$x, \$y, \$w, \$h, 'F');
\t\t\t\t\t   }
\t\t\t\t\t   else {
\t\t   \t\t\t\t\$this->tableBackgrounds[\$level*9+\$leveladj][] = array('gradient'=>false, 'x'=>\$x, 'y'=>\$y, 'w'=>\$w, 'h'=>\$h, 'col'=>\$color);
\t\t\t\t\t   }
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}

/*-- BACKGROUNDS --*/
\t\t\tif (isset(\$cell['gradient']) && \$cell['gradient'] && \$paintcell){
\t\t\t\t\$g = \$this->grad->parseBackgroundGradient(\$cell['gradient']);
\t\t\t\tif (\$g) {
 \t\t\t\t  if (\$table['borders_separate']) {
 \t\t\t\t\t\$px = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\$py = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\$pw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\$ph = \$h- \$table['border_spacing_V'];
\t\t\t\t  }
\t\t\t\t  else {
\t\t\t\t\t\$px = \$x;
\t\t\t\t\t\$py = \$y;
\t\t\t\t\t\$pw = \$w;
\t\t\t\t\t\$ph = \$h;
\t\t\t\t  }
\t\t\t\t  if (\$this->ColActive) {
\t\t\t\t\t\$this->grad->Gradient(\$px, \$py, \$pw, \$ph, \$g['type'], \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend']);
\t\t\t\t  }
\t\t\t\t  else {
\t\t   \t\t\t\$this->tableBackgrounds[\$level*9+7][] = array('gradient'=>true, 'x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t  }
\t\t\t\t}
\t\t\t}

\t\t\tif (isset(\$cell['background-image']) && \$paintcell) {
\t\t\t  if (\$cell['background-image']['gradient'] && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$cell['background-image']['gradient'] )) {
\t\t\t\t\$g = \$this->grad->parseMozGradient( \$cell['background-image']['gradient'] );
\t\t\t\tif (\$g) {
 \t\t\t\t  if (\$table['borders_separate']) {
 \t\t\t\t\t\$px = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\$py = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\$pw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\$ph = \$h- \$table['border_spacing_V'];
\t\t\t\t  }
\t\t\t\t  else {
\t\t\t\t\t\$px = \$x;
\t\t\t\t\t\$py = \$y;
\t\t\t\t\t\$pw = \$w;
\t\t\t\t\t\$ph = \$h;
\t\t\t\t  }
\t\t\t\t  if (\$this->ColActive) {
\t\t\t\t\t\$this->grad->Gradient(\$px, \$py, \$pw, \$ph, \$g['type'], \$g['stops'], \$g['colorspace'], \$g['coords'], \$g['extend']);
\t\t\t\t  }
\t\t\t\t  else {
\t\t  \t\t\t\$this->tableBackgrounds[\$level*9+7][] = array('gradient'=>true, 'x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t  }
\t\t\t\t}
\t\t\t  }
\t\t\t  else if (\$cell['background-image']['image_id']) {\t// Background pattern
\t\t\t\t\$n = count(\$this->patterns)+1;
 \t\t\t\tif (\$table['borders_separate']) {
 \t\t\t\t\t\$px = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\$py = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\$pw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\$ph = \$h- \$table['border_spacing_V'];
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$px = \$x;
\t\t\t\t\t\$py = \$y;
\t\t\t\t\t\$pw = \$w;
\t\t\t\t\t\$ph = \$h;
\t\t\t\t}
\t\t\t\tif (\$this->ColActive) {
\t\t\t\t\tlist(\$orig_w, \$orig_h, \$x_repeat, \$y_repeat) = \$this->_resizeBackgroundImage(\$cell['background-image']['orig_w'], \$cell['background-image']['orig_h'], \$pw, \$ph, \$cell['background-image']['resize'], \$cell['background-image']['x_repeat'], \$cell['background-image']['y_repeat']);
\t\t\t\t\t\$this->patterns[\$n] = array('x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'pgh'=>\$this->h, 'image_id'=>\$cell['background-image']['image_id'], 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$cell['background-image']['x_pos'] , 'y_pos'=>\$cell['background-image']['y_pos'] , 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat);
\t\t\t\t\tif (\$cell['background-image']['opacity']>0 && \$cell['background-image']['opacity']<1) { \$opac = \$this->SetAlpha(\$cell['background-image']['opacity'],'Normal',true); }
\t\t\t\t\telse { \$opac = ''; }
\t\t\t\t\t\$this->_out(sprintf('q /Pattern cs /P%d scn %s %.3F %.3F %.3F %.3F re f Q', \$n, \$opac, \$px*_MPDFK, (\$this->h-\$py)*_MPDFK, \$pw*_MPDFK, -\$ph*_MPDFK));
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$image_id = \$cell['background-image']['image_id'];
\t\t\t\t\t\$orig_w = \$cell['background-image']['orig_w'];
\t\t\t\t\t\$orig_h = \$cell['background-image']['orig_h'];
\t\t\t\t\t\$x_pos = \$cell['background-image']['x_pos'];
\t\t\t\t\t\$y_pos = \$cell['background-image']['y_pos'];
\t\t\t\t\t\$x_repeat = \$cell['background-image']['x_repeat'];
\t\t\t\t\t\$y_repeat = \$cell['background-image']['y_repeat'];
\t\t\t\t\t\$resize = \$cell['background-image']['resize'];
\t\t\t\t\t\$opacity = \$cell['background-image']['opacity'];
\t\t\t\t\t\$itype = \$cell['background-image']['itype'];
\t\t\t\t\t\$this->tableBackgrounds[\$level*9+8][] = array('x'=>\$px, 'y'=>\$py, 'w'=>\$pw, 'h'=>\$ph, 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>'', 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype);
\t\t\t\t}
\t\t\t  }
\t\t\t}
/*-- END BACKGROUNDS --*/

\t\t\t if (isset(\$cell['colspan']) && \$cell['colspan']>1) { \$ccolsp = \$cell['colspan']; }
\t\t\t else { \$ccolsp = 1; }
\t\t\t if (isset(\$cell['rowspan']) && \$cell['rowspan']>1) { \$crowsp = \$cell['rowspan']; }
\t\t\t else { \$crowsp = 1; }


\t\t\t// but still need to do this for repeated headers...
\t\t\tif (!\$table['borders_separate'] && \$this->tabletheadjustfinished && !\$this->simpleTables){
\t\t\t  if (isset(\$table['topntail']) && \$table['topntail']) {
\t\t\t\t\t\$bord_det['T'] = \$this->border_details(\$table['topntail']);
\t\t\t\t\t\$bord_det['T']['w'] /= \$this->shrin_k;
\t\t\t\t\t\$this->setBorder(\$bord, _BORDER_TOP);
\t\t\t  }
\t\t\t  if (isset(\$table['thead-underline']) && \$table['thead-underline']) {
\t\t\t\t\t\$bord_det['T'] = \$this->border_details(\$table['thead-underline']);
\t\t\t\t\t\$bord_det['T']['w'] /= \$this->shrin_k;
\t\t\t\t\t\$this->setBorder(\$bord, _BORDER_TOP);
\t\t\t  }
\t\t\t}


\t\t\t//Get info of first row ==>> table header
\t\t\t//Use > 1 row if THEAD
\t\t\tif (isset(\$table['is_thead'][\$i]) && \$table['is_thead'][\$i] && \$level==1) {
\t\t\t\tif (\$j==0) \$tableheaderrowheight += \$table['hr'][\$i];
\t\t\t\t\$tableheader[\$i][0]['trbackground-images'] = (isset(\$table['trbackground-images'][\$i]) ? \$table['trbackground-images'][\$i] : null);
\t\t\t\t\$tableheader[\$i][0]['trgradients'] = (isset(\$table['trgradients'][\$i]) ? \$table['trgradients'][\$i] : null);
\t\t\t\t\$tableheader[\$i][0]['trbgcolor'] = (isset(\$table['bgcolor'][\$i]) ? \$table['bgcolor'][\$i] : null);
\t\t\t\t\$tableheader[\$i][\$j]['x'] = \$x;
\t\t\t\t\$tableheader[\$i][\$j]['y'] = \$y;
\t\t\t\t\$tableheader[\$i][\$j]['h'] = \$h;
\t\t\t\t\$tableheader[\$i][\$j]['w'] = \$w;
\t\t\t\tif (isset(\$cell['textbuffer'])) { \$tableheader[\$i][\$j]['textbuffer'] = \$cell['textbuffer']; }
\t\t\t\telse { \$tableheader[\$i][\$j]['textbuffer'] = ''; }
\t\t\t\t\$tableheader[\$i][\$j]['a'] = \$cell['a'];
\t\t\t\t\$tableheader[\$i][\$j]['R'] = \$cell['R'];

\t\t\t\t\$tableheader[\$i][\$j]['va'] = \$cell['va'];
\t\t\t\t\$tableheader[\$i][\$j]['mih'] = \$cell['mih'];
\t\t\t\t\$tableheader[\$i][\$j]['gradient'] = (isset(\$cell['gradient']) ? \$cell['gradient'] : null);\t// *BACKGROUNDS*
\t\t\t\t\$tableheader[\$i][\$j]['background-image'] = (isset(\$cell['background-image']) ? \$cell['background-image'] : null);\t// *BACKGROUNDS*
\t\t\t\t\$tableheader[\$i][\$j]['rowspan'] = (isset(\$cell['rowspan']) ? \$cell['rowspan'] : null);
\t\t\t\t\$tableheader[\$i][\$j]['colspan'] = (isset(\$cell['colspan']) ? \$cell['colspan'] : null);
\t\t\t\t\$tableheader[\$i][\$j]['bgcolor'] = \$cell['bgcolor'];

\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t\t\$tableheader[\$i][\$j]['border'] = \$bord;
\t\t\t\t\t\$tableheader[\$i][\$j]['border_details'] = \$bord_det;
\t\t\t\t}
\t\t\t\telse if (\$this->simpleTables){
\t\t\t\t\t\$tableheader[\$i][\$j]['border'] = \$table['simple']['border'];
\t\t\t\t\t\$tableheader[\$i][\$j]['border_details'] = \$table['simple']['border_details'];
\t\t\t\t}
\t\t\t\t\$tableheader[\$i][\$j]['padding'] = \$cell['padding'];
\t\t\t}

\t\t\t// CELL BORDER
\t\t\tif (\$bord || \$bord_det) {
 \t\t\t\tif (\$table['borders_separate'] && \$paintcell) {
 \t\t\t\t\t\$this->_tableRect(\$x + (\$table['border_spacing_H']/2)+(\$bord_det['L']['w'] /2), \$y+ (\$table['border_spacing_V']/2)+(\$bord_det['T']['w'] /2), \$w-\$table['border_spacing_H']-(\$bord_det['L']['w'] /2)-(\$bord_det['R']['w'] /2), \$h- \$table['border_spacing_V']-(\$bord_det['T']['w'] /2)-(\$bord_det['B']['w']/2), \$bord, \$bord_det, false, \$table['borders_separate']);
\t\t\t\t}
 \t\t\t\telse if (!\$table['borders_separate']) {
\t\t\t\t\t\$this->_tableRect(\$x, \$y, \$w, \$h, \$bord, \$bord_det, true, \$table['borders_separate']); \t// true causes buffer
\t\t\t\t}

\t\t\t}

\t\t\t//VERTICAL ALIGN
\t\t\tif (\$cell['R'] && INTVAL(\$cell['R']) > 0 && INTVAL(\$cell['R']) < 90 && isset(\$cell['va']) && \$cell['va']!='B') { \$cell['va']='B';}
\t\t\tif (!isset(\$cell['va']) || \$cell['va']=='M') \$this->y += (\$h-\$cell['mih'])/2;
\t\t\telseif (isset(\$cell['va']) && \$cell['va']=='B') \$this->y += \$h-\$cell['mih'];

\t\t\t// NESTED CONTENT

\t\t\t// TEXT (and nested tables)
\t\t\t\$this->divalign=\$align;

\t\t\t\$this->divwidth=\$w;
\t\t\tif (!empty(\$cell['textbuffer'])) {
\t\t\t\tif (\$level==1) {
\t\t\t\t\tif (isset(\$table['is_tfoot'][\$i]) && \$table['is_tfoot'][\$i]) {
\t\t\t\t\t\tif (preg_match('/{colsum([0-9]*)[_]*}/', \$cell['textbuffer'][0][0], \$m)) {
\t\t\t\t\t\t\t\$rep = sprintf(\"%01.\".intval(\$m[1]).\"f\", \$this->colsums[\$j]);
\t\t\t\t\t\t\t\$cell['textbuffer'][0][0] = preg_replace('/{colsum[0-9_]*}/', \$rep ,\$cell['textbuffer'][0][0]);
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\telse if (!isset(\$table['is_thead'][\$i])) { \$this->colsums[\$j] += floatval(preg_replace('/^[^0-9\\.\\,]*/','',\$cell['textbuffer'][0][0])); }\t// mPDF 5.6.66
\t\t\t\t}
\t\t\t\t\$opy = \$this->y;
\t\t\t\t// mPDF ITERATION
\t\t\t\tif (\$this->iterationCounter) {
\t\t\t\t   foreach(\$cell['textbuffer'] AS \$k=>\$t) {
\t\t\t\t\tif (preg_match('/{iteration ([a-zA-Z0-9_]+)}/',\$t[0], \$m)) {
\t\t\t\t\t\t\$vname = '__'.\$m[1].'_';
\t\t\t\t\t\tif (!isset(\$this->\$vname)) { \$this->\$vname = 1; }
\t\t\t\t\t\telse { \$this->\$vname++; }
\t\t\t\t\t\t\$cell['textbuffer'][\$k][0] = preg_replace('/{iteration '.\$m[1].'}/', \$this->\$vname, \$cell['textbuffer'][\$k][0]);
\t\t\t\t\t}
\t\t\t\t   }
\t\t\t\t}


\t\t\t\tif (\$cell['R']) {
\t\t\t\t\t\$cellPtSize = \$cell['textbuffer'][0][11] / \$this->shrin_k;
\t\t\t\t\tif (!\$cellPtSize) { \$cellPtSize = \$this->default_font_size; }
\t\t\t\t\t\$cellFontHeight = (\$cellPtSize/_MPDFK);
\t\t\t\t\t\$opx = \$this->x;
\t\t\t\t\t\$angle = INTVAL(\$cell['R']);
\t\t\t\t\t// Only allow 45 to 89 degrees (when bottom-aligned) or exactly 90 or -90
\t\t\t\t\tif (\$angle > 90) { \$angle = 90; }
\t\t\t\t\telse if (\$angle > 0 && \$angle <45) { \$angle = 45; }
\t\t\t\t\telse if (\$angle < 0) { \$angle = -90; }
\t\t\t\t\t\$offset = ((sin(deg2rad(\$angle))) * 0.37 * \$cellFontHeight);
\t\t\t\t\tif (isset(\$cell['a']) && \$cell['a']=='R') {
\t\t\t\t\t\t\$this->x += (\$w) + (\$offset) - (\$cellFontHeight/3) - (\$cell['padding']['R'] + (\$table['border_spacing_H']/2));
\t\t\t\t\t}
\t\t\t\t\telse if (!isset(\$cell['a']) || \$cell['a']=='C') {
\t\t\t\t\t\t\$this->x += (\$w/2) + (\$offset);
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$this->x += (\$offset) + (\$cellFontHeight/3)+(\$cell['padding']['L'] +(\$table['border_spacing_H']/2));
\t\t\t\t\t}
\t\t\t\t\t\$str = '';
\t\t\t\t\tforeach(\$cell['textbuffer'] AS \$t) { \$str .= \$t[0].' '; }
\t\t\t\t\t\$str = trim(\$str);
\t\t\t\t\tif (!isset(\$cell['va']) || \$cell['va']=='M') {
\t\t\t\t\t\t\$this->y -= (\$h-\$cell['mih'])/2; //Undo what was added earlier VERTICAL ALIGN
\t\t\t\t\t\tif (\$angle > 0) { \$this->y += ((\$h-\$cell['mih'])/2) + \$cell['padding']['T'] + (\$cell['mih']-(\$cell['padding']['T'] + \$cell['padding']['B'])); }
\t\t\t\t\t\telse if (\$angle < 0) { \$this->y += ((\$h-\$cell['mih'])/2)+ (\$cell['padding']['T'] + (\$table['border_spacing_V']/2)); }
\t\t\t\t\t}
\t\t\t\t\telseif (isset(\$cell['va']) && \$cell['va']=='B') {
\t\t\t\t\t\t\$this->y -= \$h-\$cell['mih']; //Undo what was added earlier VERTICAL ALIGN
\t\t\t\t\t\tif (\$angle > 0) { \$this->y += \$h-(\$cell['padding']['B'] + (\$table['border_spacing_V']/2)); }
\t\t\t\t\t\telse if (\$angle < 0) { \$this->y += \$h-\$cell['mih'] + (\$cell['padding']['T'] + (\$table['border_spacing_V']/2)); }
\t\t\t\t\t}
\t\t\t\t\telseif (isset(\$cell['va']) && \$cell['va']=='T') {
\t\t\t\t\t\tif (\$angle > 0) { \$this->y += \$cell['mih']-(\$cell['padding']['B'] + (\$table['border_spacing_V']/2)); }
\t\t\t\t\t\telse if (\$angle < 0) { \$this->y += (\$cell['padding']['T'] + (\$table['border_spacing_V']/2)); }
\t\t\t\t\t}
\t\t\t\t\t\$this->Rotate(\$angle,\$this->x,\$this->y);
\t\t\t\t\t\$s_fs = \$this->FontSizePt;
\t\t\t\t\t\$s_f = \$this->FontFamily;
\t\t\t\t\t\$s_st = \$this->FontStyle;
\t\t\t\t\tif (!empty(\$cell['textbuffer'][0][3])) { //Font Color
\t\t\t\t\t\t\$cor = \$cell['textbuffer'][0][3];
\t\t\t\t\t\t\$this->SetTColor(\$cor);
\t\t\t\t\t}
\t\t\t\t\t\$s_str = \$this->strike;
\t\t\t\t\t\$this->strike = \$cell['textbuffer'][0][8]; //Strikethrough
\t\t\t\t\t\$this->SetFont(\$cell['textbuffer'][0][4],\$cell['textbuffer'][0][2],\$cellPtSize,true,true);
\t\t\t\t\t\$this->Text(\$this->x,\$this->y,\$str);
\t\t\t\t\t\$this->Rotate(0);
\t\t\t\t\t\$this->SetFont(\$s_f,\$s_st,\$s_fs,true,true);
\t\t\t\t\t\$this->SetTColor(0);
\t\t\t\t\t\$this->strike = \$s_str;
\t\t\t\t\t\$this->x = \$opx;
\t\t\t\t}
\t\t\t\telse {

\t\t\t\t\tif (!\$this->simpleTables){
\t\t\t\t\t   if (\$bord_det) {
\t\t\t\t\t\t\$btlw = \$bord_det['L']['w'];
\t\t\t\t\t\t\$btrw = \$bord_det['R']['w'];
\t\t\t\t\t\t\$bttw = \$bord_det['T']['w'];
\t\t\t\t\t   }
\t\t\t\t\t   else {
\t\t\t\t\t\t\$btlw = 0;
\t\t\t\t\t\t\$btrw = 0;
\t\t\t\t\t\t\$bttw = 0;
\t\t\t\t\t   }
\t\t\t\t\t   if (\$table['borders_separate']) {
\t\t\t\t\t\t\$xadj = \$btlw + \$cell['padding']['L'] +(\$table['border_spacing_H']/2);
\t\t\t\t\t\t\$wadj = \$btlw + \$btrw + \$cell['padding']['L'] +\$cell['padding']['R'] + \$table['border_spacing_H'];
\t\t\t\t\t\t\$yadj = \$bttw + \$cell['padding']['T'] + (\$table['border_spacing_H']/2);
\t\t\t\t\t   }
\t\t\t\t\t   else {
\t\t\t\t\t\t\$xadj = \$btlw/2 + \$cell['padding']['L'];
\t\t\t\t\t\t\$wadj = (\$btlw + \$btrw)/2 + \$cell['padding']['L'] + \$cell['padding']['R'];
\t\t\t\t\t\t\$yadj = \$bttw/2 + \$cell['padding']['T'];
\t\t\t\t\t   }
\t\t\t\t\t}
\t\t\t\t\telse if (\$this->simpleTables){
\t\t\t\t\t   if (\$table['borders_separate']) {\t// NB twice border width
\t\t\t\t\t\t\$xadj = \$table['simple']['border_details']['L']['w'] + \$cell['padding']['L'] +(\$table['border_spacing_H']/2);
\t\t\t\t\t\t\$wadj = \$table['simple']['border_details']['L']['w'] + \$table['simple']['border_details']['R']['w'] + \$cell['padding']['L'] +\$cell['padding']['R'] + \$table['border_spacing_H'];
\t\t\t\t\t\t\$yadj = \$table['simple']['border_details']['T']['w'] + \$cell['padding']['T'] + (\$table['border_spacing_H']/2);
\t\t\t\t\t   }
\t\t\t\t\t   else {
\t\t\t\t\t\t\$xadj = \$table['simple']['border_details']['L']['w']/2 + \$cell['padding']['L'];
\t\t\t\t\t\t\$wadj = (\$table['simple']['border_details']['L']['w'] + \$table['simple']['border_details']['R']['w'])/2 + \$cell['padding']['L'] + \$cell['padding']['R'];
\t\t\t\t\t\t\$yadj = \$table['simple']['border_details']['T']['w']/2 + \$cell['padding']['T'];
\t\t\t\t\t   }
\t\t\t\t\t}
\t\t\t\t\t// mPDF 5.6.13
\t\t\t\t\t\$this->decimal_offset = 0;
\t\t\t\t\tif(substr(\$cell['a'],0,1) == 'D') {
\t\t\t\t\t\tif (\$cell['colspan'] > 1) { \$this->divalign = \$c['a'] = substr(\$cell['a'],2,1); }
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$smax = \$table['decimal_align'][\$j]['maxs0'];
\t\t\t\t\t\t\t\$d_content = \$table['decimal_align'][\$j]['maxs0'] + \$table['decimal_align'][\$j]['maxs1'];
\t\t\t\t\t\t\t\$this->decimal_offset = \$smax;
\t\t\t\t\t\t\t\$extra = (\$w - \$d_content - \$wadj);
\t\t\t\t\t\t\tif (\$extra > 0) {
\t\t\t\t\t\t\t\tif(substr(\$cell['a'],2,1) == 'R') { \$this->decimal_offset += \$extra; }
\t\t\t\t\t\t\t\telse if(substr(\$cell['a'],2,1) == 'C') { \$this->decimal_offset += (\$extra)/2; }
\t\t\t\t\t\t\t}
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\t\$this->divwidth=\$w-\$wadj;
\t\t\t\t\tif (\$this->divwidth == 0) { \$this->divwidth = 0.0001; }
\t\t\t\t\t\$this->x += \$xadj;
\t\t\t\t\t\$this->y += \$yadj;
\t\t\t\t\t\$this->printbuffer(\$cell['textbuffer'],'',true);
\t\t\t\t}
\t\t\t\t\$this->y = \$opy;
\t\t\t}

/*-- BACKGROUNDS --*/
\t\t\tif (!\$this->ColActive) {
\t  \t\t  if (isset(\$table['trgradients'][\$i]) && (\$j==0 || \$table['borders_separate'])) {
\t\t\t\t\$g = \$this->grad->parseBackgroundGradient(\$table['trgradients'][\$i]);
\t\t\t\tif (\$g) {
\t\t\t\t\t\$gx = \$x0;
\t\t\t\t\t\$gy = \$y;
\t\t\t\t\t\$gh = \$h;
\t\t\t\t\t\$gw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\t\$gw -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['padding']['R'] + \$table['border_details']['R']['w'] + \$table['border_spacing_H']);
\t\t\t\t\t\t\$s = '';
 \t\t\t\t\t\t\$clx = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\t\$cly = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\t\$clw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\t\$clh = \$h- \$table['border_spacing_V'];
\t\t\t\t\t\t// Set clipping path
\t\t\t\t\t\t\$s = ' q 0 w ';\t// Line width=0
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F m ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// start point TL before the arc
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BL
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TL
\t\t\t\t\t\t\$s .= ' W n ';\t// Ends path no-op & Sets the clipping path
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx + (\$table['border_spacing_H']/2), 'y'=>\$gy + (\$table['border_spacing_V']/2), 'w'=>\$gw - \$table['border_spacing_V'], 'h'=>\$gh - \$table['border_spacing_H'], 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>\$s);
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx, 'y'=>\$gy, 'w'=>\$gw, 'h'=>\$gh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t\t}
\t\t\t\t}
\t\t\t    }
\t\t\t    if (isset(\$table['trbackground-images'][\$i]) && (\$j==0 || \$table['borders_separate'])) {
\t\t\t    if (\$table['trbackground-images'][\$i]['gradient'] && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$table['trbackground-images'][\$i]['gradient'] )) {
\t\t\t\t\$g = \$this->grad->parseMozGradient( \$table['trbackground-images'][\$i]['gradient'] );
\t\t\t\tif (\$g) {
\t\t\t\t\t\$gx = \$x0;
\t\t\t\t\t\$gy = \$y;
\t\t\t\t\t\$gh = \$h;
\t\t\t\t\t\$gw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\t\$gw -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['padding']['R'] + \$table['border_details']['R']['w'] + \$table['border_spacing_H']);
\t\t\t\t\t\t\$s = '';
 \t\t\t\t\t\t\$clx = \$x+ (\$table['border_spacing_H']/2);
\t\t\t\t\t\t\$cly = \$y+ (\$table['border_spacing_V']/2);
\t\t\t\t\t\t\$clw = \$w- \$table['border_spacing_H'];
\t\t\t\t\t\t\$clh = \$h- \$table['border_spacing_V'];
\t\t\t\t\t\t// Set clipping path
\t\t\t\t\t\t\$s = ' q 0 w ';\t// Line width=0
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F m ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// start point TL before the arc
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BL
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TR
\t\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TL
\t\t\t\t\t\t\$s .= ' W n ';\t// Ends path no-op & Sets the clipping path
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx + (\$table['border_spacing_H']/2), 'y'=>\$gy + (\$table['border_spacing_V']/2), 'w'=>\$gw - \$table['border_spacing_V'], 'h'=>\$gh - \$table['border_spacing_H'], 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>\$s);
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$this->tableBackgrounds[\$level*9+4][] = array('gradient'=>true, 'x'=>\$gx, 'y'=>\$gy, 'w'=>\$gw, 'h'=>\$gh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t\t\t}
\t\t\t\t}
\t\t\t    }
\t\t\t    else {
\t\t\t\t\$image_id = \$table['trbackground-images'][\$i]['image_id'];
\t\t\t\t\$orig_w = \$table['trbackground-images'][\$i]['orig_w'];
\t\t\t\t\$orig_h = \$table['trbackground-images'][\$i]['orig_h'];
\t\t\t\t\$x_pos = \$table['trbackground-images'][\$i]['x_pos'];
\t\t\t\t\$y_pos = \$table['trbackground-images'][\$i]['y_pos'];
\t\t\t\t\$x_repeat = \$table['trbackground-images'][\$i]['x_repeat'];
\t\t\t\t\$y_repeat = \$table['trbackground-images'][\$i]['y_repeat'];
\t\t\t\t\$resize = \$table['trbackground-images'][\$i]['resize'];
\t\t\t\t\$opacity = \$table['trbackground-images'][\$i]['opacity'];
\t\t\t\t\$itype = \$table['trbackground-images'][\$i]['itype'];
\t\t\t\t\$clippath = '';
\t\t\t\t\$gx = \$x0;
\t\t\t\t\$gy = \$y;
\t\t\t\t\$gh = \$h;
\t\t\t\t\$gw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t\t\t\tif (\$table['borders_separate']) {
\t\t\t\t\t\$gw -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['padding']['R'] + \$table['border_details']['R']['w'] + \$table['border_spacing_H']);
\t\t\t\t\t\$s = '';
 \t\t\t\t\t\$clx = \$x + (\$table['border_spacing_H']/2);
\t\t\t\t\t\$cly = \$y + (\$table['border_spacing_V']/2);
\t\t\t\t\t\$clw = \$w - \$table['border_spacing_H'];
\t\t\t\t\t\$clh = \$h - \$table['border_spacing_V'];
\t\t\t\t\t// Set clipping path
\t\t\t\t\t\$s = ' q 0 w ';\t// Line width=0
\t\t\t\t\t\$s .= sprintf('%.3F %.3F m ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// start point TL
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BL
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly+\$clh))*_MPDFK);\t// line to BR
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx+\$clw)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TR
\t\t\t\t\t\$s .= sprintf('%.3F %.3F l ', (\$clx)*_MPDFK, (\$this->h-(\$cly))*_MPDFK);\t// line to TL
\t\t\t\t\t\$s .= ' W n ';\t// Ends path no-op & Sets the clipping path
\t\t\t\t\t\$this->tableBackgrounds[\$level*9+5][] = array('x'=>\$gx + (\$table['border_spacing_H']/2), 'y'=>\$gy + (\$table['border_spacing_V']/2), 'w'=>\$gw - \$table['border_spacing_V'], 'h'=>\$gh - \$table['border_spacing_H'], 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>\$s, 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$this->tableBackgrounds[\$level*9+5][] = array('x'=>\$gx, 'y'=>\$gy, 'w'=>\$gw, 'h'=>\$gh, 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>'', 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype);
\t\t\t\t}
\t\t\t    }
\t\t\t   }
\t\t\t}

/*-- END BACKGROUNDS --*/

\t\t\t// TABLE BORDER - if separate
\t\t\tif ((\$table['borders_separate'] || (\$this->simpleTables && !\$table['simple']['border'])) && \$table['border']) {
\t\t\t   \$halfspaceL = \$table['padding']['L'] + (\$table['border_spacing_H']/2);
\t\t\t   \$halfspaceR = \$table['padding']['R'] + (\$table['border_spacing_H']/2);
\t\t\t   \$halfspaceT = \$table['padding']['T'] + (\$table['border_spacing_V']/2);
\t\t\t   \$halfspaceB = \$table['padding']['B'] + (\$table['border_spacing_V']/2);
\t\t\t   \$tbx = \$x;
\t\t\t   \$tby = \$y;
\t\t\t   \$tbw = \$w;
\t\t\t   \$tbh = \$h;
\t\t\t   \$tab_bord = 0;

\t\t\t   \$corner = '';
 \t\t\t   if (\$i == 0) {\t\t// Top
\t\t\t\t\$tby -= \$halfspaceT + (\$table['border_details']['T']['w']/2);
\t\t\t\t\$tbh += \$halfspaceT + (\$table['border_details']['T']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_TOP);
\t\t\t\t\$corner .= 'T';
\t\t\t   }
\t\t\t   if (\$i == (\$numrows-1) || (isset(\$cell['rowspan']) && (\$i+\$cell['rowspan']) == \$numrows)) {\t// Bottom
\t\t\t\t\$tbh += \$halfspaceB + (\$table['border_details']['B']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_BOTTOM);
\t\t\t\t\$corner .= 'B';
\t\t\t   }
\t\t\t   if (\$j == 0) {\t\t// Left
\t\t\t\t\$tbx -= \$halfspaceL + (\$table['border_details']['L']['w']/2);
\t\t\t\t\$tbw += \$halfspaceL + (\$table['border_details']['L']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_LEFT);
\t\t\t\t\$corner .= 'L';
\t\t\t   }
\t\t\t   if (\$j == (\$numcols-1) || (isset(\$cell['colspan']) && (\$j+\$cell['colspan']) == \$numcols)) {\t// Right
\t\t\t\t\$tbw += \$halfspaceR + (\$table['border_details']['R']['w']/2);
\t\t\t\t\$this->setBorder(\$tab_bord , _BORDER_RIGHT);
\t\t\t\t\$corner .= 'R';
\t\t\t   }
\t\t\t   \$this->_tableRect(\$tbx, \$tby, \$tbw, \$tbh, \$tab_bord , \$table['border_details'], false, \$table['borders_separate'], 'table', \$corner, \$table['border_spacing_V'], \$table['border_spacing_H'] );
\t\t\t}

\t\t\tunset(\$cell );
\t\t\t//Reset values
\t\t\t\$this->Reset();

\t\t}//end of (if isset(cells)...)
\t  }// end of columns

\t  \$newpagestarted = false;
\t  \$this->tabletheadjustfinished = false;

\t  if (\$this->ColActive && \$i < \$numrows-1 && \$level==1) { \$this->breakpoints[\$this->CurrCol][] = \$y + \$h; }\t// *COLUMNS*

/*-- COLUMNS --*/
\t  if (\$this->ColActive) {
\t\tif (count(\$this->cellBorderBuffer)) { \$this->printcellbuffer(); }
\t  }
/*-- END COLUMNS --*/

\t  if (\$i == \$numrows-1) { \$this->y = \$y + \$h; } //last row jump (update this->y position)
\t  if (\$this->table_rotate && \$level==1) {
\t\t\$this->tbrot_h += \$h;
\t  }



\t}// end of rows

\tif (\$this->progressBar) { \$this->UpdateProgressBar(7,70,' '); }\t// *PROGRESS-BAR*

\tif (count(\$this->cellBorderBuffer)) { \$this->printcellbuffer(); }


\tif (\$this->tableClipPath ) { \$this->_out(\"Q\"); }
\t\$this->tableClipPath = '';

\t// Advance down page by half width of bottom border
 \tif (\$table['borders_separate']) { \$this->y += \$table['padding']['B'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V']/2; }
\telse { \$this->y += \$table['max_cell_border_width']['B']/2; }

\tif (\$table['borders_separate'] && \$level==1) { \$this->tbrot_h += \$table['margin']['B'] + \$table['padding']['B'] + \$table['border_details']['B']['w'] + \$table['border_spacing_V']/2; }
\telse if (\$level==1) { \$this->tbrot_h += \$table['margin']['B'] + \$table['max_cell_border_width']['B']/2; }

\t\$bx = \$x0;
\t\$by = \$y0;
\tif (\$table['borders_separate']) {
\t\t\$bx -= (\$table['padding']['L'] + \$table['border_details']['L']['w'] + \$table['border_spacing_H']/2);
\t\tif (\$tablestartpageno != \$this->page) {\t// IF broken across page
\t\t\t\$by += \$table['max_cell_border_width']['T']/2;
\t\t\tif (empty(\$tableheader)) { \$by -= (\$table['border_spacing_V']/2); }
\t\t}
\t\telse if (\$split && \$startrow > 0 && empty(\$tableheader)) {
\t\t\t\$by -= (\$table['border_spacing_V']/2);
\t\t}
\t\telse {
\t\t\t\$by -= (\$table['padding']['T'] + \$table['border_details']['T']['w'] + \$table['border_spacing_V']/2);
\t\t}
\t}
\telse if (\$tablestartpageno != \$this->page && !empty(\$tableheader)) { \$by += \$maxbwtop /2; }
\t\$by -= \$tableheaderadj;
\t\$bh = \$this->y - \$by;
\tif (!\$table['borders_separate']) { \$bh -= \$table['max_cell_border_width']['B']/2; }

\tif (\$split) {
\t\t\$bw = 0;
\t\t\$finalSpread = true;
\t\tfor(\$t=\$startcol; \$t<\$numcols; \$t++) {
\t\t\tif (\$table['colPg'][\$t] == \$splitpg) { \$bw += \$table['wc'][\$t]; }
\t\t\tif (\$table['colPg'][\$t] > \$splitpg) { \$finalSpread = false; break; }
\t\t}
\t\tif (\$startcol==0) { \$firstSpread = true; }
\t\telse { \$firstSpread = false; }
\t\tif (\$table['borders_separate']) {
\t\t\t\$bw += \$table['border_spacing_H'];
\t\t\tif (\$firstSpread) {
\t\t\t\t\$bw += \$table['padding']['L'] + \$table['border_details']['L']['w'];
\t\t\t}
\t\t\telse {
\t\t\t\t\$bx += (\$table['padding']['L'] + \$table['border_details']['L']['w']);
\t\t\t}
\t\t\tif (\$finalSpread) {
\t\t\t\t\$bw += \$table['padding']['R'] + \$table['border_details']['R']['w'];
\t\t\t}
\t\t}
\t}
\telse {
\t\t\$bw = \$table['w'] - (\$table['max_cell_border_width']['L']/2) - (\$table['max_cell_border_width']['R']/2) - \$table['margin']['L'] - \$table['margin']['R'];
\t}

\tif (!\$this->ColActive) {
\t\tif (isset(\$table['bgcolor'][-1])) {
  \t\t\t\$color = \$this->ConvertColor(\$table['bgcolor'][-1]);
  \t\t\tif (\$color) {
\t\t\t   \$this->tableBackgrounds[\$level*9][] = array('gradient'=>false, 'x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'col'=>\$color);
\t\t\t}
\t\t}

/*-- BACKGROUNDS --*/
\t\tif (isset(\$table['gradient'])) {
\t\t\t\$g = \$this->grad->parseBackgroundGradient(\$table['gradient']);
\t\t\tif (\$g) {
\t\t\t   \$this->tableBackgrounds[\$level*9+1][] = array('gradient'=>true, 'x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t}
\t\t}

\t\tif (isset(\$table['background-image'])) {
\t\t   if (\$table['background-image']['gradient'] && preg_match('/(-moz-)*(repeating-)*(linear|radial)-gradient/', \$table['background-image']['gradient'] )) {
\t\t\t\$g = \$this->grad->parseMozGradient( \$table['background-image']['gradient'] );
\t\t\tif (\$g) {
\t\t\t   \$this->tableBackgrounds[\$level*9+1][] = array('gradient'=>true, 'x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'gradtype'=>\$g['type'], 'stops'=>\$g['stops'], 'colorspace'=>\$g['colorspace'], 'coords'=>\$g['coords'], 'extend'=>\$g['extend'], 'clippath'=>'');
\t\t\t}
\t\t   }
\t\t   else {
\t\t\t\$image_id = \$table['background-image']['image_id'];
\t\t\t\$orig_w = \$table['background-image']['orig_w'];
\t\t\t\$orig_h = \$table['background-image']['orig_h'];
\t\t\t\$x_pos = \$table['background-image']['x_pos'];
\t\t\t\$y_pos = \$table['background-image']['y_pos'];
\t\t\t\$x_repeat = \$table['background-image']['x_repeat'];
\t\t\t\$y_repeat = \$table['background-image']['y_repeat'];
\t\t\t\$resize = \$table['background-image']['resize'];
\t\t\t\$opacity = \$table['background-image']['opacity'];
\t\t\t\$itype = \$table['background-image']['itype'];
\t\t\t\$this->tableBackgrounds[\$level*9+2][] = array('x'=>\$bx, 'y'=>\$by, 'w'=>\$bw, 'h'=>\$bh, 'image_id'=>\$image_id, 'orig_w'=>\$orig_w, 'orig_h'=>\$orig_h, 'x_pos'=>\$x_pos, 'y_pos'=>\$y_pos, 'x_repeat'=>\$x_repeat, 'y_repeat'=>\$y_repeat, 'clippath'=>'', 'resize'=>\$resize, 'opacity'=>\$opacity, 'itype'=>\$itype);
\t\t   }
\t\t}
/*-- END BACKGROUNDS --*/
\t}

\tif (\$this->tableBackgrounds && \$level == 1) {
\t   \$s = \$this->PrintTableBackgrounds();
\t   if (\$this->table_rotate && !\$this->processingHeader && !\$this->processingFooter) {
\t\t\$this->tablebuffer = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->tablebuffer);
\t\tif (\$level == 1) { \$this->tablebuffer = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', \" \", \$this->tablebuffer); }
\t   }
\t   else if (\$this->bufferoutput) {
\t\t\$this->headerbuffer = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->headerbuffer);
\t\tif (\$level == 1) { \$this->headerbuffer = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', \" \", \$this->headerbuffer ); }
\t   }
\t   else {
\t\t\$this->pages[\$this->page] = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', '\\\\1'.\"\\n\".\$s.\"\\n\", \$this->pages[\$this->page]);
\t\tif (\$level == 1) { \$this->pages[\$this->page] = preg_replace('/(___TABLE___BACKGROUNDS'.\$this->uniqstr.')/', \" \", \$this->pages[\$this->page]); }
\t   }
\t   \$this->tableBackgrounds = array();
\t}


\t// TABLE BOTTOM MARGIN
\tif (\$table['margin']['B']) {
\t  if (!\$this->table_rotate && \$level==1) {
\t\t\$this->DivLn(\$table['margin']['B'],\$this->blklvl,true); \t// collapsible
\t  }
\t  else {
\t\t\$this->y += (\$table['margin']['B']);
\t  }
\t}

\tif (\$this->ColActive && \$level==1) { \$this->breakpoints[\$this->CurrCol][] = \$this->y; }\t// *COLUMNS*

\tif (\$this->cacheTables) { fclose(\$fh); }

\tif (\$split) {
\t\t// Are there more columns to print on a next page?
\t\tif (\$lastCol < \$numcols-1) {
\t\t\t\$splitpg++;
\t\t\t\$startcol = \$lastCol + 1;
\t\t\treturn array(false, \$startrow, \$startcol, \$splitpg, \$returny, \$y0);
\t\t}
\t\telse {
\t\t\tif (\$this->cacheTables) {
\t\t\t\tunlink(\$table['cache']);
\t\t\t\t@unlink(\$table['cache'].'.bak');
\t\t\t}
\t\t\treturn array(true,0,0,0);
\t\t}
\t}
\tif (\$this->cacheTables) {
\t\tunlink(\$table['cache']);
\t\t@unlink(\$table['cache'].'.bak');
\t}

}//END OF FUNCTION _tableWrite()


/////////////////////////END OF TABLE CODE//////////////////////////////////
/*-- END TABLES --*/

function _putextgstates() {
\tfor (\$i = 1; \$i <= count(\$this->extgstates); \$i++) {
            \$this->_newobj();
            \$this->extgstates[\$i]['n'] = \$this->n;
            \$this->_out('<</Type /ExtGState');
            foreach (\$this->extgstates[\$i]['parms'] as \$k=>\$v)
                \$this->_out('/'.\$k.' '.\$v);
            \$this->_out('>>');
            \$this->_out('endobj');
\t}
}

function _putocg() {
\tif (\$this->hasOC) { \t// mPDF 5.6.01
\t\t\$this->_newobj();
\t\t\$this->n_ocg_print=\$this->n;
\t\t\$this->_out('<</Type /OCG /Name '.\$this->_textstring('Print only'));
\t\t\$this->_out('/Usage <</Print <</PrintState /ON>> /View <</ViewState /OFF>>>>>>');
\t\t\$this->_out('endobj');
\t\t\$this->_newobj();
\t\t\$this->n_ocg_view=\$this->n;
\t\t\$this->_out('<</Type /OCG /Name '.\$this->_textstring('Screen only'));
\t\t\$this->_out('/Usage <</Print <</PrintState /OFF>> /View <</ViewState /ON>>>>>>');
\t\t\$this->_out('endobj');
\t\t\$this->_newobj();
\t\t\$this->n_ocg_hidden=\$this->n;
\t\t\$this->_out('<</Type /OCG /Name '.\$this->_textstring('Hidden'));
\t\t\$this->_out('/Usage <</Print <</PrintState /OFF>> /View <</ViewState /OFF>>>>>>');
\t\t\$this->_out('endobj');
\t}
\t// mPDF 5.6.01  Add Layers
\tif (count(\$this->layers)) {
\t\tksort(\$this->layers);
\t\tforeach(\$this->layers as \$id=>\$layer) {
\t\t\t\$this->_newobj();
\t\t\t\$this->layers[\$id]['n'] = \$this->n;
\t\t\t// mPDF 5.6.28
\t\t\tif (isset(\$this->layerDetails[\$id]['name']) && \$this->layerDetails[\$id]['name']) {
\t\t\t\t\$name = \$this->layerDetails[\$id]['name'];
\t\t\t}
\t\t\telse { \$name = \$layer['name']; }
\t\t\t\$this->_out('<</Type /OCG /Name '.\$this->_UTF16BEtextstring(\$name).'>>');
\t\t\t\$this->_out('endobj');
\t\t}
\t}
}


/*-- IMPORTS --*/

\t// from mPDFI
\tfunction _putimportedobjects() {
\t\tif (is_array(\$this->parsers) && count(\$this->parsers) > 0) {
\t\t\tforeach(\$this->parsers AS \$filename => \$p) {
\t\t\t\t\$this->current_parser =& \$this->parsers[\$filename];
\t\t\t\tif (is_array(\$this->_obj_stack[\$filename])) {
\t\t\t\t\twhile(\$n = key(\$this->_obj_stack[\$filename])) {
\t\t\t\t\t\t\$nObj = \$this->current_parser->pdf_resolve_object(\$this->current_parser->c,\$this->_obj_stack[\$filename][\$n][1]);
\t\t\t\t\t\t\$this->_newobj(\$this->_obj_stack[\$filename][\$n][0]);
\t\t\t\t\t\tif (\$nObj[0] == PDF_TYPE_STREAM) {
\t\t\t\t\t\t\t\$this->pdf_write_value(\$nObj);
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\$this->pdf_write_value(\$nObj[1]);
\t\t\t\t\t\t}
\t\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t\t\t\$this->_obj_stack[\$filename][\$n] = null; // free memory
\t\t\t\t\t\tunset(\$this->_obj_stack[\$filename][\$n]);
\t\t\t\t\t\treset(\$this->_obj_stack[\$filename]);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t}
\t}


\tfunction _putformxobjects() {
\t\t\$filter=(\$this->compress) ? '/Filter /FlateDecode ' : '';
\t\treset(\$this->tpls);
\t\tforeach(\$this->tpls AS \$tplidx => \$tpl) {
\t\t\t\$p=(\$this->compress) ? gzcompress(\$tpl['buffer']) : \$tpl['buffer'];
\t\t\t\$this->_newobj();
\t\t\t\$this->tpls[\$tplidx]['n'] = \$this->n;
\t\t\t\$this->_out('<<'.\$filter.'/Type /XObject');
\t\t\t\$this->_out('/Subtype /Form');
\t\t\t\$this->_out('/FormType 1');
\t\t\t// Left/Bottom/Right/Top
\t\t\t\$this->_out(sprintf('/BBox [%.2F %.2F %.2F %.2F]',
\t\t\t\t\$tpl['box']['x']*_MPDFK,
\t\t\t\t\$tpl['box']['y']*_MPDFK,
\t\t\t\t(\$tpl['box']['x'] + \$tpl['box']['w'])*_MPDFK,
\t\t\t\t(\$tpl['box']['y'] + \$tpl['box']['h'])*_MPDFK  )
\t\t\t);


\t\t\tif (isset(\$tpl['box']))
\t\t\t\t\$this->_out(sprintf('/Matrix [1 0 0 1 %.5F %.5F]',-\$tpl['box']['x']*_MPDFK, -\$tpl['box']['y']*_MPDFK));
\t\t\t\$this->_out('/Resources ');

\t\t\tif (isset(\$tpl['resources'])) {
\t\t\t\t\$this->current_parser =& \$tpl['parser'];
\t\t\t\t\$this->pdf_write_value(\$tpl['resources']);
\t\t\t} else {
\t\t\t\t\$this->_out('<</ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
\t\t\t\t\tif (isset(\$this->_res['tpl'][\$tplidx]['fonts']) && count(\$this->_res['tpl'][\$tplidx]['fonts'])) {
\t\t\t\t\t\t\$this->_out('/Font <<');
\t\t\t\t\t\tforeach(\$this->_res['tpl'][\$tplidx]['fonts'] as \$font)
\t\t\t\t\t\t\t\$this->_out('/F'.\$font['i'].' '.\$font['n'].' 0 R');
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t}
\t\t\t\t\tif(isset(\$this->_res['tpl'][\$tplidx]['images']) && count(\$this->_res['tpl'][\$tplidx]['images']) ||
\t\t\t\t\t   isset(\$this->_res['tpl'][\$tplidx]['tpls']) && count(\$this->_res['tpl'][\$tplidx]['tpls']))
\t\t\t\t\t{
\t\t\t\t\t\t\$this->_out('/XObject <<');
\t\t\t\t\t\tif (isset(\$this->_res['tpl'][\$tplidx]['images']) && count(\$this->_res['tpl'][\$tplidx]['images'])) {
\t\t\t\t\t\t\tforeach(\$this->_res['tpl'][\$tplidx]['images'] as \$image)
\t\t\t\t\t\t\t\t\$this->_out('/I'.\$image['i'].' '.\$image['n'].' 0 R');
\t\t\t\t\t\t}
\t\t\t\t\t\tif (isset(\$this->_res['tpl'][\$tplidx]['tpls']) && count(\$this->_res['tpl'][\$tplidx]['tpls'])) {
\t\t\t\t\t\t\tforeach(\$this->_res['tpl'][\$tplidx]['tpls'] as \$i => \$itpl)
\t\t\t\t\t\t\t\t\$this->_out(\$this->tplprefix.\$i.' '.\$itpl['n'].' 0 R');
\t\t\t\t\t\t}
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t}
\t\t\t\t\t\$this->_out('>>');
\t\t\t}

\t\t\t\$this->_out('/Length '.strlen(\$p).' >>');
\t\t\t\$this->_putstream(\$p);
\t\t\t\$this->_out('endobj');
\t\t}
\t}

/*-- END IMPORTS --*/


function _putpatterns() {
\tfor (\$i = 1; \$i <= count(\$this->patterns); \$i++) {
\t\t\$x = \$this->patterns[\$i]['x'];
\t\t\$y = \$this->patterns[\$i]['y'];
\t\t\$w = \$this->patterns[\$i]['w'];
\t\t\$h = \$this->patterns[\$i]['h'];
\t\t\$pgh = \$this->patterns[\$i]['pgh'];
\t\t\$orig_w = \$this->patterns[\$i]['orig_w'];
\t\t\$orig_h = \$this->patterns[\$i]['orig_h'];
\t\t\$image_id = \$this->patterns[\$i]['image_id'];
\t\t\$itype = \$this->patterns[\$i]['itype'];
\t\t\$bpa = \$this->patterns[\$i]['bpa'];\t// mPDF 5.6.10  background positioning area

\t\tif (\$this->patterns[\$i]['x_repeat']) { \$x_repeat = true; }
\t\telse { \$x_repeat = false; }
\t\tif (\$this->patterns[\$i]['y_repeat']) { \$y_repeat = true; }
\t\telse { \$y_repeat = false; }
\t\t\$x_pos = \$this->patterns[\$i]['x_pos'];
\t\tif (stristr(\$x_pos ,'%') ) {
\t\t\t\$x_pos += 0;
\t\t\t\$x_pos /= 100;
\t\t\tif (isset(\$bpa['w']) && \$bpa['w']) \$x_pos = (\$bpa['w'] * \$x_pos) - (\$orig_w/_MPDFK * \$x_pos);\t// mPDF 5.6.10
\t\t\telse \$x_pos = (\$w * \$x_pos) - (\$orig_w/_MPDFK * \$x_pos);
\t\t}
\t\t\$y_pos = \$this->patterns[\$i]['y_pos'];
\t\tif (stristr(\$y_pos ,'%') ) {
\t\t\t\$y_pos += 0;
\t\t\t\$y_pos /= 100;
\t\t\tif (isset(\$bpa['h']) && \$bpa['h']) \$y_pos = (\$bpa['h'] * \$y_pos) - (\$orig_h/_MPDFK * \$y_pos);\t// mPDF 5.6.10
\t\t\telse \$y_pos = (\$h * \$y_pos) - (\$orig_h/_MPDFK * \$y_pos);
\t\t}
\t\tif (isset(\$bpa['x']) && \$bpa['x']) \$adj_x = (\$x_pos + \$bpa['x']) *_MPDFK;\t// mPDF 5.6.10
\t\telse \$adj_x = (\$x_pos + \$x) *_MPDFK;
\t\tif (isset(\$bpa['y']) && \$bpa['y']) \$adj_y = ((\$pgh - \$y_pos - \$bpa['y'])*_MPDFK) - \$orig_h ;\t// mPDF 5.6.10
\t\telse \$adj_y = ((\$pgh - \$y_pos - \$y)*_MPDFK) - \$orig_h ;
\t\t\$img_obj = false;
\t\tif (\$itype == 'svg' || \$itype == 'wmf') {
\t\t\tforeach(\$this->formobjects AS \$fo) {
\t\t\t\tif (\$fo['i'] == \$image_id) {
\t\t\t\t\t\$img_obj = \$fo['n'];
\t\t\t\t\t\$fo_w = \$fo['w'];
\t\t\t\t\t\$fo_h = -\$fo['h'];
\t\t\t\t\t\$wmf_x = \$fo['x'];
\t\t\t\t\t\$wmf_y = \$fo['y'];
\t\t\t\t\tbreak;
\t\t\t\t}
\t\t\t}
\t\t}
\t\telse {
\t\t\tforeach(\$this->images AS \$img) {
\t\t\t\tif (\$img['i'] == \$image_id) { \$img_obj = \$img['n']; break; }
\t\t\t}
\t\t}
\t\tif (!\$img_obj ) { echo \"Problem: Image object not found for background pattern \".\$img['i']; exit; }

            \$this->_newobj();
            \$this->_out('<</ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
\t\tif (\$itype == 'svg' || \$itype == 'wmf') {
\t\t\t\$this->_out('/XObject <</FO'.\$image_id.' '.\$img_obj.' 0 R >>');
\t\t\t// ******* ADD ANY ExtGStates, Shading AND Fonts needed for the FormObject
\t\t\t// Set in classes/svg array['fo'] = true
\t\t\t// Required that _putshaders comes before _putpatterns in _putresources
\t\t\t// This adds any resources associated with any FormObject to every Formobject - overkill but works!
\t\t\tif (count(\$this->extgstates)) {
\t\t\t\t\$this->_out('/ExtGState <<');
\t\t\t\tforeach(\$this->extgstates as \$k=>\$extgstate)
\t\t\t\t   if (isset(\$extgstate['fo']) && \$extgstate['fo']) {
\t\t\t\t\tif (isset(\$extgstate['trans']))  \$this->_out('/'.\$extgstate['trans'].' '.\$extgstate['n'].' 0 R');
\t\t\t\t\telse \$this->_out('/GS'.\$k.' '.\$extgstate['n'].' 0 R');
\t\t\t\t   }
\t\t\t\t\$this->_out('>>');
\t\t\t}
/*-- BACKGROUNDS --*/
\t\t\tif (isset(\$this->gradients) AND (count(\$this->gradients) > 0)) {
\t\t\t\t\$this->_out('/Shading <<');
\t\t\t\tforeach (\$this->gradients as \$id => \$grad) {
\t\t\t\t   if (isset(\$grad['fo']) && \$grad['fo']) {
\t\t\t\t\t\$this->_out('/Sh'.\$id.' '.\$grad['id'].' 0 R');
\t\t\t\t   }
\t\t\t\t}
\t\t\t\t\$this->_out('>>');
\t\t\t}
/*-- END BACKGROUNDS --*/
\t\t\t\$this->_out('/Font <<');
\t\t\tforeach(\$this->fonts as \$font) {
\t\t\t\tif (!\$font['used'] && \$font['type']=='TTF') { continue; }
\t\t\t\tif (isset(\$font['fo']) && \$font['fo']) {
\t\t\t\t   if (\$font['type']=='TTF' && (\$font['sip'] || \$font['smp'])) {
\t\t\t\t\tforeach(\$font['n'] AS \$k => \$fid) {
\t\t\t\t\t\t\$this->_out('/F'.\$font['subsetfontids'][\$k].' '.\$font['n'][\$k].' 0 R');
\t\t\t\t\t}
\t\t\t\t   }
\t\t\t\t   else {
\t\t\t\t\t\$this->_out('/F'.\$font['i'].' '.\$font['n'].' 0 R');
\t\t\t\t   }
\t\t\t\t}
\t\t\t}
\t\t\t\$this->_out('>>');
\t\t}
\t\telse {
            \t\$this->_out('/XObject <</I'.\$image_id.' '.\$img_obj.' 0 R >>');
\t\t}
            \$this->_out('>>');
            \$this->_out('endobj');

\t\t\$this->_newobj();
\t\t\$this->patterns[\$i]['n'] = \$this->n;
\t\t\$this->_out('<< /Type /Pattern /PatternType 1 /PaintType 1 /TilingType 2');
\t\t\$this->_out('/Resources '. (\$this->n-1) .' 0 R');

\t\t\$this->_out(sprintf('/BBox [0 0 %.3F %.3F]',\$orig_w,\$orig_h));
\t\tif (\$x_repeat) { \$this->_out(sprintf('/XStep %.3F',\$orig_w)); }
\t\telse { \$this->_out(sprintf('/XStep %d',99999)); }
\t\tif (\$y_repeat) { \$this->_out(sprintf('/YStep %.3F',\$orig_h)); }
\t\telse { \$this->_out(sprintf('/YStep %d',99999)); }

\t\tif (\$itype == 'svg' || \$itype == 'wmf') {
\t\t\t\$this->_out(sprintf('/Matrix [1 0 0 -1 %.3F %.3F]', \$adj_x, (\$adj_y+\$orig_h)));
\t\t\t\$s = sprintf(\"q %.3F 0 0 %.3F %.3F %.3F cm /FO%d Do Q\",(\$orig_w/\$fo_w), (-\$orig_h/\$fo_h), -(\$orig_w/\$fo_w)*\$wmf_x, (\$orig_w/\$fo_w)*\$wmf_y, \$image_id);
\t\t}
\t\telse {
\t\t\t\$this->_out(sprintf('/Matrix [1 0 0 1 %.3F %.3F]',\$adj_x,\$adj_y));
\t\t\t\$s = sprintf(\"q %.3F 0 0 %.3F 0 0 cm /I%d Do Q\",\$orig_w,\$orig_h,\$image_id);
\t\t}

            if (\$this->compress) {
\t\t\t\$this->_out('/Filter /FlateDecode');
\t\t\t\$s = gzcompress(\$s);
\t\t}
\t\t\$this->_out('/Length '.strlen(\$s).'>>');
\t\t\$this->_putstream(\$s);
\t\t\$this->_out('endobj');
\t}
}

/*-- BACKGROUNDS --*/
function _putshaders() {
\t\t\t\$maxid = count(\$this->gradients); //index for transparency gradients
\t\t\tforeach (\$this->gradients as \$id => \$grad) {
\t\t\t\tif ((\$grad['type'] == 2 || \$grad['type'] == 3) && empty(\$grad['is_mask'])) {
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<<');
\t\t\t\t\t\$this->_out('/FunctionType 3');
\t\t\t\t\t\$this->_out('/Domain [0 1]');
\t\t\t\t\t\$fn = array();
\t\t\t\t\t\$bd = array();
\t\t\t\t\t\$en = array();
\t\t\t\t\tfor(\$i=0; \$i<(count(\$grad['stops'])-1); \$i++) {
\t\t\t\t\t\t\$fn[] = (\$this->n+1+\$i).' 0 R';
\t\t\t\t\t\t\$en[] = '0 1';
\t\t\t\t\t\tif (\$i>0) { \$bd[] = sprintf('%.3F', \$grad['stops'][\$i]['offset']); }
\t\t\t\t\t}
\t\t\t\t\t\$this->_out('/Functions ['.implode(' ',\$fn).']');
\t\t\t\t\t\$this->_out('/Bounds ['.implode(' ',\$bd).']');
\t\t\t\t\t\$this->_out('/Encode ['.implode(' ',\$en).']');
\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t\t\$f1 = \$this->n;
\t\t\t\t\tfor(\$i=0; \$i<(count(\$grad['stops'])-1); \$i++) {
\t\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\t\$this->_out('<<');
\t\t\t\t\t\t\$this->_out('/FunctionType 2');
\t\t\t\t\t\t\$this->_out('/Domain [0 1]');
\t\t\t\t\t\t\$this->_out('/C0 ['.\$grad['stops'][\$i]['col'].']');
\t\t\t\t\t\t\$this->_out('/C1 ['.\$grad['stops'][\$i+1]['col'].']');
\t\t\t\t\t\t\$this->_out('/N 1');
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\tif (\$grad['type'] == 2 || \$grad['type'] == 3) {
\t\t\t\t  if (isset(\$grad['trans']) && \$grad['trans']) {
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<<');
\t\t\t\t\t\$this->_out('/FunctionType 3');
\t\t\t\t\t\$this->_out('/Domain [0 1]');
\t\t\t\t\t\$fn = array();
\t\t\t\t\t\$bd = array();
\t\t\t\t\t\$en = array();
\t\t\t\t\tfor(\$i=0; \$i<(count(\$grad['stops'])-1); \$i++) {
\t\t\t\t\t\t\$fn[] = (\$this->n+1+\$i).' 0 R';
\t\t\t\t\t\t\$en[] = '0 1';
\t\t\t\t\t\tif (\$i>0) { \$bd[] = sprintf('%.3F', \$grad['stops'][\$i]['offset']); }
\t\t\t\t\t}
\t\t\t\t\t\$this->_out('/Functions ['.implode(' ',\$fn).']');
\t\t\t\t\t\$this->_out('/Bounds ['.implode(' ',\$bd).']');
\t\t\t\t\t\$this->_out('/Encode ['.implode(' ',\$en).']');
\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t\t\$f2 = \$this->n;
\t\t\t\t\tfor(\$i=0; \$i<(count(\$grad['stops'])-1); \$i++) {
\t\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\t\$this->_out('<<');
\t\t\t\t\t\t\$this->_out('/FunctionType 2');
\t\t\t\t\t\t\$this->_out('/Domain [0 1]');
\t\t\t\t\t\t\$this->_out(sprintf('/C0 [%.3F]', \$grad['stops'][\$i]['opacity']));
\t\t\t\t\t\t\$this->_out(sprintf('/C1 [%.3F]', \$grad['stops'][\$i+1]['opacity']));
\t\t\t\t\t\t\$this->_out('/N 1');
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t\t}
\t\t\t\t   }
\t\t\t\t}

\t\t\t\tif (empty(\$grad['is_mask'])) {
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<<');
\t\t\t\t\t\$this->_out('/ShadingType '.\$grad['type']);
\t\t\t\t\tif (isset(\$grad['colorspace'])) {
\t\t\t\t\t\t\$this->_out('/ColorSpace /Device'.\$grad['colorspace']);\t\t// Can use CMYK if all C0 and C1 above have 4 values
\t\t\t\t\t} else {
\t\t\t\t\t\t\$this->_out('/ColorSpace /DeviceRGB');
\t\t\t\t\t}
\t\t\t\t\tif (\$grad['type'] == 2) {
\t\t\t\t\t\t\$this->_out(sprintf('/Coords [%.3F %.3F %.3F %.3F]', \$grad['coords'][0], \$grad['coords'][1], \$grad['coords'][2], \$grad['coords'][3]));
\t\t\t\t\t\t\$this->_out('/Function '.\$f1.' 0 R');
\t\t\t\t\t\t\$this->_out('/Extend ['.\$grad['extend'][0].' '.\$grad['extend'][1].'] ');
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t}
\t\t\t\t\telse if (\$grad['type'] == 3) {
\t\t\t\t\t\t//x0, y0, r0, x1, y1, r1
\t\t\t\t\t\t//at this this time radius of inner circle is 0
\t\t\t\t\t\t\$ir = 0;
\t\t\t\t\t\tif (isset(\$grad['coords'][5]) && \$grad['coords'][5]) { \$ir = \$grad['coords'][5]; }
\t\t\t\t\t\t\$this->_out(sprintf('/Coords [%.3F %.3F %.3F %.3F %.3F %.3F]', \$grad['coords'][0], \$grad['coords'][1], \$ir, \$grad['coords'][2], \$grad['coords'][3], \$grad['coords'][4]));
\t\t\t\t\t\t\$this->_out('/Function '.\$f1.' 0 R');
\t\t\t\t\t\t\$this->_out('/Extend ['.\$grad['extend'][0].' '.\$grad['extend'][1].'] ');
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t}
\t\t\t\t\telse if (\$grad['type']==6) {
\t\t\t\t\t\t\$this->_out('/BitsPerCoordinate 16');
\t\t\t\t\t\t\$this->_out('/BitsPerComponent 8');
\t\t\t\t\t\tif (\$grad['colorspace'] == 'CMYK') { \$this->_out('/Decode[0 1 0 1 0 1 0 1 0 1 0 1]'); }
\t\t\t\t\t\telse if (\$grad['colorspace'] == 'Gray') { \$this->_out('/Decode[0 1 0 1 0 1]'); }
\t\t\t\t\t\telse { \$this->_out('/Decode[0 1 0 1 0 1 0 1 0 1]'); }
\t\t\t\t\t\t\$this->_out('/BitsPerFlag 8');
\t\t\t\t\t\t\$this->_out('/Length '.strlen(\$grad['stream']));
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\t\$this->_putstream(\$grad['stream']);
\t\t\t\t\t}
\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t}

\t\t\t\t\$this->gradients[\$id]['id'] = \$this->n;

\t\t\t\t// set pattern object
\t\t\t\t\$this->_newobj();
\t\t\t\t\$out = '<< /Type /Pattern /PatternType 2';
\t\t\t\t\$out .= ' /Shading '.\$this->gradients[\$id]['id'].' 0 R';
\t\t\t\t\$out .= ' >>';
\t\t\t\t\$out .= \"\\n\".'endobj';
\t\t\t\t\$this->_out(\$out);


\t\t\t\t\$this->gradients[\$id]['pattern'] = \$this->n;

\t\t\t\tif (isset(\$grad['trans']) && \$grad['trans']) {
\t\t\t\t\t// luminosity pattern
\t\t\t\t\t\$transid = \$id + \$maxid;
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<<');
\t\t\t\t\t\$this->_out('/ShadingType '.\$grad['type']);
\t\t\t\t\t\$this->_out('/ColorSpace /DeviceGray');
\t\t\t\t\tif (\$grad['type'] == 2) {
\t\t\t\t\t\t\$this->_out(sprintf('/Coords [%.3F %.3F %.3F %.3F]', \$grad['coords'][0], \$grad['coords'][1], \$grad['coords'][2], \$grad['coords'][3]));
\t\t\t\t\t\t\$this->_out('/Function '.\$f2.' 0 R');
\t\t\t\t\t\t\$this->_out('/Extend ['.\$grad['extend'][0].' '.\$grad['extend'][1].'] ');
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t}
\t\t\t\t\telse if (\$grad['type'] == 3) {
\t\t\t\t\t\t//x0, y0, r0, x1, y1, r1
\t\t\t\t\t\t//at this this time radius of inner circle is 0
\t\t\t\t\t\t\$ir = 0;
\t\t\t\t\t\tif (isset(\$grad['coords'][5]) && \$grad['coords'][5]) { \$ir = \$grad['coords'][5]; }
\t\t\t\t\t\t\$this->_out(sprintf('/Coords [%.3F %.3F %.3F %.3F %.3F %.3F]', \$grad['coords'][0], \$grad['coords'][1], \$ir, \$grad['coords'][2], \$grad['coords'][3], \$grad['coords'][4]));
\t\t\t\t\t\t\$this->_out('/Function '.\$f2.' 0 R');
\t\t\t\t\t\t\$this->_out('/Extend ['.\$grad['extend'][0].' '.\$grad['extend'][1].'] ');
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t}
\t\t\t\t\telse if (\$grad['type']==6) {
\t\t\t\t\t\t\$this->_out('/BitsPerCoordinate 16');
\t\t\t\t\t\t\$this->_out('/BitsPerComponent 8');
\t\t\t\t\t\t\$this->_out('/Decode[0 1 0 1 0 1]');
\t\t\t\t\t\t\$this->_out('/BitsPerFlag 8');
\t\t\t\t\t\t\$this->_out('/Length '.strlen(\$grad['stream_trans']));
\t\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\t\$this->_putstream(\$grad['stream_trans']);
\t\t\t\t\t}
\t\t\t\t\t\$this->_out('endobj');

\t\t\t\t\t\$this->gradients[\$transid]['id'] = \$this->n;
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<< /Type /Pattern /PatternType 2');
\t\t\t\t\t\$this->_out('/Shading '.\$this->gradients[\$transid]['id'].' 0 R');
\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t\t\$this->gradients[\$transid]['pattern'] = \$this->n;
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t// Need to extend size of viewing box in case of transformations
\t\t\t\t\t\$str = 'q /a0 gs /Pattern cs /p'.\$transid.' scn -'.(\$this->wPt/2).' -'.(\$this->hPt/2).' '.(2*\$this->wPt).' '.(2*\$this->hPt).' re f Q';
\t\t\t\t\t\$filter=(\$this->compress) ? '/Filter /FlateDecode ' : '';
\t\t\t\t\t\$p=(\$this->compress) ? gzcompress(\$str) : \$str;
\t\t\t\t\t\$this->_out('<< /Type /XObject /Subtype /Form /FormType 1 '.\$filter);
\t\t\t\t\t\$this->_out('/Length '.strlen(\$p));
\t\t\t\t\t\$this->_out('/BBox [-'.(\$this->wPt/2).' -'.(\$this->hPt/2).' '.(2*\$this->wPt).' '.(2*\$this->hPt).']');
\t\t\t\t\t\$this->_out('/Group << /Type /Group /S /Transparency /CS /DeviceGray >>');
\t\t\t\t\t\$this->_out('/Resources <<');
\t\t\t\t\t\$this->_out('/ExtGState << /a0 << /ca 1 /CA 1 >> >>');
\t\t\t\t\t\$this->_out('/Pattern << /p'.\$transid.' '.\$this->gradients[\$transid]['pattern'].' 0 R >>');
\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\$this->_out('>>');
\t\t\t\t\t\$this->_putstream(\$p);
\t\t\t\t\t\$this->_out('endobj');
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<< /Type /Mask /S /Luminosity /G '.(\$this->n - 1).' 0 R >>'.\"\\n\".'endobj');
\t\t\t\t\t\$this->_newobj();
\t\t\t\t\t\$this->_out('<< /Type /ExtGState /SMask '.(\$this->n - 1).' 0 R /AIS false >>'.\"\\n\".'endobj');
\t\t\t\t\tif (\$grad['fo']) { \$this->extgstates[] = array('n' => \$this->n, 'trans' => 'TGS'.\$id, 'fo'=>true); }
\t\t\t\t\telse { \$this->extgstates[] = array('n' => \$this->n, 'trans' => 'TGS'.\$id); }
\t\t\t\t}
\t\t\t}
}
/*-- END BACKGROUNDS --*/

function _putspotcolors() {
\tforeach(\$this->spotColors as \$name=>\$color) {
\t\t\$this->_newobj();
\t\t\$this->_out('[/Separation /'.str_replace(' ','#20',\$name));
\t\t\$this->_out('/DeviceCMYK <<');
\t\t\$this->_out('/Range [0 1 0 1 0 1 0 1] /C0 [0 0 0 0] ');
\t\t\$this->_out(sprintf('/C1 [%.3F %.3F %.3F %.3F] ',\$color['c']/100,\$color['m']/100,\$color['y']/100,\$color['k']/100));
\t\t\$this->_out('/FunctionType 2 /Domain [0 1] /N 1>>]');
\t\t\$this->_out('endobj');
\t\t\$this->spotColors[\$name]['n']=\$this->n;
\t}
}


function _putresources() {
\tif (\$this->hasOC || count(\$this->layers)) \t// mPDF 5.6.01
\t\t\$this->_putocg();
\t\$this->_putextgstates();
\t\$this->_putspotcolors();
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'40','Compiling Fonts'); }\t// *PROGRESS-BAR*
\t\$this->_putfonts();
\tif (\$this->progressBar) { \$this->UpdateProgressBar(2,'50','Compiling Images'); }\t// *PROGRESS-BAR*
\t\$this->_putimages();
\t\$this->_putformobjects();\t// *IMAGES-CORE*

/*-- IMPORTS --*/
\tif (\$this->enableImports) {
\t\t\$this->_putformxobjects();
\t\t\$this->_putimportedobjects();
\t}
/*-- END IMPORTS --*/

/*-- BACKGROUNDS --*/
\t\$this->_putshaders();
\t\$this->_putpatterns();
/*-- END BACKGROUNDS --*/


\t//Resource dictionary
\t\$this->offsets[2]=strlen(\$this->buffer);
\t\$this->_out('2 0 obj');
\t\$this->_out('<</ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');

\t\$this->_out('/Font <<');
\tforeach(\$this->fonts as \$font) {
\t\tif (!\$font['used'] && \$font['type']=='TTF') { continue; }
\t\tif (\$font['type']=='TTF' && (\$font['sip'] || \$font['smp'])) {
\t\t\tforeach(\$font['n'] AS \$k => \$fid) {
\t\t\t\t\$this->_out('/F'.\$font['subsetfontids'][\$k].' '.\$font['n'][\$k].' 0 R');
\t\t\t}
\t\t}
\t\telse {
\t\t\t\$this->_out('/F'.\$font['i'].' '.\$font['n'].' 0 R');
\t\t}
\t}
\t\$this->_out('>>');

\tif (count(\$this->spotColors)) {
\t\t\$this->_out('/ColorSpace <<');
\t\tforeach(\$this->spotColors as \$color)
\t\t\t\$this->_out('/CS'.\$color['i'].' '.\$color['n'].' 0 R');
\t\t\$this->_out('>>');
\t}

\tif (count(\$this->extgstates)) {
\t\t\$this->_out('/ExtGState <<');
\t\tforeach(\$this->extgstates as \$k=>\$extgstate)
\t\t\tif (isset(\$extgstate['trans']))  \$this->_out('/'.\$extgstate['trans'].' '.\$extgstate['n'].' 0 R');
\t\t\telse \$this->_out('/GS'.\$k.' '.\$extgstate['n'].' 0 R');
\t\t\$this->_out('>>');
\t}

/*-- BACKGROUNDS --*/
\tif ((isset(\$this->gradients) AND (count(\$this->gradients) > 0)) || (\$this->enableImports && count(\$this->tpls))) {\t// mPDF 5.7.3
\t\t\$this->_out('/Shading <<');
\t\tforeach (\$this->gradients as \$id => \$grad) {
\t\t\t\$this->_out('/Sh'.\$id.' '.\$grad['id'].' 0 R');
\t\t}
\t\t// mPDF 5.7.3
\t\t// If a shading dictionary is in an object (tpl) imported from another PDF, it needs to be included
\t\t// in the document resources, as well as the object resources
\t\t// Otherwise get an error in some PDF viewers
\t\tif (\$this->enableImports && count(\$this->tpls)) {
\t\t\tforeach(\$this->tpls as \$tplidx => \$tpl) {
\t\t\t\tif (isset(\$tpl['resources'])) {
\t\t\t\t\t\$this->current_parser =& \$tpl['parser'];
\t\t\t\t\treset (\$tpl['resources'][1]);
\t\t\t\t\twhile (list(\$k, \$v) = each(\$tpl['resources'][1])) {
\t\t\t\t\t\tif (\$k == '/Shading') {
\t\t\t\t\t\t\twhile (list(\$k2, \$v2) = each(\$v[1])) {
\t\t\t\t\t\t\t\t\$this->_out(\$k2 . \" \",false);
\t\t\t\t\t\t\t\t\$this->pdf_write_value(\$v2);
\t\t\t\t\t\t\t}
\t\t\t\t\t\t}
\t\t\t\t\t}


\t\t\t\t}
\t\t\t}
\t\t}

\t\t\$this->_out('>>');
/*
\t\t// ??? Not needed !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\t\t\$this->_out('/Pattern <<');
\t\tforeach (\$this->gradients as \$id => \$grad) {
\t\t\t\$this->_out('/P'.\$id.' '.\$grad['pattern'].' 0 R');
\t\t}
\t\t\$this->_out('>>');
*/
\t}
/*-- END BACKGROUNDS --*/

\tif(count(\$this->images) || count(\$this->formobjects) || (\$this->enableImports && count(\$this->tpls))) {
\t\t\$this->_out('/XObject <<');
\t\tforeach(\$this->images as \$image)
\t\t\t\$this->_out('/I'.\$image['i'].' '.\$image['n'].' 0 R');
            foreach(\$this->formobjects as \$formobject)
                \$this->_out('/FO'.\$formobject['i'].' '.\$formobject['n'].' 0 R');
/*-- IMPORTS --*/
\t\tif (\$this->enableImports && count(\$this->tpls)) {
\t\t\tforeach(\$this->tpls as \$tplidx => \$tpl) {
\t\t\t\t\$this->_out(\$this->tplprefix.\$tplidx.' '.\$tpl['n'].' 0 R');
\t\t\t}
\t\t}
/*-- END IMPORTS --*/
\t\t\$this->_out('>>');
\t}

/*-- BACKGROUNDS --*/

\tif (count(\$this->patterns)) {
\t\t\$this->_out('/Pattern <<');
\t\tforeach(\$this->patterns as \$k=>\$patterns)
\t\t\t\$this->_out('/P'.\$k.' '.\$patterns['n'].' 0 R');
\t\t\$this->_out('>>');
\t}
/*-- END BACKGROUNDS --*/

\t// mPDF 5.6.01
\tif (\$this->hasOC || count(\$this->layers)) {
\t\t\$this->_out('/Properties <<');
\t\tif (\$this->hasOC) {
\t\t\t\$this->_out('/OC1 '.\$this->n_ocg_print.' 0 R /OC2 '.\$this->n_ocg_view.' 0 R /OC3 '.\$this->n_ocg_hidden.' 0 R ');
\t\t}
\t\tif (count(\$this->layers)) {
\t\t\tforeach(\$this->layers as \$id=>\$layer)
\t\t\t\t\$this->_out('/ZI'.\$id.' '.\$layer['n'].' 0 R');
\t\t}
\t\t\$this->_out('>>');
\t}

\t\$this->_out('>>');
\t\$this->_out('endobj');\t// end resource dictionary

\t\$this->_putbookmarks(); \t// *BOOKMARKS*

\tif (isset(\$this->js) && \$this->js) {
\t\t\$this->_putjavascript();
\t}

/*-- ENCRYPTION --*/
\tif (\$this->encrypted) {
\t\t\$this->_newobj();
\t\t\$this->enc_obj_id = \$this->n;
\t\t\$this->_out('<<');
\t\t\$this->_putencryption();
\t\t\$this->_out('>>');
\t\t\$this->_out('endobj');
\t}
/*-- END ENCRYPTION --*/
}


function _putjavascript() {
\t\$this->_newobj();
\t\$this->n_js = \$this->n;
\t\$this->_out('<<');
\t\$this->_out('/Names [(EmbeddedJS) '.(1 + \$this->n).' 0 R ]');
\t\$this->_out('>>');
\t\$this->_out('endobj');

\t\$this->_newobj();
\t\$this->_out('<<');
\t\$this->_out('/S /JavaScript');
\t\$this->_out('/JS '.\$this->_textstring(\$this->js));
\t\$this->_out('>>');
\t\$this->_out('endobj');
}




/*-- ENCRYPTION --*/
function _putencryption() \t{
\t\$this->_out('/Filter /Standard');
\tif (\$this->useRC128encryption) {
\t\t\$this->_out('/V 2');
\t\t\$this->_out('/R 3');
\t\t\$this->_out('/Length 128');
\t}
\telse  {
\t\t\$this->_out('/V 1');
\t\t\$this->_out('/R 2');
\t}
\t\$this->_out('/O ('.\$this->_escape(\$this->Ovalue).')');
\t\$this->_out('/U ('.\$this->_escape(\$this->Uvalue).')');
\t\$this->_out('/P '.\$this->Pvalue);
}
/*-- END ENCRYPTION --*/

function _puttrailer() {
\t\$this->_out('/Size '.(\$this->n+1));
\t\$this->_out('/Root '.\$this->n.' 0 R');
\t\$this->_out('/Info '.\$this->InfoRoot.' 0 R');
/*-- ENCRYPTION --*/
\tif (\$this->encrypted) {
\t\t\$this->_out('/Encrypt '.\$this->enc_obj_id.' 0 R');
\t\t\$this->_out('/ID [<'.\$this->uniqid.'> <'.\$this->uniqid.'>]');
\t}
\telse {
/*-- END ENCRYPTION --*/
\t\t\$uniqid = md5(time() .  \$this->buffer);
\t\t\$this->_out('/ID [<'.\$uniqid.'> <'.\$uniqid.'>]');
/*-- ENCRYPTION --*/
\t}
/*-- END ENCRYPTION --*/
}

/*-- ENCRYPTION --*/
function SetProtection(\$permissions=array(),\$user_pass='',\$owner_pass=null, \$length=40)\t{
\t\t\$this->encrypted=false;
\t\tif (is_string(\$permissions) && strlen(\$permissions)>0) { \$permissions = array(\$permissions); }
\t\telse if (!is_array(\$permissions)) { return 0; }
\t\t\$this->last_rc4_key='';
\t\t\$this->padding=\"\\x28\\xBF\\x4E\\x5E\\x4E\\x75\\x8A\\x41\\x64\\x00\\x4E\\x56\\xFF\\xFA\\x01\\x08\".
\t\t\t\t\t\t\"\\x2E\\x2E\\x00\\xB6\\xD0\\x68\\x3E\\x80\\x2F\\x0C\\xA9\\xFE\\x64\\x53\\x69\\x7A\";

\t\t\$options = array(
\t\t\t'print' => 4, // bit 3
\t\t\t'modify' => 8, // bit 4
\t\t\t'copy' => 16, // bit 5
\t\t\t'annot-forms' => 32, // bit 6
\t\t\t'fill-forms' => 256, // bit 9
\t\t\t'extract' => 512, // bit 10
\t\t\t'assemble' => 1024,// bit 11
\t\t\t'print-highres' => 2048 // bit 12
\t\t\t);
\t\t// bit 31 = 1073741824
\t\t// bit 32 = 2147483648
\t\t// bits 13-31 = 2147479552
\t\t// bits 13-32 = 4294963200 + 192 = 4294963392
\t\t\$protection = 4294963392; // bits 7,8,13-32
\t\tforeach (\$permissions as \$permission) {
\t\t\tif (!isset(\$options[\$permission]))
\t\t\t\t\$this->Error('Incorrect permission: '.\$permission);
\t\t\tif (\$options[\$permission] > 32) { \$this->useRC128encryption = true; }
\t\t\tif (isset(\$options[\$permission])) \$protection += \$options[\$permission];
\t\t}
\t\tif (\$length==128) { \$this->useRC128encryption = true; }
\t\tif (\$owner_pass === null)
\t\t\t\$owner_pass = uniqid(rand());
\t\t\$this->encrypted = true;
\t\t\$this->_generateencryptionkey(\$user_pass, \$owner_pass, \$protection);
}


// Compute key depending on object number where the encrypted data is stored
function _objectkey(\$n) {
\tif (\$this->useRC128encryption)
\t\t\$len = 16;
\telse
\t\t\$len = 10;
\treturn substr(\$this->_md5_16(\$this->encryption_key.pack('VXxx',\$n)),0,\$len);
}

// RC4 is the standard encryption algorithm used in PDF format
function _RC4(\$key, \$text) {
\tif (\$this->last_rc4_key != \$key) {
\t\t\$k = str_repeat(\$key, 256/strlen(\$key)+1);
\t\t\$rc4 = range(0,255);
\t\t\$j = 0;
\t\tfor (\$i=0; \$i<256; \$i++){
\t\t\t\$t = \$rc4[\$i];
\t\t\t\$j = (\$j + \$t + ord(\$k[\$i])) % 256;
\t\t\t\$rc4[\$i] = \$rc4[\$j];
\t\t\t\$rc4[\$j] = \$t;
\t\t}
\t\t\$this->last_rc4_key = \$key;
\t\t\$this->last_rc4_key_c = \$rc4;
\t} else {
\t\t\$rc4 = \$this->last_rc4_key_c;
\t}

\t\$len = strlen(\$text);
\t\$a = 0;
\t\$b = 0;
\t\$out = '';
\tfor (\$i=0; \$i<\$len; \$i++){
\t\t\$a = (\$a+1)%256;
\t\t\$t= \$rc4[\$a];
\t\t\$b = (\$b+\$t)%256;
\t\t\$rc4[\$a] = \$rc4[\$b];
\t\t\$rc4[\$b] = \$t;
\t\t\$k = \$rc4[(\$rc4[\$a]+\$rc4[\$b])%256];
\t\t\$out.= chr(ord(\$text[\$i]) ^ \$k);
\t}
\treturn \$out;
}

// Get MD5 as binary string
function _md5_16(\$string) {
\treturn pack('H*',md5(\$string));
}

// Compute O value
function _Ovalue(\$user_pass, \$owner_pass) {
\t\$tmp = \$this->_md5_16(\$owner_pass);
\tif (\$this->useRC128encryption) {
\t\tfor (\$i = 0; \$i < 50; ++\$i) {
\t\t\t\$tmp = \$this->_md5_16(\$tmp);
\t\t}
\t}
\tif (\$this->useRC128encryption)
\t\t\$keybytelen = (128 / 8);
\telse
\t\t\$keybytelen = (40 / 8);
\t\$owner_RC4_key = substr(\$tmp,0,\$keybytelen);
\t\$enc = \$this->_RC4(\$owner_RC4_key, \$user_pass);
\tif (\$this->useRC128encryption) {
\t\t\$len = strlen(\$owner_RC4_key);
\t\tfor (\$i = 1; \$i <= 19; ++\$i) {
\t\t\t\$key = '';
\t\t\tfor (\$j = 0; \$j < \$len; ++\$j) {
\t\t\t\t\$key .= chr(ord(\$owner_RC4_key{\$j}) ^ \$i);
\t\t\t}
\t\t\t\$enc = \$this->_RC4(\$key, \$enc);
\t\t}
\t}
\treturn \$enc;
}

// Compute U value
function _Uvalue() {
\tif (\$this->useRC128encryption) {
\t\t\$tmp = \$this->_md5_16(\$this->padding.\$this->_hexToString(\$this->uniqid));
\t\t\$enc = \$this->_RC4(\$this->encryption_key, \$tmp);
\t\t\$len = strlen(\$tmp);
\t\tfor (\$i=1; \$i<=19; ++\$i) {
\t\t\t\$key = '';
\t\t\tfor (\$j=0; \$j<\$len; ++\$j) {
\t\t\t\t\$key .= chr(ord(\$this->encryption_key{\$j}) ^ \$i);
\t\t\t}
\t\t\t\$enc = \$this->_RC4(\$key, \$enc);
\t\t}
\t\t\$enc .= str_repeat(\"\\x00\", 16);
\t\treturn substr(\$enc, 0, 32);
\t}
\telse {
\t\treturn \$this->_RC4(\$this->encryption_key, \$this->padding);
\t}
}

// Compute encryption key
function _generateencryptionkey(\$user_pass, \$owner_pass, \$protection) {
\t// Pad passwords
\t\$user_pass = substr(\$user_pass.\$this->padding,0,32);
\t\$owner_pass = substr(\$owner_pass.\$this->padding,0,32);
\t\$chars = 'ABCDEF1234567890';
\t\$id = '';
\tfor (\$i=0; \$i<32; \$i++) { \$id .= \$chars{rand(0, 15)}; }
\t\$this->uniqid = md5(\$id);
\t// Compute O value
\t\$this->Ovalue = \$this->_Ovalue(\$user_pass,\$owner_pass);
\t// Compute encyption key
\tif (\$this->useRC128encryption)
\t\t\$keybytelen = (128/8);
\telse
\t\t\$keybytelen = (40/8);
\t\$prot = sprintf('%032b', \$protection);
\t\$perms = chr(bindec(substr(\$prot,24,8)));
\t\$perms .= chr(bindec(substr(\$prot,16,8)));
\t\$perms .= chr(bindec(substr(\$prot,8,8)));
\t\$perms .= chr(bindec(substr(\$prot,0,8)));
\t\$tmp = \$this->_md5_16(\$user_pass.\$this->Ovalue.\$perms.\$this->_hexToString(\$this->uniqid));
\tif (\$this->useRC128encryption) {
\t\tfor (\$i=0; \$i<50; ++\$i) {
\t\t\t\$tmp = \$this->_md5_16(substr(\$tmp, 0, \$keybytelen));
\t\t}
\t}
\t\$this->encryption_key = substr(\$tmp,0,\$keybytelen);
\t// Compute U value
\t\$this->Uvalue = \$this->_Uvalue();
\t// Compute P value
\t\$this->Pvalue = \$protection;
}


function _hexToString(\$hs) {
\t\$s = '';
\t\$len = strlen(\$hs);
\tif ((\$len % 2) != 0) {
\t\t\$hs .= '0';
\t\t++\$len;
\t}
\tfor (\$i = 0; \$i < \$len; \$i += 2) {
\t\t\$s .= chr(hexdec(\$hs{\$i}.\$hs{(\$i + 1)}));
\t}
\treturn \$s;
}

/*-- END ENCRYPTION --*/

//=========================================
/*-- BOOKMARKS --*/
// FROM class PDF_Bookmark

function Bookmark(\$txt,\$level=0,\$y=0) {
\t\$txt = \$this->purify_utf8_text(\$txt);
\tif (\$this->text_input_as_HTML) {
\t\t\$txt = \$this->all_entities_to_utf8(\$txt);
\t}
\tif(\$y==-1) {
\t\tif (!\$this->ColActive){ \$y=\$this->y; }
\t\telse { \$y = \$this->y0; }\t// If columns are on - mark top of columns
\t}
\t// else y is used as set, or =0 i.e. top of page
\t// DIRECTIONALITY RTL
\t\$bmo = array('t'=>\$txt,'l'=>\$level,'y'=>\$y,'p'=>\$this->page);
\tif (\$this->keep_block_together) {
\t\t\$this->ktBMoutlines[]= \$bmo;
\t}
/*-- TABLES --*/
\telse if (\$this->table_rotate) {
\t\t\$this->tbrot_BMoutlines[]= \$bmo;
\t}
\telse if (\$this->kwt) {
\t\t\$this->kwt_BMoutlines[]= \$bmo;
\t}
/*-- END TABLES --*/
\telse if (\$this->ColActive) {\t// *COLUMNS*
\t\t\$this->col_BMoutlines[]= \$bmo;\t// *COLUMNS*
\t}\t// *COLUMNS*
\telse {
\t\t\$this->BMoutlines[]= \$bmo;
\t}
}


function _putbookmarks()
{
\t\$nb=count(\$this->BMoutlines);
\tif(\$nb==0)
\t\treturn;

\t// mPDF 5.6.36
\t\$bmo = \$this->BMoutlines;
\t\$this->BMoutlines = array();
\t\$lastlevel = -1;
\tfor(\$i=0;\$i<count(\$bmo);\$i++) {
\t\tif (\$bmo[\$i]['l']>0) {
\t\t\twhile(\$bmo[\$i]['l']-\$lastlevel > 1) {\t// If jump down more than one level, insert a new entry
\t\t\t\t\$new = \$bmo[\$i];
\t\t\t\t\$new['t']=\"[\".\$new['t'].\"]\";\t// Put [] around text/title to highlight
\t\t\t\t\$new['l']=\$lastlevel+1;
\t\t\t\t\$lastlevel++;
\t\t\t\t\$this->BMoutlines[] = \$new;
\t\t\t}
\t\t}
\t\t\$this->BMoutlines[] = \$bmo[\$i];
\t\t\$lastlevel = \$bmo[\$i]['l'];
\t}
\t\$nb=count(\$this->BMoutlines);

\t\$lru=array();
\t\$level=0;
\tforeach(\$this->BMoutlines as \$i=>\$o) {
\t\tif(\$o['l']>0) {
\t\t\t\$parent=\$lru[\$o['l']-1];
\t\t\t//Set parent and last pointers
\t\t\t\$this->BMoutlines[\$i]['parent']=\$parent;
\t\t\t\$this->BMoutlines[\$parent]['last']=\$i;
\t\t\tif(\$o['l']>\$level) {
\t\t\t\t//Level increasing: set first pointer
\t\t\t\t\$this->BMoutlines[\$parent]['first']=\$i;
\t\t\t}
\t\t}
\t\telse {
\t\t\t\$this->BMoutlines[\$i]['parent']=\$nb;
\t\t}
\t\tif(\$o['l']<=\$level and \$i>0) {
\t\t\t//Set prev and next pointers
\t\t\t\$prev=\$lru[\$o['l']];
\t\t\t\$this->BMoutlines[\$prev]['next']=\$i;
\t\t\t\$this->BMoutlines[\$i]['prev']=\$prev;
\t\t}
\t\t\$lru[\$o['l']]=\$i;
\t\t\$level=\$o['l'];
\t}


\t//Outline items
\t\$n=\$this->n+1;
\tforeach(\$this->BMoutlines as \$i=>\$o) {
\t\t\$this->_newobj();
\t\t\$this->_out('<</Title '.\$this->_UTF16BEtextstring(\$o['t']));
\t\t\$this->_out('/Parent '.(\$n+\$o['parent']).' 0 R');
\t\tif(isset(\$o['prev']))
\t\t\t\$this->_out('/Prev '.(\$n+\$o['prev']).' 0 R');
\t\tif(isset(\$o['next']))
\t\t\t\$this->_out('/Next '.(\$n+\$o['next']).' 0 R');
\t\tif(isset(\$o['first']))
\t\t\t\$this->_out('/First '.(\$n+\$o['first']).' 0 R');
\t\tif(isset(\$o['last']))
\t\t\t\$this->_out('/Last '.(\$n+\$o['last']).' 0 R');


\t\tif (isset(\$this->pageDim[\$o['p']]['h'])) { \$h=\$this->pageDim[\$o['p']]['h']; }
\t\telse { \$h = 0; }

\t\t\$this->_out(sprintf('/Dest [%d 0 R /XYZ 0 %.3F null]',1+2*(\$o['p']),(\$h-\$o['y'])*_MPDFK));
\t\tif (isset(\$this->bookmarkStyles) && isset(\$this->bookmarkStyles[\$o['l']])) {
\t\t\t// font style
\t\t\t\$bms = \$this->bookmarkStyles[\$o['l']]['style'];
\t\t\t\$style = 0;
\t\t\tif (strpos(\$bms,'B') !== false) { \$style += 2; }
\t\t\tif (strpos(\$bms,'I') !== false) { \$style += 1; }
\t\t\t\$this->_out(sprintf('/F %d', \$style));
\t\t\t// Colour
\t\t\t\$col = \$this->bookmarkStyles[\$o['l']]['color'];
\t\t\tif (isset(\$col) && is_array(\$col) && count(\$col)==3) {
\t\t\t\t\$this->_out(sprintf('/C [%.3F %.3F %.3F]', (\$col[0]/255), (\$col[1]/255), (\$col[2]/255)));
\t\t\t}
\t\t}

\t\t\$this->_out('/Count 0>>');
\t\t\$this->_out('endobj');
\t}
\t//Outline root
\t\$this->_newobj();
\t\$this->OutlineRoot=\$this->n;
\t\$this->_out('<</Type /BMoutlines /First '.\$n.' 0 R');
\t\$this->_out('/Last '.(\$n+\$lru[0]).' 0 R>>');
\t\$this->_out('endobj');
}
/*-- END BOOKMARKS --*/



//======================================================


// DEPRACATED but included for backwards compatability
function startPageNums() {
}

//======================================================
/*-- TOC --*/
// ToC TABLE OF CONTENTS

// Initiate, and Mark a place for the Table of Contents to be inserted
function TOC(\$tocfont='', \$tocfontsize=0, \$tocindent=0, \$resetpagenum='', \$pagenumstyle='', \$suppress='', \$toc_orientation='', \$TOCusePaging=true, \$TOCuseLinking=false, \$toc_id=0, \$tocoutdent='') {\t// mPDF 5.6.19
\tif (!class_exists('tocontents', false)) { include(_MPDF_PATH.'classes/tocontents.php'); }
\tif (empty(\$this->tocontents)) { \$this->tocontents = new tocontents(\$this); }
\t\$this->tocontents->TOC(\$tocfont, \$tocfontsize, \$tocindent, \$resetpagenum, \$pagenumstyle, \$suppress, \$toc_orientation, \$TOCusePaging, \$TOCuseLinking, \$toc_id, \$tocoutdent);  // mPDF 5.6.19
}


function TOCpagebreakByArray(\$a) {
\tif (!is_array(\$a)) { \$a = array(); }
\tif (!class_exists('tocontents', false)) { include(_MPDF_PATH.'classes/tocontents.php'); }
\tif (empty(\$this->tocontents)) { \$this->tocontents = new tocontents(\$this); }
\t\$tocoutdent = (isset(\$a['tocoutdent']) ? \$a['tocoutdent'] : (isset(\$a['outdent']) ? \$a['outdent'] : ''));
\t\$TOCusePaging = (isset(\$a['TOCusePaging']) ? \$a['TOCusePaging'] : (isset(\$a['paging']) ? \$a['paging'] : true));
\t\$TOCuseLinking = (isset(\$a['TOCuseLinking']) ? \$a['TOCuseLinking'] : (isset(\$a['links']) ? \$a['links'] : ''));
\t\$toc_orientation = (isset(\$a['toc_orientation']) ? \$a['toc_orientation'] : (isset(\$a['toc-orientation']) ? \$a['toc-orientation'] : ''));
\t\$toc_mgl = (isset(\$a['toc_mgl']) ? \$a['toc_mgl'] : (isset(\$a['toc-margin-left']) ? \$a['toc-margin-left'] : ''));
\t\$toc_mgr = (isset(\$a['toc_mgr']) ? \$a['toc_mgr'] : (isset(\$a['toc-margin-right']) ? \$a['toc-margin-right'] : ''));
\t\$toc_mgt = (isset(\$a['toc_mgt']) ? \$a['toc_mgt'] : (isset(\$a['toc-margin-top']) ? \$a['toc-margin-top'] : ''));
\t\$toc_mgb = (isset(\$a['toc_mgb']) ? \$a['toc_mgb'] : (isset(\$a['toc-margin-bottom']) ? \$a['toc-margin-bottom'] : ''));
\t\$toc_mgh = (isset(\$a['toc_mgh']) ? \$a['toc_mgh'] : (isset(\$a['toc-margin-header']) ? \$a['toc-margin-header'] : ''));
\t\$toc_mgf = (isset(\$a['toc_mgf']) ? \$a['toc_mgf'] : (isset(\$a['toc-margin-footer']) ? \$a['toc-margin-footer'] : ''));
\t\$toc_ohname = (isset(\$a['toc_ohname']) ? \$a['toc_ohname'] : (isset(\$a['toc-odd-header-name']) ? \$a['toc-odd-header-name'] : ''));
\t\$toc_ehname = (isset(\$a['toc_ehname']) ? \$a['toc_ehname'] : (isset(\$a['toc-even-header-name']) ? \$a['toc-even-header-name'] : ''));
\t\$toc_ofname = (isset(\$a['toc_ofname']) ? \$a['toc_ofname'] : (isset(\$a['toc-odd-footer-name']) ? \$a['toc-odd-footer-name'] : ''));
\t\$toc_efname = (isset(\$a['toc_efname']) ? \$a['toc_efname'] : (isset(\$a['toc-even-footer-name']) ? \$a['toc-even-footer-name'] : ''));
\t\$toc_ohvalue = (isset(\$a['toc_ohvalue']) ? \$a['toc_ohvalue'] : (isset(\$a['toc-odd-header-value']) ? \$a['toc-odd-header-value'] : 0));
\t\$toc_ehvalue = (isset(\$a['toc_ehvalue']) ? \$a['toc_ehvalue'] : (isset(\$a['toc-even-header-value']) ? \$a['toc-even-header-value'] : 0));
\t\$toc_ofvalue = (isset(\$a['toc_ofvalue']) ? \$a['toc_ofvalue'] : (isset(\$a['toc-odd-footer-value']) ? \$a['toc-odd-footer-value'] : 0));
\t\$toc_efvalue = (isset(\$a['toc_efvalue']) ? \$a['toc_efvalue'] : (isset(\$a['toc-even-footer-value']) ? \$a['toc-even-footer-value'] : 0));
\t\$toc_preHTML = (isset(\$a['toc_preHTML']) ? \$a['toc_preHTML'] : (isset(\$a['toc-preHTML']) ? \$a['toc-preHTML'] : ''));
\t\$toc_postHTML = (isset(\$a['toc_postHTML']) ? \$a['toc_postHTML'] : (isset(\$a['toc-postHTML']) ? \$a['toc-postHTML'] : ''));
\t\$toc_bookmarkText = (isset(\$a['toc_bookmarkText']) ? \$a['toc_bookmarkText'] : (isset(\$a['toc-bookmarkText']) ? \$a['toc-bookmarkText'] : ''));
\t\$resetpagenum = (isset(\$a['resetpagenum']) ? \$a['resetpagenum'] : '');
\t\$pagenumstyle = (isset(\$a['pagenumstyle']) ? \$a['pagenumstyle'] : '');
\t\$suppress = (isset(\$a['suppress']) ? \$a['suppress'] : '');
\t\$orientation = (isset(\$a['orientation']) ? \$a['orientation'] : '');
\t\$mgl = (isset(\$a['mgl']) ? \$a['mgl'] : (isset(\$a['margin-left']) ? \$a['margin-left'] : ''));
\t\$mgr = (isset(\$a['mgr']) ? \$a['mgr'] : (isset(\$a['margin-right']) ? \$a['margin-right'] : ''));
\t\$mgt = (isset(\$a['mgt']) ? \$a['mgt'] : (isset(\$a['margin-top']) ? \$a['margin-top'] : ''));
\t\$mgb = (isset(\$a['mgb']) ? \$a['mgb'] : (isset(\$a['margin-bottom']) ? \$a['margin-bottom'] : ''));
\t\$mgh = (isset(\$a['mgh']) ? \$a['mgh'] : (isset(\$a['margin-header']) ? \$a['margin-header'] : ''));
\t\$mgf = (isset(\$a['mgf']) ? \$a['mgf'] : (isset(\$a['margin-footer']) ? \$a['margin-footer'] : ''));
\t\$ohname = (isset(\$a['ohname']) ? \$a['ohname'] : (isset(\$a['odd-header-name']) ? \$a['odd-header-name'] : ''));
\t\$ehname = (isset(\$a['ehname']) ? \$a['ehname'] : (isset(\$a['even-header-name']) ? \$a['even-header-name'] : ''));
\t\$ofname = (isset(\$a['ofname']) ? \$a['ofname'] : (isset(\$a['odd-footer-name']) ? \$a['odd-footer-name'] : ''));
\t\$efname = (isset(\$a['efname']) ? \$a['efname'] : (isset(\$a['even-footer-name']) ? \$a['even-footer-name'] : ''));
\t\$ohvalue = (isset(\$a['ohvalue']) ? \$a['ohvalue'] : (isset(\$a['odd-header-value']) ? \$a['odd-header-value'] : 0));
\t\$ehvalue = (isset(\$a['ehvalue']) ? \$a['ehvalue'] : (isset(\$a['even-header-value']) ? \$a['even-header-value'] : 0));
\t\$ofvalue = (isset(\$a['ofvalue']) ? \$a['ofvalue'] : (isset(\$a['odd-footer-value']) ? \$a['odd-footer-value'] : 0));
\t\$efvalue = (isset(\$a['efvalue']) ? \$a['efvalue'] : (isset(\$a['even-footer-value']) ? \$a['even-footer-value'] : 0));
\t\$toc_id = (isset(\$a['toc_id']) ? \$a['toc_id'] : (isset(\$a['name']) ? \$a['name'] : 0));
\t\$pagesel = (isset(\$a['pagesel']) ? \$a['pagesel'] : (isset(\$a['pageselector']) ? \$a['pageselector'] : ''));
\t\$toc_pagesel = (isset(\$a['toc_pagesel']) ? \$a['toc_pagesel'] : (isset(\$a['toc-pageselector']) ? \$a['toc-pageselector'] : ''));
\t\$sheetsize = (isset(\$a['sheetsize']) ? \$a['sheetsize'] : (isset(\$a['sheet-size']) ? \$a['sheet-size'] : ''));
\t\$toc_sheetsize = (isset(\$a['toc_sheetsize']) ? \$a['toc_sheetsize'] : (isset(\$a['toc-sheet-size']) ? \$a['toc-sheet-size'] : ''));

\t\$this->TOCpagebreak(\$tocfont, \$tocfontsize, \$tocindent, \$TOCusePaging, \$TOCuseLinking, \$toc_orientation, \$toc_mgl, \$toc_mgr, \$toc_mgt, \$toc_mgb, \$toc_mgh, \$toc_mgf, \$toc_ohname, \$toc_ehname, \$toc_ofname, \$toc_efname, \$toc_ohvalue, \$toc_ehvalue, \$toc_ofvalue, \$toc_efvalue, \$toc_preHTML, \$toc_postHTML, \$toc_bookmarkText, \$resetpagenum, \$pagenumstyle, \$suppress, \$orientation, \$mgl, \$mgr, \$mgt, \$mgb, \$mgh, \$mgf, \$ohname, \$ehname, \$ofname, \$efname, \$ohvalue, \$ehvalue, \$ofvalue, \$efvalue, \$toc_id, \$pagesel, \$toc_pagesel, \$sheetsize, \$toc_sheetsize, \$tocoutdent);\t// mPDF 5.6.19

}

function TOCpagebreak(\$tocfont='', \$tocfontsize='', \$tocindent='', \$TOCusePaging=true, \$TOCuseLinking='', \$toc_orientation='', \$toc_mgl='',\$toc_mgr='',\$toc_mgt='',\$toc_mgb='',\$toc_mgh='',\$toc_mgf='',\$toc_ohname='',\$toc_ehname='',\$toc_ofname='',\$toc_efname='',\$toc_ohvalue=0,\$toc_ehvalue=0,\$toc_ofvalue=0, \$toc_efvalue=0, \$toc_preHTML='', \$toc_postHTML='', \$toc_bookmarkText='', \$resetpagenum='', \$pagenumstyle='', \$suppress='', \$orientation='', \$mgl='',\$mgr='',\$mgt='',\$mgb='',\$mgh='',\$mgf='',\$ohname='',\$ehname='',\$ofname='',\$efname='',\$ohvalue=0,\$ehvalue=0,\$ofvalue=0,\$efvalue=0, \$toc_id=0, \$pagesel='', \$toc_pagesel='', \$sheetsize='', \$toc_sheetsize='', \$tocoutdent='') {\t// mPDF 5.6.19) {
\t\tif (!class_exists('tocontents', false)) { include(_MPDF_PATH.'classes/tocontents.php'); }
\t\tif (empty(\$this->tocontents)) { \$this->tocontents = new tocontents(\$this); }
\t\t//Start a new page
\t\tif(\$this->state==0) \$this->AddPage();
\t\tif (\$this->y == \$this->tMargin && (!\$this->mirrorMargins ||(\$this->mirrorMargins && \$this->page % 2==1))) {
\t\t\t// Don't add a page
\t\t\tif (\$this->page==1 && count(\$this->PageNumSubstitutions)==0) {
\t\t\t\tif (!\$suppress) { \$suppress = 'off'; }
\t\t\t\tif (!\$resetpagenum) { \$resetpagenum= 1; }
\t\t\t\t//\$this->PageNumSubstitutions[] = array('from'=>1, 'reset'=> \$resetpagenum, 'type'=>\$pagenumstyle, 'suppress'=> \$suppress);
\t\t\t}
\t\t\t\$this->PageNumSubstitutions[] = array('from'=>\$this->page, 'reset'=> \$resetpagenum, 'type'=>\$pagenumstyle, 'suppress'=> \$suppress);
\t\t}
\t\telse {
\t\t\t\$this->AddPage(\$orientation,'NEXT-ODD', \$resetpagenum, \$pagenumstyle, \$suppress,\$mgl,\$mgr,\$mgt,\$mgb,\$mgh,\$mgf,\$ohname,\$ehname,\$ofname,\$efname,\$ohvalue,\$ehvalue,\$ofvalue,\$efvalue,\$pagesel,\$sheetsize);
\t\t}

\t\t\$this->tocontents->TOCpagebreak(\$tocfont, \$tocfontsize, \$tocindent, \$TOCusePaging, \$TOCuseLinking, \$toc_orientation, \$toc_mgl, \$toc_mgr, \$toc_mgt, \$toc_mgb, \$toc_mgh, \$toc_mgf, \$toc_ohname, \$toc_ehname, \$toc_ofname, \$toc_efname, \$toc_ohvalue, \$toc_ehvalue, \$toc_ofvalue, \$toc_efvalue, \$toc_preHTML, \$toc_postHTML, \$toc_bookmarkText, \$resetpagenum, \$pagenumstyle, \$suppress, \$orientation, \$mgl, \$mgr, \$mgt, \$mgb, \$mgh, \$mgf, \$ohname, \$ehname, \$ofname, \$efname, \$ohvalue, \$ehvalue, \$ofvalue, \$efvalue, \$toc_id, \$pagesel, \$toc_pagesel, \$sheetsize, \$toc_sheetsize, \$tocoutdent);\t// mPDF 5.6.19
}

function TOC_Entry(\$txt, \$level=0, \$toc_id=0) {
\t\t// mPDF 5.7.2
  \t\tif (\$this->ColActive) { \$ily = \$this->y0; } else { \$ily = \$this->y; }\t// use top of columns

\t\tif (!class_exists('tocontents', false)) { include(_MPDF_PATH.'classes/tocontents.php'); }
\t\tif (empty(\$this->tocontents)) { \$this->tocontents = new tocontents(\$this); }
\t\t\$linkn = \$this->AddLink();
\t\t\$uid = '__mpdfinternallink_' . \$linkn ;
\t\tif (\$this->keep_block_together) { \$this->internallink[\$uid] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"kt\"=>true ); }
\t\telse if (\$this->table_rotate) { \$this->internallink[\$uid] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"tbrot\"=>true ); }
\t\telse if (\$this->kwt) { \$this->internallink[\$uid] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"kwt\"=>true ); }
\t\telse if (\$this->ColActive) { \$this->internallink[\$uid] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page, \"col\"=>\$this->CurrCol ); }
\t\telse \t\$this->internallink[\$uid] = array(\"Y\"=>\$ily,\"PAGE\"=>\$this->page );
\t\t\$this->internallink['#'.\$uid] = \$linkn;
\t\t\$this->SetLink(\$linkn,\$ily,\$this->page);

/*-- RTL --*/
  \t\tif (\$this->biDirectional)  {
\t\t\t\$txt = preg_replace_callback(\"/([\".\$this->pregRTLchars.\"]+)/u\", array(\$this, 'arabJoinPregCallback'), \$txt );\t// mPDF 5.7+
\t\t}
/*-- END RTL --*/
\t\tif (strtoupper(\$toc_id)=='ALL') { \$toc_id = '_mpdf_all'; }
\t\telse if (!\$toc_id) { \$toc_id = 0; }
\t\telse { \$toc_id = strtolower(\$toc_id); }
\t\t\$btoc = array('t'=>\$txt,'l'=>\$level,'p'=>\$this->page, 'link'=>\$linkn, 'toc_id'=>\$toc_id);
\t\tif (\$this->keep_block_together) {
\t\t\t\$this->_kttoc[]= \$btoc;
\t\t}
/*-- TABLES --*/
\t\telse if (\$this->table_rotate) {
\t\t\t\$this->tbrot_toc[]= \$btoc;
\t\t}
\t\telse if (\$this->kwt) {
\t\t\t\$this->kwt_toc[]= \$btoc;
\t\t}
/*-- END TABLES --*/
\t\telse if (\$this->ColActive) {\t\t// *COLUMNS*
\t\t\t\$this->col_toc[]= \$btoc;\t// *COLUMNS*
\t\t}\t\t\t\t\t\t// *COLUMNS*
\t\telse {
\t\t\t\$this->tocontents->_toc[]= \$btoc;
\t\t}
}

/*-- END TOC --*/

//======================================================
function MovePages(\$target_page, \$start_page, \$end_page=-1) {
\t// move a page/pages EARLIER in the document
\t\tif (\$end_page<1) { \$end_page = \$start_page; }
\t\t\$n_toc = \$end_page - \$start_page + 1;

\t\t// Set/Update PageNumSubstitutions changes before moving anything
\t\tif (count(\$this->PageNumSubstitutions)) {
\t\t\t\$tp_present = false;
\t\t\t\$sp_present = false;
\t\t\t\$ep_present = false;
\t\t\tforeach(\$this->PageNumSubstitutions AS \$k=>\$v) {
\t\t\t  if (\$this->PageNumSubstitutions[\$k]['from']==\$target_page) {
\t\t\t\t\$tp_present = true;
\t\t\t\tif (\$this->PageNumSubstitutions[\$k]['suppress']!='on' && \$this->PageNumSubstitutions[\$k]['suppress']!=1) {
\t\t\t\t\t\$this->PageNumSubstitutions[\$k]['suppress']='off';
\t\t\t\t}
\t\t\t  }
\t\t\t  if (\$this->PageNumSubstitutions[\$k]['from']==\$start_page) {
\t\t\t\t\$sp_present = true;
\t\t\t\tif (\$this->PageNumSubstitutions[\$k]['suppress']!='on' && \$this->PageNumSubstitutions[\$k]['suppress']!=1) {
\t\t\t\t\t\$this->PageNumSubstitutions[\$k]['suppress']='off';
\t\t\t\t}
\t\t\t  }
\t\t\t  if (\$this->PageNumSubstitutions[\$k]['from']==(\$end_page+1)) {
\t\t\t\t\$ep_present = true;
\t\t\t\tif (\$this->PageNumSubstitutions[\$k]['suppress']!='on' && \$this->PageNumSubstitutions[\$k]['suppress']!=1) {
\t\t\t\t\t\$this->PageNumSubstitutions[\$k]['suppress']='off';
\t\t\t\t}
\t\t\t  }
\t\t\t}

\t\t\tif (!\$tp_present) {
\t\t\t\tlist(\$tp_type, \$tp_suppress, \$tp_reset) = \$this->docPageSettings(\$target_page);
\t\t\t}
\t\t\tif (!\$sp_present) {
\t\t\t\tlist(\$sp_type, \$sp_suppress, \$sp_reset) = \$this->docPageSettings(\$start_page);
\t\t\t}
\t\t\tif (!\$ep_present) {
\t\t\t\tlist(\$ep_type, \$ep_suppress, \$ep_reset) = \$this->docPageSettings(\$start_page-1);
\t\t\t}

\t\t}

\t\t\$last = array();
\t\t//store pages
\t\tfor(\$i = \$start_page;\$i <= \$end_page ;\$i++)
\t\t\t\$last[]=\$this->pages[\$i];
\t\t//move pages
\t\tfor(\$i=\$start_page - 1;\$i>=(\$target_page);\$i--) {
\t\t\t\$this->pages[\$i+\$n_toc]=\$this->pages[\$i];
\t\t}
\t\t//Put toc pages at insert point
\t\tfor(\$i = 0;\$i < \$n_toc;\$i++) {
\t\t\t\$this->pages[\$target_page + \$i]=\$last[\$i];
\t\t}

/*-- BOOKMARKS --*/
\t\t// Update Bookmarks
\t\tforeach(\$this->BMoutlines as \$i=>\$o) {
\t\t\tif(\$o['p']>=\$target_page) {
\t\t\t\t\$this->BMoutlines[\$i]['p'] += \$n_toc;
\t\t\t}
\t\t}
/*-- END BOOKMARKS --*/

\t\t// Update Page Links
\t\tif (count(\$this->PageLinks)) {
\t\t   \$newarr = array();
\t\t   foreach(\$this->PageLinks as \$i=>\$o) {
\t\t\tforeach(\$this->PageLinks[\$i] as \$key => \$pl) {
\t\t\t\tif (strpos(\$pl[4],'@')===0) {
\t\t\t\t\t\$p=substr(\$pl[4],1);
\t\t\t\t\tif(\$p>=\$start_page && \$p<=\$end_page) {
\t\t\t\t\t\t\$this->PageLinks[\$i][\$key][4] = '@'.(\$p + (\$target_page - \$start_page));
\t\t\t\t\t}
\t\t\t\t\telse if(\$p>=\$target_page && \$p<\$start_page) {
\t\t\t\t\t\t\$this->PageLinks[\$i][\$key][4] = '@'.(\$p+\$n_toc);
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\tif(\$i>=\$start_page && \$i<=\$end_page) {
\t\t\t\t\$newarr[(\$i + (\$target_page - \$start_page))] = \$this->PageLinks[\$i];
\t\t\t}
\t\t\telse if(\$i>=\$target_page && \$i<\$start_page) {
\t\t\t\t\$newarr[(\$i + \$n_toc)] = \$this->PageLinks[\$i];
\t\t\t}
\t\t\telse {
\t\t\t\t\$newarr[\$i] = \$this->PageLinks[\$i];
\t\t\t}
\t\t   }
\t\t   \$this->PageLinks = \$newarr;
\t\t}

\t\t// OrientationChanges
\t\tif (count(\$this->OrientationChanges)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->OrientationChanges AS \$p=>\$v) {
\t\t\t\tif(\$p>=\$start_page && \$p<=\$end_page) { \$newarr[(\$p + (\$target_page - \$start_page))] = \$this->OrientationChanges[\$p]; }
\t\t\t\telse if(\$p>=\$target_page && \$p<\$start_page) { \$newarr[\$p+\$n_toc] = \$this->OrientationChanges[\$p]; }
\t\t\t\telse { \$newarr[\$p] = \$this->OrientationChanges[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->OrientationChanges = \$newarr;
\t\t}

\t\t// Page Dimensions
\t\tif (count(\$this->pageDim)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->pageDim AS \$p=>\$v) {
\t\t\t\tif(\$p>=\$start_page && \$p<=\$end_page) { \$newarr[(\$p + (\$target_page - \$start_page))] = \$this->pageDim[\$p]; }
\t\t\t\telse if(\$p>=\$target_page && \$p<\$start_page) { \$newarr[\$p+\$n_toc] = \$this->pageDim[\$p]; }
\t\t\t\telse { \$newarr[\$p] = \$this->pageDim[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->pageDim = \$newarr;
\t\t}

\t\t// HTML Headers & Footers
\t\tif (count(\$this->saveHTMLHeader)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->saveHTMLHeader AS \$p=>\$v) {
\t\t\t\tif(\$p>=\$start_page && \$p<=\$end_page) { \$newarr[(\$p + (\$target_page - \$start_page))] = \$this->saveHTMLHeader[\$p]; }
\t\t\t\telse if(\$p>=\$target_page && \$p<\$start_page) { \$newarr[\$p+\$n_toc] = \$this->saveHTMLHeader[\$p]; }
\t\t\t\telse { \$newarr[\$p] = \$this->saveHTMLHeader[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->saveHTMLHeader = \$newarr;
\t\t}
\t\tif (count(\$this->saveHTMLFooter)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->saveHTMLFooter AS \$p=>\$v) {
\t\t\t\tif(\$p>=\$start_page && \$p<=\$end_page) { \$newarr[(\$p + (\$target_page - \$start_page))] = \$this->saveHTMLFooter[\$p]; }
\t\t\t\telse if(\$p>=\$target_page && \$p<\$start_page) { \$newarr[\$p+\$n_toc] = \$this->saveHTMLFooter[\$p]; }
\t\t\t\telse { \$newarr[\$p] = \$this->saveHTMLFooter[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->saveHTMLFooter = \$newarr;
\t\t}

\t\t// Update Internal Links
\t\tif (count(\$this->internallink)) {
\t\t   foreach(\$this->internallink as \$key=>\$o) {
\t\t\tif(\$o['PAGE']>=\$start_page && \$o['PAGE']<=\$end_page) {
\t\t\t\t\$this->internallink[\$key]['PAGE'] += (\$target_page - \$start_page);
\t\t\t}
\t\t\telse if(\$o['PAGE']>=\$target_page && \$o['PAGE']<\$start_page) {
\t\t\t\t\$this->internallink[\$key]['PAGE'] += \$n_toc;
\t\t\t}
\t\t   }
\t\t}

\t\t// Update Links
\t\tif (count(\$this->links)) {
\t\t   foreach(\$this->links as \$key=>\$o) {
\t\t\tif(\$o[0]>=\$start_page && \$o[0]<=\$end_page) {
\t\t\t\t\$this->links[\$key][0] += (\$target_page - \$start_page);
\t\t\t}
\t\t\tif(\$o[0]>=\$target_page && \$o[0]<\$start_page) {
\t\t\t\t\$this->links[\$key][0] += \$n_toc;
\t\t\t}
\t\t   }
\t\t}

\t\t// Update Form fields
\t\tif (count(\$this->form->forms)) {
\t\t   foreach(\$this->form->forms as \$key=>\$f) {
\t\t\tif(\$f['page']>=\$start_page && \$f['page']<=\$end_page) {
\t\t\t\t\$this->form->forms[\$key]['page'] += (\$target_page - \$start_page);
\t\t\t}
\t\t\tif(\$f['page']>=\$target_page && \$f['page']<\$start_page) {
\t\t\t\t\$this->form->forms[\$key]['page'] += \$n_toc;
\t\t\t}
\t\t   }
\t\t}

/*-- ANNOTATIONS --*/
\t\t// Update Annotations
\t\tif (count(\$this->PageAnnots)) {
\t\t   \$newarr = array();
\t\t   foreach(\$this->PageAnnots as \$p=>\$anno) {
\t\t\tif(\$p>=\$start_page && \$p<=\$end_page) {
\t\t\t\t\$np = \$p + (\$target_page - \$start_page);
\t\t\t\tforeach(\$anno as \$o) {
\t\t\t\t\t\$newarr[\$np][] = \$o;
\t\t\t\t}
\t\t\t}
\t\t\telse if(\$p>=\$target_page && \$p<\$start_page) {
\t\t\t\t\$np = \$p + \$n_toc;
\t\t\t\tforeach(\$anno as \$o) {
\t\t\t\t\t\$newarr[\$np][] = \$o;
\t\t\t\t}
\t\t      }
\t\t\telse {
\t\t\t\t\$newarr[\$p] = \$this->PageAnnots[\$p];
\t\t\t}
\t\t   }
\t\t   \$this->PageAnnots = \$newarr;
\t\t   unset(\$newarr);
\t\t}
/*-- END ANNOTATIONS --*/

\t\t// Update PageNumSubstitutions
\t\tif (count(\$this->PageNumSubstitutions)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->PageNumSubstitutions AS \$k=>\$v) {
\t\t\t\tif(\$this->PageNumSubstitutions[\$k]['from']>=\$start_page && \$this->PageNumSubstitutions[\$k]['from']<=\$end_page) {
\t\t\t\t\t\$this->PageNumSubstitutions[\$k]['from'] += (\$target_page - \$start_page);
\t\t\t\t\t\$newarr[\$this->PageNumSubstitutions[\$k]['from']] = \$this->PageNumSubstitutions[\$k];
\t\t\t\t}
\t\t\t\telse if(\$this->PageNumSubstitutions[\$k]['from']>=\$target_page && \$this->PageNumSubstitutions[\$k]['from']<\$start_page) {
\t\t\t\t\t\$this->PageNumSubstitutions[\$k]['from'] += \$n_toc;
\t\t\t\t\t\$newarr[\$this->PageNumSubstitutions[\$k]['from']] = \$this->PageNumSubstitutions[\$k];
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$newarr[\$this->PageNumSubstitutions[\$k]['from']] = \$this->PageNumSubstitutions[\$k];
\t\t\t\t}
\t\t\t}

\t\t\tif (!\$sp_present) {
\t\t\t\t\t\$newarr[\$target_page] = array('from'=>\$target_page, 'suppress'=>\$sp_suppress, 'reset'=>\$sp_reset, 'type'=>\$sp_type);
\t\t\t}
\t\t\tif (!\$tp_present) {
\t\t\t\t\t\$newarr[(\$target_page + \$n_toc)] = array('from'=>(\$target_page+\$n_toc), 'suppress'=>\$tp_suppress, 'reset'=>\$tp_reset, 'type'=>\$tp_type);
\t\t\t}
\t\t\tif (!\$ep_present && \$end_page>count(\$this->pages)) {
\t\t\t\t\t\$newarr[(\$end_page+1)] = array('from'=>(\$end_page+1), 'suppress'=>\$ep_suppress, 'reset'=>\$ep_reset, 'type'=>\$ep_type);
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->PageNumSubstitutions = array();
\t\t\tforeach(\$newarr as \$v) {
\t\t\t\t\$this->PageNumSubstitutions[] = \$v;
\t\t\t}
\t\t}
}

//======================================================
function DeletePages(\$start_page, \$end_page=-1) {
\t// move a page/pages EARLIER in the document
\t\tif (\$end_page<1) { \$end_page = \$start_page; }
\t\t\$n_tod = \$end_page - \$start_page + 1;
\t\t\$last_page = count(\$this->pages);
\t\t\$n_atend = \$last_page - \$end_page + 1;

\t\t//move pages
\t\tfor(\$i=0;\$i<\$n_atend;\$i++) {
\t\t\t\$this->pages[\$start_page+\$i]=\$this->pages[\$end_page+1+\$i];
\t\t}
\t\t//delete pages
\t\tfor(\$i = 0;\$i < \$n_tod ;\$i++)
\t\t\tunset(\$this->pages[\$last_page-\$i]);


/*-- BOOKMARKS --*/
\t\t// Update Bookmarks
\t\tforeach(\$this->BMoutlines as \$i=>\$o) {
\t\t\tif(\$o['p']>=\$end_page) { \$this->BMoutlines[\$i]['p'] -= \$n_tod; }
\t\t\telse if(\$p<\$start_page) { unset(\$this->BMoutlines[\$i]); }
\t\t}
/*-- END BOOKMARKS --*/

\t\t// Update Page Links
\t\tif (count(\$this->PageLinks)) {
\t\t   \$newarr = array();
\t\t   foreach(\$this->PageLinks as \$i=>\$o) {
\t\t\tforeach(\$this->PageLinks[\$i] as \$key => \$pl) {
\t\t\t\tif (strpos(\$pl[4],'@')===0) {
\t\t\t\t\t\$p=substr(\$pl[4],1);
\t\t\t\t\tif(\$p>\$end_page) { \$this->PageLinks[\$i][\$key][4] = '@'.(\$p - \$n_tod); }
\t\t\t\t\telse if(\$p<\$start_page) { unset(\$this->PageLinks[\$i][\$key]); }
\t\t\t\t}
\t\t\t}
\t\t\tif(\$i>\$end_page) { \$newarr[(\$i - \$n_tod)] = \$this->PageLinks[\$i]; }
\t\t\telse if(\$p<\$start_page) { \$newarr[\$i] = \$this->PageLinks[\$i]; }
\t\t   }
\t\t   \$this->PageLinks = \$newarr;
\t\t}

\t\t// OrientationChanges
\t\tif (count(\$this->OrientationChanges)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->OrientationChanges AS \$p=>\$v) {
\t\t\t\tif(\$p>\$end_page) { \$newarr[(\$p - \$t_tod)] = \$this->OrientationChanges[\$p]; }
\t\t\t\telse if(\$p<\$start_page) { \$newarr[\$p] = \$this->OrientationChanges[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->OrientationChanges = \$newarr;
\t\t}

\t\t// Page Dimensions
\t\tif (count(\$this->pageDim)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->pageDim AS \$p=>\$v) {
\t\t\t\tif(\$p>\$end_page) { \$newarr[(\$p - \$n_tod)] = \$this->pageDim[\$p]; }
\t\t\t\telse if(\$p<\$start_page) { \$newarr[\$p] = \$this->pageDim[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->pageDim = \$newarr;
\t\t}

\t\t// HTML Headers & Footers
\t\tif (count(\$this->saveHTMLHeader)) {
\t\t\tforeach(\$this->saveHTMLHeader AS \$p=>\$v) {
\t\t\t\tif(\$p>\$end_page) { \$newarr[(\$p - \$n_tod)] = \$this->saveHTMLHeader[\$p]; }\t// mPDF 5.7.3
\t\t\t\telse if(\$p<\$start_page) { \$newarr[\$p] = \$this->saveHTMLHeader[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->saveHTMLHeader = \$newarr;
\t\t}
\t\tif (count(\$this->saveHTMLFooter)) {
\t\t\t\$newarr = array();
\t\t\tforeach(\$this->saveHTMLFooter AS \$p=>\$v) {
\t\t\t\tif(\$p>\$end_page) { \$newarr[(\$p - \$n_tod)] = \$this->saveHTMLFooter[\$p]; }
\t\t\t\telse if(\$p<\$start_page) { \$newarr[\$p] = \$this->saveHTMLFooter[\$p]; }
\t\t\t}
\t\t\tksort(\$newarr);
\t\t\t\$this->saveHTMLFooter = \$newarr;
\t\t}

\t\t// Update Internal Links
\t\tforeach(\$this->internallink as \$key=>\$o) {
\t\t\tif(\$o['PAGE']>\$end_page) { \$this->internallink[\$key]['PAGE'] -= \$n_tod; }
\t\t\telse if(\$o['PAGE']<\$start_page) { unset(\$this->internallink[\$key]); }
\t\t}

\t\t// Update Links
\t\tforeach(\$this->links as \$key=>\$o) {
\t\t\tif(\$o[0]>\$end_page) { \$this->links[\$key][0] -= \$n_tod; }
\t\t\telse if(\$o[0]<\$start_page) { unset(\$this->links[\$key]); }
\t\t}

\t\t// Update Form fields
\t\tforeach(\$this->form->forms as \$key=>\$f) {
\t\t\tif(\$f['page']>\$end_page) { \$this->form->forms[\$key]['page'] -= \$n_tod; }
\t\t\telse if(\$f['page']<\$start_page) { unset(\$this->form->forms[\$key]); }
\t\t}

/*-- ANNOTATIONS --*/
\t\t// Update Annotations
\t\tif (count(\$this->PageAnnots)) {
\t\t   \$newarr = array();
\t\t   foreach(\$this->PageAnnots as \$p=>\$anno) {
\t\t\tif(\$p>\$end_page) { foreach(\$anno as \$o) { \$newarr[(\$p - \$n_tod)][] = \$o; } }
\t\t\telse if(\$p<\$start_page) { \$newarr[\$p] = \$this->PageAnnots[\$p]; }
\t\t   }
\t\t   ksort(\$newarr);
\t\t   \$this->PageAnnots = \$newarr;
\t\t}
/*-- END ANNOTATIONS --*/

\t\t// Update PageNumSubstitutions
\t\tforeach(\$this->PageNumSubstitutions AS \$k=>\$v) {
\t\t\tif(\$this->PageNumSubstitutions[\$k]['from']>\$end_page) { \$this->PageNumSubstitutions[\$k]['from'] -= \$n_tod; }
\t\t\telse if(\$this->PageNumSubstitutions[\$k]['from']<\$start_page) { unset(\$this->PageNumSubstitutions[\$k]); }
\t\t}

\tunset(\$newarr);
\t\$this->page = count(\$this->pages);
}


//======================================================
/*-- INDEX --*/
// FROM class PDF_Ref == INDEX

function Reference(\$txt) {
\t\$this->IndexEntry(\$txt);
}


function IndexEntry(\$txt, \$xref='') {
\tif (\$xref) {
\t\t\$this->IndexEntrySee(\$txt,\$xref);
\t\treturn;
\t}
\t\$txt = strip_tags(\$txt);
\t\$txt = \$this->purify_utf8_text(\$txt);
\tif (\$this->text_input_as_HTML) {
\t\t\$txt = \$this->all_entities_to_utf8(\$txt);
\t}
\tif (\$this->usingCoreFont) { \$txt = mb_convert_encoding(\$txt,\$this->mb_enc,'UTF-8'); }

\t\$Present=0;
\t\$size=sizeof(\$this->Reference);

\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\$txt = str_replace(':',' - ',\$txt);\t// *RTL*
\t}\t// *RTL*
\telse {\t// *RTL*
\t\t\$txt = str_replace(':',', ',\$txt);
\t}\t// *RTL*


\t//Search the reference (AND Ref/PageNo) in the array
\tfor (\$i=0;\$i<\$size;\$i++){
\t\tif (\$this->keep_block_together) {
\t\t\tif (isset(\$this->ktReference[\$i]['t']) && \$this->ktReference[\$i]['t']==\$txt){
\t\t\t\t\$Present=1;
\t\t\t\tif (\$this->page != \$this->ktReference[\$i]['op']) {\t// mPDF 5.7.2
\t\t\t\t\t\$this->ktReference[\$i]['op'] = \$this->page;
\t\t\t\t}
\t\t\t}
\t\t}
/*-- TABLES --*/
\t\telse if (\$this->table_rotate) {
\t\t\tif (isset(\$this->tbrot_Reference[\$i]['t']) && \$this->tbrot_Reference[\$i]['t']==\$txt){
\t\t\t\t\$Present=1;
\t\t\t\tif (\$this->page != \$this->tbrot_Reference[\$i]['op']) {\t// mPDF 5.7.2
\t\t\t\t\t\$this->tbrot_Reference[\$i]['op'] = \$this->page;
\t\t\t\t}
\t\t\t}
\t\t}
\t\telse if (\$this->kwt) {
\t\t\tif (isset(\$this->kwt_Reference[\$i]['t']) && \$this->kwt_Reference[\$i]['t']==\$txt){
\t\t\t\t\$Present=1;
\t\t\t\tif (\$this->page != \$this->kwt_Reference[\$i]['op']) {\t// mPDF 5.7.2
\t\t\t\t\t\$this->kwt_Reference[\$i]['op'] = \$this->page;
\t\t\t\t}
\t\t\t}
\t\t}
/*-- END TABLES --*/
/*-- COLUMNS --*/
\t\telse if (\$this->ColActive) {
\t\t\tif (isset(\$this->col_Reference[\$i]['t']) && \$this->col_Reference[\$i]['t']==\$txt){
\t\t\t\t\$Present=1;
\t\t\t\tif (\$this->page != \$this->col_Reference[\$i]['op']) {\t// mPDF 5.7.2
\t\t\t\t\t\$this->col_Reference[\$i]['op'] = \$this->page;
\t\t\t\t}
\t\t\t}
\t\t}
/*-- END COLUMNS --*/
\t\telse {
\t\t\tif (isset(\$this->Reference[\$i]['t']) && \$this->Reference[\$i]['t']==\$txt){
\t\t\t\t\$Present=1;
\t\t\t\tif (!in_array(\$this->page,\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$this->page;
\t\t\t\t}
\t\t\t}
\t\t}
\t}
\t//If not found, add it
\tif (\$Present==0) {
\t\t\$opr = array('t'=>\$txt, 'op'=>\$this->page);
\t\tif (\$this->keep_block_together) {
\t\t\t\$this->ktReference[]= \$opr;
\t\t}
/*-- TABLES --*/
\t\telse if (\$this->table_rotate) {
\t\t\t\$this->tbrot_Reference[]= \$opr;
\t\t}
\t\telse if (\$this->kwt) {
\t\t\t\$this->kwt_Reference[]= \$opr;
\t\t}
/*-- END TABLES --*/
/*-- COLUMNS --*/
\t\telse if (\$this->ColActive) {
\t\t\t\$this->col_Reference[]= \$opr;
\t\t}
/*-- END COLUMNS --*/
\t\telse {
\t\t\t\$this->Reference[]=array('t'=>\$txt,'p'=>array(\$this->page));
\t\t}
\t}
}

// Added function to add a reference \"Elephants. See Chickens\"
function ReferenceSee(\$txta,\$txtb) {
\t\$this->IndexEntrySee(\$txta,\$txtb);
}

function IndexEntrySee(\$txta,\$txtb) {
\t\$txta = strip_tags(\$txta);
\t\$txtb = strip_tags(\$txtb);
\t\$txta = \$this->purify_utf8_text(\$txta);
\t\$txtb = \$this->purify_utf8_text(\$txtb);
\tif (\$this->text_input_as_HTML) {
\t\t\$txta = \$this->all_entities_to_utf8(\$txta);
\t\t\$txtb = \$this->all_entities_to_utf8(\$txtb);
\t}
\tif (\$this->usingCoreFont) {
\t\t\$txta = mb_convert_encoding(\$txta,\$this->mb_enc,'UTF-8');
\t\t\$txtb = mb_convert_encoding(\$txtb,\$this->mb_enc,'UTF-8');
\t}
\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\$txta = str_replace(':',' - ',\$txta);\t// *RTL*
\t\t\$txtb = str_replace(':',' - ',\$txtb);\t// *RTL*
\t}\t// *RTL*
\telse {\t// *RTL*
\t\t\$txta = str_replace(':',', ',\$txta);
\t\t\$txtb = str_replace(':',', ',\$txtb);
\t}\t// *RTL*
\t\$this->Reference[]=array('t'=>\$txta.' - see '.\$txtb,'p'=>array());
}

function CreateReference(\$NbCol=1, \$reffontsize='', \$linespacing='', \$offset=3, \$usedivletters=1, \$divlettfontsize='', \$gap=5, \$reffont='',\$divlettfont='', \$useLinking=false) {
\t\$this->CreateIndex(\$NbCol, \$reffontsize, \$linespacing, \$offset, \$usedivletters, \$divlettfontsize, \$gap, \$reffont, \$divlettfont, \$useLinking);
}

function CreateIndex(\$NbCol=1, \$reffontsize='', \$linespacing='', \$offset=3, \$usedivletters=1, \$divlettfontsize='', \$gap=5, \$reffont='',\$divlettfont='', \$useLinking=false) {
\tif (!\$reffontsize) { \$reffontsize = \$this->default_font_size; }
\tif (!\$divlettfontsize) { \$divlettfontsize = (\$this->default_font_size * 1.8); }
\tif (!\$reffont) { \$reffont = \$this->default_font; }
\tif (!\$divlettfont) { \$divlettfont = \$reffont; }
\tif (!\$linespacing) { \$linespacing= \$this->default_lineheight_correction; }
\tif (\$this->ColActive) { \$this->SetColumns(0); }\t// *COLUMNS*
\t\$size=sizeof(\$this->Reference);
\tif (\$size == 0) { return false; }


\tif (\$NbCol<2) {
\t\t\$NbCol = 1;
\t\t\$colWidth = \$this->pgwidth;
\t}
\telse {
\t\t\$this->SetColumns(\$NbCol,'',\$gap);
\t\t\$colWidth = \$this->ColWidth;
\t}
\tif (\$this->directionality == 'rtl') { \$align = 'R'; }
\telse { \$align = 'L'; }
\t\$lett = '';
\tif (!function_exists('cmp')) {
\t\tfunction cmp (\$a, \$b) {
\t\t    return strnatcmp(strtolower(\$a['t']), strtolower(\$b['t']));
\t\t}
\t}
\t//Alphabetic sort of the references
\tusort(\$this->Reference, 'cmp');
\t\$size=sizeof(\$this->Reference);
\t\$this->breakpoints[\$this->CurrCol][] = \$this->y; \t// *COLUMNS*

\t\$divlettjuststarted = false;

\t\$this->OpenTag('DIV',array('STYLE'=>'line-height: '.\$linespacing.'; font-family: '.\$reffont.'; font-size: '.\$reffontsize.'pt; '));

\t\$last_lett = '';
\tfor (\$i=0;\$i<\$size;\$i++){
\t   \tif (\$this->Reference[\$i]['t']) {
\t\t\tif (\$usedivletters) {

\t\t\t   \$lett = mb_strtoupper(mb_substr(\$this->Reference[\$i]['t'],0,1,\$this->mb_enc ),\$this->mb_enc );
\t\t\t   if (\$lett != \$last_lett) {

\t\t\t\t\$save_bp = \$this->breakpoints[\$this->CurrCol]; \t// *COLUMNS*
\t\t\t\t\$divlettjuststarted = true;

\t\t\t\tif (\$i>0) {
\t\t\t\t\t\$this->OpenTag('DIV',array('STYLE'=>'line-height: '.\$linespacing.'; font-family: '.\$divlettfont.'; font-size: '.\$divlettfontsize.'pt; font-weight: bold; page-break-after: avoid; margin-top: 0.5em; margin-collapse: collapse; '));
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t\$this->OpenTag('DIV',array('STYLE'=>'line-height: '.\$linespacing.'; font-family: '.\$divlettfont.'; font-size: '.\$divlettfontsize.'pt; font-weight: bold; page-break-after: avoid; '));
\t\t\t\t}
\t\t\t\t\$this->_saveTextBuffer(\$lett);
\t\t\t\t\$this->CloseTag('DIV');
\t\t\t   }
\t\t\t}

\t\t\t\$this->OpenTag('DIV',array('STYLE'=>'text-indent: -'.\$offset.'mm; line-height: '.\$linespacing.'; font-family: '.\$reffont.'; font-size: '.\$reffontsize.'pt; '));

/*-- RTL --*/
\t\t\t// Change Arabic + Persian. to Presentation Forms
   \t\t\tif (\$this->biDirectional)  {
\t\t\t\t\$this->Reference[\$i]['t'] = preg_replace_callback(\"/([\".\$this->pregRTLchars.\"]+)/u\", array(\$this, 'arabJoinPregCallback'), \$this->Reference[\$i]['t'] );\t// mPDF 5.7+
\t\t\t}
/*-- END RTL --*/

\t\t\t// Font-specific ligature substitution for Indic fonts
\t\t\tif (isset(\$this->CurrentFont['indic']) && \$this->CurrentFont['indic']) \$this->ConvertIndic(\$this->Reference[\$i]['t']);\t// *INDIC*

\t\t\t\$this->_saveTextBuffer(\$this->Reference[\$i]['t']);
\t\t\t\$ppp = \$this->Reference[\$i]['p'];\t// = array of page numbers to point to
\t\t\tif (count(\$ppp)) {
\t\t\t sort(\$ppp);
\t\t\t \$newarr = array();
\t\t\t \$range_start = \$ppp[0];
\t\t\t \$range_end = 0;

\t\t\t if (!\$this->usingCoreFont) { \$spacer = \"\\xc2\\xa0 \"; }
\t\t\t else { \$spacer = chr(160).' '; }
\t\t\t \$this->_saveTextBuffer(\$spacer);
\t\t\t if (\$this->directionality == 'rtl') { \$sep = '.'; \$joiner = '-'; }
\t\t\t else { \$sep = ', '; \$joiner = '-'; }
\t\t\t for (\$zi=1;\$zi<count(\$ppp);\$zi++) {
\t\t\t  // RTL - Each number separately
   \t\t\t  if (\$this->directionality == 'rtl') {
/*-- RTL --*/
\t\t\t\tif (\$zi<count(\$ppp)-1) {
\t\t\t\t\t\$txt =  \$sep . \$this->docPageNum(\$ppp[\$zi]);
\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$ppp[\$zi]; }
\t\t\t\t\telse { \$href = ''; }
\t\t\t \t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t}
/*-- END RTL --*/
\t\t\t  }

\t\t\t  else if (\$ppp[\$zi] == (\$ppp[(\$zi-1)]+1)) {
\t\t\t\t\$range_end = \$ppp[\$zi];
\t\t\t  }
\t\t\t  else {
\t\t\t\tif (\$range_end) {
\t\t\t\t\tif (\$range_end == \$range_start+1) {
\t\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$range_start; }
\t\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t\t\$txt = \$this->docPageNum(\$range_start) . \$sep;
\t\t\t \t\t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$ppp[\$zi-1]; }
\t\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t\t\$txt = \$this->docPageNum(\$ppp[\$zi-1]) . \$sep;
\t\t\t \t\t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$range_start; }
\t\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t}
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$ppp[\$zi-1]; }
\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t\$txt = \$this->docPageNum(\$ppp[\$zi-1]) . \$sep;
\t\t\t \t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t}
\t\t\t\t\$range_start = \$ppp[\$zi];
\t\t\t\t\$range_end = 0;
\t\t\t  }
\t\t\t }

\t\t\t if (\$range_end) {
\t\t\t\tif (\$range_end == \$range_start+1) {
\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$range_start; }
\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t\$txt = \$this->docPageNum(\$range_start) . \$sep;
\t\t\t \t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$range_end; }
\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t\$txt = \$this->docPageNum(\$range_end);
\t\t\t \t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$range_start; }
\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t\$txt = \$this->docPageNum(\$range_start) . \$joiner;
\t\t\t \t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t\tif (\$useLinking) { \$href = '@'.\$range_end; }
\t\t\t\t\telse { \$href = ''; }
\t\t\t\t\t\$txt = \$this->docPageNum(\$range_end);
\t\t\t \t\t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t\t}
\t\t\t }
\t\t\t else {
\t\t\t\tif (\$useLinking) { \$href = '@'.\$ppp[(count(\$ppp)-1)]; }
\t\t\t\telse { \$href = ''; }
\t\t\t\t\$txt = \$this->docPageNum(\$ppp[(count(\$ppp)-1)]);
\t\t\t \t\$this->_saveTextBuffer(\$txt, \$href);
\t\t\t }
\t\t\t}
\t\t}
\t\t\$this->CloseTag('DIV');

\t\tif (\$divlettjuststarted) { \$this->breakpoints[\$this->CurrCol] = \$save_bp; } \t// *COLUMNS*
\t\t\$divlettjuststarted = false;

\t\t\$this->breakpoints[\$this->CurrCol][] = \$this->y; \t// *COLUMNS*
\t\t\$last_lett = \$lett;
\t}
\t\$this->CloseTag('DIV');
\t\$this->breakpoints[\$this->CurrCol][] = \$this->y; \t// *COLUMNS*
\tif (\$this->ColActive) { \$this->SetColumns(0);  }\t// *COLUMNS*
}
/*-- END INDEX --*/


function AcceptPageBreak() {
\tif (count(\$this->cellBorderBuffer)) { \$this->printcellbuffer(); }\t// *TABLES*
/*-- COLUMNS --*/
\tif (\$this->ColActive==1) {
\t    if(\$this->CurrCol<\$this->NbCol-1) {
        \t//Go to the next column
\t\t\$this->CurrCol++;
       \t\$this->SetCol(\$this->CurrCol);
\t\t\$this->y=\$this->y0;
       \t\$this->ChangeColumn=1;\t// Number (and direction) of columns changed +1, +2, -2 etc.
\t\t// DIRECTIONALITY RTL
\t\tif (\$this->directionality == 'rtl') { \$this->ChangeColumn = -(\$this->ChangeColumn); }\t// *RTL*

       \t//Stay on the page
        \treturn false;
\t   }
\t   else {
    \t\t//Go back to the first column - NEW PAGE
\t\tif (count(\$this->columnbuffer)) { \$this->printcolumnbuffer(); }
\t\t\$this->SetCol(0);
\t\t\$this->y0 = \$this->tMargin;
        \t\$this->ChangeColumn= -(\$this->NbCol-1);
\t\t// DIRECTIONALITY RTL
\t\tif (\$this->directionality == 'rtl') { \$this->ChangeColumn = -(\$this->ChangeColumn); }\t// *RTL*
        \t//Page break
       \treturn true;
\t   }
\t}
/*-- END COLUMNS --*/
/*-- TABLES --*/
\telse if (\$this->table_rotate) {
\t\tif (\$this->tablebuffer) { \$this->printtablebuffer(); }
\t\treturn true;
\t}
/*-- END TABLES --*/
\telse {\t// *COLUMNS*
        \t\$this->ChangeColumn=0;
\t\treturn \$this->autoPageBreak;
\t}\t// *COLUMNS*
\treturn \$this->autoPageBreak;
}


//----------- COLUMNS ---------------------
/*-- COLUMNS --*/

function SetColumns(\$NbCol,\$vAlign='',\$gap=5) {
// NbCol = number of columns
// CurrCol = Number of the current column starting at 0
// Called externally to set columns on/off and number
// Integer 2 upwards sets columns on to that number
// Anything less than 2 turns columns off
\tif (\$NbCol<2) {\t// SET COLUMNS OFF
\t\tif (\$this->ColActive) {
\t\t\t\$this->ColActive=0;
\t\t\tif (count(\$this->columnbuffer)) { \$this->printcolumnbuffer(); }
\t\t\t\$this->NbCol=1;
\t\t\t\$this->ResetMargins();
\t\t\t\$this->pgwidth = \$this->w - \$this->lMargin - \$this->rMargin;
\t\t\t\$this->divwidth = 0;
\t\t\t\$this->Ln();
\t\t}
\t\t\$this->ColActive=0;
\t\t\$this->columnbuffer = array();
\t\t\$this->ColDetails = array();
\t\t\$this->columnLinks = array();
\t\t\$this->columnAnnots = array();
\t\t\$this->columnForms = array();
\t\t\$this->col_Reference = array();
\t\t\$this->col_BMoutlines = array();
\t\t\$this->col_toc = array();
\t\t\$this->breakpoints = array();
\t}
\telse {\t// SET COLUMNS ON
\t\tif (\$this->ColActive) {
\t\t\t\$this->ColActive=0;
\t\t\tif (count(\$this->columnbuffer)) { \$this->printcolumnbuffer(); }
\t\t\t\$this->ResetMargins();
\t\t}
\t\tif (isset(\$this->y) && \$this->y>\$this->tMargin) \$this->Ln();
\t\t\$this->NbCol=\$NbCol;
\t\t\$this->ColGap = \$gap;
\t\t\$this->divwidth = 0;
\t\t\$this->ColActive=1;
\t\t\$this->ColumnAdjust = true;\t// enables column height adjustment for the page
\t\t\$this->columnbuffer = array();
\t\t\$this->ColDetails = array();
\t\t\$this->columnLinks = array();
\t\t\$this->columnAnnots = array();
\t\t\$this->columnForms = array();
\t\t\$this->col_Reference = array();
\t\t\$this->col_BMoutlines = array();
\t\t\$this->col_toc = array();
\t\t\$this->breakpoints = array();
\t\tif ((strtoupper(\$vAlign) == 'J') || (strtoupper(\$vAlign) == 'JUSTIFY')) { \$vAlign = 'J'; }
\t\telse { \$vAlign = ''; }
\t\t\$this->colvAlign = \$vAlign;
\t\t//Save the ordinate
\t\t\$absL = \$this->DeflMargin-(\$gap/2);
\t\t\$absR = \$this->DefrMargin-(\$gap/2);
\t\t\$PageWidth = \$this->w-\$absL-\$absR;\t// virtual pagewidth for calculation only
\t\t\$ColWidth = ((\$PageWidth - (\$gap * (\$NbCol)))/\$NbCol);
\t\t\$this->ColWidth = \$ColWidth;
/*-- RTL --*/

\t\tif (\$this->directionality == 'rtl') {
\t\t\tfor (\$i=0;\$i<\$this->NbCol;\$i++) {
\t\t\t\t\$this->ColL[\$i] = \$absL + (\$gap/2) + ((\$NbCol - (\$i+1))*(\$PageWidth/\$NbCol)) ;
\t\t\t\t\$this->ColR[\$i] = \$this->ColL[\$i] + \$ColWidth;\t// NB This is not R margin -> R pos
\t\t\t}
\t\t}
\t\telse {
/*-- END RTL --*/
\t\t\tfor (\$i=0;\$i<\$this->NbCol;\$i++) {
\t\t\t\t\$this->ColL[\$i] = \$absL + (\$gap/2) + (\$i* (\$PageWidth/\$NbCol)   );
\t\t\t\t\$this->ColR[\$i] = \$this->ColL[\$i] + \$ColWidth;\t// NB This is not R margin -> R pos
\t\t\t}
\t\t}\t// *RTL*
\t\t\$this->pgwidth = \$ColWidth;
\t\t\$this->SetCol(0);
\t\t\$this->y0=\$this->y;
\t}
\t\$this->x = \$this->lMargin;
}

function SetCol(\$CurrCol) {
// Used internally to set column by number: 0 is 1st column
\t//Set position on a column
\t\$this->CurrCol=\$CurrCol;
\t\$x = \$this->ColL[\$CurrCol];
\t\$xR = \$this->ColR[\$CurrCol];\t// NB This is not R margin -> R pos
\tif ((\$this->mirrorMargins) && ((\$this->page)%2==0)) {\t// EVEN
\t\t\$x += \$this->MarginCorrection ;
\t\t\$xR += \$this->MarginCorrection ;
\t}
\t\$this->SetMargins(\$x,(\$this->w - \$xR),\$this->tMargin);
}

function AddColumn() {
\t\$this->NewColumn();
\t\$this->ColumnAdjust = false;\t// disables all column height adjustment for the page.
}
function NewColumn() {
\tif (\$this->ColActive==1) {
\t    if(\$this->CurrCol<\$this->NbCol-1) {
        \t//Go to the next column
\t\t\$this->CurrCol++;
        \t\$this->SetCol(\$this->CurrCol);
        \t\$this->y = \$this->y0;
        \t\$this->ChangeColumn=1;
\t\t// DIRECTIONALITY RTL
\t\tif (\$this->directionality == 'rtl') { \$this->ChangeColumn = -(\$this->ChangeColumn); }\t// *RTL*
        \t//Stay on the page
    \t\t}
    \t\telse {
    \t\t//Go back to the first column
        \t//Page break
\t\tif (count(\$this->columnbuffer)) { \$this->printcolumnbuffer(); }
\t\t\$this->AddPage(\$this->CurOrientation);
\t\t\$this->SetCol(0);
\t\t\$this->y0 = \$this->tMargin;
        \t\$this->ChangeColumn= -(\$this->NbCol-1);
\t\t// DIRECTIONALITY RTL
\t\tif (\$this->directionality == 'rtl') { \$this->ChangeColumn = -(\$this->ChangeColumn); }\t// *RTL*
    \t\t}
\t\t\$this->x = \$this->lMargin;
\t}
\telse {
\t\t\$this->AddPage(\$this->CurOrientation);
\t}
}

function printcolumnbuffer() {
   // Columns ended (but page not ended) -> try to match all columns - unless disabled by using a custom column-break
   if (!\$this->ColActive && \$this->ColumnAdjust && !\$this->keepColumns) {\t// mPDF 5.7.2
\t// Calculate adjustment to add to each column to calculate rel_y value
\t\$this->ColDetails[0]['add_y'] = 0;
\t\$last_col = 0;
\t// Recursively add previous column's height
\tfor(\$i=1;\$i<\$this->NbCol;\$i++) {
\t\tif (isset(\$this->ColDetails[\$i]['bottom_margin']) && \$this->ColDetails[\$i]['bottom_margin']) { // If any entries in the column
\t\t\t\$this->ColDetails[\$i]['add_y'] = (\$this->ColDetails[\$i-1]['bottom_margin'] - \$this->y0) + \$this->ColDetails[\$i-1]['add_y'];
\t\t\t\$last_col = \$i; \t// Last column actually printed
\t\t}
\t}

\t// Calculate value for each position sensitive entry as though for one column
\tforeach(\$this->columnbuffer AS \$key=>\$s) {
\t\t\$t = \$s['s'];
\t\tif (\$t == 'ACROFORM') {
\t\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'] + \$this->ColDetails[\$s['col']]['add_y'] - \$this->y0;
\t\t\t\$this->columnbuffer[\$key]['s'] = '';
\t\t}
\t\telse if (preg_match('/BT \\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) Td/',\$t)) {
\t\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'] + \$this->ColDetails[\$s['col']]['add_y'] - \$this->y0;
\t\t}
\t\telse if (preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ [\\-]{0,1}\\d+\\.\\d\\d+ re/',\$t)) {
\t\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'] + \$this->ColDetails[\$s['col']]['add_y'] - \$this->y0;
\t\t}
\t\telse if (preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) m/',\$t)) {
\t\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'] + \$this->ColDetails[\$s['col']]['add_y'] - \$this->y0;
\t\t}
\t\telse if (preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) l/',\$t)) {
\t\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'] + \$this->ColDetails[\$s['col']]['add_y'] - \$this->y0;
\t\t}
\t\telse if (preg_match('/q \\d+\\.\\d\\d+ 0 0 \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) cm \\/(I|FO)\\d+ Do Q/',\$t)) {
\t\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'] + \$this->ColDetails[\$s['col']]['add_y'] - \$this->y0;
\t\t}
\t\telse if (preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ c/',\$t)) {
\t\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'] + \$this->ColDetails[\$s['col']]['add_y'] - \$this->y0;
\t\t}
\t}
\tforeach(\$this->internallink AS \$key => \$f) {
\t  if (is_array(\$f) && isset(\$f['col'])) {
\t\t\$this->internallink[\$key]['rel_y'] = \$f['Y'] + \$this->ColDetails[\$f['col']]['add_y'] - \$this->y0;
\t  }
\t}

\t\$breaks = array();
\tforeach(\$this->breakpoints AS \$c => \$bpa) {
\t\tforeach(\$bpa AS \$rely) {
\t\t\t\$breaks[] = \$rely + \$this->ColDetails[\$c]['add_y'] - \$this->y0;
\t\t}
\t}

\tif (isset(\$this->ColDetails[\$last_col]['bottom_margin'])) { \$lcbm = \$this->ColDetails[\$last_col]['bottom_margin']; }
\telse { \$lcbm = 0; }
\t\$sum_h = \$this->ColDetails[\$last_col]['add_y'] + \$lcbm - \$this->y0;
\t//\$sum_h = max(\$this->ColDetails[\$last_col]['add_y'] + \$this->ColDetails[\$last_col]['bottom_margin'] - \$this->y0, end(\$breaks));
\t\$target_h = (\$sum_h / \$this->NbCol);

\t\$cbr = array();
\tfor(\$i=1;\$i<\$this->NbCol;\$i++) {
\t\t\$th = (\$sum_h * \$i / \$this->NbCol);
\t\tforeach(\$breaks AS \$bk=>\$val) {
\t\t\tif (\$val > \$th) {
\t\t\t\tif ((\$val-\$th) < (\$th-\$breaks[\$bk-1])) { \$cbr[\$i-1] = \$val; }
\t\t\t\telse  { \$cbr[\$i-1] = \$breaks[\$bk-1]; }
\t\t\t\tbreak;
\t\t\t}
\t\t}
\t}
\t\$cbr[(\$this->NbCol-1)] = \$sum_h;

\t// Now update the columns - divide into columns of approximately equal value
\t\$last_new_col = 0;
\t\$yadj = 0;\t// mm
\t\$xadj = 0;
\t\$last_col_bottom = 0;
\t\$lowest_bottom_y = 0;
\t\$block_bottom = 0;
\t\$newcolumn = 0;
\tforeach(\$this->columnbuffer AS \$key=>\$s) {
\t  if (isset(\$s['rel_y'])) {\t// only process position sensitive data
\t\tif (\$s['rel_y'] >= \$cbr[\$newcolumn]) {
\t\t\t\$newcolumn++;
\t\t}
\t\telse {
\t\t\t\$newcolumn = \$last_new_col ;
\t\t}


\t\t\$block_bottom = max(\$block_bottom,(\$s['rel_y']+\$s['h']));

\t\tif (\$this->directionality == 'rtl') {\t// *RTL*
\t\t\t\$xadj = -((\$newcolumn - \$s['col']) * (\$this->ColWidth + \$this->ColGap));\t// *RTL*
\t\t}\t// *RTL*
\t\telse {\t// *RTL*
\t\t\t\$xadj = (\$newcolumn - \$s['col']) * (\$this->ColWidth + \$this->ColGap);
\t\t}\t// *RTL*

\t\tif (\$last_new_col != \$newcolumn) {\t// Added new column
\t\t\t\$last_col_bottom = \$this->columnbuffer[\$key]['rel_y'];
\t\t\t\$block_bottom = 0;
\t\t}
\t\t\$yadj = (\$s['rel_y'] - \$s['y']) - (\$last_col_bottom)+\$this->y0;
\t\t// callback function
\t\t\$t = \$s['s'];

\t\t// mPDF 5.7+
\t\t\$t = \$this->columnAdjustPregReplace('Td', \$xadj, \$yadj, '/BT (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) Td/', \$t);
\t\t\$t = \$this->columnAdjustPregReplace('re', \$xadj, \$yadj, '/(\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) ([\\-]{0,1}\\d+\\.\\d\\d+) re/', \$t);
\t\t\$t = \$this->columnAdjustPregReplace('l', \$xadj, \$yadj, '/(\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) l/', \$t);
\t\t\$t = \$this->columnAdjustPregReplace('img', \$xadj, \$yadj, '/q (\\d+\\.\\d\\d+) 0 0 (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) cm \\/(I|FO)/', \$t);
\t\t\$t = \$this->columnAdjustPregReplace('draw', \$xadj, \$yadj, '/(\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) m/', \$t);
\t\t\$t = \$this->columnAdjustPregReplace('bezier',\$xadj, \$yadj, '/(\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) (\\d+\\.\\d\\d+) c/', \$t);

\t\t\$this->columnbuffer[\$key]['s'] = \$t;
\t\t\$this->columnbuffer[\$key]['newcol'] = \$newcolumn;
\t\t\$this->columnbuffer[\$key]['newy'] = \$s['y'] + \$yadj;
\t\t\$last_new_col = \$newcolumn;
\t\t\$clb = \$s['y'] + \$yadj + \$s['h'] ;\t// bottom_margin of current
\t\tif ((isset(\$this->ColDetails[\$newcolumn]['max_bottom']) && \$clb > \$this->ColDetails[\$newcolumn]['max_bottom']) || (!isset(\$this->ColDetails[\$newcolumn]['max_bottom']) && \$clb)) { \$this->ColDetails[\$newcolumn]['max_bottom'] = \$clb; }
\t\tif (\$clb > \$lowest_bottom_y) { \$lowest_bottom_y = \$clb; }
\t\t// Adjust LINKS
\t\tif (isset(\$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->PageLinks[\$this->page][\$ref][0] += (\$xadj*_MPDFK);
\t\t\t\$this->PageLinks[\$this->page][\$ref][1] -= (\$yadj*_MPDFK);
\t\t\tunset(\$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t}
\t\t// Adjust FORM FIELDS
\t\tif (isset(\$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->form->forms[\$ref]['x'] += (\$xadj);
\t\t\t\$this->form->forms[\$ref]['y'] += (\$yadj);
\t\t\tunset(\$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t}
/*-- ANNOTATIONS --*/
\t\tif (isset(\$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\tif (\$this->PageAnnots[\$this->page][\$ref]['x'] < 0) {
\t\t\t\t \$this->PageAnnots[\$this->page][\$ref]['x'] -= (\$xadj);
\t\t\t}
\t\t\telse {
\t\t\t\t \$this->PageAnnots[\$this->page][\$ref]['x'] += (\$xadj);
\t\t\t}
\t\t\t\$this->PageAnnots[\$this->page][\$ref]['y'] += (\$yadj);\t// unlike PageLinks, Page annots has y values from top in mm
\t\t\tunset(\$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t}
/*-- END ANNOTATIONS --*/
\t  }
\t}

/*-- BOOKMARKS --*/
\t// Adjust Bookmarks
\tforeach(\$this->col_BMoutlines AS \$v) {
\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$this->y0,'p'=>\$v['p']);
\t}
/*-- END BOOKMARKS --*/

/*-- INDEX --*/
\t// Adjust Reference (index)
\tforeach(\$this->col_Reference AS \$v) {
\t\t\$Present=0;
\t\t//Search the reference (AND Ref/PageNo) in the array
\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\$Present=1;
\t\t\t\tif (!in_array(\$v['op'],\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$v['op'];
\t\t\t\t}
\t\t\t}
\t\t}
\t\tif (\$Present==0) {
\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$v['op']));
\t\t}
\t}
/*-- END INDEX --*/

/*-- TOC --*/

\t // Adjust ToC
\t foreach(\$this->col_toc AS \$v) {
\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$v['p'],'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t\t\$this->links[\$v['link']][1] = \$this->y0;
\t }
/*-- END TOC --*/

\t// Adjust column length to be equal
\tif (\$this->colvAlign == 'J') {
\t foreach(\$this->columnbuffer AS \$key=>\$s) {
\t   if (isset(\$s['rel_y'])) {\t// only process position sensitive data
\t    // Set ratio to expand y values or heights
\t    if (isset(\$this->ColDetails[\$s['newcol']]['max_bottom']) && \$this->ColDetails[\$s['newcol']]['max_bottom']  && \$this->ColDetails[\$s['newcol']]['max_bottom']!=\$this->y0) {
\t\t\$ratio = (\$lowest_bottom_y - (\$this->y0)) / (\$this->ColDetails[\$s['newcol']]['max_bottom'] - (\$this->y0));
\t    }
\t    else { \$ratio = 1; }
\t    if ((\$ratio > 1) && (\$ratio <= \$this->max_colH_correction)) {
\t\t\$yadj = (\$s['newy'] - \$this->y0) * (\$ratio - 1);

\t\t// Adjust LINKS
\t\tif (isset(\$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->PageLinks[\$this->page][\$ref][1] -= (\$yadj*_MPDFK);\t// y value
\t\t\t\$this->PageLinks[\$this->page][\$ref][3] *= \$ratio;\t// height
\t\t\tunset(\$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t}
\t\t// Adjust FORM FIELDS
\t\tif (isset(\$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->form->forms[\$ref]['x'] += (\$xadj);
\t\t\t\$this->form->forms[\$ref]['y'] += (\$yadj);
\t\t\tunset(\$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t}
/*-- ANNOTATIONS --*/
\t\tif (isset(\$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->PageAnnots[\$this->page][\$ref]['y'] += (\$yadj);
\t\t\tunset(\$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t}
/*-- END ANNOTATIONS --*/
\t    }
\t  }
\t }
\tforeach(\$this->internallink AS \$key => \$f) {
\t  if (is_array(\$f) && isset(\$f['col'])) {
\t\t\$last_col_bottom = 0;
\t\tfor (\$nbc=0; \$nbc<\$this->NbCol; \$nbc++) {
\t\t\tif (\$f['rel_y'] >= \$cbr[\$nbc]) { \$last_col_bottom = \$cbr[\$nbc]; }
\t\t}
\t\t\$yadj = (\$f['rel_y'] - \$f['Y']) - \$last_col_bottom + \$this->y0;
\t\t\$f['Y'] += \$yadj;
\t\tunset(\$f['col']);
\t\tunset(\$f['rel_y']);
\t\t\$this->internallink[\$key] = \$f;
\t  }
\t}

\t \$last_col = -1;
\t \$trans_on = false;
\t foreach(\$this->columnbuffer AS \$key=>\$s) {
\t\tif (isset(\$s['rel_y'])) {\t// only process position sensitive data
\t\t\t// Set ratio to expand y values or heights
\t\t\tif (isset(\$this->ColDetails[\$s['newcol']]['max_bottom']) && \$this->ColDetails[\$s['newcol']]['max_bottom']  && \$this->ColDetails[\$s['newcol']]['max_bottom']!=\$this->y0) {
\t\t\t\t\$ratio = (\$lowest_bottom_y - (\$this->y0)) / (\$this->ColDetails[\$s['newcol']]['max_bottom'] - (\$this->y0));
\t\t\t}
\t\t\telse { \$ratio = 1; }
\t\t\tif ((\$ratio > 1) && (\$ratio <= \$this->max_colH_correction)) {
\t\t\t\t//Start Transformation
\t\t\t\t\$this->pages[\$this->page] .= \$this->StartTransform(true).\"\\n\";
\t\t\t\t\$this->pages[\$this->page] .= \$this->transformScale(100, \$ratio*100, \$x='', \$this->y0, true).\"\\n\";
\t\t\t\t\$trans_on = true;
\t\t\t}
\t\t}
\t\t// Now output the adjusted values
\t\t\$this->pages[\$this->page] .= \$s['s'].\"\\n\";
\t\tif (isset(\$s['rel_y']) && (\$ratio > 1) && (\$ratio <= \$this->max_colH_correction)) {\t// only process position sensitive data
\t\t\t//Stop Transformation
\t\t\t\$this->pages[\$this->page] .= \$this->StopTransform(true).\"\\n\";
\t \t\t\$trans_on = false;
\t\t}
\t }
\t if (\$trans_on) { \$this->pages[\$this->page] .= \$this->StopTransform(true).\"\\n\"; }
\t}
\telse {\t// if NOT \$this->colvAlign == 'J'
\t\t// Now output the adjusted values
\t\tforeach(\$this->columnbuffer AS \$s) {
\t\t\t\$this->pages[\$this->page] .= \$s['s'].\"\\n\";
\t\t}
\t}
\tif (\$lowest_bottom_y > 0) { \$this->y = \$lowest_bottom_y ; }
   }

   // Columns not ended but new page -> align columns (can leave the columns alone - just tidy up the height)
   else if (\$this->colvAlign == 'J' && \$this->ColumnAdjust && !\$this->keepColumns)  {
\t// calculate the lowest bottom margin
\t\$lowest_bottom_y = 0;
\tforeach(\$this->columnbuffer AS \$key=>\$s) {
\t   // Only process output data
\t   \$t = \$s['s'];
\t   if (\$t == 'ACROFORM' || (preg_match('/BT \\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) Td/',\$t)) || (preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ [\\-]{0,1}\\d+\\.\\d\\d+ re/',\$t)) ||
\t\t(preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) l/',\$t)) ||
\t\t(preg_match('/q \\d+\\.\\d\\d+ 0 0 \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) cm \\/(I|FO)\\d+ Do Q/',\$t)) ||
\t\t(preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) m/',\$t)) ||
\t\t(preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ c/',\$t)) ) {

\t\t\$clb = \$s['y'] + \$s['h'];
\t\tif ((isset(\$this->ColDetails[\$s['col']]['max_bottom']) && \$clb > \$this->ColDetails[\$s['col']]['max_bottom']) || !isset(\$this->ColDetails[\$s['col']]['max_bottom'])) { \$this->ColDetails[\$s['col']]['max_bottom'] = \$clb; }
\t\tif (\$clb > \$lowest_bottom_y) { \$lowest_bottom_y = \$clb; }
\t\t\$this->columnbuffer[\$key]['rel_y'] = \$s['y'];\t// Marks position sensitive data to process later
\t\tif (\$t == 'ACROFORM') { \$this->columnbuffer[\$key]['s'] = ''; }
\t   }
\t}
\t// Adjust column length equal
\t foreach(\$this->columnbuffer AS \$key=>\$s) {
\t    // Set ratio to expand y values or heights
\t    if (isset(\$this->ColDetails[\$s['col']]['max_bottom']) && \$this->ColDetails[\$s['col']]['max_bottom']) {
\t\t\$ratio = (\$lowest_bottom_y - (\$this->y0)) / (\$this->ColDetails[\$s['col']]['max_bottom'] - (\$this->y0));
\t    }
\t    else { \$ratio = 1; }
\t    if ((\$ratio > 1) && (\$ratio <= \$this->max_colH_correction)) {
\t\t\$yadj = (\$s['y'] - \$this->y0) * (\$ratio - 1);

\t\t// Adjust LINKS
\t\tif (isset(\$s['rel_y'])) {\t// only process position sensitive data
\t\t   // otherwise triggers for all entries in column buffer (.e.g. formatting) and makes below adjustments more than once
\t\t   if (isset(\$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->PageLinks[\$this->page][\$ref][1] -= (\$yadj*_MPDFK);\t// y value
\t\t\t\$this->PageLinks[\$this->page][\$ref][3] *= \$ratio;\t// height
\t\t\tunset(\$this->columnLinks[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t   }
\t\t   // Adjust FORM FIELDS
\t\t   if (isset(\$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->form->forms[\$ref]['x'] += (\$xadj);
\t\t\t\$this->form->forms[\$ref]['y'] += (\$yadj);
\t\t\tunset(\$this->columnForms[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t   }
/*-- ANNOTATIONS --*/
\t\t   if (isset(\$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])])) {
\t\t\t\$ref = \$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])];
\t\t\t\$this->PageAnnots[\$this->page][\$ref]['y'] += (\$yadj);
\t\t\tunset(\$this->columnAnnots[\$s['col']][INTVAL(\$s['x'])][INTVAL(\$s['y'])]);
\t\t   }
/*-- END ANNOTATIONS --*/
\t\t}
\t    }
\t }

/*-- BOOKMARKS --*/

\t// Adjust Bookmarks
\tforeach(\$this->col_BMoutlines AS \$v) {
\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$this->y0,'p'=>\$v['p']);
\t}
/*-- END BOOKMARKS --*/

/*-- INDEX --*/

\t// Adjust Reference (index)
\tforeach(\$this->col_Reference AS \$v) {
\t\t\$Present=0;
\t\t//Search the reference (AND Ref/PageNo) in the array
\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\$Present=1;
\t\t\t\tif (!in_array(\$v['op'],\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$v['op'];
\t\t\t\t}
\t\t\t}
\t\t}
\t\tif (\$Present==0) {
\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$v['op']));
\t\t}
\t}
/*-- END INDEX --*/

/*-- TOC --*/

\t // Adjust ToC
\t foreach(\$this->col_toc AS \$v) {
\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$v['p'],'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t\t\$this->links[\$v['link']][1] = \$this->y0;
\t }
/*-- END TOC --*/
\t \$trans_on = false;
\t foreach(\$this->columnbuffer AS \$key=>\$s) {
\t\tif (isset(\$s['rel_y'])) {\t// only process position sensitive data
\t\t\t// Set ratio to expand y values or heights
\t\t\tif (\$this->ColDetails[\$s['col']]['max_bottom']) {
\t\t\t\t\$ratio = (\$lowest_bottom_y - (\$this->y0)) / (\$this->ColDetails[\$s['col']]['max_bottom'] - (\$this->y0));
\t\t\t}
\t\t\telse { \$ratio = 1; }
\t\t\tif ((\$ratio > 1) && (\$ratio <= \$this->max_colH_correction)) {
\t\t\t\t//Start Transformation
\t\t\t\t\$this->pages[\$this->page] .= \$this->StartTransform(true).\"\\n\";
\t\t\t\t\$this->pages[\$this->page] .= \$this->transformScale(100, \$ratio*100, \$x='', \$this->y0, true).\"\\n\";
\t \t\t\t\$trans_on = true;
\t\t\t}
\t\t}
\t\t// Now output the adjusted values
\t\t\$this->pages[\$this->page] .= \$s['s'].\"\\n\";
\t\tif (isset(\$s['rel_y']) && (\$ratio > 1) && (\$ratio <= \$this->max_colH_correction)) {
\t\t\t//Stop Transformation
\t\t\t\$this->pages[\$this->page] .= \$this->StopTransform(true).\"\\n\";
\t \t\t\$trans_on = false;\t// mPDF 5.1.001
\t\t}
\t }
\t if (\$trans_on) { \$this->pages[\$this->page] .= \$this->StopTransform(true).\"\\n\"; }

\tif (\$lowest_bottom_y > 0) { \$this->y = \$lowest_bottom_y ; }
   }


   // Just reproduce the page as it was
   else {
\t// If page has not ended but height adjustment was disabled by custom column-break - adjust y
\t\$lowest_bottom_y = 0;
\tif (!\$this->ColActive && (!\$this->ColumnAdjust || \$this->keepColumns)) {
\t\t// calculate the lowest bottom margin
\t\tforeach(\$this->columnbuffer AS \$key=>\$s) {
\t\t   // Only process output data
\t\t   \$t = \$s['s'];
\t\t   if (\$t == 'ACROFORM' || (preg_match('/BT \\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) Td/',\$t)) || (preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ [\\-]{0,1}\\d+\\.\\d\\d+ re/',\$t)) ||
\t\t\t(preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) l/',\$t)) ||
\t\t\t(preg_match('/q \\d+\\.\\d\\d+ 0 0 \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) cm \\/(I|FO)\\d+ Do Q/',\$t)) ||
\t\t\t(preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) m/',\$t)) ||
\t\t\t(preg_match('/\\d+\\.\\d\\d+ (\\d+\\.\\d\\d+) \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ \\d+\\.\\d\\d+ c/',\$t)) ) {

\t\t\t\$clb = \$s['y'] + \$s['h'];
\t\t\tif (\$clb > \$this->ColDetails[\$s['col']]['max_bottom']) { \$this->ColDetails[\$s['col']]['max_bottom'] = \$clb; }
\t\t\tif (\$clb > \$lowest_bottom_y) { \$lowest_bottom_y = \$clb; }
\t\t   }
\t\t}
\t}
\tforeach(\$this->columnbuffer AS \$key=>\$s) {
\t\tif (\$s['s'] != 'ACROFORM')
\t\t\t\$this->pages[\$this->page] .= \$s['s'].\"\\n\";
\t}
\tif (\$lowest_bottom_y > 0) { \$this->y = \$lowest_bottom_y ; }
/*-- INDEX --*/

\t// Output Reference (index)
\tforeach(\$this->col_Reference AS \$v) {
\t\t\$Present=0;
\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\$Present=1;
\t\t\t\tif (!in_array(\$v['op'],\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$v['op'];
\t\t\t\t}
\t\t\t}
\t\t}
\t\tif (\$Present==0) {
\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$v['op']));
\t\t}
     }
/*-- END INDEX --*/
/*-- BOOKMARKS --*/
      // Output Bookmarks
      foreach(\$this->col_BMoutlines AS \$v) {
\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$v['y'],'p'=>\$v['p']);
      }
/*-- END BOOKMARKS --*/
/*-- TOC --*/
      // Output ToC
      foreach(\$this->col_toc AS \$v) {
\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$v['p'],'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
      }
/*-- END TOC --*/
   }
   foreach(\$this->internallink AS \$key => \$f) {
\tif (isset(\$this->internallink[\$key]['col'])) unset(\$this->internallink[\$key]['col']);
\tif (isset(\$this->internallink[\$key]['rel_y'])) unset(\$this->internallink[\$key]['rel_y']);
   }

   \$this->columnbuffer = array();
   \$this->ColDetails = array();
   \$this->columnLinks = array();
   \$this->columnAnnots = array();
   \$this->columnForms = array();

   \$this->col_Reference = array();
   \$this->col_BMoutlines = array();
   \$this->col_toc = array();
   \$this->breakpoints = array();
}

// mPDF 5.7+
function columnAdjustPregReplace(\$type, \$xadj, \$yadj, \$pattern, \$subject) {
\tpreg_match(\$pattern, \$subject, \$matches);
\tif (!isset(\$matches[3])) { \$matches[3] = 0; }
\tif (!isset(\$matches[4])) { \$matches[4] = 0; }
\tif (!isset(\$matches[5])) { \$matches[5] = 0; }
\tif (!isset(\$matches[6])) { \$matches[6] = 0; }
\treturn str_replace(\$matches[0], \$this->columnAdjustAdd(\$type, _MPDFK, \$xadj, \$yadj, \$matches[1], \$matches[2], \$matches[3], \$matches[4], \$matches[5], \$matches[6]), \$subject);
}

/*-- END COLUMNS --*/


//==================================================================
/*-- TABLES --*/
function printcellbuffer() {
\tif (count(\$this->cellBorderBuffer )) {
\t\tsort(\$this->cellBorderBuffer);
\t\tforeach(\$this->cellBorderBuffer AS \$cbb) {
\t\t\t\$cba = unpack(\"A16dom/nbord/A1side/ns/dbw/a6ca/A10style/dx/dy/dw/dh/dmbl/dmbr/dmrt/dmrb/dmtl/dmtr/dmlt/dmlb/dcpd/dover/\", \$cbb);
\t\t\t\$side = \$cba['side'];
\t\t\t\$details = array();
\t\t\t\$details[\$side]['dom'] = (float) \$cba['dom'];
\t\t\t\$details[\$side]['s'] = \$cba['s'];
\t\t\t\$details[\$side]['w'] = \$cba['bw'];
\t\t\t\$details[\$side]['c'] = \$cba['ca'];
\t\t\t\$details[\$side]['style'] = trim(\$cba['style']);
\t\t\t\$details['mbw']['BL'] = \$cba['mbl'];
\t\t\t\$details['mbw']['BR'] = \$cba['mbr'];
\t\t\t\$details['mbw']['RT'] = \$cba['mrt'];
\t\t\t\$details['mbw']['RB'] = \$cba['mrb'];
\t\t\t\$details['mbw']['TL'] = \$cba['mtl'];
\t\t\t\$details['mbw']['TR'] = \$cba['mtr'];
\t\t\t\$details['mbw']['LT'] = \$cba['mlt'];
\t\t\t\$details['mbw']['LB'] = \$cba['mlb'];
\t\t\t\$details['cellposdom'] = \$cba['cpd'];
\t\t\t\$details['p'] = \$side;
\t\t\tif (\$cba['over']==1) { \$details[\$side]['overlay'] = true;  }
\t\t\telse { \$details[\$side]['overlay'] = false; }
\t\t\t\$this->_tableRect(\$cba['x'],\$cba['y'],\$cba['w'],\$cba['h'],\$cba['bord'],\$details, false, false);

\t\t}
\t\t\$this->cellBorderBuffer = array();
\t}
}
//==================================================================
function printtablebuffer() {

\tif (!\$this->table_rotate) {
\t\t\$this->pages[\$this->page] .= \$this->tablebuffer;
\t\tforeach(\$this->tbrot_Links AS \$p => \$l) {
\t\t   foreach(\$l AS \$v) {
\t\t\t\$this->PageLinks[\$p][] = \$v;
\t\t   }
\t\t}
\t\t\$this->tbrot_Links = array();
/*-- ANNOTATIONS --*/
\t\tforeach(\$this->tbrot_Annots AS \$p => \$l) {
\t\t   foreach(\$l AS \$v) {
\t\t\t\$this->PageAnnots[\$p][] = \$v;
\t\t   }
\t\t}
\t\t\$this->tbrot_Annots = array();
/*-- END ANNOTATIONS --*/

/*-- INDEX --*/
\t      // Output Reference (index)
\t      foreach(\$this->tbrot_Reference AS \$v) {
\t\t\t\$Present=0;
\t\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\t\$Present=1;
\t\t\t\t\tif (!in_array(\$v['op'],\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$v['op'];
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\tif (\$Present==0) {
\t\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$v['op']));
\t\t\t}
\t      }
\t\t\$this->tbrot_Reference = array();
/*-- END INDEX --*/

/*-- BOOKMARKS --*/
\t      // Output Bookmarks
\t      foreach(\$this->tbrot_BMoutlines AS \$v) {
\t\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$v['y'],'p'=>\$v['p']);
\t      }
\t\t\$this->tbrot_BMoutlines = array();
/*-- END BOOKMARKS --*/

/*-- TOC --*/
\t      // Output ToC
\t      foreach(\$this->tbrot_toc AS \$v) {
\t\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$v['p'],'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t      }
\t\t\$this->tbrot_toc = array();
/*-- END TOC --*/

\t\treturn;
\t}
\t// else if rotated
\t\$lm = \$this->lMargin + \$this->blk[\$this->blklvl]['outer_left_margin'] + \$this->blk[\$this->blklvl]['border_left']['w'] + \$this->blk[\$this->blklvl]['padding_left'];
\t\$pw = \$this->blk[\$this->blklvl]['inner_width'];
\t//Start Transformation
\t\$this->pages[\$this->page] .= \$this->StartTransform(true).\"\\n\";

\tif (\$this->table_rotate > 1) {\t// clockwise
\t   if (\$this->tbrot_align == 'L') {
\t\t\$xadj = \$this->tbrot_h ;\t// align L (as is)
\t   }
\t   else if (\$this->tbrot_align == 'R') {
\t\t\$xadj = \$lm-\$this->tbrot_x0+(\$pw) ;\t// align R
\t   }
\t   else {
\t\t\$xadj = \$lm-\$this->tbrot_x0+((\$pw + \$this->tbrot_h)/2) ;\t// align C
\t   }
\t   \$yadj = 0;
\t}
\telse {\t// anti-clockwise
\t   if (\$this->tbrot_align == 'L') {
\t\t\$xadj = 0 ;\t// align L (as is)
\t   }
\t   else if (\$this->tbrot_align == 'R') {
\t\t\$xadj = \$lm-\$this->tbrot_x0+(\$pw - \$this->tbrot_h) ;\t// align R
\t   }
\t   else {
\t\t\$xadj = \$lm-\$this->tbrot_x0+((\$pw - \$this->tbrot_h)/2) ;\t// align C
\t   }
\t   \$yadj = \$this->tbrot_w;
\t}


\t\$this->pages[\$this->page] .= \$this->transformTranslate(\$xadj, \$yadj , true).\"\\n\";
\t\$this->pages[\$this->page] .= \$this->transformRotate(\$this->table_rotate, \$this->tbrot_x0 , \$this->tbrot_y0 , true).\"\\n\";

\t// Now output the adjusted values
\t\$this->pages[\$this->page] .= \$this->tablebuffer;


\tforeach(\$this->tbrot_Links AS \$p => \$l) {
\t    foreach(\$l AS \$v) {
\t\t\$w = \$v[2]/_MPDFK;
\t\t\$h = \$v[3]/_MPDFK;
\t\t\$ax = (\$v[0]/_MPDFK) - \$this->tbrot_x0;
\t\t\$ay = ((\$this->hPt-\$v[1])/_MPDFK) - \$this->tbrot_y0;
\t\tif (\$this->table_rotate > 1) {\t// clockwise
\t\t\t\$bx = \$this->tbrot_x0+\$xadj-\$ay-\$h;
\t\t\t\$by = \$this->tbrot_y0+\$yadj+\$ax;
\t\t}
\t\telse {
\t\t\t\$bx = \$this->tbrot_x0+\$xadj+\$ay;
\t\t\t\$by = \$this->tbrot_y0+\$yadj-\$ax-\$w;
\t\t}
\t\t\$v[0] = \$bx*_MPDFK;
\t\t\$v[1] = (\$this->h-\$by)*_MPDFK;
\t\t\$v[2] = \$h*_MPDFK;\t// swap width and height
\t\t\$v[3] = \$w*_MPDFK;
\t\t\$this->PageLinks[\$p][] = \$v;
\t    }
\t}
\t\$this->tbrot_Links = array();
\tforeach(\$this->internallink AS \$key => \$f) {
\t\tif (is_array(\$f) && isset(\$f['tbrot'])) {
\t\t\t\$f['Y'] = \$this->tbrot_y0;
\t\t\t\$f['PAGE'] = \$this->page;
\t\t\tunset(\$f['tbrot']);
\t\t\t\$this->internallink[\$key] = \$f;
\t\t}
\t}
/*-- ANNOTATIONS --*/
\tforeach(\$this->tbrot_Annots AS \$p => \$l) {
\t    foreach(\$l AS \$v) {
\t\t\$ax = abs(\$v['x']) - \$this->tbrot_x0;\t// abs because -ve values are internally set and held for reference if annotMargin set
\t\t\$ay = \$v['y'] - \$this->tbrot_y0;
\t\tif (\$this->table_rotate > 1) {\t// clockwise
\t\t\t\$bx = \$this->tbrot_x0+\$xadj-\$ay;
\t\t\t\$by = \$this->tbrot_y0+\$yadj+\$ax;
\t\t}
\t\telse {
\t\t\t\$bx = \$this->tbrot_x0+\$xadj+\$ay;
\t\t\t\$by = \$this->tbrot_y0+\$yadj-\$ax;
\t\t}
\t\tif (\$v['x'] < 0) {
\t\t\t\$v['x'] = -\$bx;
\t\t}
\t\telse {
\t\t\t\$v['x'] = \$bx;
\t\t}
\t\t\$v['y'] = (\$by);
\t\t\$this->PageAnnots[\$p][] = \$v;
\t    }
\t}
\t\$this->tbrot_Annots = array();
/*-- END ANNOTATIONS --*/


/*-- BOOKMARKS --*/

\t// Adjust Bookmarks
\tforeach(\$this->tbrot_BMoutlines AS \$v) {
\t\t\$v['y'] = \$this->tbrot_y0;
\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$v['y'],'p'=>\$this->page);
\t}
/*-- END BOOKMARKS --*/

/*-- INDEX --*/

\t// Adjust Reference (index)
\tforeach(\$this->tbrot_Reference AS \$v) {
\t\t\$Present=0;
\t\t//Search the reference (AND Ref/PageNo) in the array
\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\$Present=1;
\t\t\t\tif (!in_array(\$this->page,\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$this->page;
\t\t\t\t}
\t\t\t}
\t\t}
\t\tif (\$Present==0) {
\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$this->page));
\t\t}
\t}
/*-- END INDEX --*/

/*-- TOC --*/

\t// Adjust ToC - uses document page number
\tforeach(\$this->tbrot_toc AS \$v) {
\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$this->page,'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t\t\$this->links[\$v['link']][1] = \$this->tbrot_y0;
\t}
/*-- END TOC --*/



\t\$this->tbrot_Reference = array();
\t\$this->tbrot_BMoutlines = array();
\t\$this->tbrot_toc = array();

\t//Stop Transformation
\t\$this->pages[\$this->page] .= \$this->StopTransform(true).\"\\n\";


\t\$this->y = \$this->tbrot_y0 + \$this->tbrot_w;
\t\$this->x = \$this->lMargin;

\t\$this->tablebuffer = '';
}

//==================================================================
// Keep-with-table This buffers contents of h1-6 to keep on page with table
function printkwtbuffer() {
\tif (!\$this->kwt_moved) {
\t\tforeach(\$this->kwt_buffer AS \$s) { \$this->pages[\$this->page] .= \$s['s'].\"\\n\"; }
\t\tforeach(\$this->kwt_Links AS \$p => \$l) {
\t\t   foreach(\$l AS \$v) {
\t\t\t\$this->PageLinks[\$p][] = \$v;
\t\t   }
\t\t}
\t\t\$this->kwt_Links = array();
/*-- ANNOTATIONS --*/
\t\tforeach(\$this->kwt_Annots AS \$p => \$l) {
\t\t   foreach(\$l AS \$v) {
\t\t\t\$this->PageAnnots[\$p][] = \$v;
\t\t   }
\t\t}
\t\t\$this->kwt_Annots = array();
/*-- END ANNOTATIONS --*/

/*-- INDEX --*/
\t      // Output Reference (index)
\t      foreach(\$this->kwt_Reference AS \$v) {
\t\t\t\$Present=0;
\t\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\t\$Present=1;
\t\t\t\t\tif (!in_array(\$v['op'],\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$v['op'];
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\tif (\$Present==0) {
\t\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$v['op']));
\t\t\t}
\t      }
\t\t\$this->kwt_Reference = array();
/*-- END INDEX --*/

/*-- BOOKMARKS --*/
\t      // Output Bookmarks
\t      foreach(\$this->kwt_BMoutlines AS \$v) {
\t\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$v['y'],'p'=>\$v['p']);
\t      }
\t\t\$this->kwt_BMoutlines = array();
/*-- END BOOKMARKS --*/

/*-- TOC --*/
\t      // Output ToC
\t      foreach(\$this->kwt_toc AS \$v) {
\t\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$v['p'],'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t      }
\t\t\$this->kwt_toc = array();
/*-- END TOC --*/

\t\treturn;
\t}

\t//Start Transformation
\t\$this->pages[\$this->page] .= \$this->StartTransform(true).\"\\n\";
\t\$xadj = \$this->lMargin - \$this->kwt_x0 ;
\t//\$yadj = \$this->y - \$this->kwt_y0 ;
\t\$yadj = \$this->tMargin - \$this->kwt_y0 ;

\t\$this->pages[\$this->page] .= \$this->transformTranslate(\$xadj, \$yadj , true).\"\\n\";

\t// Now output the adjusted values
\tforeach(\$this->kwt_buffer AS \$s) { \$this->pages[\$this->page] .= \$s['s'].\"\\n\"; }

\t// Adjust hyperLinks
\tforeach(\$this->kwt_Links AS \$p => \$l) {
\t    foreach(\$l AS \$v) {
\t\t\$bx = \$this->kwt_x0+\$xadj;
\t\t\$by = \$this->kwt_y0+\$yadj;
\t\t\$v[0] = \$bx*_MPDFK;
\t\t\$v[1] = (\$this->h-\$by)*_MPDFK;
\t\t\$this->PageLinks[\$p][] = \$v;
\t    }
\t}
\tforeach(\$this->internallink AS \$key => \$f) {
\t\tif (is_array(\$f) && isset(\$f['kwt'])) {
\t\t\t\$f['Y'] += \$yadj;
\t\t\t\$f['PAGE'] = \$this->page;
\t\t\tunset(\$f['kwt']);
\t\t\t\$this->internallink[\$key] = \$f;
\t\t}
\t}
/*-- ANNOTATIONS --*/
\tforeach(\$this->kwt_Annots AS \$p => \$l) {
\t    foreach(\$l AS \$v) {
\t\t\$bx = \$this->kwt_x0+\$xadj;
\t\t\$by = \$this->kwt_y0+\$yadj;
\t\tif (\$v['x'] < 0) {
\t\t\t\$v['x'] = -\$bx;
\t\t}
\t\telse {
\t\t\t\$v['x'] = \$bx;
\t\t}
\t\t\$v['y'] = \$by;
\t\t\$this->PageAnnots[\$p][] = \$v;
\t    }
\t}
/*-- END ANNOTATIONS --*/

/*-- BOOKMARKS --*/

\t// Adjust Bookmarks
\tforeach(\$this->kwt_BMoutlines AS \$v) {
\t\tif (\$v['y'] != 0) { \$v['y'] += \$yadj; }
\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$v['y'],'p'=>\$this->page);
\t}
/*-- END BOOKMARKS --*/

/*-- INDEX --*/

\t// Adjust Reference (index)
\tforeach(\$this->kwt_Reference AS \$v) {
\t\t\$Present=0;
\t\t//Search the reference (AND Ref/PageNo) in the array
\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\$Present=1;
\t\t\t\tif (!in_array(\$this->page,\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$this->page;
\t\t\t\t}
\t\t\t}
\t\t}
\t\tif (\$Present==0) {
\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$this->page));
\t\t}
\t}
/*-- END INDEX --*/

/*-- TOC --*/

\t// Adjust ToC
\tforeach(\$this->kwt_toc AS \$v) {
\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$this->page,'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t\t\$this->links[\$v['link']][0] = \$this->page;
\t\t\$this->links[\$v['link']][1] += \$yadj;
\t}
/*-- END TOC --*/


\t\$this->kwt_Links = array();
\t\$this->kwt_Annots = array();

\t\$this->kwt_Reference = array();
\t\$this->kwt_BMoutlines = array();
\t\$this->kwt_toc = array();
\t//Stop Transformation
\t\$this->pages[\$this->page] .= \$this->StopTransform(true).\"\\n\";

\t\$this->kwt_buffer = array();

\t\$this->y += \$this->kwt_height;
}

/*-- END TABLES --*/


//==================================================================

function printfloatbuffer() {
\tif (count(\$this->floatbuffer)) {
\t\t\$this->objectbuffer = \$this->floatbuffer;
\t\t\$this->printobjectbuffer(false);
\t\t\$this->objectbuffer = array();
\t\t\$this->floatbuffer = array();
\t\t\$this->floatmargins = array();
\t}
}
//==================================================================

function printdivbuffer() {
\t\$p1 = \$this->blk[\$this->blklvl]['startpage'];
\t\$p2 = \$this->page;
\t\$bottom[\$p1] = \$this->ktBlock[\$p1]['bottom_margin'];
\t\$bottom[\$p2] = \$this->y;\t// \$this->ktBlock[\$p2]['bottom_margin'];
\t\$top[\$p1] = \$this->kt_y00;

\t\$top2 = \$this->h;
\tforeach(\$this->divbuffer AS \$key=>\$s) {
\t\tif (\$s['page'] == \$p2) {
\t\t\t\$top2 = MIN(\$s['y'], \$top2);
\t\t}
\t}
\t\$top[\$p2] = \$top2;
\t\$height[\$p1] = (\$bottom[\$p1] - \$top[\$p1]);
\t\$height[\$p2] = (\$bottom[\$p2] - \$top[\$p2]);
\t\$xadj[\$p1] = \$this->MarginCorrection;
\t\$yadj[\$p1] = -(\$top[\$p1] - \$top[\$p2]);
\t\$xadj[\$p2] = 0;
\t\$yadj[\$p2] = \$height[\$p1];

\t// Output without any transformation
\tif (\$this->ColActive || !\$this->keep_block_together || \$this->blk[\$this->blklvl]['startpage'] == \$this->page || (\$this->page - \$this->blk[\$this->blklvl]['startpage']) > 1 || (\$height[\$p1]+\$height[\$p2]) > \$this->h) {
\t\tforeach(\$this->divbuffer AS \$s) { \$this->pages[\$s['page']] .= \$s['s'].\"\\n\"; }
\t\tforeach(\$this->ktLinks AS \$p => \$l) {
\t\t   foreach(\$l AS \$v) {
\t\t\t\$this->PageLinks[\$p][] = \$v;
\t\t   }
\t\t}
\t\tforeach(\$this->ktForms AS \$key => \$f) {
\t\t\t\$this->form->forms[\$f['n']] = \$f;
\t\t}
/*-- ANNOTATIONS --*/
\t\tforeach(\$this->ktAnnots AS \$p => \$l) {
\t\t   foreach(\$l AS \$v) {
\t\t\t\$this->PageAnnots[\$p][] = \$v;
\t\t   }
\t\t}
/*-- END ANNOTATIONS --*/
/*-- INDEX --*/
\t      // Adjust Reference (index)
\t      foreach(\$this->ktReference AS \$v) {
\t\t\t\$Present=0;
\t\t\t//Search the reference (AND Ref/PageNo) in the array
\t\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\t\$Present=1;
\t\t\t\t\tif (!in_array(\$p2,\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$p2;
\t\t\t\t\t}
\t\t\t\t}
\t\t\t}
\t\t\t//If not found, add it
\t\t\tif (\$Present==0) {
\t\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$p2));
\t\t\t}
\t      }
/*-- END INDEX --*/

/*-- BOOKMARKS --*/
\t      // Adjust Bookmarks
\t      foreach(\$this->ktBMoutlines AS \$v) {
\t\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$v['y'],'p'=>\$v['p']);
\t      }
/*-- END BOOKMARKS --*/

/*-- TOC --*/
\t      // Adjust ToC
\t      foreach(\$this->_kttoc AS \$v) {
\t\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$v['p'],'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t      }
/*-- END TOC --*/

\t\t\$this->divbuffer = array();
\t\t\$this->ktLinks = array();
\t\t\$this->ktAnnots = array();
\t\t\$this->ktForms = array();
\t\t\$this->ktBlock = array();
\t\t\$this->ktReference = array();
\t\t\$this->ktBMoutlines = array();
\t\t\$this->_kttoc = array();
\t\t\$this->keep_block_together = 0;
\t\treturn;
\t}
\telse {
\t// Output with transformation
\t   // mPDF 5.6.17
\t   \$np = '';
\t   \$lastpage = -1;
\t   foreach(\$this->divbuffer AS \$key=>\$s) {
\t\t// callback function
\t\t\$t = \$s['s'];
\t\t\$p = \$s['page'];
\t\tif (\$p != \$lastpage) {
\t\t\t\$q = '';
\t\t\tif (\$lastpage != -1) { \$q =  ' Q'.\"\\n\"; }
\t\t\t\$t = \$q . \$this->StartTransform(true).\"\\n\" . \$this->transformTranslate(\$xadj[\$p], \$yadj[\$p] , true).\"\\n\" . \$t;
\t\t\t\$lastpage = \$p;
\t\t}
\t\t\$np .= \$t.\"\\n\";
\t   }
\t   if (\$lastpage != -1) { \$np .=  ' Q'.\"\\n\"; }

\t   \$this->pages[\$this->page] .= \$np;

\t   // Adjust hyperLinks
\t   foreach(\$this->ktLinks AS \$p => \$l) {
\t    foreach(\$l AS \$v) {
\t\t\$v[0] += (\$xadj[\$p]*_MPDFK);
\t\t\$v[1] -= (\$yadj[\$p]*_MPDFK);
\t\t\$this->PageLinks[\$p2][] = \$v;
\t    }
\t   }
\t   foreach(\$this->ktForms AS \$key => \$f) {
\t\t\$p = \$f['page'];
\t\t\$f['x'] += (\$xadj[\$p]);
\t\t\$f['y'] += (\$yadj[\$p]);
\t\t\$f['page'] = \$p2;
\t\t\$this->form->forms[\$f['n']] = \$f;
\t   }
\t   foreach(\$this->internallink AS \$key => \$f) {
\t\tif (is_array(\$f) && isset(\$f['kt'])) {
\t\t\t\$f['Y'] += (\$yadj[\$f['PAGE']]);
\t\t\t\$f['PAGE'] = \$p2;
\t\t\tunset(\$f['kt']);
\t\t\t\$this->internallink[\$key] = \$f;
\t\t}
\t   }
/*-- ANNOTATIONS --*/
\t   foreach(\$this->ktAnnots AS \$p => \$l) {
\t    foreach(\$l AS \$v) {
\t\tif (\$v['x']>0) { \$v['x'] += \$xadj[\$p]; }
\t\telse if (\$v['x']<0) { \$v['x'] -= \$xadj[\$p]; }
\t\t\$v['y'] += \$yadj[\$p];
\t\t\$this->PageAnnots[\$p2][] = \$v;
\t    }
\t   }
/*-- END ANNOTATIONS --*/

/*-- BOOKMARKS --*/
\t   // Adjust Bookmarks
\t   foreach(\$this->ktBMoutlines AS \$v) {
\t\tif (\$v['y'] != 0) { \$v['y'] += (\$yadj[\$v['p']]); }
\t\t\$this->BMoutlines[]=array('t'=>\$v['t'],'l'=>\$v['l'],'y'=>\$v['y'],'p'=>\$p2);
\t   }
/*-- END BOOKMARKS --*/

/*-- INDEX --*/
\t   // Adjust Reference (index)
\t   foreach(\$this->ktReference AS \$v) {
\t\t\$Present=0;
\t\t//Search the reference (AND Ref/PageNo) in the array
\t\tfor (\$i=0;\$i<count(\$this->Reference);\$i++){
\t\t\tif (\$this->Reference[\$i]['t']==\$v['t']){
\t\t\t\t\$Present=1;
\t\t\t\tif (!in_array(\$p2,\$this->Reference[\$i]['p'])) {
\t\t\t\t\t\$this->Reference[\$i]['p'][] = \$p2;
\t\t\t\t}
\t\t\t}
\t\t}
\t\t//If not found, add it
\t\tif (\$Present==0) {
\t\t\t\$this->Reference[]=array('t'=>\$v['t'],'p'=>array(\$p2));
\t\t}
\t   }
/*-- END INDEX --*/

/*-- TOC --*/
\t   // Adjust ToC
\t   foreach(\$this->_kttoc AS \$v) {
\t\t\$this->tocontents->_toc[]=array('t'=>\$v['t'],'l'=>\$v['l'],'p'=>\$p2,'link'=>\$v['link'],'toc_id'=>\$v['toc_id']);
\t\t\$this->links[\$v['link']][0] = \$p2;
\t\t\$this->links[\$v['link']][1] += \$yadj[\$v['p']];
\t   }
/*-- END TOC --*/

\t   \$this->y = \$top[\$p2] + \$height[\$p1] + \$height[\$p2];
\t   \$this->x = \$this->lMargin;

\t   \$this->divbuffer = array();
\t   \$this->ktLinks = array();
\t   \$this->ktAnnots = array();
\t   \$this->ktForms = array();
\t   \$this->ktBlock = array();
\t   \$this->ktReference = array();
\t   \$this->ktBMoutlines = array();
\t   \$this->_kttoc = array();
\t   \$this->keep_block_together = 0;
\t}
}


//==================================================================
// Added ELLIPSES and CIRCLES
function Circle(\$x,\$y,\$r,\$style='S') {
\t\$this->Ellipse(\$x,\$y,\$r,\$r,\$style);
}

function Ellipse(\$x,\$y,\$rx,\$ry,\$style='S') {
\tif(\$style=='F') { \$op='f'; }
\telseif(\$style=='FD' or \$style=='DF') { \$op='B'; }
\telse { \$op='S'; }
\t\$lx=4/3*(M_SQRT2-1)*\$rx;
\t\$ly=4/3*(M_SQRT2-1)*\$ry;
\t\$h=\$this->h;
\t\$this->_out(sprintf('%.3F %.3F m %.3F %.3F %.3F %.3F %.3F %.3F c', (\$x+\$rx)*_MPDFK,(\$h-\$y)*_MPDFK, (\$x+\$rx)*_MPDFK,(\$h-(\$y-\$ly))*_MPDFK, (\$x+\$lx)*_MPDFK,(\$h-(\$y-\$ry))*_MPDFK, \$x*_MPDFK,(\$h-(\$y-\$ry))*_MPDFK));
\t\$this->_out(sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c', (\$x-\$lx)*_MPDFK,(\$h-(\$y-\$ry))*_MPDFK, \t(\$x-\$rx)*_MPDFK,(\$h-(\$y-\$ly))*_MPDFK, \t(\$x-\$rx)*_MPDFK,(\$h-\$y)*_MPDFK));
\t\$this->_out(sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c', (\$x-\$rx)*_MPDFK,(\$h-(\$y+\$ly))*_MPDFK, (\$x-\$lx)*_MPDFK,(\$h-(\$y+\$ry))*_MPDFK, \$x*_MPDFK,(\$h-(\$y+\$ry))*_MPDFK));
\t\$this->_out(sprintf('%.3F %.3F %.3F %.3F %.3F %.3F c %s', (\$x+\$lx)*_MPDFK,(\$h-(\$y+\$ry))*_MPDFK, (\$x+\$rx)*_MPDFK,(\$h-(\$y+\$ly))*_MPDFK, (\$x+\$rx)*_MPDFK,(\$h-\$y)*_MPDFK, \$op));
}

/*-- DIRECTW --*/
// Added adaptation of shaded_box = AUTOSIZE-TEXT
function AutosizeText(\$text,\$w,\$font,\$style,\$szfont=72) {
\t\$text = \$this->purify_utf8_text(\$text);
\tif (\$this->text_input_as_HTML) {
\t\t\$text = \$this->all_entities_to_utf8(\$text);
\t}
\tif (\$this->usingCoreFont) { \$text = mb_convert_encoding(\$text,\$this->mb_enc,'UTF-8'); }
\t\$text = ' '.\$text.' ';
\t\$width = \$this->ConvertSize(\$w);
\t\$loop   = 0;
\twhile ( \$loop == 0 ) {
\t\t\$this->SetFont(\$font,\$style,\$szfont);
\t\t\$sz = \$this->GetStringWidth( \$text );
\t\tif ( \$sz > \$w ) { \$szfont --; }
\t\telse { \$loop ++; }
\t}
 \t\$this->SetFont(\$font,\$style,\$szfont);
\t\$this->Cell(\$w, 0, \$text, 0, 0, \"C\");
}
/*-- END DIRECTW --*/





// ====================================================
// ====================================================
/*-- RTL --*/
function reverse_letters(\$str) {
\t\$str = strtr(\$str, '{}[]()', '}{][)(');
\treturn \$this->mb_strrev(\$str, \$this->mb_enc);
}

// mPDF 5.7+
function reverse_letters_preg_callback(\$matches) {
\treturn \$this->reverse_letters(\$matches[1]);
}

function magic_reverse_dir(&\$chunk, \$join=true, \$dir) {
   if (\$this->usingCoreFont) { return 0; }
   if (\$this->biDirectional)  {
\t// mPDF 5.4.05 Include PUA for non-indexed Arabic glyphs
\t\$pregRTLchars = \$this->pregRTLchars;
\tif (\$this->CurrentFont['unAGlyphs']) { \$pregRTLchars .= \"\\x{F500}-\\x{F7FF}\"; }

\t// Change Arabic + Persian. to Presentation Forms
\tif (\$join) {
\t\t\$chunk = preg_replace_callback(\"/([\".\$pregRTLchars.\"]+)/u\", array(\$this, 'arabJoinPregCallback'), \$chunk );\t// mPDF 5.7+
\t}
\t\$contains_rtl = false;
\t\$all_rtl = true;
\t\$initSpace = false;
\t\$endSpace = false;
\t\$nonDirchars = \"\\x{A0}\\\"\\'\\(\\)\\{\\}\\[\\].,:\\\\/-=\";\t// mPDF 5.6.32
\t// mPDF 5.6.43
\t\$bdo=array();
\tpreg_match_all('/([\\x{202A}\\x{202B}])(.*?)([\\x{202C}])/u',\$chunk,\$m);
\tif (count(\$m[0])) {
\t\tfor(\$i=0;\$i<count(\$m[0]);\$i++) {
\t\t\tif (\$m[1][\$i]==\"\\xe2\\x80\\xab\") {\t// Right-to-Left Embedding [RLE] U+202B &#8235;
\t\t\t\t\$mark = code2utf(0xf800+\$i);
\t\t\t\t\$bdo[\$i] = \$this->reverse_letters(\$m[2][\$i]);
\t\t\t}
\t\t\telse if (\$m[1][\$i]==\"\\xe2\\x80\\xaa\") {\t// Left-to-Right Embedding [LRE] U+202A &#8234;
\t\t\t\t\$mark = code2utf(0xf880+\$i);
\t\t\t\t\$bdo[\$i] = \$m[2][\$i];
\t\t\t}
\t\t\t\$chunk = preg_replace('/'.preg_quote(\$m[0][\$i],'/').'/u',\$mark,\$chunk);
\t\t}
\t\t\$pregRTLchars .= \"\\x{F800}-\\x{F87F}\";
\t}
\tif (preg_match(\"/[\".\$pregRTLchars.\"]/u\",\$chunk)) {\t// Chunk contains RTL characters
\t\tif (preg_match(\"/^[ ]/\",\$chunk)) { \$initSpace = true; \$chunk = preg_replace(\"/^[ ]/\",'',\$chunk); }
\t\tif (preg_match(\"/[ ]\$/\",\$chunk)) { \$endSpace = true; \$chunk = preg_replace(\"/[ ]\$/\",'',\$chunk); }

\t\tif (preg_match(\"/[^\".\$pregRTLchars.\$nonDirchars.\" ]/u\",\$chunk)) {\t// Chunk also contains LTR characters
\t\t\t\$all_rtl = false;
\t\t\tif (\$dir == 'rtl') {
\t\t\t\t\$chunk = preg_replace(\"/([^\".\$pregRTLchars.\$nonDirchars.\"][\".\$nonDirchars.\"]*) ([\".\$nonDirchars.\"]*[^\".\$pregRTLchars.\$nonDirchars.\"])/u\",\"\\\\1\\x07\\\\2\",\$chunk);
\t\t\t}
\t\t\t\$chunk = preg_replace(\"/([\".\$pregRTLchars.\"][\".\$nonDirchars.\"]*) ([\".\$nonDirchars.\"]*[\".\$pregRTLchars.\"])/u\",\"\\\\1\\x07\\\\2\",\$chunk);
\t\t\t\$bits = explode(' ',\$chunk);
\t\t\tforeach(\$bits AS \$bitkey=>\$bit) {
\t\t\t\t\$bit = preg_replace(\"/\\x07/\",\" \",\$bit);
\t\t\t\tif (preg_match(\"/^[\".\$pregRTLchars.\$nonDirchars.\" ]*\$/u\",\$bit)) {
\t\t\t\t\t\$bits[\$bitkey] = \$this->reverse_letters(\$bit);
\t\t\t\t}
\t\t\t\telse if (preg_match(\"/[\".\$pregRTLchars.\"]/u\",\$bit)) {
\t\t\t\t\tif (\$dir == 'rtl') {
\t\t\t\t\t\t\$bit = preg_replace(\"/([^\".\$pregRTLchars.\$nonDirchars.\" ])([\".\$nonDirchars.\"]*[\".\$pregRTLchars.\"])/u\",\"\\\\1\\x07\\\\2\",\$bit );
\t\t\t\t\t\t\$bit = preg_replace(\"/([\".\$pregRTLchars.\"][\".\$nonDirchars.\"]*)([^\".\$pregRTLchars.\$nonDirchars.\" ])/u\",\"\\\\1\\x07\\\\2\",\$bit );
\t\t\t\t\t}
\t\t\t\t\telse {
\t\t\t\t\t\t\$bit = preg_replace(\"/([^\".\$pregRTLchars.\" ][\".\$nonDirchars.\"]*)([\".\$pregRTLchars.\" ])/u\",\"\\\\1\\x07\\\\2\",\$bit );
\t\t\t\t\t\t\$bit = preg_replace(\"/([\".\$pregRTLchars.\" ])([\".\$nonDirchars.\"]*[^\".\$pregRTLchars.\" ])/u\",\"\\\\1\\x07\\\\2\",\$bit );
\t\t\t\t\t}
\t\t\t\t\t\$sbits = explode(\"\\x07\",\$bit );
\t\t\t\t\tforeach(\$sbits AS \$sbitkey=>\$sbit) {
\t\t\t\t\t\t\$sbit = preg_replace(\"/\\x07/\",\"\",\$sbit);
\t\t\t\t\t\tif (preg_match(\"/^[\".\$pregRTLchars.\$nonDirchars.\" ]*\$/u\",\$sbit)) {
\t\t\t\t\t\t\t\$sbits[\$sbitkey] = \$this->reverse_letters(\$sbit);
\t\t\t\t\t\t}
\t\t\t\t\t\telse if (preg_match(\"/[\".\$pregRTLchars.\"]/u\",\$sbit) && \$dir=='rtl') {
\t\t\t\t\t\t\t\$sbits[\$sbitkey] = \$this->reverse_letters(\$sbit);
\t\t\t\t\t\t}
\t\t\t\t\t\telse {
\t\t\t\t\t\t\t// Reverse numerals only to RTL
\t\t\t\t\t\t\t\$sbit = preg_replace_callback(\"/([\\x{0660}-\\x{066C}0-9]+[\\x{0660}-\\x{066C}0-9\\.,:\\/]*[\\x{0660}-\\x{066C}0-9]+)/u\", array(\$this, 'reverse_letters_preg_callback'), \$sbit );\t// mPDF 5.7+
\t\t\t\t\t\t\t\$sbits[\$sbitkey] = \$sbit;
\t\t\t\t\t\t}
\t\t\t\t\t}
\t\t\t\t\tif (\$dir == 'rtl') { \$sbits = array_reverse(\$sbits,false); }
\t\t\t\t\t\$bits[\$bitkey] = implode('',\$sbits);
\t\t\t\t}
\t\t\t\telse if (preg_match(\"/[\".\$pregRTLchars.\"]/u\",\$bit) && \$dir=='rtl') {
\t\t\t\t\t\$bits[\$bitkey] = \$this->reverse_letters(\$bit);
\t\t\t\t}
\t\t\t\telse {
\t\t\t\t\t// Reverse numerals only to RTL
\t\t\t\t\t\$bit = preg_replace_callback(\"/([\\x{0660}-\\x{066C}0-9]+[\\x{0660}-\\x{066C}0-9\\.,:\\/]*[\\x{0660}-\\x{066C}0-9]+)/u\", array(\$this, 'reverse_letters_preg_callback'), \$bit );\t// mPDF 5.7+
\t\t\t\t\t\$bits[\$bitkey] = \$bit;
\t\t\t\t}
\t\t\t}
\t\t\tif (\$dir == 'rtl') { \$bits = array_reverse(\$bits,false); }
\t\t\t\$chunk = implode(' ',\$bits);
\t\t}
\t\telse { \$chunk = \$this->reverse_letters(\$chunk); }
\t\t\$contains_rtl = true;

\t\t// Un-Reverse numerals back to ltr
\t\t\$chunk = preg_replace_callback(\"/([\\x{0660}-\\x{066C}0-9]+[\\x{0660}-\\x{066C}0-9\\.,:\\/]*[\\x{0660}-\\x{066C}0-9]+)/u\", array(\$this, 'reverse_letters_preg_callback'), \$chunk );\t// mPDF 5.7+
\t\tif (\$dir == 'rtl') {
\t\t\tif (\$endSpace) { \$chunk = ' '.\$chunk; }
\t\t\tif (\$initSpace) { \$chunk .= ' '; }
\t\t}
\t\telse {
\t\t\tif (\$initSpace) { \$chunk = ' '.\$chunk; }
\t\t\tif (\$endSpace) { \$chunk .= ' '; }
\t\t}
\t}
\telse { \$all_rtl = false; }

\t// mPDF 5.6.43
\tif (count(\$bdo)) {
\t\tfor(\$i=0;\$i<count(\$bdo);\$i++) {
\t\t\t\$chunk = preg_replace('/[\\x{'.dechex(intval(0xf800+\$i)).'}\\x{'.dechex(intval(0xf880+\$i)).'}]/u',\$bdo[\$i],\$chunk);
\t\t}
\t}

\tif (\$all_rtl) { return 2; }
\telse if (\$contains_rtl) { return 1; }
\telse { return 0; }
   }
   return 0;
}
/*-- END RTL --*/

//
// ****************************
// ****************************


function SetSubstitutions() {
\t\$subsarray = array();
\t@include(_MPDF_PATH.'includes/subs_win-1252.php');
\t\$this->substitute = array();
\tforeach(\$subsarray AS \$key => \$val) {
\t\t\$this->substitute[code2utf(\$key)] = \$val;
\t}
}


function SubstituteChars(\$html) {
\t// only substitute characters between tags
\tif (count(\$this->substitute)) {
\t\t\$a=preg_split('/(<.*?>)/ms',\$html,-1,PREG_SPLIT_DELIM_CAPTURE);
\t\t\$html = '';
\t\tforeach(\$a as \$i => \$e) {
\t\t\tif(\$i%2==0) {
\t\t\t   \$e = strtr(\$e, \$this->substitute);
\t\t\t}
\t\t\t\$html .= \$e;
\t\t}
\t}
\treturn \$html;
}


function SubstituteCharsSIP(&\$writehtml_a, &\$writehtml_i, &\$writehtml_e) {
\tif (preg_match(\"/^(.*?)([\\x{20000}-\\x{2FFFF}]+)(.*)/u\", \$writehtml_e, \$m)) {
\t   if (isset(\$this->CurrentFont['sipext']) && \$this->CurrentFont['sipext']) {
\t\t\$font = \$this->CurrentFont['sipext'];
\t\tif (!in_array(\$font, \$this->available_unifonts)) { return 0; }
\t\t\$writehtml_a[\$writehtml_i] = \$writehtml_e = \$m[1];
\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array('span style=\"font-family: '.\$font.'\"', \$m[2], '/span', \$m[3]));
\t\t\$this->subPos = \$writehtml_i;
\t\treturn 4;
\t   }
\t}
\treturn 0;
}

// If core font is selected in document which is not onlyCoreFonts - substitute with non-core font
function SubstituteCharsNonCore(&\$writehtml_a, &\$writehtml_i, &\$writehtml_e) {
\tif (mb_convert_encoding(mb_convert_encoding(\$writehtml_e, \$this->mb_enc, \"UTF-8\"), \"UTF-8\", \$this->mb_enc) == \$writehtml_e) {
\t\treturn 0;
\t}
\t\$cw = &\$this->CurrentFont['cw'];
\t\$unicode = \$this->UTF8StringToArray(\$writehtml_e, false);
\t\$start = -1;
\t\$end = 0;
\t\$flag = 0;
\t\$ftype = '';
\t\$u = array();
\tif (!\$this->subArrMB) {
\t\tinclude(_MPDF_PATH.'includes/subs_core.php');
\t\t\$this->subArrMB['a'] = \$aarr;
\t\t\$this->subArrMB['s'] = \$sarr;
\t\t\$this->subArrMB['z'] = \$zarr;
\t}
\tforeach(\$unicode AS \$c => \$char) {
\t\tif ((\$char> 127 || (\$flag==1 && \$char==32)) && \$char != 173 && (!isset(\$this->subArrMB['a'][\$char]) || (\$flag==1 && \$char==32)) && (\$char<1536 ||  (\$char>1791 && \$char < 2304) || \$char>3455)) {
\t\t\tif (\$flag==0) { \$start=\$c; }
\t\t\t\$flag=1;
\t\t\t\$u[] = \$char;
\t\t}
\t\telse if (\$flag>0) { \$end=\$c-1; break; }
\t}
\tif (\$flag>0 && !\$end) { \$end=count(\$unicode)-1; }
\tif (\$start==-1) { return 0; }
\t// TRY IN BACKUP SUBS FONT
\tif (!is_array(\$this->backupSubsFont)) { \$this->backupSubsFont = array(\"\$this->backupSubsFont\"); }
\tforeach(\$this->backupSubsFont AS \$bsfctr=>\$bsf) {
\t\tif (\$this->fonttrans[\$bsf] == 'chelvetica' || \$this->fonttrans[\$bsf] == 'ctimes' || \$this->fonttrans[\$bsf] == 'ccourier') { continue; }
\t\t\$font = \$bsf;
\t\tunset(\$cw);
\t\t\$cw = '';
\t\tif (isset(\$this->fonts[\$font])) { \$cw = &\$this->fonts[\$font]['cw']; }
\t\telse if (file_exists(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat')) { \$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat'); }
\t\telse {

\t\t\t\$prevFontFamily = \$this->FontFamily;
\t\t\t\$prevFontStyle = \$this->currentfontstyle;
\t\t\t\$prevFontSizePt = \$this->FontSizePt;
\t\t\t\$this->SetFont(\$bsf, '', '', false);
\t\t\t\$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat');
\t\t\t\$this->SetFont(\$prevFontFamily, \$prevFontStyle, \$prevFontSizePt, false);
\t\t}
\t\tif (!\$cw) { continue; }
\t\t\$l = 0;
\t\tforeach(\$u AS \$char) {
\t\t\tif (\$char == 173 || \$this->_charDefined(\$cw,\$char) || (\$char>1536 && \$char<1791) || (\$char>2304 && \$char<3455 )) {
\t\t\t\t\$l++;
\t\t\t}
\t\t\telse {
\t\t\t\tif (\$l==0 && \$bsfctr == (count(\$this->backupSubsFont)-1)) {\t// Not found even in last backup font
\t\t\t\t\t\$cont = mb_substr(\$writehtml_e, \$start+1);
\t\t\t\t\t\$writehtml_e = mb_substr(\$writehtml_e, 0, \$start+1, 'UTF-8');
\t\t\t\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array('', \$cont));
\t\t\t\t\t\$this->subPos = \$writehtml_i+1;
\t\t\t\t\treturn 2;
\t\t\t\t}
\t\t\t\telse { break; }
\t\t\t}
\t\t}
\t\tif (\$l > 0) {
\t\t\t\$patt = mb_substr(\$writehtml_e, \$start, \$l, 'UTF-8');
\t\t\tif (preg_match(\"/(.*?)(\".preg_quote(\$patt,'/').\")(.*)/u\", \$writehtml_e, \$m)) {
\t\t\t\t\$writehtml_e = \$m[1];
\t\t\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array('span style=\"font-family: '.\$font.'\"', \$m[2], '/span', \$m[3]));
\t\t\t\t\$this->subPos = \$writehtml_i+3;
\t\t\t\treturn 4;
\t\t\t}
\t\t}
\t}

\tunset(\$cw);
\treturn 0;
}


function SubstituteCharsMB(&\$writehtml_a, &\$writehtml_i, &\$writehtml_e) {
\t\$cw = &\$this->CurrentFont['cw'];
\t\$unicode = \$this->UTF8StringToArray(\$writehtml_e, false);
\t\$start = -1;
\t\$end = 0;
\t\$flag = 0;
\t\$ftype = '';
\t\$u = array();
\tforeach(\$unicode AS \$c => \$char) {
\t\tif ((\$flag == 0 || \$flag==2) && (!\$this->_charDefined(\$cw,\$char) || (\$flag==2 && \$char==32)) && \$this->checkSIP && \$char > 131071) { \t// Unicode Plane 2 (SIP)
\t\t\tif (in_array(\$this->FontFamily ,\$this->available_CJK_fonts)) { return 0; }
\t\t\tif (\$flag==0) { \$start=\$c; }
\t\t\t\$flag=2;
\t\t\t\$u[] = \$char;
\t\t}
\t\t//else if ((\$flag == 0 || \$flag==1) && \$char != 173 && !\$this->_charDefined(\$cw,\$char) && (\$char<1423 ||  (\$char>3583 && \$char < 11263))) {
\t\telse if ((\$flag == 0 || \$flag==1) && \$char != 173 && (!\$this->_charDefined(\$cw,\$char) || (\$flag==1 && \$char==32)) && (\$char<1536 ||  (\$char>1791 && \$char < 2304) || \$char>3455)) {
\t\t\tif (\$flag==0) { \$start=\$c; }
\t\t\t\$flag=1;
\t\t\t\$u[] = \$char;
\t\t}
\t\telse if (\$flag>0) { \$end=\$c-1; break; }
\t}
\tif (\$flag>0 && !\$end) { \$end=count(\$unicode)-1; }
\tif (\$start==-1) { return 0; }
\tif (\$flag == 2) { \t// SIP
\t\t// Check if current CJK font has a ext-B related font
\t   if (isset(\$this->CurrentFont['sipext']) && \$this->CurrentFont['sipext']) {
\t\t\$font = \$this->CurrentFont['sipext'];
\t\tunset(\$cw);
\t\t\$cw = '';
\t\tif (isset(\$this->fonts[\$font])) { \$cw = &\$this->fonts[\$font]['cw']; }
\t\telse if (file_exists(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat')) { \$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat'); }
\t\telse {
\t\t\t\$prevFontFamily = \$this->FontFamily;
\t\t\t\$prevFontStyle = \$this->currentfontstyle;
\t\t\t\$prevFontSizePt = \$this->FontSizePt;
\t\t\t\$this->SetFont(\$font, '', '', false);
\t\t\t\$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat');
\t\t\t\$this->SetFont(\$prevFontFamily, \$prevFontStyle, \$prevFontSizePt, false);
\t\t}
\t\tif (!\$cw) { return 0; }
\t\t\$l = 0;
\t\tforeach(\$u AS \$char) {
\t\t\tif (\$this->_charDefined(\$cw,\$char) || \$char > 131071) {
\t\t\t\t\$l++;
\t\t\t}
\t\t\telse { break; }
\t\t}
\t\tif (\$l > 0) {
\t\t\t\$patt = mb_substr(\$writehtml_e, \$start, \$l);
\t\t\tif (preg_match(\"/(.*?)(\".preg_quote(\$patt,'/').\")(.*)/u\", \$writehtml_e, \$m)) {
\t\t\t\t\$writehtml_e = \$m[1];
\t\t\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array('span style=\"font-family: '.\$font.'\"', \$m[2], '/span', \$m[3]));
\t\t\t\t\$this->subPos = \$writehtml_i+3;
\t\t\t\treturn 4;
\t\t\t}
\t\t}
\t   }
\t\t// Check Backup SIP font (defined in config_fonts.php)
\t   if (isset(\$this->backupSIPFont) && \$this->backupSIPFont) {
\t\tif (\$this->currentfontfamily != \$this->backupSIPFont) { \$font = \$this->backupSIPFont; }
\t\telse { unset(\$cw); return 0; }
\t\tunset(\$cw);
\t\t\$cw = '';
\t\tif (isset(\$this->fonts[\$font])) { \$cw = &\$this->fonts[\$font]['cw']; }
\t\telse if (file_exists(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat')) { \$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat'); }
\t\telse {
\t\t\t\$prevFontFamily = \$this->FontFamily;
\t\t\t\$prevFontStyle = \$this->currentfontstyle;
\t\t\t\$prevFontSizePt = \$this->FontSizePt;
\t\t\t\$this->SetFont(\$this->backupSIPFont, '', '', false);
\t\t\t\$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat');
\t\t\t\$this->SetFont(\$prevFontFamily, \$prevFontStyle, \$prevFontSizePt, false);
\t\t}
\t\tif (!\$cw) { return 0; }
\t\t\$l = 0;
\t\tforeach(\$u AS \$char) {
\t\t\tif (\$this->_charDefined(\$cw,\$char) || \$char > 131071) {
\t\t\t\t\$l++;
\t\t\t}
\t\t\telse { break; }
\t\t}
\t\tif (\$l > 0) {
\t\t\t\$patt = mb_substr(\$writehtml_e, \$start, \$l);
\t\t\tif (preg_match(\"/(.*?)(\".preg_quote(\$patt,'/').\")(.*)/u\", \$writehtml_e, \$m)) {
\t\t\t\t\$writehtml_e = \$m[1];
\t\t\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array('span style=\"font-family: '.\$font.'\"', \$m[2], '/span', \$m[3]));
\t\t\t\t\$this->subPos = \$writehtml_i+3;
\t\t\t\treturn 4;
\t\t\t}
\t\t}
\t   }
\t   return 0;
\t}


\t// FIRST TRY CORE FONTS
\tif (!\$this->PDFA && !\$this->PDFX) {
\t  \$repl = array();
\t  if (!\$this->subArrMB) {
\t\tinclude(_MPDF_PATH.'includes/subs_core.php');
\t\t\$this->subArrMB['a'] = \$aarr;
\t\t\$this->subArrMB['s'] = \$sarr;
\t\t\$this->subArrMB['z'] = \$zarr;
\t  }
\t  if (isset(\$this->subArrMB['a'][\$u[0]])) {
\t\t\$font = 'tta'; \$ftype = 'C';
\t\tforeach(\$u AS \$char) {
\t\t\tif (\$this->subArrMB['a'][\$char]) { \$repl[] = \$this->subArrMB['a'][\$char]; }
\t\t\telse { break; }
\t\t}
\t  }
\t  else if (isset(\$this->subArrMB['z'][\$u[0]])) {
\t\t\$font = 'ttz'; \$ftype = 'C';
\t\tforeach(\$u AS \$char) {
\t\t\tif (\$this->subArrMB['z'][\$char]) { \$repl[] = \$this->subArrMB['z'][\$char]; }
\t\t\telse { break; }
\t\t}
\t  }
\t  else if (isset(\$this->subArrMB['s'][\$u[0]])) {
\t\t\$font = 'tts'; \$ftype = 'C';
\t\tforeach(\$u AS \$char) {
\t\t\tif (\$this->subArrMB['s'][\$char]) { \$repl[] = \$this->subArrMB['s'][\$char]; }
\t\t\telse { break; }
\t\t}
\t  }
\t  if (\$ftype=='C') {
\t\t\$patt = mb_substr(\$writehtml_e, \$start, count(\$repl));
\t\tif (preg_match(\"/(.*?)(\".preg_quote(\$patt,'/').\")(.*)/u\", \$writehtml_e, \$m)) {
\t\t\t\$writehtml_e = \$m[1];
\t\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array(\$font, implode('|', \$repl), '/'.\$font, \$m[3]));\t// e.g. <tts>
\t\t\t\$this->subPos = \$writehtml_i+3;
\t\t\treturn 4;
\t\t}
\t\treturn 0;
\t  }
\t}

\t// FIND IN DEFAULT FONT - removed mPDF 5.0

\t// LASTLY TRY IN BACKUP SUBS FONT
\tif (!is_array(\$this->backupSubsFont)) { \$this->backupSubsFont = array(\"\$this->backupSubsFont\"); }
\tforeach(\$this->backupSubsFont AS \$bsfctr=>\$bsf) {
\t\tif (\$this->currentfontfamily != \$bsf) { \$font = \$bsf; }
\t\telse { continue; }
\t\tunset(\$cw);
\t\t\$cw = '';
\t\tif (isset(\$this->fonts[\$font])) { \$cw = &\$this->fonts[\$font]['cw']; }
\t\telse if (file_exists(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat')) { \$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat'); }
\t\telse {
\t\t\t\$prevFontFamily = \$this->FontFamily;
\t\t\t\$prevFontStyle = \$this->currentfontstyle;
\t\t\t\$prevFontSizePt = \$this->FontSizePt;
\t\t\t\$this->SetFont(\$bsf, '', '', false);
\t\t\t\$cw = @file_get_contents(_MPDF_TTFONTDATAPATH.\$font.'.cw.dat');
\t\t\t\$this->SetFont(\$prevFontFamily, \$prevFontStyle, \$prevFontSizePt, false);
\t\t}
\t\tif (!\$cw) { continue; }
\t\t\$l = 0;
\t\tforeach(\$u AS \$char) {
\t\t\tif (\$char == 173 || \$this->_charDefined(\$cw,\$char) || (\$char>1536 && \$char<1791) || (\$char>2304 && \$char<3455 )) { \t// Arabic and Indic
\t\t\t\t\$l++;
\t\t\t}
\t\t\telse {
\t\t\t\tif (\$l==0 && \$bsfctr == (count(\$this->backupSubsFont)-1)) {\t// Not found even in last backup font
\t\t\t\t\t\$cont = mb_substr(\$writehtml_e, \$start+1);
\t\t\t\t\t\$writehtml_e = mb_substr(\$writehtml_e, 0, \$start+1);
\t\t\t\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array('', \$cont));
\t\t\t\t\t\$this->subPos = \$writehtml_i+1;
\t\t\t\t\treturn 2;
\t\t\t\t}
\t\t\t\telse { break; }
\t\t\t}
\t\t}
\t\tif (\$l > 0) {
\t\t\t\$patt = mb_substr(\$writehtml_e, \$start, \$l);
\t\t\tif (preg_match(\"/(.*?)(\".preg_quote(\$patt,'/').\")(.*)/u\", \$writehtml_e, \$m)) {
\t\t\t\t\$writehtml_e = \$m[1];
\t\t\t\tarray_splice(\$writehtml_a, \$writehtml_i+1, 0, array('span style=\"font-family: '.\$font.'\"', \$m[2], '/span', \$m[3]));
\t\t\t\t\$this->subPos = \$writehtml_i+3;
\t\t\t\treturn 4;
\t\t\t}
\t\t}
\t}

\tunset(\$cw);
\treturn 0;
}


function setHiEntitySubstitutions() {
\t\$entarr = array (
  'nbsp' => '160',  'iexcl' => '161',  'cent' => '162',  'pound' => '163',  'curren' => '164',  'yen' => '165',  'brvbar' => '166',  'sect' => '167',
  'uml' => '168',  'copy' => '169',  'ordf' => '170',  'laquo' => '171',  'not' => '172',  'shy' => '173',  'reg' => '174',  'macr' => '175',
  'deg' => '176',  'plusmn' => '177',  'sup2' => '178',  'sup3' => '179',  'acute' => '180',  'micro' => '181',  'para' => '182',  'middot' => '183',
  'cedil' => '184',  'sup1' => '185',  'ordm' => '186',  'raquo' => '187',  'frac14' => '188',  'frac12' => '189',  'frac34' => '190',
  'iquest' => '191',  'Agrave' => '192',  'Aacute' => '193',  'Acirc' => '194',  'Atilde' => '195',  'Auml' => '196',  'Aring' => '197',
  'AElig' => '198',  'Ccedil' => '199',  'Egrave' => '200',  'Eacute' => '201',  'Ecirc' => '202',  'Euml' => '203',  'Igrave' => '204',
  'Iacute' => '205',  'Icirc' => '206',  'Iuml' => '207',  'ETH' => '208',  'Ntilde' => '209',  'Ograve' => '210',  'Oacute' => '211',
  'Ocirc' => '212',  'Otilde' => '213',  'Ouml' => '214',  'times' => '215',  'Oslash' => '216',  'Ugrave' => '217',  'Uacute' => '218',
  'Ucirc' => '219',  'Uuml' => '220',  'Yacute' => '221',  'THORN' => '222',  'szlig' => '223',  'agrave' => '224',  'aacute' => '225',
  'acirc' => '226',  'atilde' => '227',  'auml' => '228',  'aring' => '229',  'aelig' => '230',  'ccedil' => '231',  'egrave' => '232',
  'eacute' => '233',  'ecirc' => '234',  'euml' => '235',  'igrave' => '236',  'iacute' => '237',  'icirc' => '238',  'iuml' => '239',
  'eth' => '240',  'ntilde' => '241',  'ograve' => '242',  'oacute' => '243',  'ocirc' => '244',  'otilde' => '245',  'ouml' => '246',
  'divide' => '247',  'oslash' => '248',  'ugrave' => '249',  'uacute' => '250',  'ucirc' => '251',  'uuml' => '252',  'yacute' => '253',
  'thorn' => '254',  'yuml' => '255',  'OElig' => '338',  'oelig' => '339',  'Scaron' => '352',  'scaron' => '353',  'Yuml' => '376',
  'fnof' => '402',  'circ' => '710',  'tilde' => '732',  'Alpha' => '913',  'Beta' => '914',  'Gamma' => '915',  'Delta' => '916',
  'Epsilon' => '917',  'Zeta' => '918',  'Eta' => '919',  'Theta' => '920',  'Iota' => '921',  'Kappa' => '922',  'Lambda' => '923',
  'Mu' => '924',  'Nu' => '925',  'Xi' => '926',  'Omicron' => '927',  'Pi' => '928',  'Rho' => '929',  'Sigma' => '931',  'Tau' => '932',
  'Upsilon' => '933',  'Phi' => '934',  'Chi' => '935',  'Psi' => '936',  'Omega' => '937',  'alpha' => '945',  'beta' => '946',  'gamma' => '947',
  'delta' => '948',  'epsilon' => '949',  'zeta' => '950',  'eta' => '951',  'theta' => '952',  'iota' => '953',  'kappa' => '954',
  'lambda' => '955',  'mu' => '956',  'nu' => '957',  'xi' => '958',  'omicron' => '959',  'pi' => '960',  'rho' => '961',  'sigmaf' => '962',
  'sigma' => '963',  'tau' => '964',  'upsilon' => '965',  'phi' => '966',  'chi' => '967',  'psi' => '968',  'omega' => '969',
  'thetasym' => '977',  'upsih' => '978',  'piv' => '982',  'ensp' => '8194',  'emsp' => '8195',  'thinsp' => '8201',  'zwnj' => '8204',
  'zwj' => '8205',  'lrm' => '8206',  'rlm' => '8207',  'ndash' => '8211',  'mdash' => '8212',  'lsquo' => '8216',  'rsquo' => '8217',
  'sbquo' => '8218',  'ldquo' => '8220',  'rdquo' => '8221',  'bdquo' => '8222',  'dagger' => '8224',  'Dagger' => '8225',  'bull' => '8226',
  'hellip' => '8230',  'permil' => '8240',  'prime' => '8242',  'Prime' => '8243',  'lsaquo' => '8249',  'rsaquo' => '8250',  'oline' => '8254',
  'frasl' => '8260',  'euro' => '8364',  'image' => '8465',  'weierp' => '8472',  'real' => '8476',  'trade' => '8482',  'alefsym' => '8501',
  'larr' => '8592',  'uarr' => '8593',  'rarr' => '8594',  'darr' => '8595',  'harr' => '8596',  'crarr' => '8629',  'lArr' => '8656',
  'uArr' => '8657',  'rArr' => '8658',  'dArr' => '8659',  'hArr' => '8660',  'forall' => '8704',  'part' => '8706',  'exist' => '8707',
  'empty' => '8709',  'nabla' => '8711',  'isin' => '8712',  'notin' => '8713',  'ni' => '8715',  'prod' => '8719',  'sum' => '8721',
  'minus' => '8722',  'lowast' => '8727',  'radic' => '8730',  'prop' => '8733',  'infin' => '8734',  'ang' => '8736',  'and' => '8743',
  'or' => '8744',  'cap' => '8745',  'cup' => '8746',  'int' => '8747',  'there4' => '8756',  'sim' => '8764',  'cong' => '8773',
  'asymp' => '8776',  'ne' => '8800',  'equiv' => '8801',  'le' => '8804',  'ge' => '8805',  'sub' => '8834',  'sup' => '8835',  'nsub' => '8836',
  'sube' => '8838',  'supe' => '8839',  'oplus' => '8853',  'otimes' => '8855',  'perp' => '8869',  'sdot' => '8901',  'lceil' => '8968',
  'rceil' => '8969',  'lfloor' => '8970',  'rfloor' => '8971',  'lang' => '9001',  'rang' => '9002',  'loz' => '9674',  'spades' => '9824',
  'clubs' => '9827',  'hearts' => '9829',  'diams' => '9830',
 );
\tforeach(\$entarr AS \$key => \$val) {
\t\t\$this->entsearch[] = '&'.\$key.';';
\t\t\$this->entsubstitute[] = code2utf(\$val);
\t}
}

function SubstituteHiEntities(\$html) {
\t// converts html_entities > ASCII 127 to unicode
\t// Leaves in particular &lt; to distinguish from tag marker
\tif (count(\$this->entsearch)) {
\t\t\$html = str_replace(\$this->entsearch,\$this->entsubstitute,\$html);
\t}
\treturn \$html;
}


// Edited v1.2 Pass by reference; option to continue if invalid UTF-8 chars
function is_utf8(&\$string) {
\tif (\$string === mb_convert_encoding(mb_convert_encoding(\$string, \"UTF-32\", \"UTF-8\"), \"UTF-8\", \"UTF-32\")) {
\t\treturn true;
\t}
\telse {
\t  if (\$this->ignore_invalid_utf8) {
\t\t\$string = mb_convert_encoding(mb_convert_encoding(\$string, \"UTF-32\", \"UTF-8\"), \"UTF-8\", \"UTF-32\") ;
\t\treturn true;
\t  }
\t  else {
\t\treturn false;
\t  }
\t}
}


function purify_utf8(\$html,\$lo=true) {
\t// For HTML
\t// Checks string is valid UTF-8 encoded
\t// converts html_entities > ASCII 127 to UTF-8
\t// Only exception - leaves low ASCII entities e.g. &lt; &amp; etc.
\t// Leaves in particular &lt; to distinguish from tag marker
\tif (!\$this->is_utf8(\$html)) {
\t\techo \"<p><b>HTML contains invalid UTF-8 character(s)</b></p>\";
\t\twhile (mb_convert_encoding(mb_convert_encoding(\$html, \"UTF-32\", \"UTF-8\"), \"UTF-8\", \"UTF-32\") != \$html) {
\t\t\t\$a = iconv('UTF-8', 'UTF-8', \$html);
\t\t\techo (\$a);
\t\t\t\$pos = \$start = strlen(\$a);
\t\t\t\$err = '';
\t\t\twhile ( ord(substr(\$html,\$pos,1)) > 128 ) {
\t\t\t\t\$err .= '[[#'.ord(substr(\$html,\$pos,1)).']]';
\t\t\t\t\$pos++;
\t\t\t}
\t\t\techo '<span style=\"color:red; font-weight:bold\">'.\$err.'</span>';
\t\t\t\$html = substr(\$html, \$pos);
\t\t}
\t\techo \$html;
\t\t\$this->Error(\"\");
\t}
\t\$html = preg_replace(\"/\\r/\", \"\", \$html );

\t// converts html_entities > ASCII 127 to UTF-8
\t// Leaves in particular &lt; to distinguish from tag marker
\t\$html = \$this->SubstituteHiEntities(\$html);

\t// converts all &#nnn; or &#xHHH; to UTF-8 multibyte
\t// If \$lo==true then includes ASCII < 128
\t\$html = strcode2utf(\$html,\$lo);
\treturn (\$html);
}

function purify_utf8_text(\$txt) {
\t// For TEXT
\t// Make sure UTF-8 string of characters
    if (\$txt === null) \$txt = '';
\tif (!\$this->is_utf8(\$txt)) { \$this->Error(\"Text contains invalid UTF-8 character(s)\"); }

\t\$txt = preg_replace(\"/\\r/\", \"\", \$txt );

\treturn (\$txt);
}
function all_entities_to_utf8(\$txt) {
\t// converts txt_entities > ASCII 127 to UTF-8
\t// Leaves in particular &lt; to distinguish from tag marker
\t\$txt = \$this->SubstituteHiEntities(\$txt);

\t// converts all &#nnn; or &#xHHH; to UTF-8 multibyte
\t\$txt = strcode2utf(\$txt);

\t\$txt = \$this->lesser_entity_decode(\$txt);
\treturn (\$txt);
}


// ====================================================
/*-- BARCODES --*/
// UPC/EAN barcode
// EAN13, EAN8, UPCA, UPCE, ISBN, ISSN
// Accepts 12 or 13 digits with or without - hyphens
function WriteBarcode(\$code, \$showtext=1, \$x='', \$y='', \$size=1, \$border=0, \$paddingL=1, \$paddingR=1, \$paddingT=2, \$paddingB=2, \$height=1, \$bgcol=false, \$col=false, \$btype='ISBN', \$supplement='0', \$supplement_code='', \$k=1) {
\t\t\tif (empty(\$code)) {
\t\t\t\treturn;
\t\t\t}
\t\t\t\$codestr = \$code;
\t\t\t\$code = preg_replace('/\\-/','',\$code);

\t\t\tif (!class_exists('PDFBarcode', false)) {
\t\t\t\tinclude(_MPDF_PATH.'classes/barcode.php');
\t\t\t}
\t\t\t\$this->barcode = new PDFBarcode();
\t\t\tif (\$btype == 'ISSN' || \$btype == 'ISBN') {
\t\t\t\t\$arrcode = \$this->barcode->getBarcodeArray(\$code, 'EAN13');
\t\t\t}
\t\t\telse { \$arrcode = \$this->barcode->getBarcodeArray(\$code, \$btype); }

\t\t\tif (\$arrcode === false) { \$this->Error('Error in barcode string: '.\$codestr); }
\t\t\tif(((\$btype=='EAN13' || \$btype=='ISBN' || \$btype=='ISSN') && strlen(\$code) == 12) || (\$btype=='UPCA' && strlen(\$code) == 11)
\t\t\t\t|| (\$btype=='UPCE' && strlen(\$code) == 11) || (\$btype=='EAN8' && strlen(\$code) == 7)) {
\t\t\t\t\$code .= \$arrcode['checkdigit'];
\t\t\t\tif (stristr(\$codestr,'-')) { \$codestr .= '-' . \$arrcode['checkdigit']; }
\t\t\t\telse { \$codestr .= \$arrcode['checkdigit']; }
\t\t\t}
\t\t\tif (\$btype == 'ISBN') { \$codestr = 'ISBN '.\$codestr; }
\t\t\tif (\$btype == 'ISSN') { \$codestr = 'ISSN '.\$codestr; }

\t\t\tif (empty(\$x)) {
\t\t\t\t\$x = \$this->x;
\t\t\t}
\t\t\tif (empty(\$y)) {
\t\t\t\t\$y = \$this->y;
\t\t\t}
\t\t\t// set foreground color
\t\t\t\$prevDrawColor = \$this->DrawColor;
\t\t\t\$prevTextColor = \$this->TextColor;
\t\t\t\$prevFillColor = \$this->FillColor;
\t\t\t\$lw = \$this->LineWidth;
\t\t\t\$this->SetLineWidth(0.01);

\t\t\t\$size /= \$k;\t// in case resized in a table

\t\t\t\$xres = \$arrcode['nom-X'] * \$size;
\t\t\t\$llm = \$arrcode['lightmL'] * \$arrcode['nom-X'] * \$size;\t// Left Light margin
\t\t\t\$rlm = \$arrcode['lightmR'] * \$arrcode['nom-X'] * \$size;\t// Right Light margin

\t\t\t\$bcw = (\$arrcode[\"maxw\"] * \$xres);\t// Barcode width = Should always be 31.35mm * \$size

\t\t\t\$fbw = \$bcw + \$llm + \$rlm;\t// Full barcode width incl. light margins
\t\t\t\$ow = \$fbw + \$paddingL + \$paddingR;\t// Full overall width incl. user-defined padding

\t\t\t\$fbwi = \$fbw - 2;\t// Full barcode width incl. light margins - 2mm - for isbn string

\t\t\t// cf. http://www.gs1uk.org/downloads/bar_code/Bar coding getting it right.pdf
\t\t\t\$num_height = 3 * \$size;\t\t\t\t\t// Height of numerals
\t\t\t\$fbh = \$arrcode['nom-H'] * \$size * \$height;\t\t// Full barcode height incl. numerals
\t\t\t\$bch = \$fbh - (1.5 * \$size);\t\t\t\t\t// Barcode height of bars\t (3mm for numerals)

\t\t\tif ((\$btype=='EAN13' && \$showtext) || \$btype == 'ISSN' || \$btype == 'ISBN') { // Add height for ISBN string + margin from top of bars
\t\t\t\t\$tisbnm = 1.5 * \$size;\t// Top margin between isbn (if shown) & bars
\t\t\t\t\$codestr_fontsize = 2.1 * \$size;
\t\t\t\t\$paddingT += \$codestr_fontsize + \$tisbnm  ;
\t\t\t}
\t\t\t\$oh = \$fbh + \$paddingT + \$paddingB;\t\t// Full overall height incl. user-defined padding

\t\t\t// PRINT border background color
\t\t\t\$xpos = \$x;
\t\t\t\$ypos = \$y;
\t\t\tif (\$col) {
\t\t\t\t\$this->SetDColor(\$col);
\t\t\t\t\$this->SetTColor(\$col);
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\t\t\$this->SetTColor(\$this->ConvertColor(0));
\t\t\t}
\t\t\tif (\$bgcol) {
\t\t\t\t\$this->SetFColor(\$bgcol);
\t\t\t}
\t\t\telse { \$this->SetFColor(\$this->ConvertColor(255)); }
\t\t\tif (!\$bgcol && !\$col) {\t// fn. called directly - not via HTML
\t\t\t\tif (\$border) { \$fillb = 'DF'; } else { \$fillb = 'F'; }
\t\t\t\t\$this->Rect(\$xpos, \$ypos, \$ow, \$oh, \$fillb);
\t\t\t}


\t\t\t// PRINT BARS
\t\t\t\$xpos = \$x + \$paddingL + \$llm ;
\t\t\t\$ypos = \$y + \$paddingT;
\t\t\tif (\$col) { \$this->SetFColor(\$col); }
\t\t\telse { \$this->SetFColor(\$this->ConvertColor(0)); }
\t\t\tif (\$arrcode !== false) {
\t\t\t\tforeach (\$arrcode[\"bcode\"] AS \$v) {
\t\t\t\t\t\$bw = (\$v[\"w\"] * \$xres);
\t\t\t\t\tif (\$v[\"t\"]) {
\t\t\t\t\t\t// draw a vertical bar
\t\t\t\t\t\t\$this->Rect(\$xpos, \$ypos, \$bw, \$bch, 'F');
\t\t\t\t\t}
\t\t\t\t\t\$xpos += \$bw;
\t\t\t\t}
\t\t\t}


\t\t\t// print text
\t\t\t\$prevFontFamily = \$this->FontFamily;
\t\t\t\$prevFontStyle = \$this->FontStyle;
\t\t\t\$prevFontSizePt = \$this->FontSizePt;

\t\t\t// ISBN string
\t\t\tif ((\$btype=='EAN13' && \$showtext) || \$btype=='ISBN' || \$btype=='ISSN') {
\t\t\t   if (\$this->onlyCoreFonts) {
\t\t\t\t\$this->SetFont('chelvetica');
\t\t\t   }
\t\t\t   else {
\t\t\t   \t\$this->SetFont('sans');
\t\t\t   }

\t\t\t   if (\$bgcol) { \$this->SetFColor(\$bgcol); }
\t\t\t   else { \$this->SetFColor(\$this->ConvertColor(255)); }
\t\t\t   \$this->x = \$x + \$paddingL + 1;\t// 1mm left margin (cf. \$fbwi above)
\t\t\t   // max width is \$fbwi
\t\t\t   \$loop = 0;
\t\t\t   while ( \$loop == 0 ) {
\t\t\t\t\$this->SetFontSize(\$codestr_fontsize*1.4*_MPDFK, false);\t// don't write
\t\t\t\t\$sz = \$this->GetStringWidth( \$codestr );
\t\t\t\tif (\$sz > \$fbwi)
\t\t\t\t\t\$codestr_fontsize -= 0.1;
\t\t\t\telse
\t\t\t\t\t\$loop ++;
\t\t\t   }
\t\t\t   \$this->SetFont('','',\$codestr_fontsize*1.4*_MPDFK, true, true);\t// * 1.4 because font height is only 7/10 of given mm
 \t\t\t   // WORD SPACING
\t\t\t   if (\$fbwi > \$sz) {
\t\t\t\t\$xtra =  \$fbwi - \$sz;
\t\t\t\t\$charspacing = \$xtra / (strlen(\$codestr)-1);
\t\t\t\tif (\$charspacing) { \$this->_out(sprintf('BT %.3F Tc ET',\$charspacing*_MPDFK)); }
\t\t\t   }
\t\t\t   \$this->y = \$y + \$paddingT - (\$codestr_fontsize ) - \$tisbnm ;
\t\t\t   \$this->Cell(\$fbw , \$codestr_fontsize, \$codestr);
\t\t\t   if (\$charspacing) { \$this->_out('BT 0 Tc ET'); }
\t\t\t}


\t\t\t// Bottom NUMERALS
\t\t\tif (\$this->onlyCoreFonts) {
\t\t\t\t\$this->SetFont('mono');
\t\t\t}
\t\t\telse {
\t\t\t\tif (in_array('ocrb',\$this->available_unifonts)) { \$this->SetFont('ocrb'); }
\t\t\t\telse { \$this->SetFont('mono'); }
\t\t\t}
\t\t\tif (isset(\$this->CurrentFont['desc']['CapHeight'])) { \$fh = (1000/\$this->CurrentFont['desc']['CapHeight']); }
\t\t\telse if (isset(\$this->CurrentFont['desc']['Ascent'])) { \$fh = (1000/\$this->CurrentFont['desc']['Ascent']); }
\t\t\telse { \$fh = 1.2; }

\t\t\t\$charRO = '';
\t\t\tif (\$btype=='EAN13' || \$btype=='ISBN' || \$btype=='ISSN') {
\t\t\t\t\$outerfontsize = 3;\t// Inner fontsize = 3
\t\t\t\t\$outerp = \$xres * 4;
\t\t\t\t\$innerp = \$xres * 2.5;
\t\t\t\t\$textw = (\$bcw*0.5) - \$outerp - \$innerp;
\t\t\t\t\$chars = 6; // number of numerals in each half
\t\t\t\t\$charLO = substr(\$code,0,1); // Left Outer
\t\t\t\t\$charLI = substr(\$code,1,6); // Left Inner
\t\t\t\t\$charRI = substr(\$code,7,6); // Right Inner
\t\t\t\tif (!\$supplement) \$charRO = '>'; // Right Outer
\t\t\t}
\t\t\telse if (\$btype=='UPCA') {
\t\t\t\t\$outerfontsize = 2.3;\t// Inner fontsize = 3
\t\t\t\t\$outerp = \$xres * 10;
\t\t\t\t\$innerp = \$xres * 2.5;
\t\t\t\t\$textw = (\$bcw*0.5) - \$outerp - \$innerp;
\t\t\t\t\$chars = 5;
\t\t\t\t\$charLO = substr(\$code,0,1); // Left Outer
\t\t\t\t\$charLI = substr(\$code,1,5); // Left Inner
\t\t\t\t\$charRI = substr(\$code,6,5); // Right Inner
\t\t\t\t\$charRO = substr(\$code,11,1); // Right Outer
\t\t\t}
\t\t\telse if (\$btype=='UPCE') {
\t\t\t\t\$outerfontsize = 2.3;\t// Inner fontsize = 3
\t\t\t\t\$outerp = \$xres * 4;
\t\t\t\t\$innerp = 0;
\t\t\t\t\$textw = (\$bcw*0.5) - \$outerp - \$innerp;
\t\t\t\t\$chars = 3;
\t\t\t\t\$upce_code = \$arrcode['code'];
\t\t\t\t\$charLO = substr(\$code,0,1); // Left Outer
\t\t\t\t\$charLI = substr(\$upce_code,0,3); // Left Inner
\t\t\t\t\$charRI = substr(\$upce_code,3,3); // Right Inner
\t\t\t\t\$charRO = substr(\$code,11,1); // Right Outer
\t\t\t}
\t\t\telse if (\$btype=='EAN8') {
\t\t\t\t\$outerfontsize = 3;\t// Inner fontsize = 3
\t\t\t\t\$outerp = \$xres * 4;
\t\t\t\t\$innerp = \$xres * 2.5;
\t\t\t\t\$textw = (\$bcw*0.5) - \$outerp - \$innerp;
\t\t\t\t\$chars = 4;
\t\t\t\t\$charLO = '<'; // Left Outer
\t\t\t\t\$charLI = substr(\$code,0,4); // Left Inner
\t\t\t\t\$charRI = substr(\$code,4,4); // Right Inner
\t\t\t\tif (!\$supplement) \$charRO = '>'; // Right Outer
\t\t\t}

\t\t\t\$this->SetFontSize((\$outerfontsize/3)*3*\$fh*\$size*_MPDFK);\t// 3mm numerals (FontSize is larger to account for space above/below characters)

\t\t\tif (!\$this->usingCoreFont) { \$cw = \$this->_getCharWidth(\$this->CurrentFont['cw'],32)*3*\$fh*\$size/1000; }\t// character width at 3mm
\t\t\telse { \$cw = \$this->_getCharWidth(\$this->CurrentFont['cw'],48)*3*\$fh*\$size/1000; }\t\t// 48 == char \"0\"

\t\t\t// Outer left character
\t\t\t\$y_text = \$y + \$paddingT + \$bch - (\$num_height/2);
\t\t\t\$y_text_outer = \$y + \$paddingT + \$bch - (\$num_height*(\$outerfontsize/3)/2);

\t\t\t\$this->x = \$x + \$paddingL - (\$cw*(\$outerfontsize/3)*0.1); // 0.1 is correction as char does not fill full width;
\t\t\t\$this->y = \$y_text_outer;
\t\t\t\$this->Cell(\$cw, \$num_height, \$charLO );

 \t\t\t// WORD SPACING for inner chars
\t\t\t\$xtra =  \$textw - (\$cw*\$chars);
\t\t\t\$charspacing = \$xtra / (\$chars-1);
\t\t\tif (\$charspacing) { \$this->_out(sprintf('BT %.3F Tc ET',\$charspacing*_MPDFK)); }

\t\t\tif (\$bgcol) { \$this->SetFColor(\$bgcol); }
\t\t\telse { \$this->SetFColor(\$this->ConvertColor(255)); }

\t\t\t\$this->SetFontSize(3*\$fh*\$size*_MPDFK);\t// 3mm numerals (FontSize is larger to account for space above/below characters)

\t\t\t// Inner left half characters
\t\t\t\$this->x = \$x + \$paddingL + \$llm + \$outerp;
\t\t\t\$this->y = \$y_text;
\t\t\t\$this->Cell(\$textw, \$num_height, \$charLI , 0, 0, '', 1);

\t\t\t// Inner right half characters
\t\t\t\$this->x = \$x + \$paddingL + \$llm + (\$bcw*0.5) + \$innerp;
\t\t\t\$this->y = \$y_text;
\t\t\t\$this->Cell(\$textw, \$num_height, \$charRI , 0, 0, '', 1);

\t\t\tif (\$charspacing) { \$this->_out('BT 0 Tc ET'); }

\t\t\t// Outer Right character
\t\t\t\$this->SetFontSize((\$outerfontsize/3)*3*\$fh*\$size*_MPDFK);\t// 3mm numerals (FontSize is larger to account for space above/below characters)

\t\t\t\$this->x = \$x + \$paddingL + \$llm + \$bcw + \$rlm - (\$cw*(\$outerfontsize/3)*0.9); // 0.9 is correction as char does not fill full width
\t\t\t\$this->y = \$y_text_outer;
\t\t\t\$this->Cell(\$cw*(\$outerfontsize/3), \$num_height, \$charRO , 0, 0, 'R');

\t\t\tif (\$supplement) { // EAN-2 or -5 Supplement
\t\t\t\t// PRINT BARS
\t\t\t\t\$supparrcode = \$this->barcode->getBarcodeArray(\$supplement_code, 'EAN'.\$supplement);
\t\t\t\tif (\$supparrcode === false) { \$this->Error('Error in barcode string (supplement): '.\$codestr.' '.\$supplement_code); }
\t\t\t\tif(strlen(\$supplement_code) != \$supplement) {
\t\t\t\t\t\$this->Error('Barcode supplement incorrect: '.\$supplement_code);
\t\t\t\t}
\t\t\t\t\$llm = \$fbw - ((\$arrcode['lightmR'] - \$supparrcode['sepM'])  * \$arrcode['nom-X'] * \$size);\t// Left Light margin
\t\t\t\t\$rlm = \$arrcode['lightmR'] * \$arrcode['nom-X'] * \$size;\t// Right Light margin

\t\t\t\t\$bcw = (\$supparrcode[\"maxw\"] * \$xres);\t// Barcode width = Should always be 31.35mm * \$size

\t\t\t\t\$fbw = \$bcw + \$llm + \$rlm;\t// Full barcode width incl. light margins
\t\t\t\t\$ow = \$fbw + \$paddingL + \$paddingR;\t// Full overall width incl. user-defined padding
\t\t\t\t\$bch = \$fbh - (1.5 * \$size) - (\$num_height + 0.5);\t\t// Barcode height of bars\t (3mm for numerals)

\t\t\t\t\$xpos = \$x + \$paddingL + \$llm ;
\t\t\t\t\$ypos = \$y + \$paddingT + \$num_height + 0.5;
\t\t\t\tif (\$col) { \$this->SetFColor(\$col); }
\t\t\t\telse { \$this->SetFColor(\$this->ConvertColor(0)); }
\t\t\t\tif (\$supparrcode !== false) {
\t\t\t\t\tforeach (\$supparrcode[\"bcode\"] AS \$v) {
\t\t\t\t\t\t\$bw = (\$v[\"w\"] * \$xres);
\t\t\t\t\t\tif (\$v[\"t\"]) {
\t\t\t\t\t\t\t// draw a vertical bar
\t\t\t\t\t\t\t\$this->Rect(\$xpos, \$ypos, \$bw, \$bch, 'F');
\t\t\t\t\t\t}
\t\t\t\t\t\t\$xpos += \$bw;
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\t// Characters
\t\t\t\tif (\$bgcol) { \$this->SetFColor(\$bgcol); }
\t\t\t\telse { \$this->SetFColor(\$this->ConvertColor(255)); }
\t\t\t\t\$this->SetFontSize(3*\$fh*\$size*_MPDFK);\t// 3mm numerals (FontSize is larger to account for space above/below characters)
\t\t\t\t\$this->x = \$x + \$paddingL + \$llm;
\t\t\t\t\$this->y = \$y + \$paddingT;
\t\t\t\t\$this->Cell(\$bcw, \$num_height, \$supplement_code, 0, 0, 'C');

\t\t\t\t// Outer Right character (light margin)
\t\t\t\t\$this->SetFontSize((\$outerfontsize/3)*3*\$fh*\$size*_MPDFK);\t// 3mm numerals (FontSize is larger to account for space above/below characters)
\t\t\t\t\$this->x = \$x + \$paddingL + \$llm + \$bcw + \$rlm - (\$cw*0.9); // 0.9 is correction as char does not fill full width
\t\t\t\t\$this->y = \$y + \$paddingT;
\t\t\t\t\$this->Cell(\$cw*(\$outerfontsize/3), \$num_height, '>', 0, 0, 'R');
\t\t\t}



\t\t\t// Restore **************
\t\t\t\$this->SetFont(\$prevFontFamily, \$prevFontStyle, \$prevFontSizePt);
\t\t\t\$this->DrawColor = \$prevDrawColor;
\t\t\t\$this->TextColor = \$prevTextColor;
\t\t\t\$this->FillColor = \$prevFillColor;
\t\t\t\$this->SetLineWidth(\$lw);
\t\t\t\$this->SetY(\$y);
}



// ====================================================
// POSTAL and OTHER barcodes
function WriteBarcode2(\$code, \$x='', \$y='', \$size=1, \$height=1, \$bgcol=false, \$col=false, \$btype='IMB', \$print_ratio='', \$k=1) {
\t\t\tif (empty(\$code)) { return; }
\t\t\tif (!class_exists('PDFBarcode', false)) {
\t\t\t\tinclude(_MPDF_PATH.'classes/barcode.php');
\t\t\t}
\t\t\t\$this->barcode = new PDFBarcode();
\t\t\t\$arrcode = \$this->barcode->getBarcodeArray(\$code, \$btype, \$print_ratio);

\t\t\tif (\$arrcode === false) { \$this->Error('Error in barcode string: '.\$code); }
\t\t\tif (empty(\$x)) { \$x = \$this->x; }
\t\t\tif (empty(\$y)) { \$y = \$this->y; }
\t\t\t\$prevDrawColor = \$this->DrawColor;
\t\t\t\$prevTextColor = \$this->TextColor;
\t\t\t\$prevFillColor = \$this->FillColor;
\t\t\t\$lw = \$this->LineWidth;
\t\t\t\$this->SetLineWidth(0.01);
\t\t\t\$size /= \$k;\t// in case resized in a table
\t\t\t\$xres = \$arrcode['nom-X'] * \$size;

\t\t\tif (\$btype == 'IMB' || \$btype == 'RM4SCC' || \$btype == 'KIX' || \$btype == 'POSTNET' || \$btype == 'PLANET') {
\t\t\t\t\$llm = \$arrcode['quietL'] / \$k;\t// Left Quiet margin
\t\t\t\t\$rlm = \$arrcode['quietR'] / \$k;\t// Right Quiet margin
\t\t\t\t\$tlm = \$blm = \$arrcode['quietTB'] / \$k;
\t\t\t\t\$height=1;\t\t// Overrides
\t\t\t}
\t\t\telse if (in_array(\$btype, array('C128A','C128B','C128C','EAN128A','EAN128B','EAN128C','C39','C39+','C39E','C39E+','S25','S25+','I25','I25+','I25B','I25B+','C93','MSI','MSI+','CODABAR','CODE11'))) {
\t\t\t\t\$llm = \$arrcode['lightmL'] * \$xres;\t// Left Quiet margin
\t\t\t\t\$rlm = \$arrcode['lightmR'] * \$xres;\t// Right Quiet margin
\t\t\t\t\$tlm = \$blm = \$arrcode['lightTB'] * \$xres * \$height;
\t\t\t}


\t\t\t\$bcw = (\$arrcode[\"maxw\"] * \$xres);
\t\t\t\$fbw = \$bcw + \$llm + \$rlm;\t\t// Full barcode width incl. light margins

\t\t\t\$bch = (\$arrcode[\"nom-H\"] * \$size * \$height);
\t\t\t\$fbh = \$bch + \$tlm + \$blm;\t\t// Full barcode height

\t\t\t// PRINT border background color
\t\t\t\$xpos = \$x;
\t\t\t\$ypos = \$y;
\t\t\tif (\$col) {
\t\t\t\t\$this->SetDColor(\$col);
\t\t\t\t\$this->SetTColor(\$col);
\t\t\t}
\t\t\telse {
\t\t\t\t\$this->SetDColor(\$this->ConvertColor(0));
\t\t\t\t\$this->SetTColor(\$this->ConvertColor(0));
\t\t\t}
\t\t\tif (\$bgcol) {
\t\t\t\t\$this->SetFColor(\$bgcol);
\t\t\t}
\t\t\telse { \$this->SetFColor(\$this->ConvertColor(255)); }

\t\t\t// PRINT BARS
\t\t\tif (\$col) { \$this->SetFColor(\$col); }
\t\t\telse { \$this->SetFColor(\$this->ConvertColor(0)); }
\t\t\t\$xpos = \$x + \$llm ;

\t\t\tif (\$arrcode !== false) {
\t\t\t\tforeach (\$arrcode[\"bcode\"] AS \$v) {
\t\t\t\t\t\$bw = (\$v[\"w\"] * \$xres);
\t\t\t\t\tif (\$v[\"t\"]) {
\t\t\t\t\t\t\$ypos = \$y + \$tlm + (\$bch * \$v['p'] / \$arrcode['maxh']);
\t\t\t\t\t\t\$this->Rect(\$xpos, \$ypos, \$bw, (\$v['h'] * \$bch / \$arrcode['maxh']), 'F');
\t\t\t\t\t}
\t\t\t\t\t\$xpos += \$bw;
\t\t\t\t}
\t\t\t}

\t\t\t// PRINT BEARER BARS
\t\t\tif (\$btype == 'I25B' || \$btype == 'I25B+') {
\t\t\t\t\$this->Rect(\$x, \$y, \$fbw, (\$arrcode['lightTB'] * \$xres * \$height), 'F');
\t\t\t\t\$this->Rect(\$x, \$y+\$tlm+\$bch, \$fbw, (\$arrcode['lightTB'] * \$xres * \$height), 'F');
\t\t\t}

\t\t\t// Restore **************
\t\t\t\$this->SetFont(\$prevFontFamily, \$prevFontStyle, \$prevFontSizePt);
\t\t\t\$this->DrawColor = \$prevDrawColor;
\t\t\t\$this->TextColor = \$prevTextColor;
\t\t\t\$this->FillColor = \$prevFillColor;
\t\t\t\$this->SetLineWidth(\$lw);
\t\t\t\$this->SetY(\$y);
}

/*-- END BARCODES --*/

// ====================================================
// ====================================================

function StartTransform(\$returnstring=false) {
\t  if (\$returnstring) { return('q'); }
\t  else { \$this->_out('q'); }
}
function StopTransform(\$returnstring=false) {
\t  if (\$returnstring) { return('Q'); }
\t  else { \$this->_out('Q'); }
}
function transformScale(\$s_x, \$s_y, \$x='', \$y='', \$returnstring=false) {
\tif (\$x === '') {
\t\t\$x=\$this->x;
\t}
\tif (\$y === '') {
\t\t\$y=\$this->y;
\t}
\tif ((\$s_x == 0) OR (\$s_y == 0)) {
\t\t\$this->Error('Please do not use values equal to zero for scaling');
\t}
\t\$y = (\$this->h - \$y) * _MPDFK;
\t\$x *= _MPDFK;
\t//calculate elements of transformation matrix
\t\$s_x /= 100;
\t\$s_y /= 100;
\t\$tm[0] = \$s_x;
\t\$tm[1] = 0;
\t\$tm[2] = 0;
\t\$tm[3] = \$s_y;
\t\$tm[4] = \$x * (1 - \$s_x);
\t\$tm[5] = \$y * (1 - \$s_y);
\t//scale the coordinate system
\tif (\$returnstring) { return(\$this->_transform(\$tm, true)); }
\telse { \$this->_transform(\$tm); }
}
function transformTranslate(\$t_x, \$t_y, \$returnstring=false) {
\t//calculate elements of transformation matrix
\t\$tm[0] = 1;
\t\$tm[1] = 0;
\t\$tm[2] = 0;
\t\$tm[3] = 1;
\t\$tm[4] = \$t_x * _MPDFK;
\t\$tm[5] = -\$t_y * _MPDFK;
\t//translate the coordinate system
\tif (\$returnstring) { return(\$this->_transform(\$tm, true)); }
\telse { \$this->_transform(\$tm); }
}
function transformRotate(\$angle, \$x='', \$y='', \$returnstring=false) {
\tif (\$x === '') {
\t\t\$x=\$this->x;
\t}
\tif (\$y === '') {
\t\t\$y=\$this->y;
\t}
\t\$angle = -\$angle;
\t\$y = (\$this->h - \$y) * _MPDFK;
\t\$x *= _MPDFK;
\t//calculate elements of transformation matrix
\t\$tm[0] = cos(deg2rad(\$angle));
\t\$tm[1] = sin(deg2rad(\$angle));
\t\$tm[2] = -\$tm[1];
\t\$tm[3] = \$tm[0];
\t\$tm[4] = \$x + \$tm[1] * \$y - \$tm[0] * \$x;
\t\$tm[5] = \$y - \$tm[0] * \$y - \$tm[1] * \$x;
\t//rotate the coordinate system around (\$x,\$y)
\tif (\$returnstring) { return(\$this->_transform(\$tm, true)); }
\telse { \$this->_transform(\$tm); }
}
// mPDF 5.7.3 TRANSFORMS
function transformSkew(\$angle_x, \$angle_y, \$x='', \$y='', \$returnstring=false) {
\tif (\$x === '') {
\t\t\$x = \$this->x;
\t}
\tif (\$y === '') {
\t\t\$y = \$this->y;
\t}
\t\$angle_x = -\$angle_x;
\t\$angle_y = -\$angle_y;
\t\$x *= _MPDFK;
\t\$y = (\$this->h - \$y) * _MPDFK;
\t//calculate elements of transformation matrix
\t\$tm = array();
\t\$tm[0] = 1;
\t\$tm[1] = tan(deg2rad(\$angle_y));
\t\$tm[2] = tan(deg2rad(\$angle_x));
\t\$tm[3] = 1;
\t\$tm[4] = -\$tm[2] * \$y;
\t\$tm[5] = -\$tm[1] * \$x;
\t//skew the coordinate system
\tif (\$returnstring) { return(\$this->_transform(\$tm, true)); }
\telse { \$this->_transform(\$tm); }
}
function _transform(\$tm, \$returnstring=false) {
\tif (\$returnstring) { return(sprintf('%.4F %.4F %.4F %.4F %.4F %.4F cm', \$tm[0], \$tm[1], \$tm[2], \$tm[3], \$tm[4], \$tm[5])); }
\telse { \$this->_out(sprintf('%.4F %.4F %.4F %.4F %.4F %.4F cm', \$tm[0], \$tm[1], \$tm[2], \$tm[3], \$tm[4], \$tm[5])); }
}



/*-- INDIC --*/
// INDIC ============================
// This conversion can only be done when font is set
function ConvertIndic(&\$str) {
\tif (preg_match('/^ind_([a-z]{2})_/',\$this->currentfontfamily, \$m)) {
\t\tif (!class_exists('indic', false)) { include(_MPDF_PATH.'classes/indic.php'); }
\t\tif (empty(\$this->indic)) { \$this->indic = new indic(\$this); }
\t\t\$earr = \$this->UTF8StringToArray(\$str, false);
\t\t\$str = \$this->indic->substituteIndic(\$earr, \$m[1], \$this->currentfontfamily);
\t}
}
/*-- END INDIC --*/

// AUTOFONT =========================
function AutoFont(\$html) {
\tif (\$this->onlyCoreFonts) { return \$html; }
\t\$this->useLang = true;
\tif (\$this->autoFontGroupSize == 1) { \$extra = \$this->pregASCIIchars1; }
\telse if (\$this->autoFontGroupSize == 3) { \$extra = \$this->pregASCIIchars3; }
\telse {  \$extra = \$this->pregASCIIchars2; }
\t\$n = '';
\t\$a=preg_split('/<(.*?)>/ms',\$html,-1,PREG_SPLIT_DELIM_CAPTURE);
\tforeach(\$a as \$i => \$e) {
\t   if(\$i%2==0) {
\t\t\$e = strcode2utf(\$e);
\t\t\$e = \$this->lesser_entity_decode(\$e);

\t\t// Use U=FFF0 and U+FFF1 to mark start and end of span tags to prevent nesting occurring
\t\t// \"\\xef\\xbf\\xb0\" ##lthtmltag## \"\\xef\\xbf\\xb1\" ##gthtmltag##

/*-- CJK-FONTS --*/
\t\tif (\$this->autoFontGroups & AUTOFONT_CJK) {
\t\t\t\$e = preg_replace_callback(\"/([\".\$this->pregCJKchars .\$extra.\"]*[\".\$this->pregCJKchars .\"][\".\$this->pregCJKchars .\$extra.\"]*)/u\", array(\$this, 'replaceCJKPregCallback'), \$e );\t// mPDF 5.7+
\t\t}
/*-- END CJK-FONTS --*/

/*-- RTL --*/
\t\tif (\$this->autoFontGroups & AUTOFONT_RTL) {
\t\t\t// HEBREW
\t\t\t\$e = preg_replace(\"/([\".\$this->pregHEBchars .\$extra.\"]*[\".\$this->pregHEBchars .\"][\".\$this->pregHEBchars .\$extra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"he\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// All Arabic
\t\t\t\$e = preg_replace_callback(\"/([\".\$this->pregARABICchars .\$extra.\"]*[\".\$this->pregARABICchars .\"][\".\$this->pregARABICchars .\$extra.\"]*)/u\", array(\$this, 'replaceArabicPregCallback'), \$e );\t// mPDF 5.7+
\t\t}
/*-- END RTL --*/

/*-- INDIC --*/
\t\t// INDIC
\t\tif (\$this->autoFontGroups & AUTOFONT_INDIC) {
\t\t\t// Bengali
\t\t\t\$e = preg_replace(\"/([\".\$this->pregBNchars .\$this->pregINDextra.\"]*[\".\$this->pregBNchars .\"][\".\$this->pregBNchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"bn\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Devanagari (= script for Hindi, Nepali + Sindhi)
\t\t\t\$e = preg_replace(\"/([\".\$this->pregHIchars .\$this->pregINDextra.\"]*[\".\$this->pregHIchars .\"][\".\$this->pregHIchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"hi\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Gujarati
\t\t\t\$e = preg_replace(\"/([\".\$this->pregGUchars .\$this->pregINDextra.\"]*[\".\$this->pregGUchars .\"][\".\$this->pregGUchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"gu\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Malayalam
\t\t\t\$e = preg_replace(\"/([\".\$this->pregMLchars .\$this->pregINDextra.\"]*[\".\$this->pregMLchars .\"][\".\$this->pregMLchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"ml\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Kannada
\t\t\t\$e = preg_replace(\"/([\".\$this->pregKNchars .\$this->pregINDextra.\"]*[\".\$this->pregKNchars .\"][\".\$this->pregKNchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"kn\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Oriya
\t\t\t\$e = preg_replace(\"/([\".\$this->pregORchars .\$this->pregINDextra.\"]*[\".\$this->pregORchars .\"][\".\$this->pregORchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"or\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Punjabi ?= Gurmuhki
\t\t\t\$e = preg_replace(\"/([\".\$this->pregPAchars .\$this->pregINDextra.\"]*[\".\$this->pregPAchars .\"][\".\$this->pregPAchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"pa\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Tamil
\t\t\t\$e = preg_replace(\"/([\".\$this->pregTAchars .\$this->pregINDextra.\"]*[\".\$this->pregTAchars .\"][\".\$this->pregTAchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"ta\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Telugu
\t\t\t\$e = preg_replace(\"/([\".\$this->pregTEchars .\$this->pregINDextra.\"]*[\".\$this->pregTEchars .\"][\".\$this->pregTEchars .\$this->pregINDextra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"te\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t}
/*-- END INDIC --*/


\t\tif (\$this->autoFontGroups & AUTOFONT_THAIVIET) {
\t\t\t// THAI
\t\t\t\$e = preg_replace(\"/([\\x{0E00}-\\x{0E7F}\".\$extra.\"]*[\\x{0E00}-\\x{0E7F}][\\x{0E00}-\\x{0E7F}\".\$extra.\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"th\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t\t// Vietnamese
\t\t\t\$e = preg_replace(\"/([\".\$this->pregVIETchars .\$this->pregVIETPluschars .\"]*[\".\$this->pregVIETchars .\"][\".\$this->pregVIETchars .\$this->pregVIETPluschars .\"]*)/u\", \"\\xef\\xbf\\xb0span lang=\\\"vi\\\"\\xef\\xbf\\xb1\\\\1\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\", \$e);
\t\t}

\t\t\$e = preg_replace('/[&]/','&amp;',\$e);
\t\t\$e = preg_replace('/[<]/','&lt;',\$e);
\t\t\$e = preg_replace('/[>]/','&gt;',\$e);
\t\t\$e = preg_replace(\"/(\\xef\\xbf\\xb0span lang=\\\"([a-z\\-A-Z]{2,5})\\\"\\xef\\xbf\\xb1)\\s+/\",' \\\\1',\$e);
\t\t\$e = preg_replace(\"/[ ]+(\\xef\\xbf\\xb0\\/span\\xef\\xbf\\xb1)/\",'\\\\1 ',\$e);

\t\t\$e = preg_replace(\"/\\xef\\xbf\\xb0span lang=\\\"([a-z\\-A-Z]{2,5})\\\"\\xef\\xbf\\xb1/\",\"\\xef\\xbf\\xb0span lang=\\\"\\\\1\\\" class=\\\"lang_\\\\1\\\"\\xef\\xbf\\xb1\",\$e);

\t\t\$e = preg_replace(\"/\\xef\\xbf\\xb0/\",'<',\$e);
\t\t\$e = preg_replace(\"/\\xef\\xbf\\xb1/\",'>',\$e);

\t\t\$a[\$i] = \$e;
\t   }
\t   else {
\t\t\$a[\$i] = '<'.\$e.'>';
\t   }
\t}
\t\$n = implode('',\$a);
\treturn \$n;
}


/*-- CJK-FONTS --*/
function replaceCJK(\$str) {
\t// Use U=FFF0 and U+FFF1 to mark start and end of span tags to prevent nesting occurring
\t// \"\\xef\\xbf\\xb0\" ##lthtmltag## \"\\xef\\xbf\\xb1\" ##gthtmltag##
\tif (preg_match(\"/[\".\$this->pregUHCchars.\"]/u\", \$str)) {
\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"ko\\\"\\xef\\xbf\\xb1\" . \$str .\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t}
\telse if (preg_match(\"/[\".\$this->pregSJISchars.\"]/u\", \$str)) {
\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"ja\\\"\\xef\\xbf\\xb1\" . \$str .\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t}
\t// if in Unicode Plane 2, probably HKCS (incl in BIG5) if not Japanese
\telse if (preg_match(\"/[\\x{20000}-\\x{2FFFF}]/u\", \$str)) {
\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"zh-HK\\\"\\xef\\xbf\\xb1\" . \$str .\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t}
\telse{
\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"zh-CN\\\"\\xef\\xbf\\xb1\" . \$str .\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t}
\treturn \$str;
}

// mPDF 5.7+
function replaceCJKPregCallback(\$matches) {
\treturn \$this->replaceCJK(stripslashes(\$matches[1]));
}
/*-- END CJK-FONTS --*/

/*-- RTL --*/
function replaceArabic(\$str) {
\t// PASHTO, SINDHI, URDU, ARABIC, PERSIAN
\t\$persian = \"\\x{067E}\\x{0686}\\x{0698}\\x{06AF}\";

\t\$urdu = \"\\x{0679}\\x{0688}\\x{0691}\\x{06BA}\\x{06BE}\\x{06C1}\\x{06D2}\";
\t\$pashto = \"\\x{067C}\\x{0681}\\x{0685}\\x{0689}\\x{0693}\\x{0696}\\x{069A}\\x{06BC}\\x{06D0}\";\t// ? and U+06AB, U+06CD
\t\$sindhi = \"\\x{067A}\\x{067B}\\x{067D}\\x{067F}\\x{0680}\\x{0684}\\x{068D}\\x{068A}\\x{068F}\\x{068C}\\x{0687}\\x{0683}\\x{0699}\\x{06AA}\\x{06A6}\\x{06BB}\\x{06B1}\\x{06B3}\";
\t// Use U=FFF0 and U+FFF1 to mark start and end of span tags to prevent nesting occurring
\t// \"\\xef\\xbf\\xb0\" ##lthtmltag## \"\\xef\\xbf\\xb1\" ##gthtmltag##

\tif (preg_match(\"/[\".\$this->pregNonARABICchars .\"]/u\", \$str) ) {
\t\tif (preg_match(\"/[\".\$sindhi .\"]/u\", \$str) ) {
\t\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"sd\\\"\\xef\\xbf\\xb1\".\$str.\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t\t}
\t\telse if (preg_match(\"/[\".\$urdu .\"]/u\", \$str) ) {
\t\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"ur\\\"\\xef\\xbf\\xb1\".\$str.\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t\t}
\t\telse if (preg_match(\"/[\".\$pashto .\"]/u\", \$str) ) {
\t\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"ps\\\"\\xef\\xbf\\xb1\".\$str.\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t\t}
\t\telse if (preg_match(\"/[\".\$persian .\"]/u\", \$str) ) {
\t\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"fa\\\"\\xef\\xbf\\xb1\".\$str.\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t\t}
\t\telse {
\t\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"ar\\\"\\xef\\xbf\\xb1\".\$str.\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t\t}
\t}
\tif (preg_match(\"/[\".\$persian .\"]/u\", \$str) ) {
\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"fa\\\"\\xef\\xbf\\xb1\".\$str.\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t}
\telse {
\t\treturn \"\\xef\\xbf\\xb0span lang=\\\"ar\\\"\\xef\\xbf\\xb1\".\$str.\"\\xef\\xbf\\xb0/span\\xef\\xbf\\xb1\";
\t}
\treturn \$str;
}

// mPDF 5.7+
function replaceArabicPregCallback(\$matches) {
\treturn \$this->replaceArabic(stripslashes(\$matches[1]));
}

// ARABIC ===========================
// mPDF 5.4.08
function InitArabic() {

\t// JOIN TO FOLLOWING LETTER IN LOGICAL ORDER (i.e. AS INITIAL)
\t\$this->arabPrevLink = \"\";
\t// U+060c; U+061b; U+061f; U+0626; U+0628;
\t\$this->arabPrevLink .= \"\\xd8\\x8c\\xd8\\x9b\\xd8\\x9f\\xd8\\xa6\\xd8\\xa8\";
\t// U+062a; U+062b; U+062c; U+062d; U+062e;
\t\$this->arabPrevLink .= \"\\xd8\\xaa\\xd8\\xab\\xd8\\xac\\xd8\\xad\\xd8\\xae\";
\t// U+0633; U+0634; U+0635; U+0636; U+0637; U+0638; U+0639; U+063a;
\t\$this->arabPrevLink .= \"\\xd8\\xb3\\xd8\\xb4\\xd8\\xb5\\xd8\\xb6\\xd8\\xb7\\xd8\\xb8\\xd8\\xb9\\xd8\\xba\";
\t// U+0640; U+0641; U+0642; U+0643; U+0644; U+0645; U+0646; U+0647; U+0649; U+064a;
\t\$this->arabPrevLink .= \"\\xd9\\x80\\xd9\\x81\\xd9\\x82\\xd9\\x83\\xd9\\x84\\xd9\\x85\\xd9\\x86\\xd9\\x87\\xd9\\x89\\xd9\\x8a\";
\t// U+0678; U+0679; U+067a; U+067b; U+067c; U+067d; U+067e; U+067f;
\t\$this->arabPrevLink .= \"\\xd9\\xb8\\xd9\\xb9\\xd9\\xba\\xd9\\xbb\\xd9\\xbc\\xd9\\xbd\\xd9\\xbe\\xd9\\xbf\";
\t// U+0680; U+0681; U+0682; U+0683; U+0684; U+0685; U+0686; U+0687;
\t\$this->arabPrevLink .= \"\\xda\\x80\\xda\\x81\\xda\\x82\\xda\\x83\\xda\\x84\\xda\\x85\\xda\\x86\\xda\\x87\";
\t// U+069a; U+069b; U+069c; U+069d; U+069e; U+069f;
\t\$this->arabPrevLink .= \"\\xda\\x9a\\xda\\x9b\\xda\\x9c\\xda\\x9d\\xda\\x9e\\xda\\x9f\";
\t// U+06a0; U+06a1; U+06a2; U+06a3; U+06a4; U+06a5; U+06a6; U+06A7; U+06A8;
\t\$this->arabPrevLink .= \"\\xda\\xa0\\xda\\xa1\\xda\\xa2\\xda\\xa3\\xda\\xa4\\xda\\xa5\\xda\\xa6\\xda\\xa7\\xda\\xa8\";
\t// U+06a9; U+06aa; U+06ab; U+06ac; U+06ad; U+06ae; U+06af;
\t\$this->arabPrevLink .= \"\\xda\\xa9\\xda\\xaa\\xda\\xab\\xda\\xac\\xda\\xad\\xda\\xae\\xda\\xaf\";
\t// U+06b0; U+06b1; U+06b2; U+06b3; U+06b4; U+06b5; U+06b6; U+06b7; U+06b8; U+06b9;
\t\$this->arabPrevLink .= \"\\xda\\xb0\\xda\\xb1\\xda\\xb2\\xda\\xb3\\xda\\xb4\\xda\\xb5\\xda\\xb6\\xda\\xb7\\xda\\xb8\\xda\\xb9\";
\t// U+06ba; U+06bb; U+06bc; U+06be; U+06bf;
\t\$this->arabPrevLink .= \"\\xda\\xba\\xda\\xbb\\xda\\xbc\\xda\\xbe\\xda\\xbf\";
\t// U+06c1; U+06cc; U+06ce; U+06d0; U+06d1;
\t\$this->arabPrevLink .= \"\\xdb\\x81\\xdb\\x8c\\xdb\\x8e\\xdb\\x90\\xdb\\x91\";




\t// JOIN TO PREVIOUS LETTER IN LOGICAL ORDER (i.e. AS FINAL FORM)
\t\$this->arabNextLink = \"\";
\t// U+0622; U+0623; U+0624; U+0625; U+0626; U+0627; U+0628; U+0629;
\t\$this->arabNextLink .= \"\\xd8\\xa2\\xd8\\xa3\\xd8\\xa4\\xd8\\xa5\\xd8\\xa6\\xd8\\xa7\\xd8\\xa8\\xd8\\xa9\";
\t// U+062A; U+062B; U+062C; U+062D; U+062E; U+062F;
\t\$this->arabNextLink .= \"\\xd8\\xaa\\xd8\\xab\\xd8\\xac\\xd8\\xad\\xd8\\xae\\xd8\\xaf\";
\t// U+0630; U+0631; U+0632; U+0633; U+0634; U+0635; U+0636; U+0637; U+0638; U+0639; U+063A;
\t\$this->arabNextLink .= \"\\xd8\\xb0\\xd8\\xb1\\xd8\\xb2\\xd8\\xb3\\xd8\\xb4\\xd8\\xb5\\xd8\\xb6\\xd8\\xb7\\xd8\\xb8\\xd8\\xb9\\xd8\\xba\";
\t// U+0640; U+0641; U+0642; U+0643; U+0644; U+0645; U+0646; U+0647; U+0648; U+0649; U+064A;
\t\$this->arabNextLink .= \"\\xd9\\x80\\xd9\\x81\\xd9\\x82\\xd9\\x83\\xd9\\x84\\xd9\\x85\\xd9\\x86\\xd9\\x87\\xd9\\x88\\xd9\\x89\\xd9\\x8a\";
\t// U+0671; U+0672; U+0675; U+0676; U+0677; U+0678; U+0679;
\t\$this->arabNextLink .= \"\\xd9\\xb1\\xd9\\xb2\\xd9\\xb5\\xd9\\xb6\\xd9\\xb7\\xd9\\xb8\\xd9\\xb9\";
\t// U+067A; U+067B; U+067C; U+067D; U+067E; U+067F;
\t\$this->arabNextLink .= \"\\xd9\\xba\\xd9\\xbb\\xd9\\xbc\\xd9\\xbd\\xd9\\xbe\\xd9\\xbf\";
\t// U+0680; U+0681; U+0682; U+0683; U+0684; U+0685; U+0686; U+0687; U+0688; U+0689;
\t\$this->arabNextLink .= \"\\xda\\x80\\xda\\x81\\xda\\x82\\xda\\x83\\xda\\x84\\xda\\x85\\xda\\x86\\xda\\x87\\xda\\x88\\xda\\x89\";
\t// U+068A; U+068B; U+068C; U+068D;  U+068F;U+068F;
\t\$this->arabNextLink .= \"\\xda\\x8a\\xda\\x8b\\xda\\x8c\\xda\\x8d\\xda\\x8e\\xda\\x8f\";
\t// U+0690; U+0691; U+0692; U+0693; U+0694; U+0695; U+0696; U+0697; U+0698; U+0699;
\t\$this->arabNextLink .= \"\\xda\\x90\\xda\\x91\\xda\\x92\\xda\\x93\\xda\\x94\\xda\\x95\\xda\\x96\\xda\\x97\\xda\\x98\\xda\\x99\";
\t// U+069A; U+069B; U+069C; U+069D; U+069E; U+069F;
\t\$this->arabNextLink .= \"\\xda\\x9a\\xda\\x9b\\xda\\x9c\\xda\\x9d\\xda\\x9e\\xda\\x9f\";
\t// U+06A0; U+06A1; U+06A2; U+06A3; U+06A4; U+06A5; U+06A6; U+06A7; U+06A8; U+06A9;
\t\$this->arabNextLink .= \"\\xda\\xa0\\xda\\xa1\\xda\\xa2\\xda\\xa3\\xda\\xa4\\xda\\xa5\\xda\\xa6\\xda\\xa7\\xda\\xa8\\xda\\xa9\";
\t// U+06AA; U+06AB; U+06AC; U+06AD; U+06AE; U+06AF;
\t\$this->arabNextLink .= \"\\xda\\xaa\\xda\\xab\\xda\\xac\\xda\\xad\\xda\\xae\\xda\\xaf\";
\t// U+06B0; U+06B1; U+06B2; U+06B3; U+06B4; U+06B5; U+06B6; U+06B7; U+06B8; U+06B9;
\t\$this->arabNextLink .= \"\\xda\\xb0\\xda\\xb1\\xda\\xb2\\xda\\xb3\\xda\\xb4\\xda\\xb5\\xda\\xb6\\xda\\xb7\\xda\\xb8\\xda\\xb9\";
\t// U+06BA; U+06BB; U+06BC; U+06BE; U+06BF;
\t\$this->arabNextLink .= \"\\xda\\xba\\xda\\xbb\\xda\\xbc\\xda\\xbe\\xda\\xbf\";
\t// U+06C0; U+06C1; U+06C2; U+06C3; U+06C4; U+06C5; U+06C6; U+06C7; U+06C8; U+06C9;
\t\$this->arabNextLink .= \"\\xdb\\x80\\xdb\\x81\\xdb\\x82\\xdb\\x83\\xdb\\x84\\xdb\\x85\\xdb\\x86\\xdb\\x87\\xdb\\x88\\xdb\\x89\";
\t// U+06CA; U+06CB; U+06CC; U+06CD; U+06CE; U+06CF;
\t\$this->arabNextLink .= \"\\xdb\\x8a\\xdb\\x8b\\xdb\\x8c\\xdb\\x8d\\xdb\\x8e\\xdb\\x8f\";
\t// U+06D0; U+06d1; U+06D2; U+06D3;
\t\$this->arabNextLink .= \"\\xdb\\x90\\xdb\\x91\\xdb\\x92\\xdb\\x93\";


\t// VOWELS ++

\t// U+064b U+064c; U+064d; U+064e; U+064f; U+0650; U+0651; U+0652;
\t\$this->arabVowels = \"\\xd9\\x8b\\xd9\\x8c\\xd9\\x8d\\xd9\\x8e\\xd9\\x8f\\xd9\\x90\\xd9\\x91\\xd9\\x92\";

\t// Added chars that may not be vowels but should not interrupt joining
\t// U+0670; U+0653;
\t\$this->arabVowels .= \"\\xd9\\xb0\\xd9\\x93\";
\t// ? should also add - U+615, 616, 617-61A, 653-65E, 6D6-6DC, 6DF-6E4, 6E7, 6E8, 6EA-6ED



\t// ISOLATED FORM :: FINAL :: INITIAL :: MEDIAL
\t// FB** - FE** = Arabic presentation Forms
\t// F5** F6** F7** = Private use area used by unAGlyphs in mPDF
\t\$this->arabGlyphs = array(
\t\"\\xd8\\x8c\"=>array(\"\\xd8\\x8c\", \"\\xd8\\x8c\", \"\\xd8\\x8c\", \"\\xd8\\x8c\"), /* 060C, 060C, 060C, 060C */
\t\"\\xd8\\x9b\"=>array(\"\\xd8\\x9b\", \"\\xd8\\x9b\", \"\\xd8\\x9b\", \"\\xd8\\x9b\"), /* 061B, 061B, 061B, 061B */
\t\"\\xd8\\x9f\"=>array(\"\\xd8\\x9f\", \"\\xd8\\x9f\", \"\\xd8\\x9f\", \"\\xd8\\x9f\"), /* 061F, 061F, 061F, 061F */
\t\"\\xd8\\xa1\"=>array(\"\\xd8\\xa1\", \"\\xd8\\xa1\", \"\\xd8\\xa1\", \"\\xd8\\xa1\"), /* 0621, 0621, 0621, 0621 */
\t\"\\xd8\\xa2\"=>array(\"\\xd8\\xa2\", \"\\xef\\xba\\x82\", \"\\xd8\\xa2\", \"\\xef\\xba\\x82\"), /* 0622, FE82, 0622, FE82 */
\t\"\\xd8\\xa3\"=>array(\"\\xd8\\xa3\", \"\\xef\\xba\\x84\", \"\\xd8\\xa3\", \"\\xef\\xba\\x84\"), /* 0623, FE84, 0623, FE84 */
\t\"\\xd8\\xa4\"=>array(\"\\xd8\\xa4\", \"\\xef\\xba\\x86\", \"\\xd8\\xa4\", \"\\xef\\xba\\x86\"), /* 0624, FE86, 0624, FE86 */
\t\"\\xd8\\xa5\"=>array(\"\\xd8\\xa5\", \"\\xef\\xba\\x88\", \"\\xd8\\xa5\", \"\\xef\\xba\\x88\"), /* 0625, FE88, 0625, FE88 */
\t\"\\xd8\\xa6\"=>array(\"\\xd8\\xa6\", \"\\xef\\xba\\x8a\", \"\\xef\\xba\\x8b\", \"\\xef\\xba\\x8c\"), /* 0626, FE8A, FE8B, FE8C */
\t\"\\xd8\\xa7\"=>array(\"\\xd8\\xa7\", \"\\xef\\xba\\x8e\", \"\\xd8\\xa7\", \"\\xef\\xba\\x8e\"), /* 0627, FE8E, 0627, FE8E */
\t\"\\xd8\\xa8\"=>array(\"\\xd8\\xa8\", \"\\xef\\xba\\x90\", \"\\xef\\xba\\x91\", \"\\xef\\xba\\x92\"), /* 0628, FE90, FE91, FE92 */
\t\"\\xd8\\xa9\"=>array(\"\\xd8\\xa9\", \"\\xef\\xba\\x94\", \"\\xd8\\xa9\", \"\\xef\\xba\\x94\"), /* 0629, FE94, 0629, FE94 */
\t\"\\xd8\\xaa\"=>array(\"\\xd8\\xaa\", \"\\xef\\xba\\x96\", \"\\xef\\xba\\x97\", \"\\xef\\xba\\x98\"), /* 062A, FE96, FE97, FE98 */
\t\"\\xd8\\xab\"=>array(\"\\xd8\\xab\", \"\\xef\\xba\\x9a\", \"\\xef\\xba\\x9b\", \"\\xef\\xba\\x9c\"), /* 062B, FE9A, FE9B, FE9C */
\t\"\\xd8\\xac\"=>array(\"\\xd8\\xac\", \"\\xef\\xba\\x9e\", \"\\xef\\xba\\x9f\", \"\\xef\\xba\\xa0\"), /* 062C, FE9E, FE9F, FEA0 */
\t\"\\xd8\\xad\"=>array(\"\\xd8\\xad\", \"\\xef\\xba\\xa2\", \"\\xef\\xba\\xa3\", \"\\xef\\xba\\xa4\"), /* 062D, FEA2, FEA3, FEA4 */
\t\"\\xd8\\xae\"=>array(\"\\xd8\\xae\", \"\\xef\\xba\\xa6\", \"\\xef\\xba\\xa7\", \"\\xef\\xba\\xa8\"), /* 062E, FEA6, FEA7, FEA8 */
\t\"\\xd8\\xaf\"=>array(\"\\xd8\\xaf\", \"\\xef\\xba\\xaa\", \"\\xd8\\xaf\", \"\\xef\\xba\\xaa\"), /* 062F, FEAA, 062F, FEAA */
\t\"\\xd8\\xb0\"=>array(\"\\xd8\\xb0\", \"\\xef\\xba\\xac\", \"\\xd8\\xb0\", \"\\xef\\xba\\xac\"), /* 0630, FEAC, 0630, FEAC */
\t\"\\xd8\\xb1\"=>array(\"\\xd8\\xb1\", \"\\xef\\xba\\xae\", \"\\xd8\\xb1\", \"\\xef\\xba\\xae\"), /* 0631, FEAE, 0631, FEAE */
\t\"\\xd8\\xb2\"=>array(\"\\xd8\\xb2\", \"\\xef\\xba\\xb0\", \"\\xd8\\xb2\", \"\\xef\\xba\\xb0\"), /* 0632, FEB0, 0632, FEB0 */
\t\"\\xd8\\xb3\"=>array(\"\\xd8\\xb3\", \"\\xef\\xba\\xb2\", \"\\xef\\xba\\xb3\", \"\\xef\\xba\\xb4\"), /* 0633, FEB2, FEB3, FEB4 */
\t\"\\xd8\\xb4\"=>array(\"\\xd8\\xb4\", \"\\xef\\xba\\xb6\", \"\\xef\\xba\\xb7\", \"\\xef\\xba\\xb8\"), /* 0634, FEB6, FEB7, FEB8 */
\t\"\\xd8\\xb5\"=>array(\"\\xd8\\xb5\", \"\\xef\\xba\\xba\", \"\\xef\\xba\\xbb\", \"\\xef\\xba\\xbc\"), /* 0635, FEBA, FEBB, FEBC */
\t\"\\xd8\\xb6\"=>array(\"\\xd8\\xb6\", \"\\xef\\xba\\xbe\", \"\\xef\\xba\\xbf\", \"\\xef\\xbb\\x80\"), /* 0636, FEBE, FEBF, FEC0 */
\t\"\\xd8\\xb7\"=>array(\"\\xd8\\xb7\", \"\\xef\\xbb\\x82\", \"\\xef\\xbb\\x83\", \"\\xef\\xbb\\x84\"), /* 0637, FEC2, FEC3, FEC4 */
\t\"\\xd8\\xb8\"=>array(\"\\xd8\\xb8\", \"\\xef\\xbb\\x86\", \"\\xef\\xbb\\x87\", \"\\xef\\xbb\\x88\"), /* 0638, FEC6, FEC7, FEC8 */
\t\"\\xd8\\xb9\"=>array(\"\\xd8\\xb9\", \"\\xef\\xbb\\x8a\", \"\\xef\\xbb\\x8b\", \"\\xef\\xbb\\x8c\"), /* 0639, FECA, FECB, FECC */
\t\"\\xd8\\xba\"=>array(\"\\xd8\\xba\", \"\\xef\\xbb\\x8e\", \"\\xef\\xbb\\x8f\", \"\\xef\\xbb\\x90\"), /* 063A, FECE, FECF, FED0 */
\t\"\\xd9\\x80\"=>array(\"\\xd9\\x80\", \"\\xd9\\x80\", \"\\xd9\\x80\", \"\\xd9\\x80\"), /* 0640, 0640, 0640, 0640 */
\t\"\\xd9\\x81\"=>array(\"\\xd9\\x81\", \"\\xef\\xbb\\x92\", \"\\xef\\xbb\\x93\", \"\\xef\\xbb\\x94\"), /* 0641, FED2, FED3, FED4 */
\t\"\\xd9\\x82\"=>array(\"\\xd9\\x82\", \"\\xef\\xbb\\x96\", \"\\xef\\xbb\\x97\", \"\\xef\\xbb\\x98\"), /* 0642, FED6, FED7, FED8 */
\t\"\\xd9\\x83\"=>array(\"\\xd9\\x83\", \"\\xef\\xbb\\x9a\", \"\\xef\\xbb\\x9b\", \"\\xef\\xbb\\x9c\"), /* 0643, FEDA, FEDB, FEDC */
\t\"\\xd9\\x84\"=>array(\"\\xd9\\x84\", \"\\xef\\xbb\\x9e\", \"\\xef\\xbb\\x9f\", \"\\xef\\xbb\\xa0\"), /* 0644, FEDE, FEDF, FEE0 */
\t\"\\xd9\\x85\"=>array(\"\\xd9\\x85\", \"\\xef\\xbb\\xa2\", \"\\xef\\xbb\\xa3\", \"\\xef\\xbb\\xa4\"), /* 0645, FEE2, FEE3, FEE4 */
\t\"\\xd9\\x86\"=>array(\"\\xd9\\x86\", \"\\xef\\xbb\\xa6\", \"\\xef\\xbb\\xa7\", \"\\xef\\xbb\\xa8\"), /* 0646, FEE6, FEE7, FEE8 */
\t\"\\xd9\\x87\"=>array(\"\\xd9\\x87\", \"\\xef\\xbb\\xaa\", \"\\xef\\xbb\\xab\", \"\\xef\\xbb\\xac\"), /* 0647, FEEA, FEEB, FEEC */
\t\"\\xd9\\x88\"=>array(\"\\xd9\\x88\", \"\\xef\\xbb\\xae\", \"\\xd9\\x88\", \"\\xef\\xbb\\xae\"), /* 0648, FEEE, 0648, FEEE */

/* 0649 Alef Maksura should only appear at end of word (in Arabic) So Initial and medial are shown as isolated/final */
\t\"\\xd9\\x89\"=>array(\"\\xd9\\x89\", \"\\xef\\xbb\\xb0\", \"\\xd9\\x89\", \"\\xef\\xbb\\xb0\"), /* 0649, FEF0, 0649, FEF0 */

/* 0649 Alef Maksura Initial and Medial forms as given in Unicode FBE8 and FBE9 for Uighur Kazakh (not in some fonts) */
\t\"\\xd9\\x89\"=>array(\"\\xd9\\x89\", \"\\xef\\xbb\\xb0\", \"\\xef\\xaf\\xa8\", \"\\xef\\xaf\\xa9\"), /* 0649, FEF0, FBE8, FBE9 not in most fonts */

\t\"\\xd9\\x8a\"=>array(\"\\xd9\\x8a\", \"\\xef\\xbb\\xb2\", \"\\xef\\xbb\\xb3\", \"\\xef\\xbb\\xb4\"), /* 064A, FEF2, FEF3, FEF4 */
\t\"\\xd9\\x8b\"=>array(\"\\xd9\\x8b\", \"\\xd9\\x8b\", \"\\xd9\\x8b\", \"\\xd9\\x8b\"), /* 064B, 064B, 064B, 064B */
\t\"\\xd9\\x8c\"=>array(\"\\xd9\\x8c\", \"\\xd9\\x8c\", \"\\xd9\\x8c\", \"\\xd9\\x8c\"), /* 064C, 064C, 064C, 064C */
\t\"\\xd9\\x8d\"=>array(\"\\xd9\\x8d\", \"\\xd9\\x8d\", \"\\xd9\\x8d\", \"\\xd9\\x8d\"), /* 064D, 064D, 064D, 064D */
\t\"\\xd9\\x8e\"=>array(\"\\xd9\\x8e\", \"\\xd9\\x8e\", \"\\xd9\\x8e\", \"\\xd9\\x8e\"), /* 064E, 064E, 064E, 064E */
\t\"\\xd9\\x8f\"=>array(\"\\xd9\\x8f\", \"\\xd9\\x8f\", \"\\xd9\\x8f\", \"\\xd9\\x8f\"), /* 064F, 064F, 064F, 064F */
\t\"\\xd9\\x90\"=>array(\"\\xd9\\x90\", \"\\xd9\\x90\", \"\\xd9\\x90\", \"\\xd9\\x90\"), /* 0650, 0650, 0650, 0650 */
\t\"\\xd9\\x91\"=>array(\"\\xd9\\x91\", \"\\xd9\\x91\", \"\\xd9\\x91\", \"\\xd9\\x91\"), /* 0651, 0651, 0651, 0651 */
\t\"\\xd9\\x92\"=>array(\"\\xd9\\x92\", \"\\xd9\\x92\", \"\\xd9\\x92\", \"\\xd9\\x92\"), /* 0652, 0652, 0652, 0652 */
\t\"\\xd9\\xb1\"=>array(\"\\xd9\\xb1\", \"\\xef\\xad\\x91\", \"\\xd9\\xb1\", \"\\xef\\xad\\x91\"), /* 0671, FB51, 0671, FB51 */
\t\"\\xd9\\xb2\"=>array(\"\\xd9\\xb2\", \"\\xef\\x95\\xb2\", \"\\xd9\\xb2\", \"\\xef\\x95\\xb2\"), /* 0672, F572, 0672, F572 */
\t\"\\xd9\\xb5\"=>array(\"\\xd9\\xb5\", \"\\xef\\x95\\xb5\", \"\\xd9\\xb5\", \"\\xef\\x95\\xb5\"), /* 0675, F575, 0675, F575 */
\t\"\\xd9\\xb8\"=>array(\"\\xd9\\xb8\", \"\\xef\\x95\\xb8\", \"\\xef\\xba\\x8b\", \"\\xef\\xba\\x8c\"), /* 0678, F578, FE8B, FE8C ( as 0626 ) */
\t\"\\xd9\\xb9\"=>array(\"\\xd9\\xb9\", \"\\xef\\xad\\xa7\", \"\\xef\\xad\\xa8\", \"\\xef\\xad\\xa9\"), /* 0679, FB67, FB68, FB69 */
\t\"\\xd9\\xba\"=>array(\"\\xd9\\xba\", \"\\xef\\xad\\x9f\", \"\\xef\\xad\\xa0\", \"\\xef\\xad\\xa1\"), /* 067A, FB5F, FB60, FB61 */
\t\"\\xd9\\xbb\"=>array(\"\\xd9\\xbb\", \"\\xef\\xad\\x93\", \"\\xef\\xad\\x94\", \"\\xef\\xad\\x95\"), /* 067B, FB53, FB54, FB55 */
\t\"\\xd9\\xbc\"=>array(\"\\xd9\\xbc\", \"\\xef\\x95\\xbc\", \"\\xef\\x99\\xbc\", \"\\xef\\x9d\\xbc\"), /* 067C, F57C, F67C, F77C */
\t\"\\xd9\\xbd\"=>array(\"\\xd9\\xbd\", \"\\xef\\x95\\xbd\", \"\\xef\\x99\\xbd\", \"\\xef\\x9d\\xbd\"), /* 067D, F57D, F67D, F77D */
\t\"\\xd9\\xbe\"=>array(\"\\xd9\\xbe\", \"\\xef\\xad\\x97\", \"\\xef\\xad\\x98\", \"\\xef\\xad\\x99\"), /* 067E, FB57, FB58, FB59 */
\t\"\\xd9\\xbf\"=>array(\"\\xd9\\xbf\", \"\\xef\\xad\\xa3\", \"\\xef\\xad\\xa4\", \"\\xef\\xad\\xa5\"), /* 067F, FB63, FB64, FB65 */
\t\"\\xda\\x80\"=>array(\"\\xda\\x80\", \"\\xef\\xad\\x9b\", \"\\xef\\xad\\x9c\", \"\\xef\\xad\\x9d\"), /* 0680, FB5B, FB5C, FB5D */
\t\"\\xda\\x81\"=>array(\"\\xda\\x81\", \"\\xef\\x96\\x81\", \"\\xef\\x9a\\x81\", \"\\xef\\x9e\\x81\"), /* 0681, F581, F681, F781 */
\t\"\\xda\\x82\"=>array(\"\\xda\\x82\", \"\\xef\\x96\\x82\", \"\\xef\\x9a\\x82\", \"\\xef\\x9e\\x82\"), /* 0682, F582, F682, F782 */
\t\"\\xda\\x83\"=>array(\"\\xda\\x83\", \"\\xef\\xad\\xb7\", \"\\xef\\xad\\xb8\", \"\\xef\\xad\\xb9\"), /* 0683, FB77, FB78, FB79 */
\t\"\\xda\\x84\"=>array(\"\\xda\\x84\", \"\\xef\\xad\\xb3\", \"\\xef\\xad\\xb4\", \"\\xef\\xad\\xb5\"), /* 0684, FB73, FB74, FB75 */
\t\"\\xda\\x85\"=>array(\"\\xda\\x85\", \"\\xef\\x96\\x85\", \"\\xef\\x9a\\x85\", \"\\xef\\x9e\\x85\"), /* 0685, F585, F685, F785 */
\t\"\\xda\\x86\"=>array(\"\\xda\\x86\", \"\\xef\\xad\\xbb\", \"\\xef\\xad\\xbc\", \"\\xef\\xad\\xbd\"), /* 0686, FB7B, FB7C, FB7D */
\t\"\\xda\\x87\"=>array(\"\\xda\\x87\", \"\\xef\\xad\\xbf\", \"\\xef\\xae\\x80\", \"\\xef\\xae\\x81\"), /* 0687, FB7F, FB80, FB81 */
\t\"\\xda\\x88\"=>array(\"\\xda\\x88\", \"\\xef\\xae\\x89\", \"\\xda\\x88\", \"\\xda\\x88\"), /* 0688, FB89, 0688, 0688 */
\t\"\\xda\\x89\"=>array(\"\\xda\\x89\", \"\\xef\\x96\\x89\", \"\\xda\\x89\", \"\\xda\\x89\"), /* 0689, F589, 0689, 0689 */
\t\"\\xda\\x91\"=>array(\"\\xda\\x91\", \"\\xef\\xae\\x8d\", \"\\xda\\x91\", \"\\xef\\xae\\x8d\"), /* 0691, FB8D, 0691, FB8D */
\t\"\\xda\\x93\"=>array(\"\\xda\\x93\", \"\\xef\\x96\\x93\", \"\\xda\\x93\", \"\\xda\\x93\"), /* 0693, F593, 0693, 0693 */
\t\"\\xda\\x96\"=>array(\"\\xda\\x96\", \"\\xef\\x96\\x96\", \"\\xda\\x96\", \"\\xda\\x96\"), /* 0696, F596, 0696, 0696 */
\t\"\\xda\\x98\"=>array(\"\\xda\\x98\", \"\\xef\\xae\\x8b\", \"\\xda\\x98\", \"\\xef\\xae\\x8b\"), /* 0698, FB8B, 0698, FB8B */
\t\"\\xda\\x9a\"=>array(\"\\xda\\x9a\", \"\\xef\\x96\\x9a\", \"\\xef\\x9a\\x9a\", \"\\xef\\x9e\\x9a\"), /* 069A, F59A, F69A, F79A */
\t\"\\xda\\x9b\"=>array(\"\\xda\\x9b\", \"\\xef\\x96\\x9b\", \"\\xef\\x9a\\x9b\", \"\\xef\\x9e\\x9b\"), /* 069B, F59B, F69B, F79B */
\t\"\\xda\\x9c\"=>array(\"\\xda\\x9c\", \"\\xef\\x96\\x9c\", \"\\xef\\x9a\\x9c\", \"\\xef\\x9e\\x9c\"), /* 069C, F59C, F69C, F79C */
\t\"\\xda\\x9d\"=>array(\"\\xda\\x9d\", \"\\xef\\x96\\x9d\", \"\\xef\\x9a\\x9d\", \"\\xef\\x9e\\x9d\"), /* 069D, F59D, F69D, F79D */
\t\"\\xda\\x9e\"=>array(\"\\xda\\x9e\", \"\\xef\\x96\\x9e\", \"\\xef\\x9a\\x9e\", \"\\xef\\x9e\\x9e\"), /* 069E, F59E, F69E, F79E */
\t\"\\xda\\xa0\"=>array(\"\\xda\\xa0\", \"\\xef\\x96\\xa0\", \"\\xef\\x9a\\xa0\", \"\\xef\\x9e\\xa0\"), /* 06A0, F5A0, F6A0, F7A0 */
\t\"\\xda\\xa1\"=>array(\"\\xda\\xa1\", \"\\xef\\x96\\xa1\", \"\\xef\\x9a\\xa1\", \"\\xef\\x9e\\xa1\"), /* 06A1, F5A1, F6A1, F7A1 */
\t\"\\xda\\xa2\"=>array(\"\\xda\\xa2\", \"\\xef\\x96\\xa2\", \"\\xef\\x9a\\xa2\", \"\\xef\\x9e\\xa2\"), /* 06A2, F5A2, F6A2, F7A2 */
\t\"\\xda\\xa3\"=>array(\"\\xda\\xa3\", \"\\xef\\x96\\xa3\", \"\\xef\\x9a\\xa3\", \"\\xef\\x9e\\xa3\"), /* 06A3, F5A3, F6A3, F7A3 */
\t\"\\xda\\xa4\"=>array(\"\\xda\\xa4\", \"\\xef\\xad\\xab\", \"\\xef\\xad\\xac\", \"\\xef\\xad\\xad\"), /* 06A4, FB6B, FB6C, FB6D */
\t\"\\xda\\xa5\"=>array(\"\\xda\\xa5\", \"\\xef\\x96\\xa5\", \"\\xef\\x9a\\xa5\", \"\\xef\\x9e\\xa5\"), /* 06A5, F5A5, F6A5, F7A5 */
\t\"\\xda\\xa6\"=>array(\"\\xda\\xa6\", \"\\xef\\xad\\xaf\", \"\\xef\\xad\\xb0\", \"\\xef\\xad\\xb1\"), /* 06A6, FB6F, FB70, FB71 */
\t\"\\xda\\xa9\"=>array(\"\\xda\\xa9\", \"\\xef\\xae\\x8f\", \"\\xef\\xae\\x90\", \"\\xef\\xae\\x91\"), /* 06A9, FB8F, FB90, FB91 */
\t\"\\xda\\xaa\"=>array(\"\\xda\\xaa\", \"\\xef\\x96\\xaa\", \"\\xef\\x9a\\xaa\", \"\\xef\\x9e\\xaa\"), /* 06AA, F5AA, F6AA, F7AA */
\t\"\\xda\\xab\"=>array(\"\\xda\\xab\", \"\\xef\\x96\\xab\", \"\\xef\\x9a\\xab\", \"\\xef\\x9e\\xab\"), /* 06AB, F5AB, F6AB, F7AB */
\t\"\\xda\\xac\"=>array(\"\\xda\\xac\", \"\\xef\\x96\\xac\", \"\\xef\\x9a\\xac\", \"\\xef\\x9e\\xac\"), /* 06AC, F5AC, F6AC, F7AC */
\t\"\\xda\\xad\"=>array(\"\\xda\\xad\", \"\\xef\\xaf\\x94\", \"\\xef\\xaf\\x95\", \"\\xef\\xaf\\x96\"), /* 06AD, FBD4, FBD5, FBD6 */
\t\"\\xda\\xae\"=>array(\"\\xda\\xae\", \"\\xef\\x96\\xae\", \"\\xef\\x9a\\xae\", \"\\xef\\x9e\\xae\"), /* 06AE, F5AE, F6AE, F7AE */
\t\"\\xda\\xaf\"=>array(\"\\xda\\xaf\", \"\\xef\\xae\\x93\", \"\\xef\\xae\\x94\", \"\\xef\\xae\\x95\"), /* 06Af, FB93, FB94, FB95 */
\t\"\\xda\\xb0\"=>array(\"\\xda\\xb0\", \"\\xef\\x96\\xb0\", \"\\xef\\x9a\\xb0\", \"\\xef\\x9e\\xb0\"), /* 06B0, F5B0, F6B0, F7B0 */
\t\"\\xda\\xb1\"=>array(\"\\xda\\xb1\", \"\\xef\\xae\\x9b\", \"\\xef\\xae\\x9c\", \"\\xef\\xae\\x9d\"), /* 06B1, FB9B, FB9C, FB9D */
\t\"\\xda\\xb2\"=>array(\"\\xda\\xb2\", \"\\xef\\x96\\xb2\", \"\\xef\\x9a\\xb2\", \"\\xef\\x9e\\xb2\"), /* 06B2, F5B2, F6B2, F7B2 */
\t\"\\xda\\xb3\"=>array(\"\\xda\\xb3\", \"\\xef\\xae\\x97\", \"\\xef\\xae\\x98\", \"\\xef\\xae\\x99\"), /* 06B3, FB97, FB98, FB99 */
\t\"\\xda\\xb4\"=>array(\"\\xda\\xb4\", \"\\xef\\x96\\xb4\", \"\\xef\\x9a\\xb4\", \"\\xef\\x9e\\xb4\"), /* 06B4, F5B4, F6B4, F7B4 */
\t\"\\xda\\xb5\"=>array(\"\\xda\\xb5\", \"\\xef\\x96\\xb5\", \"\\xef\\x9a\\xb5\", \"\\xef\\x9e\\xb5\"), /* 06B5, F5B5, F6B5, F7B5 */
\t\"\\xda\\xb6\"=>array(\"\\xda\\xb6\", \"\\xef\\x96\\xb6\", \"\\xef\\x9a\\xb6\", \"\\xef\\x9e\\xb6\"), /* 06B6, F5B6, F6B6, F7B6 */
\t\"\\xda\\xb7\"=>array(\"\\xda\\xb7\", \"\\xef\\x96\\xb7\", \"\\xef\\x9a\\xb7\", \"\\xef\\x9e\\xb7\"), /* 06B7, F5B7, F6B7, F7B7 */
\t\"\\xda\\xb8\"=>array(\"\\xda\\xb8\", \"\\xef\\x96\\xb8\", \"\\xef\\x9a\\xb8\", \"\\xef\\x9e\\xb8\"), /* 06B8, F5B8, F6B8, F7B8 */
\t\"\\xda\\xb9\"=>array(\"\\xda\\xb9\", \"\\xef\\x96\\xb9\", \"\\xef\\x9a\\xb9\", \"\\xef\\x9e\\xb9\"), /* 06B9, F5B9, F6B9, F7B9 */
\t\"\\xda\\xba\"=>array(\"\\xda\\xba\", \"\\xef\\xae\\x9f\", \"\\xda\\xba\", \"\\xda\\xba\"), /* 06BA, FB9F, 06BA, 06BA */
\t\"\\xda\\xbb\"=>array(\"\\xda\\xbb\", \"\\xef\\xae\\xa1\", \"\\xef\\xae\\xa2\", \"\\xef\\xae\\xa3\"), /* 06BB, FBA1, FBA2, FBA3 */
\t\"\\xda\\xbc\"=>array(\"\\xda\\xbc\", \"\\xef\\x96\\xbc\", \"\\xef\\x9a\\xbc\", \"\\xef\\x9e\\xbc\"), /* 06BC, F5BC, F6BC, F7BC */
\t\"\\xda\\xbe\"=>array(\"\\xda\\xbe\", \"\\xef\\xae\\xab\", \"\\xef\\xae\\xac\", \"\\xef\\xae\\xad\"), /* 06BE, FBAB, FBAC, FBAD */
\t\"\\xda\\xbf\"=>array(\"\\xda\\xbf\", \"\\xef\\x96\\xbf\", \"\\xef\\x9a\\xbf\", \"\\xef\\x9e\\xbf\"), /* 06BF, F5BF, F6BF, F7BF */
\t\"\\xdb\\x80\"=>array(\"\\xdb\\x80\", \"\\xef\\xae\\xa5\", \"\\xdb\\x80\", \"\\xef\\xae\\xa5\"), /* 06C0, FBA5, 06C0, FBA5 */
\t\"\\xdb\\x81\"=>array(\"\\xdb\\x81\", \"\\xef\\xae\\xa7\", \"\\xef\\xae\\xa8\", \"\\xef\\xae\\xa9\"), /* 06C1, FBA7, FBA8, FBA9 */
\t\"\\xdb\\x8c\"=>array(\"\\xdb\\x8c\", \"\\xef\\xaf\\xbd\", \"\\xef\\xaf\\xbe\", \"\\xef\\xaf\\xbf\"), /* 06CC, FBFD, FBFE, FBFF */
\t\"\\xdb\\x8d\"=>array(\"\\xdb\\x8d\", \"\\xef\\x97\\x8d\", \"\\xdb\\x8d\", \"\\xef\\x97\\x8d\"), /* 06CD, F5CD, 06CD, F5CD */
\t\"\\xdb\\x8e\"=>array(\"\\xdb\\x8e\", \"\\xef\\x97\\x8e\", \"\\xef\\x9b\\x8e\", \"\\xef\\x9f\\x8e\"), /* 06CE, F5CE, F6CE, F7CE */
\t\"\\xdb\\x90\"=>array(\"\\xdb\\x90\", \"\\xef\\xaf\\xa5\", \"\\xef\\xaf\\xa6\", \"\\xef\\xaf\\xa7\"), /* 06D0, FBE5, FBE6, FBE7 */
\t\"\\xdb\\x91\"=>array(\"\\xdb\\x91\", \"\\xef\\x97\\x91\", \"\\xef\\xad\\x98\", \"\\xef\\xad\\x99\"), /* 06D1, F5D1, FB58, FB59 Fudge borrows from 067E */
\t\"\\xdb\\x92\"=>array(\"\\xdb\\x92\", \"\\xef\\xae\\xaf\", \"\\xdb\\x92\", \"\\xef\\xae\\xaf\"), /* 06D2, FBAF, 06D2, FBAF */
\t\"\\xdb\\x93\"=>array(\"\\xdb\\x93\", \"\\xef\\xae\\xb1\", \"\\xdb\\x93\", \"\\xef\\xae\\xb1\"), /* 06D3, FBB1, 06D3, FBB1 */
\t);


\t// LAM with ALEF ligatures (Mandatory ligatures)

\t// U+0644; U+0622;   U+0644; U+0623;   U+0644; U+0625;   U+0644; U+0627;
\t\$this->arabLigGlyphs = \"\\xd9\\x84\\xd8\\xa2\\xd9\\x84\\xd8\\xa3\\xd9\\x84\\xd8\\xa5\\xd9\\x84\\xd8\\xa7\";
\t\$this->arabLigHex = 'FEF5FEF6FEF5FEF6FEF7FEF8FEF7FEF8FEF9FEFAFEF9FEFAFEFBFEFCFEFBFEFC';

}

// mPDF 5.4.08
function ArabJoin(\$str) {
\tif (!\$this->arabGlyphs) { \$this->InitArabic(); }
\t\$crntChar = null;
\t\$prevChar = null;
\t\$nextChar = null;
\t\$output = array();
\t\$chars = preg_split('//u', \$str);
\t\$max = count(\$chars);
\tfor (\$i = \$max - 1; \$i >= 0; \$i--) {
\t\t\$crntChar = \$chars[\$i];
\t\tif (\$i > 0){ \$prevChar = \$chars[\$i - 1]; }
\t\telse{ \$prevChar = NULL; }
\t\tif (\$prevChar && mb_strpos(\$this->arabVowels, \$prevChar, 0, 'utf-8') !== false) {
\t\t\t\$prevChar = \$chars[\$i - 2];
\t\t\tif (\$prevChar && mb_strpos(\$this->arabVowels, \$prevChar, 0, 'utf-8') !== false) {
\t\t\t\t\$prevChar = \$chars[\$i - 3];
\t\t\t}
\t\t}
\t\tif (\$crntChar && mb_strpos(\$this->arabVowels, \$crntChar, 0, 'utf-8') !== false) {
\t\t\t// If next_char = nextLink && prev_char = prevLink:
\t\t\t// Added && \$prevchar (defined) else error on mb_strpos()
\t\t\tif (\$chars[\$i + 1] && (mb_strpos(\$this->arabNextLink, \$chars[\$i + 1], 0, 'utf-8') !== false)  && \$prevChar && (mb_strpos(\$this->arabPrevLink, \$prevChar, 0, 'utf-8') !== false)) {
\t\t\t\t\$output[] = \$this->get_arab_glyphs(\$crntChar, 1);\t// <final> form
\t\t\t}
\t\t\telse {
\t\t\t\t\$output[] = \$this->get_arab_glyphs(\$crntChar, 0);  // <isolated> form
\t\t\t}
\t\t\tcontinue;
\t\t}
\t\t// NB = &#x622 &#x623; &#x625; &#x627;     &#x644;
\t\tif (isset(\$chars[\$i + 1]) && in_array(\$chars[\$i + 1], array(\"\\xd8\\xa2\",\"\\xd8\\xa3\",\"\\xd8\\xa5\",\"\\xd8\\xa7\")) && \$crntChar == \"\\xd9\\x84\"){
\t\t\tcontinue;
\t\t}
\t\tif (ord(\$crntChar) < 128) {
\t\t\t\$output[] = \$crntChar;
\t\t\t\$nextChar = \$crntChar;
\t\t\tcontinue;
\t\t}
\t\t\$form = 0;
\t\tif (\$prevChar == \"\\xd9\\x84\" && (\$crntChar == \"\\xd8\\xa2\" || \$crntChar == \"\\xd8\\xa3\" || \$crntChar == \"\\xd8\\xa5\" || \$crntChar == \"\\xd8\\xa7\")) {
\t\t\tif (\$chars[\$i - 2] && mb_strpos(\$this->arabPrevLink, \$chars[\$i - 2], 0, 'utf-8') !== false) {
\t\t\t\t\$form++;\t// <final> form
\t\t\t}
\t\t\t\$pos = mb_strpos(\$this->arabLigGlyphs, (\$prevChar . \$crntChar), 0, 'utf-8');
\t\t\t\$pos = \$pos*8 + \$form*4;
\t\t\t\$pres = (mb_substr(\$this->arabLigHex, \$pos, 4, 'utf-8'));
\t\t\t// If presentation forms for mandatory ligatures with diacritics not present (even if remapped from e.g. uni0644uni0625)
\t\t\t// try replacing with mandatory ligature Alef/lam isolated/final FEFB/FEFC + diacritic glyph
\t\t\tif (!\$this->_charDefined(\$this->CurrentFont['cw'], hexdec(\$pres)) && \$this->_charDefined(\$this->CurrentFont['cw'], hexdec('FEFB'))) {
\t\t\t\tif (\$pres=='FEF5') { \$output[] = strcode2utf('&#xFEFB;&#x0653;'); }
\t\t\t\telse if (\$pres=='FEF6') { \$output[] = strcode2utf('&#xFEFC;&#x0653;'); }
\t\t\t\telse if (\$pres=='FEF7') { \$output[] = strcode2utf('&#xFEFB;&#x0654;'); }
\t\t\t\telse if (\$pres=='FEF8') { \$output[] = strcode2utf('&#xFEFC;&#x0654;'); }
\t\t\t\telse if (\$pres=='FEF9') { \$output[] = strcode2utf('&#xFEFB;&#x0655;'); }
\t\t\t\telse if (\$pres=='FEFA') { \$output[] = strcode2utf('&#xFEFC;&#x0655;'); }
\t\t\t}
\t\t\telse {
\t\t\t\t\$output[] = strcode2utf('&#x' . \$pres . ';');
\t\t\t}
\t\t\t\$nextChar = \$prevChar;
\t\t\tcontinue;
\t\t}
\t\tif (\$prevChar && mb_strpos(\$this->arabPrevLink, \$prevChar, 0, 'utf-8') !== false) {
\t\t\t\$form++;
\t\t}
\t\tif (\$nextChar && mb_strpos(\$this->arabNextLink, \$nextChar, 0, 'utf-8') !== false) {
\t\t\t\$form += 2;
\t\t}
\t\t\$output[] = \$this->get_arab_glyphs(\$crntChar, \$form) ;
\t\t\$nextChar = \$crntChar;
\t}
\t\$ra = array_reverse(\$output);
\t\$s = implode(\$ra);
\treturn \$s;
}

// mPDF 5.7+
function arabJoinPregCallback(\$matches) {
\treturn \$this->ArabJoin(stripslashes(\$matches[1]));
}

// mPDF 5.4.08
function get_arab_glyphs(\$char, \$type) {
\tif (\$type>0 && isset(\$this->arabGlyphs[\$char])) {
\t\t// If presentation form specified FB** - FE** = Arabic presentation Forms
\t\tif (preg_match(\"/[\\x{FB50}-\\x{FEFF}]/u\",\$this->arabGlyphs[\$char][\$type])) {
\t\t\t\$unicode = \$this->UTF8StringToArray(\$this->arabGlyphs[\$char][\$type], false);
\t\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'],\$unicode[0])) { return \$this->arabGlyphs[\$char][\$type]; }
\t\t\telse if (isset(\$this->CurrentFont['unAGlyphs'])) {
\t\t\t\t\$uni = \$this->UTF8StringToArray(\$char, false);
\t\t\t\t\$pua = \$uni[0] - 1536 + 62464 + 256*\$type ;
\t\t\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'], \$pua)) { return strcode2utf('&#x' . dechex(\$pua) . ';'); }
\t\t\t\telse return \$char;
\t\t\t}
\t\t\telse return \$char;
\t\t}
\t\t// If PUA form specified and unAGlphs font set F5** F6** F7** = Private use area used by unAGlyphs in mPDF
\t\tif (preg_match(\"/[\\x{F500}-\\x{F7FF}]/u\",\$this->arabGlyphs[\$char][\$type]) && isset(\$this->CurrentFont['unAGlyphs'])) {
\t\t\t\$unicode = \$this->UTF8StringToArray(\$this->arabGlyphs[\$char][\$type], false);
\t\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'],\$unicode[0])) { return \$this->arabGlyphs[\$char][\$type]; }
\t\t\telse return \$char;
\t\t}
\t\treturn \$this->arabGlyphs[\$char][\$type];
\t}
\telse return \$char;
}
/*-- END RTL --*/



//===========================
// Functions originally in htmltoolkit - moved mPDF 4.0

// Call-back function Used for usort in fn _tableWrite

function _cmpdom(\$a, \$b) {
    return (\$a[\"dom\"] < \$b[\"dom\"]) ? -1 : 1;
}

function mb_strrev(\$str, \$enc = 'utf-8'){
\t\$ch = array();
\t\$ch = preg_split('//u',\$str);
\t\$revch = array_reverse(\$ch);
\treturn implode('',\$revch);
}

/*-- COLUMNS --*/
// Callback function from function printcolumnbuffer in mpdf
function columnAdjustAdd(\$type,\$k,\$xadj,\$yadj,\$a,\$b,\$c=0,\$d=0,\$e=0,\$f=0) {
   if (\$type == 'Td') { \t// xpos,ypos
\t\$a += (\$xadj * \$k);
\t\$b -= (\$yadj * \$k);
\treturn 'BT '.sprintf('%.3F %.3F',\$a,\$b).' Td';
   }
   else if (\$type == 're') { \t// xpos,ypos,width,height
\t\$a += (\$xadj * \$k);
\t\$b -= (\$yadj * \$k);
\treturn sprintf('%.3F %.3F %.3F %.3F',\$a,\$b,\$c,\$d).' re';
   }
   else if (\$type == 'l') { \t// xpos,ypos,x2pos,y2pos
\t\$a += (\$xadj * \$k);
\t\$b -= (\$yadj * \$k);
\treturn sprintf('%.3F %.3F l',\$a,\$b);
   }
   else if (\$type == 'img') { \t// width,height,xpos,ypos
\t\$c += (\$xadj * \$k);
\t\$d -= (\$yadj * \$k);
\treturn sprintf('q %.3F 0 0 %.3F %.3F %.3F',\$a,\$b,\$c,\$d).' cm /'.\$e;
   }
   else if (\$type == 'draw') { \t// xpos,ypos
\t\$a += (\$xadj * \$k);
\t\$b -= (\$yadj * \$k);
\treturn sprintf('%.3F %.3F m',\$a,\$b);
   }
   else if (\$type == 'bezier') { \t// xpos,ypos,x2pos,y2pos,x3pos,y3pos
\t\$a += (\$xadj * \$k);
\t\$b -= (\$yadj * \$k);
\t\$c += (\$xadj * \$k);
\t\$d -= (\$yadj * \$k);
\t\$e += (\$xadj * \$k);
\t\$f -= (\$yadj * \$k);
\treturn sprintf('%.3F %.3F %.3F %.3F %.3F %.3F',\$a,\$b,\$c,\$d,\$e,\$f).' c';
   }
}
/*-- END COLUMNS --*/



function ConvertColor(\$color=\"#000000\"){
\t\$color = trim(strtolower(\$color));
\t\$c = false;
\tif (\$color=='transparent') { return false; }
\telse if (\$color=='inherit') { return false; }
\telse if (isset(\$this->SVGcolors[\$color])) \$color = \$this->SVGcolors[\$color];

\tif (preg_match('/^[\\d]+\$/',\$color)) { \$c = (array(1,\$color)); }\t// i.e. integer only
\telse if (\$color[0] == '#') { //case of #nnnnnn or #nnn
\t\t\$cor = preg_replace('/\\s+.*/','',\$color);\t// in case of Background: #CCC url() x-repeat etc.
  \t\tif (strlen(\$cor) == 4) { // Turn #RGB into #RRGGBB
\t\t \t  \$cor = \"#\" . \$cor[1] . \$cor[1] . \$cor[2] . \$cor[2] . \$cor[3] . \$cor[3];
\t\t}
\t\t\$r = hexdec(substr(\$cor, 1, 2));
\t\t\$g = hexdec(substr(\$cor, 3, 2));
\t\t\$b = hexdec(substr(\$cor, 5, 2));
\t\t\$c = array(3,\$r,\$g,\$b);
\t}
\telse if (preg_match('/(rgba|rgb|device-cmyka|cmyka|device-cmyk|cmyk|hsla|hsl|spot)\\((.*?)\\)/',\$color,\$m)) {\t// mPDF 5.6.05
\t\t\$type= \$m[1];
\t\t\$cores = explode(\",\", \$m[2]);
\t\t\$ncores = count(\$cores);
\t\tif (stristr(\$cores[0],'%') ) {
\t\t\t\$cores[0] += 0;
\t\t\tif (\$type=='rgb' || \$type=='rgba') { \$cores[0] = intval(\$cores[0]*255/100); }
\t\t}
\t\tif (\$ncores>1 && stristr(\$cores[1],'%') ) {
\t\t\t\$cores[1] += 0;
\t\t\tif (\$type=='rgb' || \$type=='rgba') { \$cores[1] = intval(\$cores[1]*255/100); }
\t\t\tif (\$type=='hsl' || \$type=='hsla') { \$cores[1] = \$cores[1]/100; }
\t\t}
\t\tif (\$ncores>2 && stristr(\$cores[2],'%') ) {
\t\t\t\$cores[2] += 0;
\t\t\tif (\$type=='rgb' || \$type=='rgba') { \$cores[2] = intval(\$cores[2]*255/100); }
\t\t\tif (\$type=='hsl' || \$type=='hsla') { \$cores[2] = \$cores[2]/100; }
\t\t}
\t\tif (\$ncores>3 && stristr(\$cores[3],'%') ) {
\t\t\t\$cores[3] += 0;
\t\t}

\t\tif (\$type=='rgb') { \$c = array(3,\$cores[0],\$cores[1],\$cores[2]); }
\t\telse if (\$type=='rgba') { \$c = array(5,\$cores[0],\$cores[1],\$cores[2],\$cores[3]*100); }
\t\telse if (\$type=='cmyk' || \$type=='device-cmyk') { \$c = array(4,\$cores[0],\$cores[1],\$cores[2],\$cores[3]); }\t// mPDF 5.6.05
\t\telse if (\$type=='cmyka' || \$type=='device-cmyka') { \$c = array(6,\$cores[0],\$cores[1],\$cores[2],\$cores[3],\$cores[4]*100); }\t// mPDF 5.6.05
\t\telse if (\$type=='hsl' || \$type=='hsla') {
\t\t\t\$conv = \$this->hsl2rgb(\$cores[0]/360,\$cores[1],\$cores[2]);
\t\t\tif (\$type=='hsl') { \$c = array(3,\$conv[0],\$conv[1],\$conv[2]); }
\t\t\telse if (\$type=='hsla') { \$c = array(5,\$conv[0],\$conv[1],\$conv[2],\$cores[3]*100); }
\t\t}
\t\telse if (\$type=='spot') {
\t\t\t\$name = strtoupper(trim(\$cores[0]));
\t\t\t// mPDF 5.6.59
\t\t\tif(!isset(\$this->spotColors[\$name])) {
\t\t\t\tif (isset(\$cores[5])) { \$this->AddSpotColor(\$cores[0],\$cores[2],\$cores[3],\$cores[4],\$cores[5]); }
\t\t\t\telse { \$this->Error('Undefined spot color: '.\$name); }
\t\t\t}
\t\t\t\$c = array(2,\$this->spotColors[\$name]['i'],\$cores[1]);
\t\t}
\t}


\t// \$this->restrictColorSpace
\t// 1 - allow GRAYSCALE only [convert CMYK/RGB->gray]
\t// 2 - allow RGB / SPOT COLOR / Grayscale [convert CMYK->RGB]
\t// 3 - allow CMYK / SPOT COLOR / Grayscale [convert RGB->CMYK]
\tif (\$this->PDFA || \$this->PDFX || \$this->restrictColorSpace) {
\t\tif (\$c[0]==1) {\t// GRAYSCALE
\t\t}
\t\telse if (\$c[0]==2) {\t// SPOT COLOR
\t\t\tif (!isset(\$this->spotColorIDs[\$c[1]])) { die('Error: Spot colour has not been defined - '.\$this->spotColorIDs[\$c[1]]); }
\t\t\tif (\$this->PDFA) {
\t\t\t\tif (\$this->PDFA && !\$this->PDFAauto) { \$this->PDFAXwarnings[] = \"Spot color specified '\".\$this->spotColorIDs[\$c[1]].\"' (converted to process color)\"; }
\t\t\t\tif (\$this->restrictColorSpace!=3) {
\t\t\t\t\t\$sp = \$this->spotColors[\$this->spotColorIDs[\$c[1]]];
\t\t\t\t\t\$c = \$this->cmyk2rgb(array(4,\$sp['c'],\$sp['m'],\$sp['y'],\$sp['k']));
\t\t\t\t}
\t\t\t}
\t\t\telse if (\$this->restrictColorSpace==1) {
\t\t\t\t\$sp = \$this->spotColors[\$this->spotColorIDs[\$c[1]]];
\t\t\t\t\$c = \$this->cmyk2gray(array(4,\$sp['c'],\$sp['m'],\$sp['y'],\$sp['k']));
\t\t\t}
\t\t}
\t\telse if (\$c[0]==3) {\t// RGB
\t\t\tif (\$this->PDFX || (\$this->PDFA && \$this->restrictColorSpace==3)) {
\t\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"RGB color specified '\".\$color.\"' (converted to CMYK)\"; }
\t\t\t\t\$c = \$this->rgb2cmyk(\$c);
\t\t\t}
\t\t\telse if (\$this->restrictColorSpace==1) { \$c = \$this->rgb2gray(\$c); }
\t\t\telse if (\$this->restrictColorSpace==3) { \$c = \$this->rgb2cmyk(\$c); }
\t\t}
\t\telse if (\$c[0]==4) {\t// CMYK
\t\t\tif (\$this->PDFA && \$this->restrictColorSpace!=3) {
\t\t\t\tif (\$this->PDFA && !\$this->PDFAauto) { \$this->PDFAXwarnings[] = \"CMYK color specified '\".\$color.\"' (converted to RGB)\"; }
\t\t\t\t\$c = \$this->cmyk2rgb(\$c);
\t\t\t}
\t\t\telse if (\$this->restrictColorSpace==1) { \$c = \$this->cmyk2gray(\$c); }
\t\t\telse if (\$this->restrictColorSpace==2) { \$c = \$this->cmyk2rgb(\$c); }
\t\t}
\t\telse if (\$c[0]==5) {\t// RGBa
\t\t\tif (\$this->PDFX || (\$this->PDFA && \$this->restrictColorSpace==3)) {
\t\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"RGB color with transparency specified '\".\$color.\"' (converted to CMYK without transparency)\"; }
\t\t\t\t\$c = \$this->rgb2cmyk(\$c);
\t\t\t\t\$c = array(4, \$c[1], \$c[2], \$c[3], \$c[4]);
\t\t\t}
\t\t\telse if (\$this->PDFA && \$this->restrictColorSpace!=3) {
\t\t\t\tif (!\$this->PDFAauto) { \$this->PDFAXwarnings[] = \"RGB color with transparency specified '\".\$color.\"' (converted to RGB without transparency)\"; }
\t\t\t\t\$c = \$this->rgb2cmyk(\$c);
\t\t\t\t\$c = array(4, \$c[1], \$c[2], \$c[3], \$c[4]);
\t\t\t}
\t\t\telse if (\$this->restrictColorSpace==1) { \$c = \$this->rgb2gray(\$c); }
\t\t\telse if (\$this->restrictColorSpace==3) { \$c = \$this->rgb2cmyk(\$c); }
\t\t}
\t\telse if (\$c[0]==6) {\t// CMYKa
\t\t\tif (\$this->PDFA && \$this->restrictColorSpace!=3) {
\t\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"CMYK color with transparency specified '\".\$color.\"' (converted to RGB without transparency)\"; }
\t\t\t\t\$c = \$this->cmyk2rgb(\$c);
\t\t\t\t\$c = array(3, \$c[1], \$c[2], \$c[3]);
\t\t\t}
\t\t\telse if (\$this->PDFX || (\$this->PDFA && \$this->restrictColorSpace==3)) {
\t\t\t\tif ((\$this->PDFA && !\$this->PDFAauto) || (\$this->PDFX && !\$this->PDFXauto)) { \$this->PDFAXwarnings[] = \"CMYK color with transparency specified '\".\$color.\"' (converted to CMYK without transparency)\"; }
\t\t\t\t\$c = \$this->cmyk2rgb(\$c);
\t\t\t\t\$c = array(3, \$c[1], \$c[2], \$c[3]);
\t\t\t}
\t\t\telse if (\$this->restrictColorSpace==1) { \$c = \$this->cmyk2gray(\$c); }
\t\t\telse if (\$this->restrictColorSpace==2) { \$c = \$this->cmyk2rgb(\$c); }
\t\t}
\t}
\tif (is_array(\$c)) {
\t\t\$c = array_pad(\$c, 6, 0);
\t\t\$cstr = pack(\"a1ccccc\", \$c[0], (\$c[1] & 0xFF), (\$c[2] & 0xFF), (\$c[3] & 0xFF), (\$c[4] & 0xFF), (\$c[5] & 0xFF) );
\t}
\treturn \$cstr;
}

function rgb2gray(\$c) {
\tif (isset(\$c[4])) { return array(1,((\$c[1] * .21) + (\$c[2] * .71) + (\$c[3] * .07)), ord(1), \$c[4]); }
\telse { return array(1,((\$c[1] * .21) + (\$c[2] * .71) + (\$c[3] * .07))); }
}

function cmyk2gray(\$c) {
\t\$rgb = \$this->cmyk2rgb(\$c);
\treturn \$this->rgb2gray(\$rgb);
}

function rgb2cmyk(\$c) {
\t\$cyan = 1 - (\$c[1] / 255);
\t\$magenta = 1 - (\$c[2] / 255);
\t\$yellow = 1 - (\$c[3] / 255);
\t\$min = min(\$cyan, \$magenta, \$yellow);

\tif (\$min == 1) {
\t\tif (\$c[0]==5) { return array (6,100,100,100,100, \$c[4]); }
\t\telse { return array (4,100,100,100,100); }
\t\t// For K-Black
\t\t//if (\$c[0]==5) { return array (6,0,0,0,100, \$c[4]); }
\t\t//else { return array (4,0,0,0,100); }
\t}
\t\$K = \$min;
\t\$black = 1 - \$K;
\tif (\$c[0]==5) { return array (6,(\$cyan-\$K)*100/\$black, (\$magenta-\$K)*100/\$black, (\$yellow-\$K)*100/\$black, \$K*100, \$c[4]); }
\telse { return array (4,(\$cyan-\$K)*100/\$black, (\$magenta-\$K)*100/\$black, (\$yellow-\$K)*100/\$black, \$K*100); }
}


function cmyk2rgb(\$c) {
\t\$rgb = array();
\t\$colors = 255 - (\$c[4]*2.55);
\t\$rgb[0] = intval(\$colors * (255 - (\$c[1]*2.55))/255);
\t\$rgb[1] = intval(\$colors * (255 - (\$c[2]*2.55))/255);
\t\$rgb[2] = intval(\$colors * (255 - (\$c[3]*2.55))/255);
\tif (\$c[0]==6) { return array (5,\$rgb[0],\$rgb[1],\$rgb[2], \$c[5]); }
\telse { return array (3,\$rgb[0],\$rgb[1],\$rgb[2]); }
}

function rgb2hsl(\$var_r, \$var_g, \$var_b) {
    \$var_min = min(\$var_r,\$var_g,\$var_b);
    \$var_max = max(\$var_r,\$var_g,\$var_b);
    \$del_max = \$var_max - \$var_min;
    \$l = (\$var_max + \$var_min) / 2;
    if (\$del_max == 0) {
            \$h = 0;
            \$s = 0;
    }
    else {
            if (\$l < 0.5) { \$s = \$del_max / (\$var_max + \$var_min); }
            else { \$s = \$del_max / (2 - \$var_max - \$var_min); }
            \$del_r = (((\$var_max - \$var_r) / 6) + (\$del_max / 2)) / \$del_max;
            \$del_g = (((\$var_max - \$var_g) / 6) + (\$del_max / 2)) / \$del_max;
            \$del_b = (((\$var_max - \$var_b) / 6) + (\$del_max / 2)) / \$del_max;
            if (\$var_r == \$var_max) { \$h = \$del_b - \$del_g; }
            elseif (\$var_g == \$var_max)  { \$h = (1 / 3) + \$del_r - \$del_b; }
            elseif (\$var_b == \$var_max)  { \$h = (2 / 3) + \$del_g - \$del_r; };
            if (\$h < 0) { \$h += 1; }
            if (\$h > 1) { \$h -= 1; }
    }
    return array(\$h,\$s,\$l);
}


function hsl2rgb(\$h2,\$s2,\$l2) {
\t// Input is HSL value of complementary colour, held in \$h2, \$s, \$l as fractions of 1
\t// Output is RGB in normal 255 255 255 format, held in \$r, \$g, \$b
\t// Hue is converted using function hue_2_rgb, shown at the end of this code
\tif (\$s2 == 0) {
\t\t\$r = \$l2 * 255;
\t\t\$g = \$l2 * 255;
\t\t\$b = \$l2 * 255;
\t}
\telse {
\t\tif (\$l2 < 0.5) { \$var_2 = \$l2 * (1 + \$s2); }
\t\telse { \$var_2 = (\$l2 + \$s2) - (\$s2 * \$l2); }
\t\t\$var_1 = 2 * \$l2 - \$var_2;
\t\t\$r = round(255 * \$this->hue_2_rgb(\$var_1,\$var_2,\$h2 + (1 / 3)));
\t\t\$g = round(255 * \$this->hue_2_rgb(\$var_1,\$var_2,\$h2));
\t\t\$b = round(255 * \$this->hue_2_rgb(\$var_1,\$var_2,\$h2 - (1 / 3)));
\t}
\treturn array(\$r,\$g,\$b);
}

function hue_2_rgb(\$v1,\$v2,\$vh) {
\t// Function to convert hue to RGB, called from above
\tif (\$vh < 0) { \$vh += 1; };
\tif (\$vh > 1) { \$vh -= 1; };
\tif ((6 * \$vh) < 1) { return (\$v1 + (\$v2 - \$v1) * 6 * \$vh); };
\tif ((2 * \$vh) < 1) { return (\$v2); };
\tif ((3 * \$vh) < 2) { return (\$v1 + (\$v2 - \$v1) * ((2 / 3 - \$vh) * 6)); };
\treturn (\$v1);
}

function _invertColor(\$cor) {
\tif (\$cor[0]==3 || \$cor[0]==5) {\t// RGB
\t\treturn array(3, (255-\$cor[1]), (255-\$cor[2]), (255-\$cor[3]));
\t}
\telse if (\$cor[0]==4 || \$cor[0]==6) {\t// CMYK
\t\treturn array(4, (100-\$cor[1]), (100-\$cor[2]), (100-\$cor[3]), (100-\$cor[4]));
\t}
\telse if (\$cor[0]==1) {\t// Grayscale
\t\treturn array(1, (255-\$cor[1]));
\t}
\t// Cannot cope with non-RGB colors at present
\tdie('Error in _invertColor - trying to invert non-RGB color');
}

function _colAtoString(\$cor) {
\t\$s = '';
\tif (\$cor{0}==1) \$s = 'rgb('.ord(\$cor{1}).','.ord(\$cor{1}).','.ord(\$cor{1}).')';
\telse if (\$cor{0}==2) \$s = 'spot('.ord(\$cor{1}).','.ord(\$cor{2}).')';\t\t// SPOT COLOR
\telse if (\$cor{0}==3) \$s = 'rgb('.ord(\$cor{1}).','.ord(\$cor{2}).','.ord(\$cor{3}).')';
\telse if (\$cor{0}==4) \$s = 'cmyk('.ord(\$cor{1}).','.ord(\$cor{2}).','.ord(\$cor{3}).','.ord(\$cor{4}).')';
\telse if (\$cor{0}==5) \$s = 'rgba('.ord(\$cor{1}).','.ord(\$cor{2}).','.ord(\$cor{3}).','.sprintf('%0.2F',ord(\$cor{4})/100).')';
\telse if (\$cor{0}==6) \$s = 'cmyka('.ord(\$cor{1}).','.ord(\$cor{2}).','.ord(\$cor{3}).','.ord(\$cor{4}).','.sprintf('%0.2F',ord(\$cor{5})/100).')';
\treturn \$s;
}

function ConvertSize(\$size=5,\$maxsize=0,\$fontsize=false,\$usefontsize=true){
// usefontsize - setfalse for e.g. margins - will ignore fontsize for % values
// Depends of maxsize value to make % work properly. Usually maxsize == pagewidth
// For text \$maxsize = Fontsize
// Setting e.g. margin % will use maxsize (pagewidth) and em will use fontsize
  //Identify size (remember: we are using 'mm' units here)
\t\$size = trim(strtolower(\$size));

  if ( \$size == 'thin' ) \$size = 1*(25.4/\$this->dpi); //1 pixel width for table borders
  elseif ( stristr(\$size,'px') ) \$size *= (25.4/\$this->dpi); //pixels
  elseif ( stristr(\$size,'cm') ) \$size *= 10; //centimeters
  elseif ( stristr(\$size,'mm') ) \$size += 0; //millimeters
  elseif ( stristr(\$size,'pt') ) \$size *= 25.4/72; //72 pts/inch
  elseif ( stristr(\$size,'rem') ) {\t// mPDF 5.6.12
  \t\$size += 0; //make \"0.83rem\" become simply \"0.83\"
\t\$size *= (\$this->default_font_size / _MPDFK);
  }
  elseif ( stristr(\$size,'em') ) {
  \t\$size += 0; //make \"0.83em\" become simply \"0.83\"
\tif (\$fontsize) { \$size *= \$fontsize; }
\telse { \$size *= \$maxsize; }
  }
  elseif ( stristr(\$size,'%') ) {
  \t\$size += 0; //make \"90%\" become simply \"90\"
\tif (\$fontsize && \$usefontsize) { \$size *= \$fontsize/100; }
\telse { \$size *= \$maxsize/100; }
  }
  elseif ( stristr(\$size,'in') ) \$size *= 25.4; //inches
  elseif ( stristr(\$size,'pc') ) \$size *= 38.1/9; //PostScript picas
  elseif ( stristr(\$size,'ex') ) {\t// Approximates \"ex\" as half of font height
  \t\$size += 0; //make \"3.5ex\" become simply \"3.5\"
\tif (\$fontsize) { \$size *= \$fontsize/2; }
\telse { \$size *= \$maxsize/2; }
  }
  elseif ( \$size == 'medium' ) \$size = 3*(25.4/\$this->dpi); //3 pixel width for table borders
  elseif ( \$size == 'thick' ) \$size = 5*(25.4/\$this->dpi); //5 pixel width for table borders
  elseif (\$size == 'xx-small') {
\tif (\$fontsize) { \$size *= \$fontsize*0.7; }
\telse { \$size *= \$maxsize*0.7; }
  }
  elseif (\$size == 'x-small') {
\tif (\$fontsize) { \$size *= \$fontsize*0.77; }
\telse { \$size *= \$maxsize*0.77; }
  }
  elseif (\$size == 'small') {
\tif (\$fontsize) { \$size *= \$fontsize*0.86; }
\telse { \$size *= \$maxsize*0.86; }
  }
  elseif (\$size == 'medium') {
\tif (\$fontsize) { \$size *= \$fontsize; }
\telse { \$size *= \$maxsize; }
  }
  elseif (\$size == 'large') {
\tif (\$fontsize) { \$size *= \$fontsize*1.2; }
\telse { \$size *= \$maxsize*1.2; }
  }
  elseif (\$size == 'x-large') {
\tif (\$fontsize) { \$size *= \$fontsize*1.5; }
\telse { \$size *= \$maxsize*1.5; }
  }
  elseif (\$size == 'xx-large') {
\tif (\$fontsize) { \$size *= \$fontsize*2; }
\telse { \$size *= \$maxsize*2; }
  }
  else \$size *= (25.4/\$this->dpi); //nothing == px

  return \$size;
}

// mPDF 5.7.3 TRANSFORMS
function ConvertAngle(\$s, \$makepositive=true) {
\tif (preg_match('/([\\-]*[0-9\\.]+)(deg|grad|rad)/i',\$s,\$m)) {
\t\t\$angle = \$m[1] + 0;
\t\tif (strtolower(\$m[2])=='deg') { \$angle = \$angle; }
\t\telse if (strtolower(\$m[2])=='grad') { \$angle *= (360/400); }
\t\telse if (strtolower(\$m[2])=='rad') { \$angle = rad2deg(\$angle); }
\t\twhile(\$angle >= 360) { \$angle -= 360; }
\t\twhile(\$angle <= -360) { \$angle += 360; }
\t\tif (\$makepositive) {\t// always returns an angle between 0 and 360deg
\t\t\tif (\$angle < 0) { \$angle += 360; }
\t\t}
\t}
\telse { \$angle = \$s + 0; }
\treturn \$angle;
}

function lesser_entity_decode(\$html) {
  //supports the most used entity codes (only does ascii safe characters)
 \t//\$html = str_replace(\"&nbsp;\",\" \",\$html);\t// mPDF 5.3.59
 \t\$html = str_replace(\"&lt;\",\"<\",\$html);
 \t\$html = str_replace(\"&gt;\",\">\",\$html);

 \t\$html = str_replace(\"&apos;\",\"'\",\$html);
 \t\$html = str_replace(\"&quot;\",'\"',\$html);
 \t\$html = str_replace(\"&amp;\",\"&\",\$html);
\treturn \$html;
}

function AdjustHTML(\$html, \$tabSpaces=8) {
\t//Try to make the html text more manageable (turning it into XHTML)
\tif (PHP_VERSION_ID < 50307) {
\t\tif (strlen(\$html) > 100000) {
\t\t\tif (PHP_VERSION_ID < 50200) \$this->Error(\"The HTML code is more than 100,000 characters. You should use WriteHTML() with smaller string lengths.\");
\t\t\telse ini_set(\"pcre.backtrack_limit\",\"1000000\");
\t\t}
\t}

/*-- ANNOTATIONS --*/
\tpreg_match_all(\"/(<annotation.*?>)/si\", \$html, \$m);
\tif (count(\$m[1])) {
\t\tfor(\$i=0;\$i<count(\$m[1]);\$i++) {
\t\t\t\$sub = preg_replace(\"/\\n/si\", \"\\xbb\\xa4\\xac\", \$m[1][\$i]);
\t\t\t\$html = preg_replace('/'.preg_quote(\$m[1][\$i], '/').'/si', \$sub, \$html);
\t\t}
\t}
/*-- END ANNOTATIONS --*/

\tpreg_match_all(\"/(<svg.*?<\\/svg>)/si\", \$html, \$svgi);
\tif (count(\$svgi[0])) {
\t\tfor(\$i=0;\$i<count(\$svgi[0]);\$i++) {
\t\t\t\$file = _MPDF_TEMP_PATH.'_tempSVG'.uniqid(rand(1,100000),true).'_'.\$i.'.svg';
\t\t\t//Save to local file
\t\t\tfile_put_contents(\$file, \$svgi[0][\$i]);
\t\t\t\$html = str_replace(\$svgi[0][\$i], '<img src=\"'.\$file.'\" />', \$html); \t// mPDF 5.5.18
\t\t}
\t}

\t//Remove javascript code from HTML (should not appear in the PDF file)
\t\$html = preg_replace('/<script.*?<\\/script>/is','',\$html);

\t//Remove special comments
\t\$html = preg_replace('/<!--mpdf/i','',\$html);
\t\$html = preg_replace('/mpdf-->/i','',\$html);

\t//Remove comments from HTML (should not appear in the PDF file)
\t\$html = preg_replace('/<!--.*?-->/s','',\$html);

\t\$html = preg_replace('/\\f/','',\$html); //replace formfeed by nothing
\t\$html = preg_replace('/\\r/','',\$html); //replace carriage return by nothing

\t// Well formed XHTML end tags
\t\$html = preg_replace('/<(br|hr)\\/>/i',\"<\\\\1 />\",\$html);
\t// Get rid of empty <thead></thead>
\t\$html = preg_replace('/<thead>\\s*<\\/thead>/i','',\$html);
\t\$html = preg_replace('/<tfoot>\\s*<\\/tfoot>/i','',\$html);
\t\$html = preg_replace('/<table[^>]*>\\s*<\\/table>/i','',\$html);
\t\$html = preg_replace('/<tr>\\s*<\\/tr>/i','',\$html);

\t// Remove spaces at end of table cells
\t\$html = preg_replace(\"/[ \\n\\r]+<\\/t(d|h)/\",'</t\\\\1',\$html);\t\t// mPDF 5.5.09

\t\$html = preg_replace(\"/[ ]*<dottab\\s*[\\/]*>[ ]*/\",'<dottab />',\$html);

\t// Concatenates any Substitute characters from symbols/dingbats
\t\$html = str_replace('</tts><tts>','|',\$html);
\t\$html = str_replace('</ttz><ttz>','|',\$html);
\t\$html = str_replace('</tta><tta>','|',\$html);

\t\$html = preg_replace('/<br \\/>\\s*/is',\"<br />\",\$html);

\t\$html = preg_replace('/<wbr[ \\/]*>\\s*/is',\"&#173;\",\$html);\t// mPDF 5.6.04

\t// Preserve '\\n's in content between the tags <pre> and </pre>
\tif (preg_match('/<pre/',\$html)) {
\t\t\$html_a = preg_split('/(\\<\\/?pre[^\\>]*\\>)/', \$html, -1, 2);
\t\t\$h = array();
\t\t\$c=0;
\t\tforeach(\$html_a AS \$s) {
\t\t\tif (\$c>1 && preg_match('/^<\\/pre/i',\$s)) { \$c--; \$s=preg_replace('/<\\/pre/i','</innerpre',\$s); }
\t\t\telse if (\$c>0 && preg_match('/^<pre/i',\$s)) { \$c++; \$s=preg_replace('/<pre/i','<innerpre',\$s); }
\t\t\telse if (preg_match('/^<pre/i',\$s)) { \$c++; }
\t\t\telse if (preg_match('/^<\\/pre/i',\$s)) { \$c--; }
\t\t\tarray_push(\$h, \$s);
\t\t}
\t\t\$html = implode(\"\", \$h);
\t}
\t\$thereispre = preg_match_all('#<pre(.*?)>(.*?)</pre>#si',\$html,\$temp);
\t// Preserve '\\n's in content between the tags <textarea> and </textarea>
\t\$thereistextarea = preg_match_all('#<textarea(.*?)>(.*?)</textarea>#si',\$html,\$temp2);
\t\$html = preg_replace('/[\\n]/',' ',\$html); //replace linefeed by spaces
\t\$html = preg_replace('/[\\t]/',' ',\$html); //replace tabs by spaces

\t// Converts < to &lt; when not a tag
\t\$html = preg_replace('/<([^!\\/a-zA-Z_:])/i','&lt;\\\\1',\$html);\t// mPDF 5.7.3
\t\$html = preg_replace(\"/[ ]+/\",' ',\$html);

\t\$html = preg_replace('/\\/li>\\s+<\\/(u|o)l/i','/li></\\\\1l',\$html);
\t\$html = preg_replace('/\\/(u|o)l>\\s+<\\/li/i','/\\\\1l></li',\$html);
\t\$html = preg_replace('/\\/li>\\s+<\\/(u|o)l/i','/li></\\\\1l',\$html);
\t\$html = preg_replace('/\\/li>\\s+<li/i','/li><li',\$html);
\t\$html = preg_replace('/<(u|o)l([^>]*)>[ ]+/i','<\\\\1l\\\\2>',\$html);
\t\$html = preg_replace('/[ ]+<(u|o)l/i','<\\\\1l',\$html);

\t\$iterator = 0;
\twhile(\$thereispre) //Recover <pre attributes>content</pre>
\t{
\t\t\$temp[2][\$iterator] = preg_replace('/<([^!\\/a-zA-Z_:])/','&lt;\\\\1',\$temp[2][\$iterator]);\t// mPDF 5.7.2\t// mPDF 5.7.3
\t\t\$temp[2][\$iterator] = preg_replace_callback(\"/^([^\\n\\t]*?)\\t/m\", array(\$this, 'tabs2spaces_callback'), \$temp[2][\$iterator]);\t// mPDF 5.7+
\t\t\$temp[2][\$iterator] = preg_replace('/\\t/',str_repeat(\" \",\$tabSpaces),\$temp[2][\$iterator]);

\t\t\$temp[2][\$iterator] = preg_replace('/\\n/',\"<br />\",\$temp[2][\$iterator]);
\t\t\$temp[2][\$iterator] = str_replace('\\\\',\"\\\\\\\\\",\$temp[2][\$iterator]);
\t\t//\$html = preg_replace('#<pre(.*?)>(.*?)</pre>#si','<erp'.\$temp[1][\$iterator].'>'.\$temp[2][\$iterator].'</erp>',\$html,1);
\t\t\$html = preg_replace('#<pre(.*?)>(.*?)</pre>#si','<erp'.\$temp[1][\$iterator].'>'.str_replace('\$','\\\$',\$temp[2][\$iterator]).'</erp>',\$html,1);\t// mPDF 5.7+
\t\t\$thereispre--;
\t\t\$iterator++;
\t}
\t\$iterator = 0;
\twhile(\$thereistextarea) //Recover <textarea attributes>content</textarea>
\t{
\t\t\$temp2[2][\$iterator] = preg_replace('/\\t/',str_repeat(\" \",\$tabSpaces),\$temp2[2][\$iterator]);
\t\t\$temp2[2][\$iterator] = str_replace('\\\\',\"\\\\\\\\\",\$temp2[2][\$iterator]);\t// mPDF 5.3.88
\t\t\$html = preg_replace('#<textarea(.*?)>(.*?)</textarea>#si','<aeratxet'.\$temp2[1][\$iterator].'>'.trim(\$temp2[2][\$iterator]) .'</aeratxet>',\$html,1);
\t\t\$thereistextarea--;
\t\t\$iterator++;
\t}
\t//Restore original tag names
\t\$html = str_replace(\"<erp\",\"<pre\",\$html);
\t\$html = str_replace(\"</erp>\",\"</pre>\",\$html);
\t\$html = str_replace(\"<aeratxet\",\"<textarea\",\$html);
\t\$html = str_replace(\"</aeratxet>\",\"</textarea>\",\$html);
\t\$html = str_replace(\"</innerpre\",\"</pre\",\$html);
\t\$html = str_replace(\"<innerpre\",\"<pre\",\$html);

\t\$html = preg_replace('/<textarea([^>]*)><\\/textarea>/si','<textarea\\\\1> </textarea>',\$html);
\t\$html = preg_replace('/(<table[^>]*>)\\s*(<caption)(.*?<\\/caption>)(.*?<\\/table>)/si','\\\\2 position=\"top\"\\\\3\\\\1\\\\4\\\\2 position=\"bottom\"\\\\3',\$html);\t// *TABLES*
\t\$html = preg_replace('/<(h[1-6])([^>]*)(>(?:(?!h[1-6]).)*?<\\/\\\\1>\\s*<table)/si','<\\\\1\\\\2 keep-with-table=\"1\"\\\\3',\$html);\t// *TABLES*
\t\$html = preg_replace(\"/\\xbb\\xa4\\xac/\", \"\\n\", \$html);

\treturn \$html;
}
// mPDF 5.7+
function tabs2spaces_callback(\$matches) {
\treturn (stripslashes(\$matches[1]) . str_repeat(' ', \$this->tabSpaces - (mb_strlen(stripslashes(\$matches[1])) % \$this->tabSpaces)));
}
// mPDF 5.7+
function date_callback(\$matches) {
\treturn date(\$matches[1]);
}

/*-- LISTS --*/
function dec2other(\$num, \$cp) {
\t\$nstr = (string) \$num;
\t\$rnum = '';
\tfor (\$i=0;\$i<strlen(\$nstr);\$i++) {
\t\tif (\$this->_charDefined(\$this->CurrentFont['cw'],\$cp+intval(\$nstr[\$i]))) { // contains arabic-indic numbers
\t\t\t\$rnum .= code2utf(\$cp+intval(\$nstr[\$i]));
\t\t}
\t\telse { \$rnum .= \$nstr[\$i]; }
\t}
\treturn \$rnum;
}

function dec2alpha(\$valor,\$toupper=\"true\"){
// returns a string from A-Z to AA-ZZ to AAA-ZZZ
// OBS: A = 65 ASCII TABLE VALUE
  if ((\$valor < 1)  || (\$valor > 18278)) return \"?\"; //supports 'only' up to 18278
  \$c1 = \$c2 = \$c3 = '';
  if (\$valor > 702) // 3 letters (up to 18278)
    {
      \$c1 = 65 + floor((\$valor-703)/676);
      \$c2 = 65 + floor(((\$valor-703)%676)/26);
      \$c3 = 65 + floor(((\$valor-703)%676)%26);
    }
  elseif (\$valor > 26) // 2 letters (up to 702)
  {
      \$c1 = (64 + (int)((\$valor-1) / 26));
      \$c2 = (64 + (int)(\$valor % 26));
      if (\$c2 == 64) \$c2 += 26;
  }
  else // 1 letter (up to 26)
  {
      \$c1 = (64 + \$valor);
  }
  \$alpha = chr(\$c1);
  if (\$c2 != '') \$alpha .= chr(\$c2);
  if (\$c3 != '') \$alpha .= chr(\$c3);
  if (!\$toupper) \$alpha = strtolower(\$alpha);
  return \$alpha;
}


function dec2roman(\$valor,\$toupper=true){
 //returns a string as a roman numeral
  \$r1=\$r2=\$r3=\$r4='';
  if ((\$valor >= 5000) || (\$valor < 1)) return \"?\"; //supports 'only' up to 4999
  \$aux = (int)(\$valor/1000);
  if (\$aux!==0)
  {
    \$valor %= 1000;
    while(\$aux!==0)
    {
    \t\$r1 .= \"M\";
    \t\$aux--;
    }
  }
  \$aux = (int)(\$valor/100);
  if (\$aux!==0)
  {
    \$valor %= 100;
    switch(\$aux){
    \tcase 3: \$r2=\"C\";
    \tcase 2: \$r2.=\"C\";
    \tcase 1: \$r2.=\"C\"; break;
  \t  case 9: \$r2=\"CM\"; break;
  \t  case 8: \$r2=\"C\";
  \t  case 7: \$r2.=\"C\";
    \tcase 6: \$r2.=\"C\";
      case 5: \$r2=\"D\".\$r2; break;
      case 4: \$r2=\"CD\"; break;
      default: break;
\t  }
  }
  \$aux = (int)(\$valor/10);
  if (\$aux!==0)
  {
    \$valor %= 10;
    switch(\$aux){
    \tcase 3: \$r3=\"X\";
    \tcase 2: \$r3.=\"X\";
    \tcase 1: \$r3.=\"X\"; break;
    \tcase 9: \$r3=\"XC\"; break;
    \tcase 8: \$r3=\"X\";
    \tcase 7: \$r3.=\"X\";
  \t  case 6: \$r3.=\"X\";
      case 5: \$r3=\"L\".\$r3; break;
      case 4: \$r3=\"XL\"; break;
      default: break;
    }
  }
  switch(\$valor){
  \tcase 3: \$r4=\"I\";
  \tcase 2: \$r4.=\"I\";
  \tcase 1: \$r4.=\"I\"; break;
  \tcase 9: \$r4=\"IX\"; break;
  \tcase 8: \$r4=\"I\";
    case 7: \$r4.=\"I\";
    case 6: \$r4.=\"I\";
    case 5: \$r4=\"V\".\$r4; break;
    case 4: \$r4=\"IV\"; break;
    default: break;
  }
  \$roman = \$r1.\$r2.\$r3.\$r4;
  if (!\$toupper) \$roman = strtolower(\$roman);
  return \$roman;
}
/*-- END LISTS --*/


//===========================
/*-- IMPORTS --*/
function SetImportUse() {
\t\$this->enableImports = true;
\tini_set('auto_detect_line_endings',1);
\trequire_once(_MPDF_PATH.\"mpdfi/pdf_context.php\");
\trequire_once(_MPDF_PATH.\"mpdfi/pdf_parser.php\");
\trequire_once(_MPDF_PATH.\"mpdfi/fpdi_pdf_parser.php\");
}

// from mPDFI
function hex2str(\$hex) {
\treturn pack(\"H*\", str_replace(array(\"\\r\",\"\\n\",\" \"),\"\", \$hex));
}

function str2hex(\$str) {
\treturn current(unpack(\"H*\",\$str));
}


function pdf_write_value(&\$value) {
\tswitch (\$value[0]) {
\t\tcase PDF_TYPE_NUMERIC :
\t\tcase PDF_TYPE_TOKEN :
\t\t\t// A numeric value or a token.
\t\t\t// Simply output them
\t\t\t\$this->_out(\$value[1].\" \", false);
\t\t\tbreak;

\t\tcase PDF_TYPE_ARRAY :
\t\t\t// An array. Output the proper
\t\t\t// structure and move on.
\t\t\t\$this->_out(\"[\",false);
\t\t\tfor (\$i = 0; \$i < count(\$value[1]); \$i++) {
\t\t\t\t\$this->pdf_write_value(\$value[1][\$i]);
\t\t\t}
\t\t\t\$this->_out(\"]\");
\t\t\tbreak;

\t\tcase PDF_TYPE_DICTIONARY :
\t\t\t// A dictionary.
\t\t\t\$this->_out(\"<<\",false);
\t\t\treset (\$value[1]);
\t\t\twhile (list(\$k, \$v) = each(\$value[1])) {
\t\t\t\t\$this->_out(\$k . \" \",false);
\t\t\t\t\$this->pdf_write_value(\$v);
\t\t\t}
\t\t\t\$this->_out(\">>\");
\t\t\tbreak;

\t\tcase PDF_TYPE_OBJREF :
\t\t\t// An indirect object reference
\t\t\t// Fill the object stack if needed
\t\t\t\$cpfn =& \$this->current_parser->filename;
\t\t\tif (!isset(\$this->_don_obj_stack[\$cpfn][\$value[1]])) {
\t\t\t\t\t\$this->_newobj(false,true);
\t\t\t\t\t\$this->_obj_stack[\$cpfn][\$value[1]] = array(\$this->n, \$value);
\t\t\t\t\t\$this->_don_obj_stack[\$cpfn][\$value[1]] = array(\$this->n, \$value);
\t\t\t}
\t\t\t\$objid = \$this->_don_obj_stack[\$cpfn][\$value[1]][0];
\t\t\t\$this->_out(\"{\$objid} 0 R\"); //{\$value[2]}
\t\t\tbreak;

\t\tcase PDF_TYPE_STRING :
\t\t\tif (\$this->encrypted) {
\t\t\t\t\$value[1] = \$this->_RC4(\$this->_objectkey(\$this->_current_obj_id), \$value[1]);
\t\t\t\t\$value[1] = \$this->_escape(\$value[1]);
\t\t\t}
\t\t\t// A string.
\t\t\t\$this->_out('('.\$value[1].')');
\t\t\tbreak;

\t\tcase PDF_TYPE_STREAM :
\t\t\t// A stream. First, output the
\t\t\t// stream dictionary, then the
\t\t\t// stream data itself.
\t\t\t\$this->pdf_write_value(\$value[1]);
\t\t\tif (\$this->encrypted) {
\t\t\t\t\$value[2][1] = \$this->_RC4(\$this->_objectkey(\$this->_current_obj_id), \$value[2][1]);
\t\t\t}
\t\t\t\$this->_out(\"stream\");
\t\t\t\$this->_out(\$value[2][1]);
\t\t\t\$this->_out(\"endstream\");
\t\t\tbreak;

\t\tcase PDF_TYPE_HEX :
\t\t\tif (\$this->encrypted) {
\t\t\t\t\$value[1] = \$this->hex2str(\$value[1]);
\t\t\t\t\$value[1] = \$this->_RC4(\$this->_objectkey(\$this->_current_obj_id), \$value[1]);
\t\t\t\t// remake hexstring of encrypted string
\t\t\t\t\$value[1] = \$this->str2hex(\$value[1]);
\t\t\t}
\t\t\t\$this->_out(\"<\".\$value[1].\">\");
\t\t\tbreak;

\t\tcase PDF_TYPE_NULL :
\t\t\t// The null object.
\t\t\t\$this->_out(\"null\");
\t\t\tbreak;
\t}
}

// ========== OVERWRITE SEARCH STRING IN A PDF FILE ================
function OverWrite(\$file_in, \$search, \$replacement, \$dest=\"D\", \$file_out=\"mpdf\" ) {
\t\$pdf = file_get_contents(\$file_in);

\tif (!is_array(\$search)) {
\t\t\$x = \$search;
\t\t\$search = array(\$x);
\t}
\tif (!is_array(\$replacement)) {
\t\t\$x = \$replacement;
\t\t\$search = array(\$x);
\t}

\tif (!\$this->onlyCoreFonts && !\$this->usingCoreFont) {
\t  foreach(\$search AS \$k=>\$val) {
\t\t\$search[\$k] = \$this->UTF8ToUTF16BE(\$search[\$k] , false);
\t\t\$search[\$k] = \$this->_escape(\$search[\$k]);
\t\t\$replacement[\$k] = \$this->UTF8ToUTF16BE(\$replacement[\$k], false);
\t\t\$replacement[\$k] = \$this->_escape(\$replacement[\$k]);
\t  }
\t}
\telse {
\t  foreach(\$replacement AS \$k=>\$val) {
\t\t\$replacement[\$k] = mb_convert_encoding(\$replacement[\$k],\$this->mb_enc,'utf-8');
\t\t\$replacement[\$k] = \$this->_escape(\$replacement[\$k]);
\t  }
\t}

\t// Get xref into array
\t\$xref = array();
\tpreg_match(\"/xref\\n0 (\\d+)\\n(.*?)\\ntrailer/s\",\$pdf,\$m);
\t\$xref_objid = \$m[1];
\tpreg_match_all('/(\\d{10}) (\\d{5}) (f|n)/',\$m[2],\$x);
\tfor(\$i=0; \$i<count(\$x[0]); \$i++) {
\t\t\$xref[] = array(intval(\$x[1][\$i]), \$x[2][\$i], \$x[3][\$i]);
\t}

\t\$changes = array();
\tpreg_match(\"/<<\\s*\\/Type\\s*\\/Pages\\s*\\/Kids\\s*\\[(.*?)\\]\\s*\\/Count/s\",\$pdf,\$m);
\tpreg_match_all(\"/(\\d+) 0 R /s\",\$m[1],\$o);
\t\$objlist = \$o[1];
\tforeach(\$objlist AS \$obj) {
\t  if (\$this->compress) {
\t  \tpreg_match(\"/\".(\$obj+1).\" 0 obj\\n<<\\s*\\/Filter\\s*\\/FlateDecode\\s*\\/Length (\\d+)>>\\nstream\\n(.*?)\\nendstream\\n/s\",\$pdf,\$m);
\t  }
\t  else {
\t  \tpreg_match(\"/\".(\$obj+1).\" 0 obj\\n<<\\s*\\/Length (\\d+)>>\\nstream\\n(.*?)\\nendstream\\n/s\",\$pdf,\$m);
\t  }
\t  \$s = \$m[2];
\t  if (!\$s) { continue; }
\t  \$oldlen = \$m[1];
\t  if (\$this->encrypted) {
\t\t\$s = \$this->_RC4(\$this->_objectkey(\$obj+1), \$s);
\t  }
\t  if (\$this->compress) {
\t  \t\$s = gzuncompress(\$s);
\t  }
  \t  foreach(\$search AS \$k=>\$val) {
\t\t\$s = str_replace(\$search[\$k],\$replacement[\$k],\$s);
\t  }
\t  if (\$this->compress) {
\t\t\$s = gzcompress(\$s);
\t  }
\t  if (\$this->encrypted) {
\t\t\$s = \$this->_RC4(\$this->_objectkey(\$obj+1), \$s);
\t  }
\t  \$newlen = strlen(\$s);
\t  \$changes[(\$xref[\$obj+1][0])] = (\$newlen - \$oldlen) + (strlen(\$newlen) - strlen(\$oldlen ));
\t  if (\$this->compress) {
\t  \t\$newstr = (\$obj+1) . \" 0 obj\\n<</Filter /FlateDecode /Length \".\$newlen.\">>\\nstream\\n\".\$s.\"\\nendstream\\n\";
\t  }
\t  else {
\t  \t\$newstr = (\$obj+1) . \" 0 obj\\n<</Length \".\$newlen.\">>\\nstream\\n\".\$s.\"\\nendstream\\n\";
\t  }
\t  \$pdf = str_replace(\$m[0],\$newstr,\$pdf);
\t}

\t// Update xref in PDF
\tkrsort(\$changes);
\t\$newxref = \"xref\\n0 \".\$xref_objid.\"\\n\";
\tforeach(\$xref AS \$v) {
\t\tforeach(\$changes AS \$ck => \$cv) {
\t\t\tif (\$v[0] > \$ck) { \$v[0] += \$cv; }
\t\t}
\t\t\$newxref .= sprintf('%010d',\$v[0]) . ' ' . \$v[1] . ' ' .\$v[2] . \" \\n\";
\t}
\t\$newxref .= \"trailer\";
\t\$pdf = preg_replace(\"/xref\\n0 \\d+\\n.*?\\ntrailer/s\",\$newxref,\$pdf);

\t// Update startxref in PDF
\tpreg_match(\"/startxref\\n(\\d+)\\n%%EOF/s\", \$pdf, \$m);
\t\$startxref = \$m[1];
\t\$startxref += array_sum(\$changes);
\t\$pdf = preg_replace(\"/startxref\\n(\\d+)\\n%%EOF/s\",\"startxref\\n\".\$startxref.\"\\n%%EOF\",\$pdf);

\t// OUTPUT
\tswitch(\$dest) {
\t\tcase 'I':
\t\t\t//Send to standard output
\t\t\tif(isset(\$_SERVER['SERVER_NAME']))
\t\t\t{
\t\t\t\t//We send to a browser
\t\t\t\tHeader('Content-Type: application/pdf');
\t\t\t\tHeader('Content-Length: '.strlen(\$pdf));
\t\t\t\tHeader('Content-disposition: inline; filename='.\$file_out);
\t\t\t}
\t\t\techo \$pdf;
\t\t\tbreak;
\t\tcase 'F':
\t\t\t//Save to local file
\t\t\tif (!\$file_out) { \$file_out = 'mpdf.pdf'; }
\t\t\t\$f=fopen(\$file_out,'wb');
\t\t\tif(!\$f) die('Unable to create output file: '.\$file_out);
\t\t\tfwrite(\$f,\$pdf,strlen(\$pdf));
\t\t\tfclose(\$f);
\t\t\tbreak;
\t\tcase 'S':
\t\t\t//Return as a string
\t\t\treturn \$pdf;
\t\tcase 'D':
\t\tdefault:
\t\t\t//Download file
\t\t\tif(isset(\$_SERVER['HTTP_USER_AGENT']) and strpos(\$_SERVER['HTTP_USER_AGENT'],'MSIE'))
\t\t\t\tHeader('Content-Type: application/force-download');
\t\t\telse
\t\t\t\tHeader('Content-Type: application/octet-stream');
\t\t\tHeader('Content-Length: '.strlen(\$pdf));
\t\t\tHeader('Content-disposition: attachment; filename='.\$file_out);
 \t\t\techo \$pdf;
\t\t\tbreak;
\t}
}


function GetTemplateSize(\$tplidx, \$_w=0, \$_h=0) {
\tif (!\$this->tpls[\$tplidx])
\t\treturn false;
\t\$w = \$this->tpls[\$tplidx]['box']['w'];
\t\$h = \$this->tpls[\$tplidx]['box']['h'];
\tif (\$_w == 0 and \$_h == 0) {
\t\t\$_w = \$w;
\t\t\$_h = \$h;
\t}
\tif(\$_w==0)
\t\t\$_w=\$_h*\$w/\$h;
\tif(\$_h==0)
\t\t\$_h=\$_w*\$h/\$w;
\treturn array(\"w\" => \$_w, \"h\" => \$_h);
}

// Thumbnails
function Thumbnail(\$file, \$npr=3, \$spacing=10) {\t//\$npr = number per row
\t\$w = ((\$this->pgwidth + \$spacing)/\$npr) - \$spacing;
\t\$oldlinewidth = \$this->LineWidth;
\t\$this->SetLineWidth(0.02);
\t\$this->SetDColor(\$this->ConvertColor(0));
\t\$h = 0;
\t\$maxh = 0;
\t\$x = \$_x = \$this->lMargin;
\t\$_y = \$this->tMargin;
\tif (\$this->y==0) { \$y = \$_y; } else { \$y = \$this->y; }
\t\$pagecount = \$this->SetSourceFile(\$file);
\tfor (\$n = 1; \$n <= \$pagecount; \$n++) {
\t\t\$tplidx = \$this->ImportPage(\$n);
\t\t\$size = \$this->useTemplate(\$tplidx, \$x, \$y, \$w);
\t\t\$this->Rect(\$x, \$y, \$size['w'], \$size['h']);
\t\t\$h = max(\$h, \$size['h']);
\t\t\$maxh = max(\$h, \$maxh);
\t\tif (\$n % \$npr == 0) {
\t\t   if ((\$y + \$h + \$spacing + \$maxh)>\$this->PageBreakTrigger && \$n != \$pagecount) {
\t\t\t\$this->AddPage();
\t\t\t\$x = \$_x;
\t\t\t\$y = \$_y;
\t\t   }
\t\t   else {
\t\t\t\$y += \$h+\$spacing ;
\t\t\t\$x = \$_x;
\t\t\t\$h = 0;
\t\t   }
\t\t}
\t\telse {
\t\t\t\$x += \$w+\$spacing ;
\t\t}
\t}
\t\$this->SetLineWidth(\$oldlinewidth);
}

function SetSourceFile(\$filename) {
\t\$this->current_filename = \$filename;
\t\$fn =& \$this->current_filename;
\tif (!isset(\$this->parsers[\$fn]))
\t\t// \$this->parsers[\$fn] =& new fpdi_pdf_parser(\$fn,\$this);
\t\t\$this->parsers[\$fn] = new fpdi_pdf_parser(\$fn,\$this);
\tif (!\$this->parsers[\$fn]->success) {
\t\t\$this->Error(\$this->parsers[\$fn]->errormsg);\t// Delete this line to return false on fail
\t\treturn false;
\t}
\t\$this->current_parser =& \$this->parsers[\$fn];
\treturn \$this->parsers[\$fn]->getPageCount();
}
function ImportPage(\$pageno=1, \$crop_x=null, \$crop_y=null, \$crop_w=0, \$crop_h=0, \$boxName='/CropBox') {
\t\$fn =& \$this->current_filename;
\t\$parser =& \$this->parsers[\$fn];
\t\$parser->setPageno(\$pageno);

\t\$this->tpl++;
\t\$this->tpls[\$this->tpl] = array();
\t\$tpl =& \$this->tpls[\$this->tpl];
\t\$tpl['parser'] =& \$parser;
\t\$tpl['resources'] = \$parser->getPageResources();
\t\$tpl['buffer'] = \$parser->getContent();
\tif (!in_array(\$boxName, \$parser->availableBoxes))
\t\treturn \$this->Error(sprintf(\"Unknown box: %s\", \$boxName));
\t\$pageboxes = \$parser->getPageBoxes(\$pageno);
\t/**
\t * MediaBox
\t * CropBox: Default -> MediaBox
\t * BleedBox: Default -> CropBox
\t * TrimBox: Default -> CropBox
\t * ArtBox: Default -> CropBox
\t */
\tif (!isset(\$pageboxes[\$boxName]) && (\$boxName == \"/BleedBox\" || \$boxName == \"/TrimBox\" || \$boxName == \"/ArtBox\"))
\t\t\$boxName = \"/CropBox\";
\tif (!isset(\$pageboxes[\$boxName]) && \$boxName == \"/CropBox\")
\t\t\$boxName = \"/MediaBox\";
\tif (!isset(\$pageboxes[\$boxName]))
\t\treturn false;
\t\$box = \$pageboxes[\$boxName];

\t\$tpl['box'] = \$box;
\t// To build an array that can be used by useTemplate()
\t\$this->tpls[\$this->tpl] = array_merge(\$this->tpls[\$this->tpl],\$box);
\t// An imported page will start at 0,0 everytime. Translation will be set in _putformxobjects()
\t\$tpl['x'] = 0;
\t\$tpl['y'] = 0;
\t\$tpl['w'] = \$tpl['box']['w'] ;
\t\$tpl['h'] = \$tpl['box']['h'] ;
\tif (\$crop_w) { \$tpl['box']['w'] = \$crop_w; }
\tif (\$crop_h) { \$tpl['box']['h'] = \$crop_h; }
\tif (isset(\$crop_x)) { \$tpl['box']['x'] = \$crop_x; }
\tif (isset(\$crop_y)) {\$tpl['box']['y'] = \$tpl['h'] - \$crop_y  - \$crop_h ; }

\t\$page =& \$parser->pages[\$parser->pageno];
\t// fix for rotated pages
\t\$rotation = \$parser->getPageRotation(\$pageno);

\tif (isset(\$rotation[1]) && (\$angle = \$rotation[1] % 360) != 0 && \$tpl['box']['w'] == \$tpl['w']) {
\t\t\$steps = \$angle / 90;

\t\t\$_w = \$tpl['w'];
\t\t\$_h = \$tpl['h'];
\t\t\$tpl['w'] = \$steps % 2 == 0 ? \$_w : \$_h;
\t\t\$tpl['h'] = \$steps % 2 == 0 ? \$_h : \$_w;
\t\tif (\$steps % 2 != 0) {
\t\t\t\$x = \$y = (\$steps == 1 || \$steps == -3) ? \$tpl['h'] : \$tpl['w'];
\t\t} else {
\t\t\t\$x = \$tpl['w'];
\t\t\t\$y = \$tpl['h'];
\t\t}
\t\t\$cx=(\$x/2+\$tpl['box']['x'])*_MPDFK;
\t\t\$cy=(\$y/2+\$tpl['box']['y'])*_MPDFK;
\t\t\$angle*=-1;
\t\t\$angle*=M_PI/180;
\t\t\$c=cos(\$angle);
\t\t\$s=sin(\$angle);
\t\t\$tpl['box']['w'] = \$tpl['w'] ;
\t\t\$tpl['box']['h'] = \$tpl['h'] ;
\t\t\$tpl['buffer'] = sprintf('q %.5F %.5F %.5F %.5F %.2F %.2F cm 1 0 0 1 %.2F %.2F cm %s Q',\$c,\$s,-\$s,\$c,\$cx,\$cy,-\$cx,-\$cy, \$tpl['buffer']);
\t}
\treturn \$this->tpl;
}
function UseTemplate(\$tplidx, \$_x=null, \$_y=null, \$_w=0, \$_h=0) {
\tif (!isset(\$this->tpls[\$tplidx]))
\t\t\$this->Error(\"Template does not exist!\");
\tif(\$this->state==0) { \$this->AddPage(); }
\t\$out = 'q 0 J 1 w 0 j 0 G'.\"\\n\"; // reset standard values
\t\$x = \$this->tpls[\$tplidx]['x'];
\t\$y = \$this->tpls[\$tplidx]['y'];
\t\$w = \$this->tpls[\$tplidx]['w'];
\t\$h = \$this->tpls[\$tplidx]['h'];
\tif (\$_x == null) { \$_x = \$x; }
\tif (\$_y == null) { \$_y = \$y; }
\tif (\$_x === -1) { \$_x = \$this->x; }
\tif (\$_y === -1) { \$_y = \$this->y; }

\t\$wh = \$this->getTemplateSize(\$tplidx,\$_w,\$_h);
\t\$_w = \$wh['w'];
\t\$_h = \$wh['h'];
\t\$out .= sprintf(\"q %.4F 0 0 %.4F %.2F %.2F cm\", (\$_w/\$this->tpls[\$tplidx]['box']['w']), (\$_h/\$this->tpls[\$tplidx]['box']['h']), \$_x*_MPDFK, (\$this->h-(\$_y+\$_h))*_MPDFK).\"\\n\";
\t\$out .= \$this->tplprefix.\$tplidx.\" Do Q\\n\";

\t\$s = array(\"w\" => \$_w, \"h\" => \$_h);
\t\$out .= \"Q\\n\";
\t\$this->pages[\$this->page] = \$out . \$this->pages[\$this->page];
\treturn \$s;
}
function SetPageTemplate(\$tplidx='') {
\tif (!isset(\$this->tpls[\$tplidx])) {
\t\t\$this->pageTemplate = '';
\t\treturn false;
\t}
\t\$this->pageTemplate = \$tplidx;
}
function SetDocTemplate(\$file='', \$continue=0) {
\t\$this->docTemplate = \$file;
\t\$this->docTemplateContinue = \$continue;
}
/*-- END IMPORTS --*/


/* ---------------------------------------------- */
/* ---------------------------------------------- */
/* ---------------------------------------------- */
/* ---------------------------------------------- */
/* ---------------------------------------------- */

// JAVASCRIPT
function _set_object_javascript (\$string) {
\t\$this->_newobj();
\t\$this->_out('<<');
\t\$this->_out('/S /JavaScript ');
\t\$this->_out('/JS '.\$this->_textstring(\$string));
\t\$this->_out('>>');
\t\$this->_out('endobj');
}

function SetJS(\$script) {
\t\$this->js = \$script;
}




}//end of Class




?>
";
    }

    public function getTemplateName()
    {
        return "support/include/mpdf/mpdf.php";
    }

    public function getDebugInfo()
    {
        return array (  19 => 1,);
    }

    /** @deprecated since 1.27 (to be removed in 2.0). Use getSourceContext() instead */
    public function getSource()
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 1.27 and will be removed in 2.0. Use getSourceContext() instead.', E_USER_DEPRECATED);

        return $this->getSourceContext()->getCode();
    }

    public function getSourceContext()
    {
        return new Twig_Source("", "support/include/mpdf/mpdf.php", "C:\\wamp\\www\\Symfony\\app\\Resources\\views\\support\\include\\mpdf\\mpdf.php");
    }
}
